(function () {
  'use strict';

  var n,
    l$2,
    u$2,
    t$1,
    r$3,
    o$3,
    f$2,
    e$1,
    c$2 = {},
    s$2 = [],
    a$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h$2(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function v$2(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function y$2(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return p$2(l, f, t, r, null);
  }
  function p$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$2 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function _$2(n) {
    return n.children;
  }
  function k$2(n, l) {
    this.props = n, this.context = l;
  }
  function b$1(n, l) {
    if (null == l) return n.__ ? b$1(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? b$1(n) : null;
  }
  function g$2(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return g$2(n);
    }
  }
  function m$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !w$2.__r++ || r$3 !== l$2.debounceRendering) && ((r$3 = l$2.debounceRendering) || o$3)(w$2);
  }
  function w$2() {
    var n, l, u, i, r, o, e, c;
    for (t$1.sort(f$2); n = t$1.shift();) n.__d && (l = t$1.length, i = void 0, r = void 0, e = (o = (u = n).__v).__e, (c = u.__P) && (i = [], (r = h$2({}, o)).__v = o.__v + 1, L$1(c, o, r, u.__n, void 0 !== c.ownerSVGElement, null != o.__h ? [e] : null, i, null == e ? b$1(o) : e, o.__h), M(i, o), o.__e != e && g$2(o)), t$1.length > l && t$1.sort(f$2));
    w$2.__r = 0;
  }
  function x$1(n, l, u, i, t, r, o, f, e, a) {
    var h,
      v,
      y,
      d,
      k,
      g,
      m,
      w = i && i.__k || s$2,
      x = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (d = u.__k[h] = null == (d = l[h]) || "boolean" == typeof d || "function" == typeof d ? null : "string" == typeof d || "number" == typeof d || "bigint" == typeof d ? p$2(null, d, null, null, d) : Array.isArray(d) ? p$2(_$2, {
      children: d
    }, null, null, null) : d.__b > 0 ? p$2(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {
      if (d.__ = u, d.__b = u.__b + 1, null === (y = w[h]) || y && d.key == y.key && d.type === y.type) w[h] = void 0;else for (v = 0; v < x; v++) {
        if ((y = w[v]) && d.key == y.key && d.type === y.type) {
          w[v] = void 0;
          break;
        }
        y = null;
      }
      L$1(n, d, y = y || c$2, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (m || (m = []), y.ref && m.push(y.ref, null, d), m.push(v, d.__c || k, d)), null != k ? (null == g && (g = k), "function" == typeof d.type && d.__k === y.__k ? d.__d = e = A$1(d, e, n) : e = C$1(n, d, y, w, k, e), "function" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = b$1(y));
    }
    for (u.__e = g, h = x; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = $$1(i).nextSibling), S(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) O(m[h], m[++h], m[++h]);
  }
  function A$1(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? A$1(i, l, u) : C$1(u, i, i, t, i.__e, l));
    return l;
  }
  function P(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      P(n, l);
    }) : l.push(n)), l;
  }
  function C$1(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function $$1(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = $$1(u))) return i;
    return null;
  }
  function H$1(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || T$2(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || T$2(n, r, l[r], u[r], i);
  }
  function I$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a$2.test(l) ? u : u + "px";
  }
  function T$2(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || I$1(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || I$1(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? z$1 : j$1, r) : n.removeEventListener(l, r ? z$1 : j$1, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function j$1(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function z$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function L$1(n, u, i, t, r, o, f, e, c) {
    var s,
      a,
      v,
      y,
      p,
      d,
      b,
      g,
      m,
      w,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], w = s ? m ? m.props.value : s.__ : t, i.__c ? b = (a = u.__c = i.__c).__ = a.__E : ("prototype" in I && I.prototype.render ? u.__c = a = new I(g, w) : (u.__c = a = new k$2(g, w), a.constructor = I, a.render = q$2), m && m.sub(a), a.props = g, a.state || (a.state = {}), a.context = w, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != I.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h$2({}, a.__s)), h$2(a.__s, I.getDerivedStateFromProps(g, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == I.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(g, w), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(g, a.__s, w) || u.__v === i.__v) {
            for (u.__v !== i.__v && (a.props = g, a.state = a.__s, a.__d = !1), a.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < a._sb.length; A++) a.__h.push(a._sb[A]);
            a._sb = [], a.__h.length && f.push(a);
            break n;
          }
          null != a.componentWillUpdate && a.componentWillUpdate(g, a.__s, w), null != a.componentDidUpdate && a.__h.push(function () {
            a.componentDidUpdate(y, p, d);
          });
        }
        if (a.context = w, a.props = g, a.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (a.state = a.__s, a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), $ = 0; $ < a._sb.length; $++) a.__h.push(a._sb[$]);
          a._sb = [];
        } else do {
          a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;
        } while (a.__d && ++C < 25);
        a.state = a.__s, null != a.getChildContext && (t = h$2(h$2({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === _$2 && null == s.key ? s.props.children : s, x$1(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), b && (a.__E = a.__ = null), a.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = N$1(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function M(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function N$1(l, u, i, t, r, o, f, e) {
    var s,
      a,
      h,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, e = !1;
    }
    if (null === d) y === p || e && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || c$2).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || ""));
      }
      if (H$1(l, p, y, r, e), h) u.__k = [];else if (_ = u.props.children, x$1(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && b$1(i, 0), e), null != o) for (_ = o.length; _--;) null != o[_] && v$2(o[_]);
      e || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && T$2(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && T$2(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function O(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function S(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || O(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && S(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || v$2(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function q$2(n, l, u) {
    return this.constructor(n, u);
  }
  function B$2(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], L$1(i, u = (!r && t || i).__k = y$2(_$2, null, [u]), o || c$2, c$2, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), M(f, u);
  }
  function E(l, u, i) {
    var t,
      r,
      o,
      f = h$2({}, l.props);
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p$2(l.type, f, t || l.key, r || l.ref, null);
  }
  function F$2(n, l) {
    var u = {
      __c: l = "__cC" + e$1++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(function (n) {
            n.__e = !0, m$1(n);
          });
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = s$2.slice, l$2 = {
    __e: function (n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$2 = 0, k$2.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h$2({}, this.state), "function" == typeof n && (n = n(h$2({}, u), this.props)), n && h$2(u, n), null != n && this.__v && (l && this._sb.push(l), m$1(this));
  }, k$2.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
  }, k$2.prototype.render = _$2, t$1 = [], o$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$2 = function (n, l) {
    return n.__v.__b - l.__v.__b;
  }, w$2.__r = 0, e$1 = 0;
  var _$1 = 0;
  function o$2(o, e, n, t, f, l) {
    var s,
      u,
      a = {};
    for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
    var i = {
      type: o,
      props: a,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: l
    };
    if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
    return l$2.vnode && l$2.vnode(i), i;
  }
  var t,
    r$2,
    u$1,
    i$1,
    o$1 = 0,
    f$1 = [],
    c$1 = [],
    e = l$2.__b,
    a$1 = l$2.__r,
    v$1 = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d$1(t, u) {
    l$2.__h && l$2.__h(r$2, t, o$1 || u), o$1 = 0;
    var i = r$2.__H || (r$2.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c$1
    }), i.__[t];
  }
  function h$1(n) {
    return o$1 = 1, s$1(B$1, n);
  }
  function s$1(n, u, i) {
    var o = d$1(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$2, !r$2.u)) {
      var f = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !c || c.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
      };
      r$2.u = !0;
      var c = r$2.shouldComponentUpdate,
        e = r$2.componentWillUpdate;
      r$2.componentWillUpdate = function (n, t, r) {
        if (this.__e) {
          var u = c;
          c = void 0, f(n, t, r), c = u;
        }
        e && e.call(this, n, t, r);
      }, r$2.shouldComponentUpdate = f;
    }
    return o.__N || o.__;
  }
  function p$1(u, i) {
    var o = d$1(t++, 3);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__H.__h.push(o));
  }
  function y$1(u, i) {
    var o = d$1(t++, 4);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__h.push(o));
  }
  function _(n) {
    return o$1 = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o$1 = 6, y$1(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d$1(t++, 7);
    return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o$1 = 8, F$1(function () {
      return n;
    }, t);
  }
  function q$1(n) {
    var u = r$2.context[n.__c],
      i = d$1(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$2)), u.props.value) : n.__;
  }
  function b() {
    for (var t; t = f$1.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$2 = null, e && e(n);
  }, l$2.__r = function (n) {
    a$1 && a$1(n), t = 0;
    var i = (r$2 = n.__c).__H;
    i && (u$1 === r$2 ? (i.__h = [], r$2.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c$1, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u$1 = r$2;
  }, l$2.diffed = function (t) {
    v$1 && v$1(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f$1.push(o) && i$1 === l$2.requestAnimationFrame || ((i$1 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c$1 && (n.__ = n.__V), n.i = void 0, n.__V = c$1;
    })), u$1 = r$2 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$2,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$2 = t;
  }
  function w$1(n) {
    var t = r$2;
    n.__c = n.__(), r$2 = t;
  }
  function z(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  function getBuildModeUnmemoized$1() {
    try {
      if (process.env.NODE_ENV === "development") return "development";
      return "production";
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode$1 = getBuildModeUnmemoized$1; //memoize(getBuildModeUnmemoized) as typeof getBuildModeUnmemoized;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }
  let timeoutHandle = null;
  function callCountU(hook) {
    var _window, _window$_hookCallCoun, _window$_hookCallCoun2, _window$_hookCallCoun3, _window$_hookCallCoun4, _window$_hookCallCoun5;
    const name = hook.name;
    if (filters.has(name)) return;
    (_window$_hookCallCoun = (_window = window)._hookCallCount) !== null && _window$_hookCallCoun !== void 0 ? _window$_hookCallCoun : _window._hookCallCount = {
      callCountsMoment: {},
      callCountsTotal: {}
    };
    (_window$_hookCallCoun3 = (_window$_hookCallCoun2 = window._hookCallCount.callCountsMoment)[name]) !== null && _window$_hookCallCoun3 !== void 0 ? _window$_hookCallCoun3 : _window$_hookCallCoun2[name] = 0;
    (_window$_hookCallCoun5 = (_window$_hookCallCoun4 = window._hookCallCount.callCountsTotal)[name]) !== null && _window$_hookCallCoun5 !== void 0 ? _window$_hookCallCoun5 : _window$_hookCallCoun4[name] = 0;
    window._hookCallCount.callCountsMoment[name] += 1;
    window._hookCallCount.callCountsTotal[name] += 1;
    if (timeoutHandle == null) {
      timeoutHandle = requestIdleCallback(() => {
        console.log(window._hookCallCount.callCountsMoment);
        window._hookCallCount.callCountsMoment = {};
        timeoutHandle = null;
      });
    }
  }
  const filters = new Set();
  const monitorCallCount = getBuildMode$1() == "development" ? callCountU : noop;

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability$1(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    if (getBuildMode$1() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering$1(f) {
    var _l$2$debounceRenderin;
    ((_l$2$debounceRenderin = l$2.debounceRendering) !== null && _l$2$debounceRenderin !== void 0 ? _l$2$debounceRenderin : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState$1(onChange, getInitialValue, customDebounceRendering) {
    monitorCallCount(usePassiveState$1);
    const valueRef = _(Unset$3);
    const reasonRef = _(Unset$3);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$3);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability$1("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$3 && getInitialValue != undefined) {
        try {
          var _onChange;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$3) tryEnsureValue();
      return valueRef.current === Unset$3 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$3 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$3 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering$1)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$3 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$3;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$3 = Symbol();
  function returnNull$1() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately$1(f) {
    f();
  }
  const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64$1(value) {
    return Table$1[value];
  }
  function random6Bits$1() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits$1() {
    return [random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * because useBeforeLayoutEffect also needs random IDs for its own reasons)
   */
  function generateRandomId$1(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits$1().map(n => base64$1(n)).join(""));
  }
  const previousInputs$1 = new Map();
  const toRun$1 = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName$1 = "diffed";
  const originalCommit$1 = l$2[commitName$1];
  const newCommit$1 = function () {
    for (const [id, effectInfo] of toRun$1) {
      const oldInputs = previousInputs$1.get(id);
      if (argsChanged$1(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs$1.set(id, effectInfo.inputs);
      }
    }
    toRun$1.clear();
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    originalCommit$1 === null || originalCommit$1 === void 0 ? void 0 : originalCommit$1(...args);
  };
  l$2[commitName$1] = newCommit$1;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect$1(effect, inputs) {
    monitorCallCount(useBeforeLayoutEffect$1);
    const [id] = h$1(() => generateRandomId$1());
    if (effect) toRun$1.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun$1.delete(id);
    p$1(() => {
      return () => {
        toRun$1.delete(id);
        previousInputs$1.delete(id);
      };
    }, [id]);
  }
  function argsChanged$1(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset$2 = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter$1(value) {
    monitorCallCount(useStableGetter$1);
    const ref = _(Unset$2);
    useBeforeLayoutEffect$1(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset$2) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject$1(t) {
    const e = Object.entries(t);
    useEnsureStability$1("useStableObject", e.length, ...e.map(_ref => {
      let [_k, v] = _ref;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map$1 = new WeakMap();
  function isStableGetter$1(obj) {
    var _map$1$get;
    return (_map$1$get = map$1.get(obj)) !== null && _map$1$get !== void 0 ? _map$1$get : false;
  }
  function setIsStableGetter$1(obj) {
    map$1.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback$1(fn, noDeps) {
    monitorCallCount(useStableCallback$1);
    useEnsureStability$1("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter$1(fn));
    if (isStableGetter$1(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter$1(fn);
      return setIsStableGetter$1(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter$1(T$1(fn, []));
    }
  }
  function useMergedChildren$1(lhs, rhs) {
    monitorCallCount(useMergedChildren$1);
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }
  function r$1(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx$1() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses$1(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    monitorCallCount(useMergedClasses$1);
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx$1(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx$1(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef$1(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs$1(rhs, lhs) {
    monitorCallCount(useMergedRefs$1);
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback$1(function combined(current) {
      processRef$1(current, lhs);
      processRef$1(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject$1(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles$1(lhs, rhs) {
    monitorCallCount(useMergedStyles$1);
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles$1(styleStringToObject$1(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles$1(lhs, styleStringToObject$1(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log$1 = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps$1() {
    monitorCallCount(useMergedProps$1);
    for (var _len3 = arguments.length, allProps = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      allProps[_key3] = arguments[_key3];
    }
    useEnsureStability$1("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2$1(ret, nextProps);
    }
    return ret;
  }
  const knowns$1 = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown$1(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions$1(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log$1 === null || log$1 === void 0 ? void 0 : log$1("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2$1(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs$1(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles$1(lhsAll.style, rhsAll.style),
      className: useMergedClasses$1(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren$1(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns$1.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns$1.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown$1(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions$1(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * `"mode"` controls if there's one handler that calls all your functions (default), or one handler added per function (`"single"`).
   *
   * The default, `"grouped"`, is faster when you have, say, a button component, used hundreds of times on a page, that each installs a global event handler.
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options, mode) {
    monitorCallCount(useGlobalHandler);
    mode || (mode = "grouped");
    useEnsureStability$1("useGlobalHandler", mode);
    if (mode === "grouped") {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      useGlobalHandlerGrouped(target, type, handler, options);
    } else {
      useGlobalHandlerSingle(target, type, handler, options);
    }
  }
  let mapThing = new Map();
  function doMapThing(op, target, type, handler, options) {
    if (handler) {
      const optionsKey = JSON.stringify(options);
      const byType = mapThing.get(target) || new Map();
      const byOptions = byType.get(type) || new Map();
      const info = byOptions.get(optionsKey) || {
        listener: null,
        listeners: new Set()
      };
      op(info, handler);
      byOptions.set(optionsKey, info);
      byType.set(type, byOptions);
      mapThing.set(target, byType);
    }
  }
  function addToMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.add(h);
      if (info.listener == null) target.addEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  function removeFromMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.delete(h);
      if (info.listener == null) target.removeEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  /**
   * This is way faster for large numbers of event handlers.
   *
   * For example, if every button listens for a global click, or something,
   * it would be nice if it was efficient at least.
   */
  function useGlobalHandlerGrouped(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        addToMapThing(target, type, stableHandler, options);
        return () => removeFromMapThing(target, type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }
  function useGlobalHandlerSingle(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement$1(args) {
    monitorCallCount(useRefElement$1);
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability$1("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState$1(handler, returnNull$1, runImmediately$1);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      propsStable: propsStable.current,
      refElementReturn: {
        getElement
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck$1(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass$1(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck$1(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass$1(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck$1(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass$1(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren$1(parentParameters) {
    monitorCallCount(useManagedChildren$1);
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability$1("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering$1(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering$1(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject$1({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject$1({
        managedChildContext: useStableObject$1({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild$1(info, managedChildParameters) {
    var _info$context;
    monitorCallCount(useManagedChild$1);
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context = info.context) !== null && _info$context !== void 0 ? _info$context : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState$1(initialState) {
    monitorCallCount(useState$1);
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }
  function g(n, t) {
    for (var e in t) n[e] = t[e];
    return n;
  }
  function C(n, t) {
    for (var e in n) if ("__source" !== e && !(e in t)) return !0;
    for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function x(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, y$2(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new k$2()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var R = l$2.__b;
  l$2.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$2.__e;
  l$2.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    T(n, t, e, r);
  };
  var I = l$2.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$2.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new k$2()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && y$2(_$2, null, n.fallback);
    return i && (i.__h = null), [y$2(_$2, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) e.pop()();
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  (V.prototype = new k$2()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = P(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var B = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    H = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
    Y = /[A-Z0-9]/g,
    $ = "undefined" != typeof document,
    q = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
    };
  k$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(k$2.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var K = l$2.event;
  function Q() {}
  function X() {
    return this.cancelBubble;
  }
  function nn() {
    return this.defaultPrevented;
  }
  l$2.event = function (n) {
    return K && (n = K(n)), n.persist = Q, n.isPropagationStopped = X, n.isDefaultPrevented = nn, n.nativeEvent = n;
  };
  var en = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    rn = l$2.vnode;
  l$2.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      for (var o in u = {}, e) {
        var i = e[o];
        if (!("value" === o && "defaultValue" in e && null == i || $ && "children" === o && "noscript" === t)) {
          var l = o.toLowerCase();
          "defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : "ondoubleclick" === l ? o = "ondblclick" : "onchange" !== l || "input" !== t && "textarea" !== t || q(e.type) ? "onfocus" === l ? o = "onfocusin" : "onblur" === l ? o = "onfocusout" : Z.test(o) ? o = l : -1 === t.indexOf("-") && H.test(o) ? o = o.replace(Y, "-$&").toLowerCase() : null === i && (i = void 0) : l = o = "oninput", "oninput" === l && u[o = l] && (o = "oninputCapture"), u[o] = i;
        }
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = P(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = P(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (en.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", en));
    }
    n.$$typeof = B, rn && rn(n);
  };
  var un = l$2.__r;
  l$2.__r = function (n) {
    un && un(n), n.__c;
  };
  var on = l$2.diffed;
  l$2.diffed = function (n) {
    on && on(n);
    var t = n.props,
      e = n.__e;
    null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value);
  };

  /**
   * Easy access to an HTMLElement that can be controlled imperatively.
   *
   * The HTMLElement rendered is controlled by the `tag` prop (e.g. "span", "div").
   *
   * The `handle` prop should be e.g. `useRef<ImperativeHandle<HTMLDivElement>>(null)`
   */
  x(k(ImperativeElementU));
  function useImperativeProps(_ref2) {
    let {
      refElementReturn: {
        getElement
      }
    } = _ref2;
    monitorCallCount(useImperativeProps);
    const currentImperativeProps = _({
      className: new Set(),
      style: {},
      children: null,
      others: {}
    });
    const hasClass = T$1(cls => {
      return currentImperativeProps.current.className.has(cls);
    }, []);
    const setClass = T$1((cls, enabled) => {
      if (hasClass(cls) == !enabled) {
        var _getElement;
        (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.classList[enabled ? "add" : "remove"](cls);
        currentImperativeProps.current.className[enabled ? "add" : "delete"](cls);
      }
    }, []);
    const setStyle = T$1((prop, value) => {
      const element = getElement();
      if (element) {
        if (currentImperativeProps.current.style[prop] != value) {
          currentImperativeProps.current.style[prop] = value;
          if (prop.startsWith("--")) {
            if (value != null) element.style.setProperty(prop, "".concat(value));else element.style.removeProperty(prop);
          } else {
            element.style[prop] = value !== null && value !== void 0 ? value : "";
          }
        }
      }
    }, []);
    const setChildren = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.children != children) {
        currentImperativeProps.current.children = children;
        e.textContent = children;
      }
    }, []);
    const getAttribute = T$1(prop => {
      return currentImperativeProps.current.others[prop];
    }, []);
    const setAttribute = T$1((prop, value) => {
      if (value != null) {
        var _getElement2;
        currentImperativeProps.current.others[prop] = value;
        (_getElement2 = getElement()) === null || _getElement2 === void 0 ? void 0 : _getElement2.setAttribute(prop, value);
      } else {
        var _getElement3;
        delete currentImperativeProps.current.others[prop];
        (_getElement3 = getElement()) === null || _getElement3 === void 0 ? void 0 : _getElement3.removeAttribute(prop);
      }
    }, []);
    const setEventHandler = T$1((type, handler, options) => {
      const element = getElement();
      const mappedKey = EventMapping[type];
      if (element) {
        if (handler) {
          element.addEventListener(type, handler, options);
          currentImperativeProps.current.others[mappedKey] = handler;
        } else if (currentImperativeProps.current.others[mappedKey]) {
          element.removeEventListener(type, currentImperativeProps.current.others[mappedKey], options);
          currentImperativeProps.current.others[mappedKey] = undefined;
        }
      }
    }, []);
    return {
      imperativeHandle: _({
        hasClass,
        setClass,
        setStyle,
        getAttribute,
        setAttribute,
        setEventHandler,
        setChildren
      }).current,
      props: useMergedProps$1({
        className: [...currentImperativeProps.current.className].join(" "),
        style: currentImperativeProps.current.style
      }, currentImperativeProps.current.others)
    };
  }
  function ImperativeElementU(_ref3, ref) {
    let {
      tag: Tag,
      handle,
      ...props
    } = _ref3;
    const {
      propsStable,
      refElementReturn
    } = useRefElement$1({
      refElementParameters: {}
    });
    const {
      props: iprops,
      imperativeHandle
    } = useImperativeProps({
      refElementReturn
    });
    A(handle, () => imperativeHandle);
    return y$2(Tag, useMergedProps$1(propsStable, iprops, props, {
      ref
    }));
  }
  const EventMapping = {
    abort: "onAbort",
    animationend: "onAnimationEnd",
    animationstart: "onAnimationStart",
    animationiteration: "onAnimationIteration",
    beforeinput: "onBeforeInput",
    blur: "onBlur",
    canplay: "onCanPlay",
    canplaythrough: "onCanPlayThrough",
    change: "onChange",
    click: "onClick",
    compositionend: "onCompositionEnd",
    compositionstart: "onCompositionStart",
    compositionupdate: "onCompositionUpdate",
    contextmenu: "onContextMenu",
    cut: "onCut",
    dblclick: "onDblClick",
    drag: "onDrag",
    dragend: "onDragEnd",
    dragenter: "onDragEnter",
    dragleave: "onDragLeave",
    dragover: "onDragOver",
    dragstart: "onDragStart",
    drop: "onDrop",
    durationchange: "onDurationChange",
    emptied: "onEmptied",
    ended: "onEnded",
    error: "onError",
    focus: "onFocus",
    focusin: "onfocusin",
    focusout: "onfocusout",
    formdata: "onFormData",
    gotpointercapture: "onGotPointerCapture",
    input: "onInput",
    invalid: "onInvalid",
    keydown: "onKeyDown",
    keypress: "onKeyPress",
    keyup: "onKeyUp",
    load: "onLoad",
    loadeddata: "onLoadedData",
    loadedmetadata: "onLoadedMetadata",
    loadstart: "onLoadStart",
    lostpointercapture: "onLostPointerCapture",
    mousedown: "onMouseDown",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseover: "onMouseOver",
    mouseup: "onMouseUp",
    paste: "onPaste",
    pause: "onPause",
    play: "onPlay",
    playing: "onPlaying",
    pointercancel: "onPointerCancel",
    pointerdown: "onPointerDown",
    pointerenter: "onPointerEnter",
    pointerleave: "onPointerLeave",
    pointermove: "onPointerMove",
    pointerout: "onPointerOut",
    pointerover: "onPointerOver",
    pointerup: "onPointerUp",
    progress: "onProgress",
    reset: "onReset",
    scroll: "onScroll",
    seeked: "onSeeked",
    seeking: "onSeeking",
    select: "onSelect",
    stalled: "onStalled",
    submit: "onSubmit",
    suspend: "onSuspend",
    timeupdate: "onTimeUpdate",
    toggle: "onToggle",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart",
    transitionend: "onTransitionEnd",
    volumechange: "onVolumeChange",
    waiting: "onWaiting",
    wheel: "onWheel"
  };
  F$2(null);
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();
  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];
  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');
  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;
  function getBuildModeUnmemoized() {
    try {
      var _process, _process$env;
      if (((_process = process) === null || _process === void 0 ? void 0 : (_process$env = _process.env) === null || _process$env === void 0 ? void 0 : _process$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode = memoize(getBuildModeUnmemoized);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      values[_key4 - 1] = arguments[_key4];
    }
    if (getBuildMode() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$2$debounceRenderin2;
    ((_l$2$debounceRenderin2 = l$2.debounceRendering) !== null && _l$2$debounceRenderin2 !== void 0 ? _l$2$debounceRenderin2 : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$1);
    const reasonRef = _(Unset$1);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$1);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange3;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange3 = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange3 !== void 0 ? _onChange3 : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange4;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange4 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange4 !== void 0 ? _onChange4 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$1 = Symbol();
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }
  const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  const previousInputs = new Map();
  const toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName = "diffed";
  const originalCommit = l$2[commitName];
  const newCommit = function () {
    for (const [id, effectInfo] of toRun) {
      const oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup2;
        (_effectInfo$cleanup2 = effectInfo.cleanup) === null || _effectInfo$cleanup2 === void 0 ? void 0 : _effectInfo$cleanup2.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$2[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    const [id] = h$1(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    p$1(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    const ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    const e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref4 => {
      let [_k, v] = _ref4;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback(function combined(current) {
      processRef(current, lhs);
      processRef(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len6 = arguments.length, allProps = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      allProps[_key6] = arguments[_key6];
    }
    useEnsureStability("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  const knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var _info$context2;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context2 = info.context) !== null && _info$context2 !== void 0 ? _info$context2 : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref5) {
    let {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref5;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    const [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    // Shared between onChildrenMountChange and changeIndex, not public
    // Only called when `closestFit` is false, naturally.
    const getClosestFit = T$1(requestedIndex => {
      const children = getChildren();
      let closestDistance = Infinity;
      let closestIndex = null;
      children.forEach(child => {
        if (child != null && isValid(child)) {
          console.assert(typeof child.index == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    const reevaluateClosestFit = useStableCallback(() => {
      const children = getChildren();
      const requestedIndex = getRequestedIndex();
      const currentIndex = getCurrentIndex();
      const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
        const closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (currentChild) setAt(currentChild, false, closestFitIndex, currentIndex);
        if (closestFitIndex != null) {
          const closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true, closestFitIndex, currentIndex);
        }
      }
    });
    const changeIndex = T$1((arg, reason) => {
      const children = getChildren();
      const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      setRequestedIndex(requestedIndex, reason);
      const currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
        return null;
      } else {
        const childIsValid = newMatchingChild && isValid(newMatchingChild);
        if (childIsValid || !closestFit) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
          if (newMatchingChild) setAt(newMatchingChild, true, requestedIndex, currentIndex);
          return requestedIndex;
        } else {
          console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            setAt(newMatchingChild, true, closestFitIndex, currentIndex);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    y$1(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }
  F$2(null);
  function getExclusiveTransitionContextPrememoization(exclusivityKey) {
    if (exclusivityKey == null) return null;
    return F$2(null);
  }
  const SwappableContext = F$2({
    getAnimateOnMount: () => false
  });
  /**
   * Returns the context for a given `exclusivityKey`, creating one if it doesn't already exist.
   *
   * If
   */
  const GetExclusiveTransitionContext = memoize(getExclusiveTransitionContextPrememoization);
  const CssClassContext = F$2({
    GetBaseClass: () => "ptl",
    GetEnterClass: () => "n",
    GetExitClass: () => "x",
    GetMeasureClass: () => "m",
    GetInitClass: () => "i",
    GetTransitionClass: () => "t",
    GetFinalizeClass: () => "f"
  });
  function useCssClasses() {
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass
    } = q$1(CssClassContext);
    const GetDirectionClass = T$1(direction => {
      switch (direction) {
        case "enter":
          return GetEnterClass();
        case "exit":
          return GetExitClass();
      }
    }, []);
    const GetPhaseClass = T$1(phase => {
      switch (phase) {
        case "measure":
          return GetMeasureClass();
        case "init":
          return GetInitClass();
        case "transition":
          return GetTransitionClass();
        case "finalize":
          return GetFinalizeClass();
      }
    }, []);
    return {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    };
  }
  let globalCount = -1;
  function ExclusiveTransitionProvider(_ref6) {
    let {
      exclusivityKey,
      children
    } = _ref6;
    useEnsureStability("ExclusiveTransitionProvider", exclusivityKey);
    const [getNextIndexInLine, setNextIndexInLine] = usePassiveState(null);
    const {
      context,
      managedChildrenReturn,
      managedChildrenReturn: {
        getChildren
      }
    } = useManagedChildren({
      managedChildrenParameters: {}
    });
    const {
      changeIndex,
      getCurrentIndex
    } = useChildrenFlag({
      getChildren,
      closestFit: false,
      initialIndex: null,
      onIndexChange: null,
      setAt: T$1((m, v) => {
        m.setExclusivelyOpen(v);
      }, []),
      getAt: T$1(m => m.getExclusivelyOpen(), []),
      isValid: T$1(m => {
        return true;
      }, [])
    });
    const onVisibilityChange = T$1((index, visible) => {
      const nextInLine = getNextIndexInLine();
      const currentInLine = getCurrentIndex();
      if (visible == "show" && index != currentInLine) {
        /**
         * When a child transition shows itself initially
         * (i.e. requests itself to be the exclusive transition)
         * we either let it open immediately if there's no one finishing their exit,
         * or wait until that aforementioned exit has finished.
         */
        if (currentInLine == null) {
          changeIndex(index);
        } else {
          var _getChildren$getAt, _getChildren$getAt$fo;
          (_getChildren$getAt = getChildren().getAt(currentInLine)) === null || _getChildren$getAt === void 0 ? void 0 : (_getChildren$getAt$fo = _getChildren$getAt.forceClose) === null || _getChildren$getAt$fo === void 0 ? void 0 : _getChildren$getAt$fo.call(_getChildren$getAt);
          setNextIndexInLine(index);
        }
      } else if (visible == "hidden") {
        /**
         * When a child transition has finished its exit transition,
         * make sure that if someone requested to be shown in the meantime
         * that we do so.
         */
        if (nextInLine != null) {
          changeIndex(nextInLine);
          setNextIndexInLine(null);
        }
      }
    }, []);
    const context2 = useStableObject({
      ...context,
      exclusiveTransitionContext: useStableObject({
        exclusivityKey,
        onVisibilityChange
      })
    });
    const ExclusiveTransitionContext = GetExclusiveTransitionContext(exclusivityKey);
    return ExclusiveTransitionContext == null ? children !== null && children !== void 0 ? children : null : o$2(ExclusiveTransitionContext.Provider, {
      value: context2,
      children: children
    });
  }
  function useExclusiveTransition(_ref7) {
    let {
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        forceClose,
        exclusivityKey
      }
    } = _ref7;
    const c = GetExclusiveTransitionContext(exclusivityKey);
    useEnsureStability("useExclusiveTransition", c == null);
    const context = c ? q$1(c) : null;
    const index = F$1(() => {
      globalCount += 1;
      return globalCount.toString();
    }, []);
    const [exclusivelyOpen, setExclusivelyOpen, getExclusivelyOpen] = useState(!!show);
    useManagedChild({
      context,
      managedChildParameters: {
        index
      }
    }, {
      index,
      getExclusivelyOpen,
      setExclusivelyOpen,
      forceClose
    });
    const parentOnVisChange = context === null || context === void 0 ? void 0 : context.exclusiveTransitionContext.onVisibilityChange;
    const onVisibilityChange = T$1(visible => {
      parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, visible == false ? "hidden" : "show");
    }, [parentOnVisChange, index]);
    y$1(() => {
      if (show) parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, "show");
    }, [show, parentOnVisChange, index]);
    return {
      exclusiveTransitionReturn: {
        isExclusive: context != null,
        exclusivelyOpen,
        setExclusivelyOpen,
        getExclusivelyOpen,
        onVisibilityChange
      }
    };
  }

  /**
   * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
   * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
   *
   * TODO: Still needed?
   */
  function forwardElementRef(Component) {
    const ForwardedComponent = k(Component);
    return ForwardedComponent;
  }
  /**
   * Useful in particular for Slides with a Tab Panel --
   * if we do Math.sign(currentIndex - slideIndex), it
   * transitions nicely in the expected direction,
   * but we need to "remember" which direction to use
   * when it's the current panel (and the difference is 0)
   */
  function useLastNonNullValue(value) {
    const lastNonNullValue = _(null);
    p$1(() => {
      if (value != null) lastNonNullValue.current = value;
    }, [value]);
    return value !== null && value !== void 0 ? value : lastNonNullValue.current;
  }

  /**
   * Creates a set of props that implement a swap container.
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useCreateSwappableProps(_ref8, otherProps) {
    let {
      inline
    } = _ref8;
    const {
      GetBaseClass
    } = useCssClasses();
    return useMergedProps({
      className: clsx("".concat(GetBaseClass(), "-swap-container"), inline && "".concat(GetBaseClass(), "-swap-container-inline"))
    }, otherProps);
  }
  /**
   * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
   *
   * You must manage each child `<Transitionable>` component's `show` prop -- this component *does not* manage any sort of state in that regard.
   *
   * If you pass a regular element (like a div) or other single component, then thee props and ref will be forwarded onto that element. Otherwise, all the children will be wrapped in a div or span depending on the `inline` prop.
   * @param param0
   * @returns
   */
  const Swappable = x(forwardElementRef(function Swappable(_ref9, ref) {
    var _inline;
    let {
      children: c,
      inline,
      childrenAnimateOnMount,
      exclusivityKey,
      ...p
    } = _ref9;
    let children = c;
    if (!children.type) children = !inline ? o$2("div", {
      children: children
    }) : o$2("span", {
      children: children
    });
    (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
    const transitionProps = useCreateSwappableProps({
      inline
    }, {
      ...p,
      ref
    });
    const mergedWithChildren = useMergedProps(transitionProps, children.props);
    const animateOnMount = _(childrenAnimateOnMount !== null && childrenAnimateOnMount !== void 0 ? childrenAnimateOnMount : false);
    p$1(() => {
      animateOnMount.current = true;
    }, []);
    const contextValue = _({
      getAnimateOnMount: () => {
        return animateOnMount.current;
      }
    });
    let ret = E(children, mergedWithChildren);
    ret = o$2(SwappableContext.Provider, {
      value: contextValue.current,
      children: ret
    });
    if (exclusivityKey) {
      ret = o$2(ExclusiveTransitionProvider, {
        exclusivityKey: exclusivityKey,
        children: ret
      }, exclusivityKey);
    }
    return ret;
  }));
  // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
  // Not perfect, but it's not supposed to be. `inline` is for perfect.
  const inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
  function getTimeoutDuration(element) {
    return Math.max(...window.getComputedStyle(element || document.body).getPropertyValue("transition-duration").split(",").map(str => {
      if (str.endsWith("ms")) return +str.substring(0, str.length - 2);
      if (str.endsWith("s")) return +str.substring(0, str.length - 1) * 1000;
      return 1000;
    }));
  }
  function parseState(nextState) {
    return nextState.split("-");
  }
  /**
   * Provide props that can be used to animate a transition.
   *
   * @param param0
   * @returns
   */
  function useTransition(_ref10) {
    var _animateOnMount, _measure, _easingIn, _easingOut;
    let {
      transitionParameters: {
        propsIncoming: {
          children,
          ...p
        },
        show,
        animateOnMount,
        measure,
        exitVisibility,
        duration,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    } = _ref10;
    useEnsureStability("useTransition", onVisibilityChange);
    const {
      getAnimateOnMount
    } = q$1(SwappableContext);
    exitVisibility || (exitVisibility = "hidden");
    (_animateOnMount = animateOnMount) !== null && _animateOnMount !== void 0 ? _animateOnMount : animateOnMount = getAnimateOnMount();
    (_measure = measure) !== null && _measure !== void 0 ? _measure : measure = false;
    const getExitVisibility = useStableGetter(exitVisibility);
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    } = useCssClasses();
    const getMeasure = useStableGetter(measure);
    const {
      exclusiveTransitionReturn: {
        exclusivelyOpen,
        isExclusive,
        onVisibilityChange: exclusiveTransitionVisibilityChange
      }
    } = useExclusiveTransition({
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        exclusivityKey,
        forceClose: useStableCallback(() => {
          internalOnShowChanged(false, getMeasure());
        })
      }
    });
    if (isExclusive) {
      show = show && exclusivelyOpen;
    }
    const {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({});
    const cssProperties = _({});
    const classNames = _(new Set([// This is removed during useLayoutEffect on the first render
    // (at least once `show` is non-null)
    "".concat(GetBaseClass(), "-pending")]));
    const handleTransitionFinished = T$1(() => {
      const state = getState();
      console.assert(!!state);
      if (state) {
        const [direction, phase] = parseState(state);
        if (phase == "transition") {
          setState("".concat(direction, "-finalize"));
          if (timeoutHandle.current > 0) {
            var _timeoutClearFunction;
            (_timeoutClearFunction = timeoutClearFunction.current) === null || _timeoutClearFunction === void 0 ? void 0 : _timeoutClearFunction.call(timeoutClearFunction, timeoutHandle.current);
            timeoutHandle.current = -1;
          }
        }
      }
    }, []);
    const otherProps = _({
      onTransitionEnd: e => {
        if (e.target == getElement() && e.elapsedTime) {
          handleTransitionFinished();
        }
      }
    });
    const hasMounted = _(false);
    /**
     * Sets the element's CSS class to match the given direction and phase.
     */
    const updateClasses = T$1((element, direction, phase) => {
      if (element == null) return;
      const exitVisibility = getExitVisibility();
      const allClassesToRemove = ["".concat(GetBaseClass(), "-").concat(GetEnterClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-ev-", "inert"), "".concat(GetBaseClass(), "-ev-", "removed"), "".concat(GetBaseClass(), "-ev-", "hidden"), "".concat(GetBaseClass(), "-ev-", "visible"), "".concat(GetBaseClass(), "-pending")];
      const allClassesToAdd = ["".concat(GetBaseClass()), "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction)), phase ? "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction), "-").concat(GetPhaseClass(phase)) : "", "".concat(GetBaseClass(), "-ev-").concat(exitVisibility)];
      element.classList.remove(...allClassesToRemove);
      allClassesToRemove.map(v => classNames.current.delete(v));
      element.classList.add(...allClassesToAdd);
      allClassesToAdd.map(v => classNames.current.add(v));
    }, []);
    /**
     * Updates a single "measure" variable (or removes it)
     */
    const updateSizeProperty = T$1((element, varName, value) => {
      if (value != null) {
        value = "".concat(value, "px");
        element.style.setProperty(varName, value);
        cssProperties.current[varName] = value;
      } else {
        element.style.removeProperty(varName);
        delete cssProperties.current[varName];
      }
    }, []);
    /**
     * Adds the "measure" variupdateClassesables to the element if requested.
     */
    const measureElementAndUpdateProperties = T$1((element, measure) => {
      if (element) {
        var _size, _size2, _size3, _size4;
        let size = null;
        if (measure) {
          size = element.getBoundingClientRect();
        }
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-top"), (_size = size) === null || _size === void 0 ? void 0 : _size.top);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-left"), (_size2 = size) === null || _size2 === void 0 ? void 0 : _size2.left);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-width"), (_size3 = size) === null || _size3 === void 0 ? void 0 : _size3.width);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-height"), (_size4 = size) === null || _size4 === void 0 ? void 0 : _size4.height);
      }
    }, []);
    // We use both useTimeout and requestAnimationFrame for timing certain things --
    // raf is used for changing from init to transition (would use queueMicrotask but it can't be cancelled)
    // setTimeout is used for changing from transition to finalize (as a backup in case transitionend doesn't fire)
    //
    // In order to avoid stale callbacks running (i.e. when we rapidly switch between visible and not)
    // we need to make sure we accurately cancel anything that can change our state on a delay.
    //
    // Also of note, we store "(f) => window.clearTimeout(f)" instead of just "window.clearTimeout" because
    // of the implicit window object -- problems with a missing `this` object and all that nonsense.
    const timeoutHandle = _(-1);
    const timeoutClearFunction = _(null);
    /**
     * Any time the state changes, there's some logic we need to run:
     *
     * * If we're changing to an `init` phase, update the classes, then wait a moment and then change to the `transition` phase.
     * * If we're changing to a `transition` phase, update the classes, then wait until the transition completes, then change to the `finalize` phase.
     *
     * Any change in state or classes/styles does not implicitly cause a re-render.
     */
    const onStateChange = T$1((nextState, prevState, reason) => {
      if (nextState == null) return;
      const [nextDirection, nextPhase] = parseState(nextState);
      const element = getElement();
      // Make sure no stale change code ever runs
      if (timeoutHandle.current >= 0 && timeoutClearFunction.current) timeoutClearFunction.current(timeoutHandle.current);
      // Handle inert props/property
      const exitVisibility = getExitVisibility();
      if (exitVisibility) {
        const inert = exitVisibility == "inert" && nextDirection == "exit" && nextPhase == "finalize" ? true : undefined;
        if (inert) otherProps.current.inert = true;else delete otherProps.current["inert"];
        if (element) element.inert = inert || false;
      }
      const isBeingPainted = nextDirection == "enter" || nextDirection == "exit" && nextPhase != "finalize";
      onVisibilityChange === null || onVisibilityChange === void 0 ? void 0 : onVisibilityChange(isBeingPainted);
      exclusiveTransitionVisibilityChange === null || exclusiveTransitionVisibilityChange === void 0 ? void 0 : exclusiveTransitionVisibilityChange(isBeingPainted);
      updateClasses(element, nextDirection, nextPhase);
      if (element && (nextPhase == "init" || nextPhase == "transition")) forceReflow(element);
      switch (nextPhase) {
        case "measure":
          {
            if (element) measureElementAndUpdateProperties(element, true);
            //setState(`${nextDirection}-init`);
            updateClasses(element, nextDirection, "init");
            if (element) forceReflow(element);
            // !!Intentional fall-through!!
          }

        case "init":
          {
            timeoutHandle.current = requestAnimationFrame(() => {
              setState("".concat(nextDirection, "-transition"));
            });
            timeoutClearFunction.current = f => cancelAnimationFrame(f);
            break;
          }
        case "transition":
          {
            timeoutHandle.current = setTimeout(() => {
              handleTransitionFinished();
            }, getTimeoutDuration(element) * 1.5);
            timeoutClearFunction.current = f => clearTimeout(f);
            break;
          }
        case "finalize":
          {
            // Nothing to do or schedule or anything -- we just update our classes and we're done.
            timeoutClearFunction.current = null; // Does this make it more or less clear?
            break;
          }
        default:
          {
            debugger; // Intentional
            console.log("Invalid state used in transition: ".concat(nextState, ". Previous state was ").concat(prevState !== null && prevState !== void 0 ? prevState : "null"));
            break;
          }
      }
    }, []);
    const [getState, setState] = usePassiveState(onStateChange, returnNull, runImmediately);
    // When we mount, and every time thereafter that `show` changes,
    // change our current state according to that `show` value.
    y$1(() => internalOnShowChanged(show, measure), [measure, show]);
    // This has no dependences and is relied on in two different areas
    function internalOnShowChanged(show, measure) {
      // If `show` is null, then we don't change anything.
      if (show == null) return;
      // (If `show` is true/false, we'll remove the CSS classes during `onChange`)
      const currentState = getState();
      let nextPhase = measure ? "measure" : "init";
      if (currentState) {
        const [currentDirection, currentPhase] = parseState(currentState);
        if (currentPhase != "finalize") nextPhase = "transition";
      }
      // Note: the setState change handler runs immediately with no debounce.
      if (show) {
        if (hasMounted.current || animateOnMount) setState("enter-".concat(nextPhase));else setState("enter-finalize");
      } else {
        if (hasMounted.current || animateOnMount) setState("exit-".concat(nextPhase));else setState("exit-finalize");
      }
      hasMounted.current = true;
    }
    if (duration != null) cssProperties.current["--".concat(GetBaseClass(), "-duration")] = duration + "ms";else delete cssProperties.current["--".concat(GetBaseClass(), "-duration")];
    (_easingIn = easingIn) !== null && _easingIn !== void 0 ? _easingIn : easingIn = easing;
    (_easingOut = easingOut) !== null && _easingOut !== void 0 ? _easingOut : easingOut = easing;
    if (easingOut != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")] = easingOut;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")];
    if (easingIn != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")] = easingIn;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")];
    // No matter what delayMountUntilShown is,
    // once we've rendered our children once, 
    // ensure that we don't unmount them again and waste all that work.
    // (If you really need this you can just unmount the entire transition itself)
    const definitelyShouldMountChildren = show || !delayMountUntilShown;
    const hasRenderedChildren = _(false);
    const renderChildren = definitelyShouldMountChildren || hasRenderedChildren.current;
    p$1(() => {
      if (definitelyShouldMountChildren) hasRenderedChildren.current || (hasRenderedChildren.current = true);
    }, [hasRenderedChildren.current ? false : definitelyShouldMountChildren]);
    const childrenIsVnode = children && children.type && children.props;
    const finalProps = useMergedProps(p, propsStable, otherProps.current, {
      className: [...classNames.current, "".concat(GetBaseClass()), "".concat(GetBaseClass(), "-ev-").concat(exitVisibility), "".concat(GetBaseClass(), "-inline-direction-", "ltr"), "".concat(GetBaseClass(), "-block-direction-", "ttb")].join(" "),
      style: cssProperties.current
    }, childrenIsVnode ? {
      ref: children.ref,
      ...children.props
    } : {});
    const resetContext = _({
      getAnimateOnMount: returnFalse
    }).current;
    let modifiedChildren;
    if (childrenIsVnode) {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: E(children, finalProps)
      });
    } else {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: o$2("span", {
          ...finalProps,
          children: children
        })
      });
    }
    return renderChildren ? modifiedChildren : null;
  }
  function forceReflow(e) {
    // Try really hard to make sure this isn't optimized out by anything.
    // We need it for its document reflow side effect.
    const p = globalThis._dummy;
    globalThis._dummy = e.getBoundingClientRect();
    globalThis._dummy = e.style.opacity;
    globalThis._dummy = e.style.transform;
    globalThis._dummy = p;
    return e;
  }

  /**
   * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useBasePropsFade(_ref11) {
    let {
      fadeParameters: {
        fadeMin,
        fadeMax
      }
    } = _ref11;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-fade"),
      style: {
        ["--".concat(GetBaseClass(), "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
        ["--".concat(GetBaseClass(), "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
   *
   * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
   * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
   * It's generally recommended to either use the components that include a combined fade effect,
   * or just directly a `<Transitionable>` on your own.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Fade(_ref12, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref12;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  function useBasePropsClip(_ref13) {
    var _ref14, _ref15, _ref16, _ref17;
    let {
      clipParameters: {
        clipMin,
        clipMinBlock,
        clipMinInline,
        clipOrigin,
        clipOriginBlock,
        clipOriginInline
      }
    } = _ref13;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: clsx("".concat(GetBaseClass(), "-clip")),
      style: {
        ["--".concat(GetBaseClass(), "-clip-origin-inline")]: (_ref14 = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref14 !== void 0 ? _ref14 : 0.5,
        ["--".concat(GetBaseClass(), "-clip-origin-block")]: (_ref15 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref15 !== void 0 ? _ref15 : 0,
        ["--".concat(GetBaseClass(), "-clip-min-inline")]: (_ref16 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref16 !== void 0 ? _ref16 : 1,
        ["--".concat(GetBaseClass(), "-clip-min-block")]: (_ref17 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref17 !== void 0 ? _ref17 : 0
      }
    };
  }
  x(forwardElementRef(function Clip(_ref18, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref18;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ClipFade(_ref19, ref) {
    let {
      delayMountUntilShown,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      clipMin,
      clipMinBlock,
      clipMinInline,
      clipOrigin,
      clipOriginBlock,
      clipOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref19;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   *
   * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
   *
   * @example <Transitionable measure {...useCreateCollapseProps(...)} />
   */
  function useBasePropsCollapse(_ref20) {
    let {
      collapseParameters: {
        minBlockSize
      }
    } = _ref20;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-collapse"),
      style: {
        ["--".concat(GetBaseClass(), "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
   *
   * *Important*: This component is *not* efficient for the browser to animate!
   * Make sure you do testing on lower power devices, or prefer a lighter
   * alternative, like `<Clip>`.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Collapse(_ref21, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      delayMountUntilShown,
      minBlockSize,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref21;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function CollapseFade(_ref22, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      animateOnMount,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      exitVisibility,
      minBlockSize,
      onVisibilityChange,
      ...rest
    } = _ref22;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsFlip(_ref23) {
    var _useLastNonNullValue, _useLastNonNullValue2;
    let {
      flipParameters: {
        flipAngleBlock,
        flipAngleInline,
        flipPerspective
      }
    } = _ref23;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-flip"),
      style: {
        ["--".concat(GetBaseClass(), "-flip-angle-inline")]: "".concat((_useLastNonNullValue = useLastNonNullValue(flipAngleInline)) !== null && _useLastNonNullValue !== void 0 ? _useLastNonNullValue : 0, "deg"),
        ["--".concat(GetBaseClass(), "-flip-angle-block")]: "".concat((_useLastNonNullValue2 = useLastNonNullValue(flipAngleBlock)) !== null && _useLastNonNullValue2 !== void 0 ? _useLastNonNullValue2 : 0, "deg"),
        ["--".concat(GetBaseClass(), "-perspective")]: "".concat(flipPerspective !== null && flipPerspective !== void 0 ? flipPerspective : 800, "px")
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
   *
   * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * exclusivityKey allows for convenient setups inside of a `SwapContainer`
   * (`flipInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Flip(_ref24, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      flipAngleInline,
      flipAngleBlock,
      flipPerspective,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref24;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFlip({
          flipParameters: {
            flipAngleBlock,
            flipAngleInline,
            flipPerspective
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsSlide(_ref25) {
    var _slideTargetInline, _slideTargetBlock;
    let {
      slideParameters: {
        slideTargetInline,
        slideTargetBlock
      }
    } = _ref25;
    slideTargetInline = useLastNonNullValue(slideTargetInline);
    slideTargetBlock = useLastNonNullValue(slideTargetBlock);
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-slide"),
      style: {
        ["--".concat(GetBaseClass(), "-slide-target-inline")]: "".concat((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 0),
        ["--".concat(GetBaseClass(), "-slide-target-block")]: "".concat((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
   *
   * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * which allows for convenient setups inside of a `SwapContainer`
   * (`slideInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Slide(_ref26, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      onVisibilityChange,
      slideTargetInline,
      slideTargetBlock,
      show,
      animateOnMount,
      exitVisibility,
      delayMountUntilShown,
      ...rest
    } = _ref26;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange,
        propsIncoming: useMergedProps(useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideFade(_ref27, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref27;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsZoom(_ref28) {
    var _ref29, _ref30, _ref31, _ref32;
    let {
      zoomParameters: {
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }
    } = _ref28;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-zoom"),
      style: {
        ["--".concat(GetBaseClass(), "-zoom-origin-inline")]: "".concat((_ref29 = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref29 !== void 0 ? _ref29 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-origin-block")]: "".concat((_ref30 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref30 !== void 0 ? _ref30 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-min-inline")]: "".concat((_ref31 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref31 !== void 0 ? _ref31 : 0),
        ["--".concat(GetBaseClass(), "-zoom-min-block")]: "".concat((_ref32 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref32 !== void 0 ? _ref32 : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
   * @see `Transitionable` `ZoomFade`
   */
  x(forwardElementRef(function Zoom(_ref33, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref33;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoom(_ref34, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref34;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoomFade(_ref35, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      fadeMax,
      fadeMin,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref35;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ZoomFade(_ref36, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref36;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.13.1", l$2, {
    Fragment: _$2,
    Component: k$2
  });
  var o = {};
  function a(e) {
    return e.type === _$2 ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
  }
  var i = [],
    c = [];
  function s() {
    return i.length > 0 ? i[i.length - 1] : null;
  }
  var u = !1;
  function l(e) {
    return "function" == typeof e.type && e.type != _$2;
  }
  function f(n) {
    for (var e = [n], t = n; null != t.__o;) e.push(t.__o), t = t.__o;
    return e.reduce(function (n, e) {
      n += "  in " + a(e);
      var t = e.__source;
      return t ? n += " (at " + t.fileName + ":" + t.lineNumber + ")" : u || (u = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
    }, "");
  }
  var p = "function" == typeof WeakMap;
  function d(n) {
    return n ? "function" == typeof n.type ? d(n.__) : n : {};
  }
  var h = k$2.prototype.setState;
  k$2.prototype.setState = function (n, e) {
    return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(s())), h.call(this, n, e);
  };
  var y = k$2.prototype.forceUpdate;
  function v(n) {
    var e = n.props,
      t = a(n),
      o = "";
    for (var r in e) if (e.hasOwnProperty(r) && "children" !== r) {
      var i = e[r];
      "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), o += " " + r + "=" + JSON.stringify(i);
    }
    var c = e.children;
    return "<" + t + o + (c && c.length ? ">..</" + t + ">" : " />");
  }
  k$2.prototype.forceUpdate = function (n) {
    return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(s())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + f(this.__v)), y.call(this, n);
  }, function () {
    !function () {
      var n = l$2.__b,
        t = l$2.diffed,
        o = l$2.__,
        r = l$2.vnode,
        a = l$2.__r;
      l$2.diffed = function (n) {
        l(n) && c.pop(), i.pop(), t && t(n);
      }, l$2.__b = function (e) {
        l(e) && i.push(e), n && n(e);
      }, l$2.__ = function (n, e) {
        c = [], o && o(n, e);
      }, l$2.vnode = function (n) {
        n.__o = c.length > 0 ? c[c.length - 1] : null, r && r(n);
      }, l$2.__r = function (n) {
        l(n) && c.push(n), a && a(n);
      };
    }();
    var n = !1,
      t = l$2.__b,
      r = l$2.diffed,
      s = l$2.vnode,
      u = l$2.__e,
      h = l$2.__,
      y = l$2.__h,
      m = p ? {
        useEffect: new WeakMap(),
        useLayoutEffect: new WeakMap(),
        lazyPropTypes: new WeakMap()
      } : null,
      b = [];
    l$2.__e = function (n, e, t, o) {
      if (e && e.__c && "function" == typeof n.then) {
        var r = n;
        n = new Error("Missing Suspense. The throwing component was: " + a(e));
        for (var i = e; i; i = i.__) if (i.__c && i.__c.__c) {
          n = r;
          break;
        }
        if (n instanceof Error) throw n;
      }
      try {
        (o = o || {}).componentStack = f(e), u(n, e, t, o), "function" != typeof n.then && setTimeout(function () {
          throw n;
        });
      } catch (n) {
        throw n;
      }
    }, l$2.__ = function (n, e) {
      if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
      var t;
      switch (e.nodeType) {
        case 1:
        case 11:
        case 9:
          t = !0;
          break;
        default:
          t = !1;
      }
      if (!t) {
        var o = a(n);
        throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + o + " />, " + e + ");");
      }
      h && h(n, e);
    }, l$2.__b = function (e) {
      var r = e.type,
        i = d(e.__);
      if (n = !0, void 0 === r) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + v(e) + "\n\n" + f(e));
      if (null != r && "object" == typeof r) {
        if (void 0 !== r.__k && void 0 !== r.__e) throw new Error("Invalid type passed to createElement(): " + r + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + v(r) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
        throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r) ? "array" : r));
      }
      if ("thead" !== r && "tfoot" !== r && "tbody" !== r || "table" === i.type ? "tr" === r && "thead" !== i.type && "tfoot" !== i.type && "tbody" !== i.type && "table" !== i.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + v(e) + "\n\n" + f(e)) : "td" === r && "tr" !== i.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + v(e) + "\n\n" + f(e)) : "th" === r && "tr" !== i.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + v(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + v(e) + "\n\n" + f(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("string" == typeof e.type) for (var c in e.props) if ("o" === c[0] && "n" === c[1] && "function" != typeof e.props[c] && null != e.props[c]) throw new Error("Component's \"" + c + '" property should be a function, but got [' + typeof e.props[c] + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && m && !m.lazyPropTypes.has(e.type)) {
          var s = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
          try {
            var u = e.type();
            m.lazyPropTypes.set(e.type, !0), console.warn(s + "Component wrapped in lazy() is " + a(u));
          } catch (n) {
            console.warn(s + "We will log the wrapped component's name once it is loaded.");
          }
        }
        var l = e.props;
        e.type.__f && delete (l = function (n, e) {
          for (var t in e) n[t] = e[t];
          return n;
        }({}, l)).ref, function (n, e, t, r, a) {
          Object.keys(n).forEach(function (t) {
            var i;
            try {
              i = n[t](e, t, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (n) {
              i = n;
            }
            i && !(i.message in o) && (o[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
          });
        }(e.type.propTypes, l, 0, a(e), function () {
          return f(e);
        });
      }
      t && t(e);
    }, l$2.__h = function (e, t, o) {
      if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
      y && y(e, t, o);
    };
    var w = function (n, e) {
        return {
          get: function () {
            var t = "get" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
          },
          set: function () {
            var t = "set" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
          }
        };
      },
      g = {
        nodeName: w("nodeName", "use vnode.type"),
        attributes: w("attributes", "use vnode.props"),
        children: w("children", "use vnode.props.children")
      },
      E = Object.create({}, g);
    l$2.vnode = function (n) {
      var e = n.props;
      if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
        var t = n.props = {};
        for (var o in e) {
          var r = e[o];
          "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
        }
      }
      n.__proto__ = E, s && s(n);
    }, l$2.diffed = function (e) {
      if (e.__k && e.__k.forEach(function (n) {
        if ("object" == typeof n && n && void 0 === n.type) {
          var t = Object.keys(n).join(",");
          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + f(e));
        }
      }), n = !1, r && r(e), null != e.__k) for (var t = [], o = 0; o < e.__k.length; o++) {
        var a = e.__k[o];
        if (a && null != a.key) {
          var i = a.key;
          if (-1 !== t.indexOf(i)) {
            console.error('Following component has two or more children with the same key attribute: "' + i + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + v(e) + "\n\n" + f(e));
            break;
          }
          t.push(i);
        }
      }
    };
  }();

  /**
   * Relatively low-level hook that allows you to inspect
   * when the entire URL changes, either because the hash changed,
   * or because the Back/Forward browser buttons were pressed.
   *
   * (Changing query parameters reloads the page and so isn't
   * tracked, unless of course it's because of the browser
   * navigating back/forwards).
   *
   * In general, you'll want to inspect a specific directory of
   * a path, or a specific query parameter value, not the
   * entire URL.
   */
  function useUrl(onUrlChange) {
    const [getUrl, setUrl] = usePassiveState$1(useStableCallback$1(onUrlChange), T$1(() => window.location.toString(), []));
    useGlobalHandler(window, "hashchange", e => {
      setUrl(window.location.toString());
    });
    useGlobalHandler(window, "popstate", e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#the_history_stack
      // TODO: If this assert never fires, it's *probably* fine??
      console.assert(window.location.toString() === document.location.toString());
      setUrl(window.location.toString());
    });
    return [getUrl, setUrl];
  }

  //export const RouterLevelContext = createContext(0);
  /**
   * Internal helper to trim the crusts off of a hash path.
   * @param hash
   * @returns
   */
  function trimHash(hash) {
    if (hash.startsWith("#")) hash = hash.substr(1);
    if (hash.startsWith("/")) hash = hash.substr(1);
    if (hash.endsWith("/")) hash = hash.substr(0, hash.length - 1);
    return hash;
  }
  function normalizeHashToPath(hash) {
    hash = trimHash(hash);
    return hash.split("/");
  }
  // Not public -- just contains shared code for history modification.
  // This is what actually changes History and updates the window's URL.
  function setEntireHash(hash, action) {
    var _action;
    (_action = action) !== null && _action !== void 0 ? _action : action = "push";
    hash = trimHash(hash);
    let oldURL = window.location.toString();
    let nextUrl = new URL(window.location.toString());
    nextUrl.hash = "#".concat(hash);
    history["".concat(action, "State")]({}, document.title, nextUrl);
    // Modifying history doesn't actually cause a hashchange event.
    window.dispatchEvent(new HashChangeEvent('hashchange', {
      oldURL,
      newURL: nextUrl.toString()
    }));
  }
  /**
   * Modifies the given Search Params object to have its key be set to the given value.
   *
   * Specifically for boolean types this ensures that the param is simply existant/non-existant,
   * but for other types this is pretty straightforward.
   * @param params
   * @param key
   * @param value
   * @param type
   */
  function unparseParam(params, key, value, type) {
    if (type === "boolean") {
      if (value === true) {
        params.set(key, "");
      } else {
        params.delete(key);
      }
    } else {
      params.set(key, "".concat(value));
    }
  }
  /**
   * Parses the requested Search Param from the given URL.
   *
   * The type will be automatically parsed with special handling for booleans
   */
  function parseParam(url, key, type) {
    let value = url.searchParams.get(key);
    switch (type) {
      case "string":
        return value !== null && value !== void 0 ? value : null;
      case "boolean":
        return value != null;
      case "number":
        if (value == null) return null;
        let parsed = +value;
        if (isFinite(parsed)) return parsed;
        return null;
      case "bigint":
        if (value == null) return null;
        try {
          return BigInt(value);
        } catch (ex) {
          return null;
        }
    }
    return value !== null && value !== void 0 ? value : null;
  }
  //export interface RouterChildInfo extends ManagedChildInfo<string> {
  //    notifyOfSiblingsHaveNoMatches(noMatches: boolean): void;
  //path: RouterPathType | null;
  //    matches: boolean | null;
  //}

  function useConsumeRouter(_ref37) {
    let {
      context,
      managedChildParameters,
      managedChildParameters: {
        index
      },
      consumeRouterParameters: {
        onLocalPathChange,
        localPath: wantedLocalPath
      }
    } = _ref37;
    const {
      routerContext: {
        level,
        notifyParentThatNonDefaultMatchHasChanged
      }
    } = context;
    const [anyMatchesAmongNonDefaultSiblings, setAnyMatchesAmongNonDefaultSiblings] = useState$1(null);
    const [pathWhenMatching, setPathWhenMatching] = useState$1(null);
    const {
      managedChildReturn
    } = useManagedChild$1({
      context,
      managedChildParameters
    }, {
      index,
      setAnyMatchesAmongNonDefaultSiblings: useStableCallback$1(anyMatches => {
        setAnyMatchesAmongNonDefaultSiblings(anyMatches);
        onLocalPathChange2(wantedLocalPath, anyMatches, getLocalPath());
      })
    });
    y$1(() => {
      onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, getLocalPath());
    }, [wantedLocalPath, anyMatchesAmongNonDefaultSiblings]);
    const onLocalPathChange2 = useStableCallback$1(function (wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path) {
      const matches = pathCompare(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
      setMatches(matches);
      console.log("".concat(index, ": onLocalPathChange2(wlp: ").concat((wantedLocalPath !== null && wantedLocalPath !== void 0 ? wantedLocalPath : "null").toString(), ", amands: ").concat((anyMatchesAmongNonDefaultSiblings !== null && anyMatchesAmongNonDefaultSiblings !== void 0 ? anyMatchesAmongNonDefaultSiblings : "null").toString(), ", p: ").concat(path, "): ").concat((matches !== null && matches !== void 0 ? matches : "null").toString()));
      if (matches) setPathWhenMatching(path);
      if (wantedLocalPath != null) {
        notifyParentThatNonDefaultMatchHasChanged(index, matches);
      } else {
        notifyParentThatNonDefaultMatchHasChanged(index, null);
      }
    });
    const [matches, setMatches] = useState$1(null);
    const [getLocalPath, setLocalPath] = useLocalPath({
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange: useStableCallback$1((path, prev, reason) => {
          onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
          onLocalPathChange === null || onLocalPathChange === void 0 ? void 0 : onLocalPathChange(path, prev, reason);
        })
      }
    });
    return {
      managedChildReturn,
      consumeRouterReturn: {
        level,
        matches,
        getLocalPath,
        setLocalPath,
        pathWhenMatching
      }
    };
  }
  function useLocalPath(_ref38) {
    let {
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange
      }
    } = _ref38;
    useEnsureStability$1("useLocalPath", level);
    const urlToPath = T$1(url => {
      const oldHashPath = normalizeHashToPath(trimHash(new URL(url).hash));
      return oldHashPath[level];
    }, []);
    const [getLocalPath, setLocalPath] = usePassiveState$1(useStableCallback$1(onLocalPathChange), T$1(() => {
      return urlToPath(window.location.href);
    }, [urlToPath]));
    // Any time the URL changes, inspect the hash
    // at our current level, and change our local copy of our path
    // in our passive state. This will trigger our callback if they're different.
    useUrl(url => {
      setLocalPath(urlToPath(url));
    });
    return [getLocalPath, setLocalPath];
  }
  function pathCompare(requestedLocalHash, anyMatchesAmongNonDefaultSiblings, localPath) {
    var _localPath;
    let matches;
    (_localPath = localPath) !== null && _localPath !== void 0 ? _localPath : localPath = "";
    if (requestedLocalHash instanceof RegExp) matches = requestedLocalHash.test(localPath);else if (requestedLocalHash instanceof Function) matches = requestedLocalHash(localPath);else if (requestedLocalHash == null) matches = anyMatchesAmongNonDefaultSiblings == null ? null : !anyMatchesAmongNonDefaultSiblings;else matches = requestedLocalHash === localPath;
    return matches;
  }

  /**
   * Error class used when attemps to modify the root directory occur.
   */
  class RootRouterError extends Error {
    constructor() {
      super("The root Router's path can only be pushed to and cannot be set or popped from.");
    }
  }

  /**
   * Removes the directory at the current level, effectively returning
   * to the previous level.  You can also switch to a different
   * previous level if you would like.
   */
  function usePopLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      setEntireHash(popLocalPath(level, dir), action);
    }, [level]);
  }
  function popLocalPath(level, dir) {
    if (level < 0) throw new RootRouterError();
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, level).map(s => s !== null && s !== void 0 ? s : "");
    if (dir) {
      dir = trimHash(dir);
      newHashPath[newHashPath.length - 1] = dir;
    }
    return newHashPath.join("/");
  }

  /**
   * Adds a directory at one level deeper.
   */
  function usePushLocalPath(level) {
    return T$1(function pushLocalHash(dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      dir = trimHash(dir);
      const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
      let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
      newHashPath.splice(level + 1, 1, dir);
      setEntireHash(newHashPath.join("/"), action);
    }, [level]);
  }

  /**
   * Replaces the directory at the current level with a new one. You can
   * choose whether or not any trailing paths are kept -- by default this is false.
   * @returns
   */
  function useSetLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      setEntireHash(setLocalPath(level, dir, keepTrailing || false), action);
    }, [level]);
  }
  function setLocalPath(level, dir, keepTrailing) {
    if (level < 0) throw new RootRouterError();
    dir = trimHash(dir);
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
    newHashPath.splice(level, 1, dir);
    return newHashPath.join("/");
  }

  /**
   * Allows easy access to the controls at the current level.
   *
   * You can also get this information from a child <Router />
   * by passing in a ref (e.g. <Router ref={setControls} />).
   */
  function useRouterControls(level) {
    // This is the hash at this level specifically, 
    // so it contains no directory separators.
    const popLocalPath = usePopLocalPath(level);
    const pushLocalPath = usePushLocalPath(level);
    const setLocalPath = useSetLocalPath(level);
    return F$1(() => ({
      popLocalPath,
      pushLocalPath,
      setLocalPath
    }), [popLocalPath, pushLocalPath, setLocalPath]);
  }
  const RouterContext = F$2(null);
  //const RouterContext = createContext<RouterContextType | null>(null);
  /**
   * The "parent" part of a router.
   *
   * This is responsible for coordinating, among all children, which route to show.
   * This coordination is really only needed for the "default" pathway, which
   * needs to know as painlessly as possible whether any of its siblings are currently valid.
   *
   * It also increases the depth by one, starting at depth=-1 for the root router is *just* a parent.
   */
  function useProvideRouter(_ref39) {
    var _q$;
    let {
      managedChildrenParameters
    } = _ref39;
    const {
      context,
      managedChildrenReturn
    } = useManagedChildren$1({
      managedChildrenParameters
    });
    const {
      routerContext: {
        level
      }
    } = (_q$ = q$1(RouterContext)) !== null && _q$ !== void 0 ? _q$ : {
      routerContext: {
        level: -1
      }
    };
    const matchingIndices = _(new Set());
    const [getShowingDefault, setShowingDefault] = usePassiveState$1(useStableCallback$1(showingDefault => {
      managedChildrenReturn.getChildren().forEach(child => {
        child.setAnyMatchesAmongNonDefaultSiblings(!showingDefault);
      });
    }), returnNull$1);
    const onNonDefaultChildMatchChanged = useStableCallback$1((index, matches) => {
      matchingIndices.current[matches ? "add" : "delete"](index);
      setShowingDefault(matchingIndices.current.size == 0);
    });
    return {
      context: useStableObject$1({
        ...context,
        routerContext: useStableObject$1({
          level: level + 1,
          notifyParentThatNonDefaultMatchHasChanged: onNonDefaultChildMatchChanged
        })
      }),
      managedChildrenReturn
    };
  }

  /**
   * Allows you to conditionally hide/show content based on a path in the hash component of the URL.
   *
   * @param param0
   * @param ref
   * @returns
   */
  function Router(_ref40, ref) {
    var _consumeRouterReturn;
    let {
      localPath,
      onLocalPathChange,
      children
    } = _ref40;
    const context = q$1(RouterContext);
    const {
      context: contextFromParent,
      managedChildrenReturn
    } = useProvideRouter({
      managedChildrenParameters: {}
    });
    const index = F$1(() => (localPath !== null && localPath !== void 0 ? localPath : "<default>") + "-".concat(Math.random()), [localPath]);
    let consumeRouterReturn = null;
    useEnsureStability$1("Router", !!context);
    if (context) {
      consumeRouterReturn = useConsumeRouter({
        consumeRouterParameters: {
          localPath,
          onLocalPathChange
        },
        context,
        managedChildParameters: {
          index
        }
      });
    }
    const {
      consumeRouterReturn: {
        level,
        matches,
        pathWhenMatching
      }
    } = (_consumeRouterReturn = consumeRouterReturn) !== null && _consumeRouterReturn !== void 0 ? _consumeRouterReturn : {
      consumeRouterReturn: {
        level: -1,
        matches: null,
        pathWhenMatching: null
      }
    };
    const controls = useRouterControls(level);
    A(ref, () => ({
      level,
      matches,
      pathWhenMatching,
      ...controls
    }));
    return o$2(RouterContext.Provider, {
      value: contextFromParent,
      children: children(level == -1 ? "/" : matches ? pathWhenMatching : null, useRouterControls(level))
    });
  }

  /**
   * Provides access to the requested Search Param's value
   *
   * Note that while this function is like usePassiveState (itself like useState and useEffect combined),
   * the `setState` return function is, due to browser limitations, not syncronous, but that's
   * like most calls to `setState` anyway I guess?
   *
   * @param paramKey The name of the URL search parameter to reference
   * @param type The type of data encode/decode (`"string"` | `"boolean"` | `"number"` | `"bigint"`)
   * @param onParamValueChanged Will be called any time the requested Search Parameter's value changes.
   */
  function useSearchParams(paramKey, type, onParamValueChanged) {
    // We keep a local copy of our current Search Param value
    // because changing it is actually an asyncronous operation
    // and we can't know when it ends aside from just "did the URL change or not"
    // so we might as well keep this state around locally to compensate.
    const [getSavedParamValue, setSavedParamValue] = usePassiveState$1(onParamValueChanged, T$1(() => {
      return parseParam(new URL(window.location.toString()), paramKey, type);
    }, []));
    const setParamWithHistory = useStableCallback$1((newValueOrUpdater, reason) => {
      let prevValue = parseParam(new URL(window.location.toString()), paramKey, type);
      let nextValue = typeof newValueOrUpdater == "function" ? newValueOrUpdater(prevValue) : newValueOrUpdater;
      let newParams = new URLSearchParams(new URL(window.location.toString()).searchParams);
      unparseParam(newParams, paramKey, nextValue, type);
      let nextUrl = new URL(window.location.toString());
      nextUrl.search = prettyPrintParams(newParams);
      history["".concat(reason !== null && reason !== void 0 ? reason : "replace", "State")]({}, document.title, nextUrl);
      setSavedParamValue(nextValue);
    });
    // Any time the URL changes, it means the Search Param we care about might have changed.
    // Parse it out and save it.
    useUrl(useStableCallback$1(url => {
      const newParam = parseParam(new URL(url), paramKey, type);
      setSavedParamValue(newParam);
    }));
    return [getSavedParamValue, setParamWithHistory];
  }
  function prettyPrintParams(params) {
    const paramArray = [...params.entries()].filter((key, value) => value != null);
    if (paramArray.length == 0) return "";
    let queryString = paramArray.map(_ref41 => {
      let [key, value] = _ref41;
      if (value === "" || value === true) return "".concat(encodeURIComponent(key));else return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
    }).join("&");
    return "?".concat(queryString);
  }
  const Component = () => {
    const [url, setUrl] = useState$1("");
    useUrl(setUrl);
    const [example, setExampleLocal] = useState$1(null);
    const [getExample, setExample] = useSearchParams("example", "number");
    return o$2(Router, {
      localPath: null,
      children: (path, _ref42) => {
        let {
          pushLocalPath,
          popLocalPath,
          setLocalPath
        } = _ref42;
        return path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is the current URL: ", o$2("code", {
              children: url
            }), "."]
          }), o$2("p", {
            children: "This is content in the root router. It is always displayed, no matter what."
          }), o$2("p", {
            children: ["The ", o$2("code", {
              children: "Router"
            }), " that's rendering this content cannot have path-related functions performed on it, since the path is always just implicitly ", o$2("code", {
              children: "/"
            }), "."]
          }), o$2("p", {
            children: "Just beneath me is a child component that reads the first path after the root."
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => {
                debugger;
                pushLocalPath("test1");
              },
              children: "Push \"test1\""
            })
          }), o$2("p", {
            children: o$2("button", {
              disabled: true,
              onClick: () => popLocalPath(),
              children: "Pop"
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => setLocalPath("test1"),
              children: "Set \"test1\""
            })
          }), o$2("p", {
            children: o$2("label", {
              children: ["Search param example: ", o$2("input", {
                value: example !== null && example !== void 0 ? example : undefined,
                type: "number",
                onInput: e => setExample(e.currentTarget.valueAsNumber)
              })]
            })
          }), o$2("hr", {}), o$2(Swappable, {
            children: o$2("div", {
              children: o$2(Level1, {})
            })
          })]
        });
      }
    });
  };
  function Level1() {
    //const [{ popLocalPath, pushLocalPath, setLocalPath }, setRouteControls] = useState<Partial<RouterControls>>({});
    return o$2(_$2, {
      children: [o$2(Router, {
        localPath: null,
        children: (path, _ref43) => {
          let {
            popLocalPath,
            pushLocalPath,
            setLocalPath
          } = _ref43;
          return path != null && o$2("div", {
            children: [o$2("p", {
              children: ["This is within the first-level child ", o$2("code", {
                children: "Router"
              }), " that displays ", o$2("em", {
                children: "default content"
              }), ". That is, if no other ", o$2("code", {
                children: "Router"
              }), " at this level matches (which is presumably true if you're reading this), then ", o$2("em", {
                children: "this"
              }), " ", o$2("code", {
                children: "Router"
              }), " will display."]
            }), o$2("p", {
              children: ["The current path is: ", o$2("code", {
                children: path
              })]
            }), o$2("p", {
              children: ["These buttons are hooked up to this ", o$2("code", {
                children: "Router"
              }), "'s ", o$2("code", {
                children: "ref"
              }), ", so they control this level in the path."]
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("");
              },
              children: "(empty string)"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test1");
              },
              children: "test1"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test2");
              },
              children: "test2"
            })]
          });
        }
      }), o$2(Router, {
        localPath: "",
        children: path => path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is within the first-level child ", o$2("code", {
              children: "Router"
            }), " that displays when the path is empty (this is different from the default path, taken when there is no match from anyone at this level)."]
          }), o$2("p", {
            children: ["The current path is: ", o$2("code", {
              children: path
            })]
          })]
        })
      })]
    });
  }
  /*
  function Test1() {
        const [{ popLocalPath: popHash1, pushLocalPath: pushHash1, setLocalPath: setHash1 }, setRouteControls] = useState<Partial<RouterControls>>({});
       return (
          <>
              <p>This is within the first-level child <code>Router</code> that displays when the path is <code>test1</code>.<Test1 /></p>
              <p>Level 1, Test1
                  <button onClick={() => { debugger; pushHash1?.("testa") }}>testA</button>
                  <Router ref={setRouteControls} localPath="testa">
                      <div>A</div>
                  </Router>
              </p>
          </>
       )
  }
   function Test2() {
      const [route0Controls, setRoute0Controls] = useState<RouterRefType | null>(null);
      const [route1Controls, setRoute1Controls] = useState<RouterRefType | null>(null);
       const [param, setParam] = useSearchParams("param", "boolean");
      console.log(param == null ? "<null>" : param);
      return (<>
          Test2: "{param == null ? "<null>" : param}".
          <Swappable>
              <span>
                  <Router ref={setRoute1Controls} localPath="">
                      <div>
                          Test2
                          <button onClick={() => route1Controls?.setLocalPath?.("testa")}>testA</button>
                      </div>
                  </Router>
                  <Router ref={setRoute1Controls} localPath="testa">
                      <div>
                          <div>A</div>
                          <label><input checked={param ?? false} type="checkbox" onInput={e => { e.preventDefault(); setParam(e.currentTarget.checked) }} />Checkbox</label>
                      </div>
                  </Router>
              </span>
          </Swappable>
      </>
      )
  }*/
  requestAnimationFrame(() => {
    B$2(o$2(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jYXRjaC1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDRlZWY2N2QyODE1NDI3OTVlZWY5ZDRiMWQ0NzNiZjU4NWYyZWM1MzVfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXRpbC91c2UtY2FsbC1jb3VudC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91dGlsL3JhbmRvbS1pZC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDEuMi4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDRlZWY2N2QyODE1NDI3OTVlZWY5ZDRiMWQ0NzNiZjU4NWYyZWM1MzVfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXByb3BzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDRlZWY2N2QyODE1NDI3OTVlZWY5ZDRiMWQ0NzNiZjU4NWYyZWM1MzVfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDRlZWY2N2QyODE1NDI3OTVlZWY5ZDRiMWQ0NzNiZjU4NWYyZWM1MzVfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tpbmctZWxlbWVudHNAMC4xLjEvbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS93aWNnLWluZXJ0QDMuMS4yL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLW1hbmFnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANGVlZjY3ZDI4MTU0Mjc5NWVlZjlkNGIxZDQ3M2JmNTg1ZjJlYzUzNV9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvUHVyZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9wb3J0YWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtaW1wZXJhdGl2ZS1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0ZWVmNjdkMjgxNTQyNzk1ZWVmOWQ0YjFkNDczYmY1ODVmMmVjNTM1X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vY2xzeEAxLjIuMS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXJlZnMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2NraW5nLWVsZW1lbnRzQDAuMS4xL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vd2ljZy1pbmVydEAzLjEuMi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvY29udGV4dC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2V4Y2x1c2l2ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvdXRpbC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3N3YXBwYWJsZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb25hYmxlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvZmFkZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NsaXAudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jbGlwLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jb2xsYXBzZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NvbGxhcHNlLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9mbGlwLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvc2xpZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS1mYWRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvem9vbS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3NsaWRlLXpvb20udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS16b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy96b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGV2dG9vbHMvc3JjL2RldnRvb2xzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NoZWNrLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NvbXBvbmVudC1zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9kZWJ1Zy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9pbmRleC5qcyIsIi4uL3NyYy91c2UtdXJsLnRzeCIsIi4uL3NyYy91dGlsLnRzeCIsIi4uL3NyYy91c2Utcm91dGVyLWNvbnN1bWVyLnRzeCIsIi4uL3NyYy9yb290LXJvdXRlci1lcnJvci50cyIsIi4uL3NyYy91c2UtcG9wLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1wdXNoLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1zZXQtbG9jYWwtcGF0aC50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1jb250cm9scy50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1wcm92aWRlci50c3giLCIuLi9zcmMvcm91dGVyLnRzeCIsIi4uL3NyYy91c2Utc2VhcmNoLXBhcmFtcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBhXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYlxuICovXG5jb25zdCBkZXB0aFNvcnQgPSAoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoO1xuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdHdoaWxlICgoYyA9IHJlcmVuZGVyUXVldWUuc2hpZnQoKSkpIHtcblx0XHRpZiAoYy5fZGlydHkpIHtcblx0XHRcdGxldCByZW5kZXJRdWV1ZUxlbmd0aCA9IHJlcmVuZGVyUXVldWUubGVuZ3RoO1xuXHRcdFx0cmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdFx0aWYgKHJlcmVuZGVyUXVldWUubGVuZ3RoID4gcmVuZGVyUXVldWVMZW5ndGgpIHtcblx0XHRcdFx0Ly8gV2hlbiBpLmUuIHJlcmVuZGVyaW5nIGEgcHJvdmlkZXIgYWRkaXRpb25hbCBuZXcgaXRlbXMgY2FuIGJlIGluamVjdGVkLCB3ZSB3YW50IHRvXG5cdFx0XHRcdC8vIGtlZXAgdGhlIG9yZGVyIGZyb20gdG9wIHRvIGJvdHRvbSB3aXRoIHRob3NlIG5ldyBpdGVtcyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW0gaW4gYVxuXHRcdFx0XHQvLyBzaW5nbGUgcGFzc1xuXHRcdFx0XHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRbXX0gKi9cblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChcblx0XHRcdGNoaWxkVk5vZGUgPT0gbnVsbCB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tICE9IG51bGwgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSA9PSBuZXdQYXJlbnRWTm9kZS5fbmV4dERvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXdQYXJlbnRWTm9kZS5fX25leHREb20gcG9pbnRzIHRvIGEgZG9tIG5vZGUgdGhhdCBpcyBhYm91dCB0b1xuXHRcdFx0XHQvLyBiZSB1bm1vdW50ZWQsIHRoZW4gZ2V0IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhhdCB2bm9kZSBhbmQgc2V0XG5cdFx0XHRcdC8vIF9uZXh0RG9tIHRvIGl0XG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gZ2V0TGFzdERvbShvbGRQYXJlbnRWTm9kZSkubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBnZXRMYXN0RG9tKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09IG51bGwgfHwgdHlwZW9mIHZub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLl9kb207XG5cdH1cblxuXHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0Zm9yIChsZXQgaSA9IHZub2RlLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdGxldCBsYXN0RG9tID0gZ2V0TGFzdERvbShjaGlsZCk7XG5cdFx0XHRcdGlmIChsYXN0RG9tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhc3REb207XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ3dpZHRoJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hlaWdodCcgJiZcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZS5pbmRleE9mKCctJykgIT0gLTEpKSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIHRydWVdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUsIHNsaWNlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQvLyBJZiB0aGUgcHJldmlvdXMgZGlmZiBiYWlsZWQgb3V0LCByZXN1bWUgY3JlYXRpbmcvaHlkcmF0aW5nLlxuXHRpZiAob2xkVk5vZGUuX2h5ZHJhdGluZyAhPSBudWxsKSB7XG5cdFx0aXNIeWRyYXRpbmcgPSBvbGRWTm9kZS5faHlkcmF0aW5nO1xuXHRcdG9sZERvbSA9IG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdC8vIGlmIHdlIHJlc3VtZSwgd2Ugd2FudCB0aGUgdHJlZSB0byBiZSBcInVubG9ja2VkXCJcblx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IFtvbGREb21dO1xuXHR9XG5cblx0aWYgKCh0bXAgPSBvcHRpb25zLl9kaWZmKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHR0cnkge1xuXHRcdG91dGVyOiBpZiAodHlwZW9mIG5ld1R5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0bGV0IGMsIGlzTmV3LCBvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90LCBjbGVhclByb2Nlc3NpbmdFeGNlcHRpb247XG5cdFx0XHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBjcmVhdGVDb250ZXh0IGFwaS4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHdpbGwgcGFzc1xuXHRcdFx0Ly8gdGhlIGNvbnRleHQgdmFsdWUgYXMgYHRoaXMuY29udGV4dGAganVzdCBmb3IgdGhpcyBjb21wb25lbnQuXG5cdFx0XHR0bXAgPSBuZXdUeXBlLmNvbnRleHRUeXBlO1xuXHRcdFx0bGV0IHByb3ZpZGVyID0gdG1wICYmIGdsb2JhbENvbnRleHRbdG1wLl9pZF07XG5cdFx0XHRsZXQgY29tcG9uZW50Q29udGV4dCA9IHRtcFxuXHRcdFx0XHQ/IHByb3ZpZGVyXG5cdFx0XHRcdFx0PyBwcm92aWRlci5wcm9wcy52YWx1ZVxuXHRcdFx0XHRcdDogdG1wLl9kZWZhdWx0VmFsdWVcblx0XHRcdFx0OiBnbG9iYWxDb250ZXh0O1xuXG5cdFx0XHQvLyBHZXQgY29tcG9uZW50IGFuZCBzZXQgaXQgdG8gYGNgXG5cdFx0XHRpZiAob2xkVk5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0XHRjID0gbmV3Vk5vZGUuX2NvbXBvbmVudCA9IG9sZFZOb2RlLl9jb21wb25lbnQ7XG5cdFx0XHRcdGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wZW5kaW5nRXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbmV3IGNvbXBvbmVudFxuXHRcdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRoZSBjaGVjayBhYm92ZSB2ZXJpZmllcyB0aGF0IG5ld1R5cGUgaXMgc3VwcG9zZSB0byBiZSBjb25zdHJ1Y3RlZFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRydXN0IG1lLCBDb21wb25lbnQgaW1wbGVtZW50cyB0aGUgaW50ZXJmYWNlIHdlIHdhbnRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIHtcblx0XHRcdFx0XHRcdC8vIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBhIGJhaWwgYmVjYXVzZSBvZiBzQ1Ugd2UgaGF2ZSB0byB1cGRhdGVcblx0XHRcdFx0XHRcdC8vIHRoZSBwcm9wcywgc3RhdGUgYW5kIGRpcnR5LXN0YXRlLlxuXHRcdFx0XHRcdFx0Ly8gd2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIHN0cmljdC1lcXVhbGl0eSB3ZSBkb24ndCBhcyB0aGUgY2hpbGQgY291bGQgc3RpbGxcblx0XHRcdFx0XHRcdC8vIGJlIGRpcnRpZWQgc2VlICMzODgzXG5cdFx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJbiBjYXNlcyBvZiBiYWlsaW5nIGR1ZSB0byBzdHJpY3QtZXF1YWxpdHkgd2UgaGF2ZSB0byByZXNldCBmb3JjZSBhcyB3ZWxsXG5cdFx0XHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuLmZvckVhY2godm5vZGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlKSB2bm9kZS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkge1xuXHRcdFx0YXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHRcdHZub2RlLl9jb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KFxuXHRcdFx0XHRcdHJbaV0sXG5cdFx0XHRcdFx0cGFyZW50Vk5vZGUsXG5cdFx0XHRcdFx0c2tpcFJlbW92ZSB8fCB0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHtcblx0XHRyZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX3BhcmVudCA9IHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG9iamVjdH0gW3JlcGxhY2VOb2RlXSBPcHRpb25hbDogQXR0ZW1wdCB0byByZS11c2UgYW5cbiAqIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgcmVwbGFjZU5vZGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudERvbSwgcmVwbGFjZU5vZGUpIHtcblx0aWYgKG9wdGlvbnMuX3Jvb3QpIG9wdGlvbnMuX3Jvb3Qodm5vZGUsIHBhcmVudERvbSk7XG5cblx0Ly8gV2UgYWJ1c2UgdGhlIGByZXBsYWNlTm9kZWAgcGFyYW1ldGVyIGluIGBoeWRyYXRlKClgIHRvIHNpZ25hbCBpZiB3ZSBhcmUgaW5cblx0Ly8gaHlkcmF0aW9uIG1vZGUgb3Igbm90IGJ5IHBhc3NpbmcgdGhlIGBoeWRyYXRlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgRE9NXG5cdC8vIGVsZW1lbnQuLlxuXHRsZXQgaXNIeWRyYXRpbmcgPSB0eXBlb2YgcmVwbGFjZU5vZGUgPT09ICdmdW5jdGlvbic7XG5cblx0Ly8gVG8gYmUgYWJsZSB0byBzdXBwb3J0IGNhbGxpbmcgYHJlbmRlcigpYCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZVxuXHQvLyBET00gbm9kZSwgd2UgbmVlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRyZWUuIFdlIGRvXG5cdC8vIHRoaXMgYnkgYXNzaWduaW5nIGEgbmV3IGBfY2hpbGRyZW5gIHByb3BlcnR5IHRvIERPTSBub2RlcyB3aGljaCBwb2ludHNcblx0Ly8gdG8gdGhlIGxhc3QgcmVuZGVyZWQgdHJlZS4gQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50LCB3aGljaFxuXHQvLyBtZWFucyB0aGF0IHdlIGFyZSBtb3VudGluZyBhIG5ldyB0cmVlIGZvciB0aGUgZmlyc3QgdGltZS5cblx0bGV0IG9sZFZOb2RlID0gaXNIeWRyYXRpbmdcblx0XHQ/IG51bGxcblx0XHQ6IChyZXBsYWNlTm9kZSAmJiByZXBsYWNlTm9kZS5fY2hpbGRyZW4pIHx8IHBhcmVudERvbS5fY2hpbGRyZW47XG5cblx0dm5vZGUgPSAoXG5cdFx0KCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZSkgfHxcblx0XHRwYXJlbnREb21cblx0KS5fY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsImltcG9ydCB7IGFzc2lnbiwgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKFxuXHRcdHZub2RlLnR5cGUsXG5cdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSB8fCB2bm9kZS5rZXksXG5cdFx0cmVmIHx8IHZub2RlLnJlZixcblx0XHRudWxsXG5cdCk7XG59XG4iLCIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgncHJlYWN0JykuVk5vZGV9IFZOb2RlICovXG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGZpbGUgZXhwb3J0cyB2YXJpb3VzIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQmFiZWwncyBcImF1dG9tYXRpY1wiIEpTWCBydW50aW1lIEFQSTpcbiAqIC0ganN4KHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeHModHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIF9fc291cmNlLCBfX3NlbGYpXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGNyZWF0ZVZOb2RlIGhlcmUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cbiAqIEJlbmNobWFya3M6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWY2YjU0YTBiNDYzMjEwMGE3ZGNkMmIzXG4gKi9cblxuLyoqXG4gKiBKU1guRWxlbWVudCBmYWN0b3J5IHVzZWQgYnkgQmFiZWwncyB7cnVudGltZTpcImF1dG9tYXRpY1wifSBKU1ggdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1ZOb2RlWyd0eXBlJ119IHR5cGVcbiAqIEBwYXJhbSB7Vk5vZGVbJ3Byb3BzJ119IHByb3BzXG4gKiBAcGFyYW0ge1ZOb2RlWydrZXknXX0gW2tleV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW2lzU3RhdGljQ2hpbGRyZW5dXG4gKiBAcGFyYW0ge3Vua25vd259IFtfX3NvdXJjZV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW19fc2VsZl1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgX19zb3VyY2UsIF9fc2VsZikge1xuXHQvLyBXZSdsbCB3YW50IHRvIHByZXNlcnZlIGByZWZgIGluIHByb3BzIHRvIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yXG5cdC8vIGZvcndhcmRSZWYgY29tcG9uZW50cyBpbiB0aGUgZnV0dXJlLCBidXQgdGhhdCBzaG91bGQgaGFwcGVuIHZpYVxuXHQvLyBhIHNlcGFyYXRlIFBSLlxuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdyZWYnKSB7XG5cdFx0XHRyZWYgPSBwcm9wc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wczogbm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IC0tdm5vZGVJZCxcblx0XHRfX3NvdXJjZSxcblx0XHRfX3NlbGZcblx0fTtcblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHMuXG5cdC8vIE5vdGU6IGB0eXBlYCBpcyBvZnRlbiBhIFN0cmluZywgYW5kIGNhbiBiZSBgdW5kZWZpbmVkYCBpbiBkZXZlbG9wbWVudC5cblx0aWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIChyZWYgPSB0eXBlLmRlZmF1bHRQcm9wcykpIHtcblx0XHRmb3IgKGkgaW4gcmVmKVxuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkUHJvcHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHJlZltpXTtcblx0XHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQge1xuXHRjcmVhdGVWTm9kZSBhcyBqc3gsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeHMsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeERFVixcblx0RnJhZ21lbnRcbn07XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRsZXQgcHJldlNjdSA9IGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuXHRcdFx0Y29uc3QgcHJldkNXVSA9IGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgZm9yY2VkIHVwZGF0ZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCB3aWxsXG5cdFx0XHQvLyBub3QgYmUgY2FsbGVkLiBCdXQgd2UgdXNlIHRoYXQgdG8gdXBkYXRlIHRoZSBob29rIHZhbHVlcywgc28gd2Vcblx0XHRcdC8vIG5lZWQgdG8gY2FsbCBpdC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uKHAsIHMsIGMpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2ZvcmNlKSB7XG5cdFx0XHRcdFx0bGV0IHRtcCA9IHByZXZTY3U7XG5cdFx0XHRcdFx0Ly8gQ2xlYXIgdG8gYXZvaWQgb3RoZXIgc0NVIGhvb2tzIGZyb20gYmVpbmcgY2FsbGVkXG5cdFx0XHRcdFx0cHJldlNjdSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR1cGRhdGVIb29rU3RhdGUocCwgcywgYyk7XG5cdFx0XHRcdFx0cHJldlNjdSA9IHRtcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcmV2Q1dVKSBwcmV2Q1dVLmNhbGwodGhpcywgcCwgcywgYyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBUaGlzIFNDVSBoYXMgdGhlIHB1cnBvc2Ugb2YgYmFpbGluZyBvdXQgYWZ0ZXIgcmVwZWF0ZWQgdXBkYXRlc1xuXHRcdFx0Ly8gdG8gc3RhdGVmdWwgaG9va3MuXG5cdFx0XHQvLyB3ZSBzdG9yZSB0aGUgbmV4dCB2YWx1ZSBpbiBfbmV4dFZhbHVlWzBdIGFuZCBrZWVwIGRvaW5nIHRoYXQgZm9yIGFsbFxuXHRcdFx0Ly8gc3RhdGUgc2V0dGVycywgaWYgd2UgaGF2ZSBuZXh0IHN0YXRlcyBhbmRcblx0XHRcdC8vIGFsbCBuZXh0IHN0YXRlcyB3aXRoaW4gYSBjb21wb25lbnQgZW5kIHVwIGJlaW5nIGVxdWFsIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG5cdFx0XHQvLyB3ZSBhcmUgc2FmZSB0byBiYWlsIG91dCBmb3IgdGhpcyBzcGVjaWZpYyBjb21wb25lbnQuXG5cdFx0XHQvKipcblx0XHRcdCAqXG5cdFx0XHQgKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50W1wic2hvdWxkQ29tcG9uZW50VXBkYXRlXCJdfVxuXHRcdFx0ICovXG5cdFx0XHQvLyBAdHMtaWdub3JlIC0gV2UgZG9uJ3QgdXNlIFRTIHRvIGRvd250cmFuc3BpbGVcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZUhvb2tTdGF0ZShwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdXBkYXRlSG9va1N0YXRlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH07XG59XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKTogXCJwcm9kdWN0aW9uXCIgfCBcImRldmVsb3BtZW50XCIge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudiEuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBcImRldmVsb3BtZW50XCI7XG5cbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEJ1aWxkTW9kZSA9IGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQ7Ly9tZW1vaXplKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQpIGFzIHR5cGVvZiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkOyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vb3A7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5pbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuXG5sZXQgdGltZW91dEhhbmRsZSA9IG51bGwgYXMgbnVtYmVyIHwgbnVsbDtcblxuaW50ZXJmYWNlIEhvb2tDYWxsQ291bnQge1xuICAgIGNhbGxDb3VudHNUb3RhbDogeyBbSzogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIH07XG4gICAgY2FsbENvdW50c01vbWVudDogeyBbSzogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIH1cbn1cblxudHlwZSBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCA9IChXaW5kb3cgJiB0eXBlb2YgZ2xvYmFsVGhpcykgJiB7XG4gICAgX2hvb2tDYWxsQ291bnQ6IEhvb2tDYWxsQ291bnQ7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb3VudFUoaG9vazogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBuYW1lID0gaG9vay5uYW1lO1xuICAgIGlmIChmaWx0ZXJBbGwgfHwgZmlsdGVycy5oYXMobmFtZSkpXG4gICAgICAgIHJldHVybjtcblxuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50ID8/PSB7IGNhbGxDb3VudHNNb21lbnQ6IHt9LCBjYWxsQ291bnRzVG90YWw6IHt9IH07XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudFtuYW1lXSA/Pz0gMDtcbiAgICAod2luZG93IGFzIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50KS5faG9va0NhbGxDb3VudC5jYWxsQ291bnRzVG90YWxbbmFtZV0gPz89IDA7XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudFtuYW1lXSEgKz0gMTtcbiAgICAod2luZG93IGFzIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50KS5faG9va0NhbGxDb3VudC5jYWxsQ291bnRzVG90YWxbbmFtZV0hICs9IDE7XG5cbiAgICBpZiAodGltZW91dEhhbmRsZSA9PSBudWxsKSB7XG4gICAgICAgIHRpbWVvdXRIYW5kbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHNNb21lbnQpO1xuICAgICAgICAgICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudCA9IHt9O1xuICAgICAgICAgICAgdGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubGV0IGZpbHRlckFsbCA9IGZhbHNlO1xuY29uc3QgZmlsdGVycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUNhbGxDb3VudChob29rOiBGdW5jdGlvbiB8IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJBbGwgPSAoaG9vayA9PT0gXCJhbGxcIik7XG5cbiAgICBpZiAoaG9vayAhPSBcImFsbFwiKVxuICAgICAgICBmaWx0ZXJzLmFkZChob29rLm5hbWUpO1xufVxuXG5leHBvcnQgY29uc3QgbW9uaXRvckNhbGxDb3VudDogdHlwZW9mIGNhbGxDb3VudFUgPSAoZ2V0QnVpbGRNb2RlKCkgPT0gXCJkZXZlbG9wbWVudFwiKSA/IGNhbGxDb3VudFUgOiBub29wO1xuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldEJ1aWxkTW9kZSB9IGZyb20gXCIuLi91dGlsL21vZGUuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKiogVGFrZXMgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgYSB2YWx1ZSwgdW5saWtlIGBPblBhc3NpdmVTdGF0ZUNoYW5nZWAgd2hpY2ggcmVhY3RzIHRvIHRob3NlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8UywgUj4gPSAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpIDogKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uOiBSKSA9PiB2b2lkKTtcbi8qKiBSZXNwb25kcyB0byBhIGNoYW5nZSBpbiBhIHZhbHVlLCB1bmxpa2UgYFBhc3NpdmVTdGF0ZVVwZGF0ZXJgIHdoaWNoIGNhdXNlcyB0aGUgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8UywgUj4gPSAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSkgOiAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbjogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuXG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIGlmIChnZXRCdWlsZE1vZGUoKSA9PSAncHJvZHVjdGlvbicpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZjxBcnJheTxUPj4oW10pO1xuICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWY8QXJyYXk8Ym9vbGVhbj4+KFtdKTtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCBhcyBhbnksIC0xKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFUgZXh0ZW5kcyBUPih2YWx1ZTogVSwgaTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSArIDE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpfS1pbmRleGVkIGFyZ3VtZW50ICgke2kgPj0gMD8gSlNPTi5zdHJpbmdpZnkodmFsdWVzW2ldKSA6IFwidGhlIG51bWJlciBvZiBzdXBwb3NlZGx5IHN0YWJsZSBlbGVtZW50c1wifSkuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gcXVldWVNaWNyb3Rhc2spKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlUGFzc2l2ZVN0YXRlKTtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMV0pID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0aGlzIGhlcmUgKGFzIHdlbGwgYXMgYmVsb3cpIGluIGNhc2UgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgaW52b2tlcyB0aGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmVhc29uUmVmLmN1cnJlbnQgPSByZWFzb24gYXMgUjtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWFzb24gPSByZWFzb25SZWYuY3VycmVudCEgYXMgUjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogcHJldkRlcCwgbmV4dFJlYXNvbikgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9XG5cbi8qKiBcbiAqIEFuIGFsdGVybmF0aXZlIHRvIHVzZSBmb3IgYGN1c3RvbURlYm91bmNlUmVuZGVyaW5nYCB0aGF0IGNhdXNlcyBgdXNlUGFzc2l2ZVN0YXRlYCB0byBydW4gY2hhbmdlcyB3aXRob3V0IHdhaXRpbmcgYSB0aWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuSW1tZWRpYXRlbHkoZjogKCkgPT4gdm9pZCkgeyBmKCk7IH0iLCJcblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiBiZWNhdXNlIHVzZUJlZm9yZUxheW91dEVmZmVjdCBhbHNvIG5lZWRzIHJhbmRvbSBJRHMgZm9yIGl0cyBvd24gcmVhc29ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XG59IiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi4vdXRpbC9yYW5kb20taWQuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjayB8IG51bGwsIGlucHV0cz86IElucHV0cykge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlQmVmb3JlTGF5b3V0RWZmZWN0KTtcblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIGlmIChlZmZlY3QpXG4gICAgICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcbiAgICBlbHNlXG4gICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbaWRdKVxufVxuXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzPzogSW5wdXRzLCBuZXdBcmdzPzogSW5wdXRzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhb2xkQXJncyB8fFxuICAgICAgICBvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncz8ubGVuZ3RoIHx8XG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG4gICAgKTtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlU3RhYmxlR2V0dGVyKTtcblxuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKCkgPT4geyByZWYuY3VycmVudCA9IHZhbHVlOyB9KSwgW3ZhbHVlXSk7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgYXMgdW5rbm93biA9PT0gVW5zZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgcmV0cmlldmVkIGZyb20gdXNlU3RhYmxlR2V0dGVyKCkgY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyLicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbn1cblxuXG4vKipcbiAqIExpa2UgYHVzZVN0YWJsZUdldHRlcmAsIGJ1dCAqKipyZXF1aXJlcyoqKiB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlIG9iamVjdCBpcyBhbHNvIHN0YWJsZSxcbiAqIGFuZCBpbiB0dXJuIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaXRzZWxmIGlzIHN0YWJsZS5cbiAqIEBwYXJhbSB0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVPYmplY3Q8VCBleHRlbmRzIHt9Pih0OiBUKTogVCB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5lbnRyaWVzKHQpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZU9iamVjdFwiLCBlLmxlbmd0aCwgLi4uZS5tYXAoKFtfaywgdl0pID0+IHYpKTtcbiAgICByZXR1cm4gdXNlUmVmKHQpLmN1cnJlbnQ7XG59XG5cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrTmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlU3RhYmxlQ2FsbGJhY2spO1xuICAgIFxuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0sIHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRDaGlsZHJlbik7XG4gICAgXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbnR5cGUgQyA9IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNsYXNzTmFtZVwiXTtcbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxuICogRHVwbGljYXRlIGNsYXNzZXMgYXJlIHJlbW92ZWQgKG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFueXdheSkuXG4gKiBcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XG4gKiBAcGFyYW0gcmhzIENsYXNzZXMgb2YgdGhlIHNlY29uZCBjb21wb25lbnRcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2xhc3NlcyhsaHNDbGFzczogQywgbGhzQ2xhc3NOYW1lOiBDLCByaHNDbGFzczogQywgcmhzQ2xhc3NOYW1lOiBDKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZENsYXNzZXMpO1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAocmVmIGFzIFJlZk9iamVjdDxUIHwgbnVsbD4pLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gKiBAcGFyYW0gbGhzIFxuICogQHBhcmFtIHJocyBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXCJyZWZcIl0sIGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXCJyZWZcIl0pIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZFJlZnMpO1xuICAgIFxuICAgIC8vIFRoaXMgKm11c3QqIGJlIHN0YWJsZSBpbiBvcmRlciB0byBwcmV2ZW50IHJlcGVhdGVkIHJlc2V0IGBudWxsYCBjYWxscyBhZnRlciBldmVyeSByZW5kZXIuXG4gICAgY29uc3QgY29tYmluZWQgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBjb21iaW5lZChjdXJyZW50OiBFIHwgbnVsbCkge1xuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcbiAgICB9KTtcblxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocyE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHMhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZFN0eWxlcyk7XG5cbiAgICAvLyBFYXN5IGNhc2UsIHdoZW4gdGhlcmUgYXJlIG5vIHN0eWxlcyB0byBtZXJnZSByZXR1cm4gbm90aGluZy5cbiAgICBpZiAoIWxocyAmJiAhcmhzKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXG4gICAgICAgIGlmIChsaHMgJiYgIXJocylcbiAgICAgICAgICAgIHJldHVybiBsaHM7XG4gICAgICAgIGlmICghbGhzICYmIHJocylcbiAgICAgICAgICAgIHJldHVybiByaHM7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0eXBlIHRvIGFuIG9iamVjdCBiYWcgdHlwZSBhbmQgcnVuIGl0IGFnYWluLlxuICAgICAgICBpZiAobGhzICYmIHJocykge1xuICAgICAgICAgICAgLy8gKHVzZU1lcmdlZFN0eWxlcyBpc24ndCBhIHRydWUgaG9vayAtLSB0aGlzIGlzbid0IGEgdmlvbGF0aW9uKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHN0eWxlU3RyaW5nVG9PYmplY3QobGhzIGFzIHN0cmluZyksIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHN0eWxlU3RyaW5nVG9PYmplY3QocmhzIGFzIHN0cmluZykpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2dpYz8/P1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFRoZXkncmUgYm90aCBzdHJpbmdzLCBqdXN0IGNvbmNhdGVuYXRlIHRoZW0uXG4gICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gYCR7bGhzfTske3JocyA/PyBcIlwifWAgYXMgdW5rbm93biBhcyBzdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4obGhzID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxuICAgICAgICAuLi4ocmhzID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDbGFzc2VzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jbGFzc2VzLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkUHJvcHMpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPiksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPik+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGgsIFByZWFjdERPTUF0dHJpYnV0ZXMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxuICogXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cbiAqIFxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cbiAqL1xudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xuXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XG5cblxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xuXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcblxuXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xuXG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICogXG4gKiBgXCJtb2RlXCJgIGNvbnRyb2xzIGlmIHRoZXJlJ3Mgb25lIGhhbmRsZXIgdGhhdCBjYWxscyBhbGwgeW91ciBmdW5jdGlvbnMgKGRlZmF1bHQpLCBvciBvbmUgaGFuZGxlciBhZGRlZCBwZXIgZnVuY3Rpb24gKGBcInNpbmdsZVwiYCkuIFxuICogXG4gKiBUaGUgZGVmYXVsdCwgYFwiZ3JvdXBlZFwiYCwgaXMgZmFzdGVyIHdoZW4geW91IGhhdmUsIHNheSwgYSBidXR0b24gY29tcG9uZW50LCB1c2VkIGh1bmRyZWRzIG9mIHRpbWVzIG9uIGEgcGFnZSwgdGhhdCBlYWNoIGluc3RhbGxzIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuXG4gKiBcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxuICogQHJldHVybnNcbiAqICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdLCBtb2RlPzogXCJncm91cGVkXCIgfCBcInNpbmdsZVwiKTogdm9pZCB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VHbG9iYWxIYW5kbGVyKTtcbiAgICBtb2RlIHx8PSBcImdyb3VwZWRcIjtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VHbG9iYWxIYW5kbGVyXCIsIG1vZGUpO1xuXG4gICAgaWYgKG1vZGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXG4gICAgICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXG4gICAgICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXG4gICAgICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJHcm91cGVkPFQsIEV2ZW50VHlwZSwgSD4odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJTaW5nbGU8VCwgRXZlbnRUeXBlLCBIPih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxudHlwZSBHbG9iYWxIYW5kbGVySW5mbyA9IHsgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7IGxpc3RlbmVyczogU2V0PEV2ZW50TGlzdGVuZXI+OyB9O1xudHlwZSBNYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8c3RyaW5nLCBHbG9iYWxIYW5kbGVySW5mbz5cbnR5cGUgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8VHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RXZlbnRUYXJnZXQ+LCBNYXBPZk9wdGlvbnNUb0luZm8+O1xubGV0IG1hcFRoaW5nID0gbmV3IE1hcDxFdmVudFRhcmdldCwgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8+KCk7XG5cbmZ1bmN0aW9uIGRvTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4ob3A6IChpOiBHbG9iYWxIYW5kbGVySW5mbywgaDogRXZlbnRMaXN0ZW5lcikgPT4gdm9pZCwgdGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zOiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBpZiAoaGFuZGxlcikge1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnNLZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYnlUeXBlID0gbWFwVGhpbmcuZ2V0KHRhcmdldCkgfHwgKG5ldyBNYXAoKSBhcyBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbyk7XG4gICAgICAgIGNvbnN0IGJ5T3B0aW9ucyA9IChieVR5cGUuZ2V0KHR5cGUpIHx8IChuZXcgTWFwKCkgYXMgTWFwT2ZPcHRpb25zVG9JbmZvKSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBieU9wdGlvbnMuZ2V0KG9wdGlvbnNLZXkpIHx8IHsgbGlzdGVuZXI6IG51bGwhLCBsaXN0ZW5lcnM6IG5ldyBTZXQoKSB9O1xuXG4gICAgICAgIG9wKGluZm8sIGhhbmRsZXIpO1xuXG4gICAgICAgIGJ5T3B0aW9ucy5zZXQob3B0aW9uc0tleSwgaW5mbyk7XG4gICAgICAgIGJ5VHlwZS5zZXQodHlwZSwgYnlPcHRpb25zKTtcbiAgICAgICAgbWFwVGhpbmcuc2V0KHRhcmdldCwgYnlUeXBlKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWRkVG9NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM6IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuYWRkKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbU1hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuZGVsZXRlKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB3YXkgZmFzdGVyIGZvciBsYXJnZSBudW1iZXJzIG9mIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBGb3IgZXhhbXBsZSwgaWYgZXZlcnkgYnV0dG9uIGxpc3RlbnMgZm9yIGEgZ2xvYmFsIGNsaWNrLCBvciBzb21ldGhpbmcsXG4gKiBpdCB3b3VsZCBiZSBuaWNlIGlmIGl0IHdhcyBlZmZpY2llbnQgYXQgbGVhc3QuIFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGFkZFRvTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVGcm9tTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlclNpbmdsZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cbiAqIFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICogXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIGBgYFxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xuXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcbiAgICAgICAgfSwgW3R5cGVdKTtcblxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XG5cbiAgICB9LCBbXSk7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcblxuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xuICAgIC8qKlxuICAgICAqIEZvciB0aGUgc2FrZSBvZiBjb252ZW5pZW5jZSxcbiAgICAgKiB0aGlzIG9uZSBpcyBvcHRpb25hbCwgc2luY2UgdXNpbmcgdGhpcyBob29rIGlzIHNvIGNvbW1vbixcbiAgICAgKiBidXQgdXNpbmcgaXRzIHBhcmFtZXRlciBvcHRpb25zIGlzIHNvIHVuY29tbW9uLCBhbmQgaXQnc1xuICAgICAqIGFic2Vuc2UgaXNuJ3QgdXN1YWxseSBiZWNhdXNlIGl0IHdhcyBmb3Jnb3R0ZW4sIGl0J3MgYmVjYXVzZVxuICAgICAqIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAgICAqL1xuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzPzoge1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+O1xuICAgICAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnRQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdIHtcbiAgICByZXR1cm4gW3IucmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSwgLi4ub3RoZXJQcm9wc107XG59Ki9cblxuLyoqXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cbiAqIFxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXG4gKiBcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJnczogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VSZWZFbGVtZW50KTtcblxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzLnJlZkVsZW1lbnRQYXJhbWV0ZXJzIHx8IHt9KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+PigoZSwgcHJldlZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xuICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XG5cbiAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XG5cbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbCwgbmV2ZXI+KGhhbmRsZXIsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4oeyByZWY6IHNldEVsZW1lbnQgfSk7XG5cbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnQsXG4gICAgICAgIFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCBkZWJvdW5jZVJlbmRlcmluZywgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdXG5cbiAgICBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IEludGVybmFsQ2hpbGRJbmZvPE0+O1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ6IChpbmRleDogTVtcImluZGV4XCJdLCBtb3VudGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWQ6IChpbmRleDogTVtcImluZGV4XCJdKSA9PiAoKCkgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXG4gKiBcbiAqICogYGluZGV4YCByZWZlcnMgdG8gd2hpY2ggY2hpbGQgdGhpcyBpcy5cbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcbiAqICogYHN1YkluZm9gIGlzIGFueXRoaW5nIHVzZWQgYnkgYSBkZXJpdmVkIGhvb2suIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGZvciBleGFtcGxlLCBuZWVkcyB0byBrbm93IGhvdyB0byBmb2N1cyBhbiBhcmJpdHJhcnkgY2hpbGQsIHNvIHRoZSBjaGlsZCBwb3B1bGF0ZXMgYGluZm9gIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBtZXRob2QgY2FsbGVkIGBmb2N1c1NlbGZgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4ge1xuICAgIGluZGV4OiBUO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgICAgICogXG4gICAgICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRPRE86IFRoaXMgZW5kZWQgdXAgbm90IGJlaW5nIG5lZWRlZCBieSBhbnl0aGluZy4gSXMgaXQgbmVjZXNzYXJ5PyBEb2VzIGl0IGNvc3QgYW55dGhpbmc/XG4gICAgICAgICAqL1xuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PE1bXCJpbmRleFwiXT47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxNW1wiaW5kZXhcIl0+O1xuXG4gICAgICAgIG9uQ2hpbGRDb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNvdW50OiBudW1iZXIpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHkgc2hhcmVkIGFtb25nIGFsbCBtYW5hZ2VkIGNoaWxkcmVuLlxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgcmVkdW5kYW50IHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCwgd2hpY2ggaXMuLi5laC4gQnV0IHRoZSB0eXBlcyBhcmUgY2xlYXIuXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxNLCBcImluZGV4XCI+O1xuXG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKioqU1RBQkxFKioqXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCAqKmJvdGgqKiBgZ2V0Q2hpbGRyZW5gIGFuZCB0aGUgYE1hbmFnZWRDaGlsZHJlbmAgb2JqZWN0IGl0IHJldHVybnMgYXJlIHN0YWJsZSFcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgaW5zdGVhZCBvZiBhbiBvYmplY3QgYmVjYXVzZSB3aGVuIGZ1bmN0aW9uIGNhbGxzIGhhcHBlbiBvdXQgb2Ygb3JkZXIgaXQncyBlYXNpZXIgdG8ganVzdCBoYXZlIGFsd2F5cyBiZWVuIHBhc3NpbmcgYW5kIHJldHVybiBnZXR0ZXJzIGV2ZXJ5d2hlcmUgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cbiAgICB9O1xuXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogTVtcImluZGV4XCJdKTogTSB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqICoqVU5TVEFCTEUqKiwgXG4gICAgICogYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgXG4gICAgICogYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbixcbiAgICAgKiBvciBhdCBsZWFzdCBwcm9wZXJseSBuYW1lIGl0LlxuICAgICAqIFxuICAgICAqIFdIQVQgVEhJUyBET0VTOlxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIGNoaWxkcmVuLCBzbGljZXMgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlbSwgXG4gICAgICogYW5kLCAqY3J1dGlhbGx5KiwgZmlsbHMgaW4gYW55IGhvbGVzIGluIHRoZSBhcnJheSB3aXRoIGEgcHNldWRvLWNoaWxkIHRoYXQganVzdCBjb250YWlucyBhbiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGJlaGF2aW9yLCB0byBiZSBjbGVhciwgaXMgb25seSBuZWNlc3NhcnkgZm9yIHNvcnRpbmcgYW5kIHJlYXJyYW5naW5nIGJlY2F1c2VcbiAgICAgKiBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyByZXF1aXJlIGtub3dpbmcgcGVyZmVjdGx5IHdoaWNoIGluZGV4IG1hcHMgdG8gd2hpY2guXG4gICAgICogV2UgZG9uJ3QgbmVlZCBhbnkgb3RoZXIgbWlzc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYXJyYXkgYmVzaWRlcyB0aGUgbWlzc2luZyBpbmRleC5cbiAgICAgKiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1bXTtcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ2hpbGRJbmZvPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+IHtcbiAgICBhcnI6IEFycmF5PE0+O1xuICAgIHJlYzogUGFydGlhbDxSZWNvcmQ8TVtcImluZGV4XCJdLCBNPj47XG4gICAgaGlnaGVzdEluZGV4OiBudW1iZXI7XG4gICAgbG93ZXN0SW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1hbmFnZWRDaGlsZHJlbik7XG4gICAgXG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRDb3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZENvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEhpZ2hlc3RJbmRleCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2ldID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IHsgaW5kZXg6IGkgfSBhcyBNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1hbmFnZWRDaGlsZCk7XG5cbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChpbmZvLmNvbnRleHQgPz8geyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuQXJyYXkgPT0gbnVsbCB8fCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4hIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbiwgbmV3U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCwgcHJldlNlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwpOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VTdGF0ZSk7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlXG4gKiBAcGFyYW0geyp9IHhcbiAqIEBwYXJhbSB7Kn0geVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdHJldHVybiAoeCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNsYXNzIHdpdGggYSBwcmVkZWZpbmVkIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHApIHtcblx0dGhpcy5wcm9wcyA9IHA7XG59XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcbi8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIE1lbW9pemUgYSBjb21wb25lbnQsIHNvIHRoYXQgaXQgb25seSB1cGRhdGVzIHdoZW4gdGhlIHByb3BzIGFjdHVhbGx5IGhhdmVcbiAqIGNoYW5nZWQuIFRoaXMgd2FzIHByZXZpb3VzbHkga25vd24gYXMgYFJlYWN0LnB1cmVgLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gYyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICogQHBhcmFtIHsocHJldjogb2JqZWN0LCBuZXh0OiBvYmplY3QpID0+IGJvb2xlYW59IFtjb21wYXJlcl0gQ3VzdG9tIGVxdWFsaXR5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vKGMsIGNvbXBhcmVyKSB7XG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0XHRsZXQgcmVmID0gdGhpcy5wcm9wcy5yZWY7XG5cdFx0bGV0IHVwZGF0ZVJlZiA9IHJlZiA9PSBuZXh0UHJvcHMucmVmO1xuXHRcdGlmICghdXBkYXRlUmVmICYmIHJlZikge1xuXHRcdFx0cmVmLmNhbGwgPyByZWYobnVsbCkgOiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBhcmVyKSB7XG5cdFx0XHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIWNvbXBhcmVyKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgIXVwZGF0ZVJlZjtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lbW9lZChwcm9wcykge1xuXHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gc2hvdWxkVXBkYXRlO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGMsIHByb3BzKTtcblx0fVxuXHRNZW1vZWQuZGlzcGxheU5hbWUgPSAnTWVtbygnICsgKGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lKSArICcpJztcblx0TWVtb2VkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblx0TWVtb2VkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTWVtb2VkO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5sZXQgb2xkRGlmZkhvb2sgPSBvcHRpb25zLl9kaWZmO1xub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0aWYgKHZub2RlLnR5cGUgJiYgdm5vZGUudHlwZS5fZm9yd2FyZGVkICYmIHZub2RlLnJlZikge1xuXHRcdHZub2RlLnByb3BzLnJlZiA9IHZub2RlLnJlZjtcblx0XHR2bm9kZS5yZWYgPSBudWxsO1xuXHR9XG5cdGlmIChvbGREaWZmSG9vaykgb2xkRGlmZkhvb2sodm5vZGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0ZPUldBUkRfU1lNQk9MID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRTeW1ib2wuZm9yICYmXG5cdFx0U3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSkgfHxcblx0MHhmNDc7XG5cbi8qKlxuICogUGFzcyByZWYgZG93biB0byBhIGNoaWxkLiBUaGlzIGlzIG1haW5seSB1c2VkIGluIGxpYnJhcmllcyB3aXRoIEhPQ3MgdGhhdFxuICogd3JhcCBjb21wb25lbnRzLiBVc2luZyBgZm9yd2FyZFJlZmAgdGhlcmUgaXMgYW4gZWFzeSB3YXkgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnQgaW5zdGVhZCBvZiBvbmUgb2YgdGhlIHdyYXBwZXIgaXRzZWxmLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Gb3J3YXJkRm59IGZuXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkUmVmKGZuKSB7XG5cdGZ1bmN0aW9uIEZvcndhcmRlZChwcm9wcykge1xuXHRcdGxldCBjbG9uZSA9IGFzc2lnbih7fSwgcHJvcHMpO1xuXHRcdGRlbGV0ZSBjbG9uZS5yZWY7XG5cdFx0cmV0dXJuIGZuKGNsb25lLCBwcm9wcy5yZWYgfHwgbnVsbCk7XG5cdH1cblxuXHQvLyBtb2J4LXJlYWN0IGNoZWNrcyBmb3IgdGhpcyBiZWluZyBwcmVzZW50XG5cdEZvcndhcmRlZC4kJHR5cGVvZiA9IFJFQUNUX0ZPUldBUkRfU1lNQk9MO1xuXHQvLyBtb2J4LXJlYWN0IGhlYXZpbHkgcmVsaWVzIG9uIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG5cdC8vIEl0IGV4cGVjdHMgYW4gb2JqZWN0IGhlcmUgd2l0aCBhIGByZW5kZXJgIHByb3BlcnR5LFxuXHQvLyBhbmQgcHJvdG90eXBlLnJlbmRlciB3aWxsIGZhaWwuIFdpdGhvdXQgdGhpc1xuXHQvLyBtb2J4LXJlYWN0IHRocm93cy5cblx0Rm9yd2FyZGVkLnJlbmRlciA9IEZvcndhcmRlZDtcblxuXHRGb3J3YXJkZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSBGb3J3YXJkZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdEZvcndhcmRlZC5kaXNwbGF5TmFtZSA9ICdGb3J3YXJkUmVmKCcgKyAoZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSkgKyAnKSc7XG5cdHJldHVybiBGb3J3YXJkZWQ7XG59XG4iLCJpbXBvcnQgeyB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCBtYXBGbiA9IChjaGlsZHJlbiwgZm4pID0+IHtcblx0aWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gdG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheShjaGlsZHJlbikubWFwKGZuKSk7XG59O1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxuZXhwb3J0IGNvbnN0IENoaWxkcmVuID0ge1xuXHRtYXA6IG1hcEZuLFxuXHRmb3JFYWNoOiBtYXBGbixcblx0Y291bnQoY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gPyB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLmxlbmd0aCA6IDA7XG5cdH0sXG5cdG9ubHkoY2hpbGRyZW4pIHtcblx0XHRjb25zdCBub3JtYWxpemVkID0gdG9DaGlsZEFycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAobm9ybWFsaXplZC5sZW5ndGggIT09IDEpIHRocm93ICdDaGlsZHJlbi5vbmx5Jztcblx0XHRyZXR1cm4gbm9ybWFsaXplZFswXTtcblx0fSxcblx0dG9BcnJheTogdG9DaGlsZEFycmF5XG59O1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9kb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb24ndCBjYWxsIG9sZENhdGNoRXJyb3IgaWYgd2UgZm91bmQgYSBTdXNwZW5zZVxuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQoZXJyb3IsIG5ld1ZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xufTtcblxuY29uc3Qgb2xkVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcbm9wdGlvbnMudW5tb3VudCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5fb25SZXNvbHZlKSB7XG5cdFx0Y29tcG9uZW50Ll9vblJlc29sdmUoKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgaHlkcmF0aW5nXG5cdC8vIG1vc3QgbGlrZWx5IGl0IGlzIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWRcblx0Ly8gd2Ugc2V0IHRoZSB2bm9kZS50eXBlIGFzIGBudWxsYCBzbyB0aGF0IGl0IGlzIG5vdCBhIHR5cGVvZiBmdW5jdGlvblxuXHQvLyBzbyB0aGUgdW5tb3VudCB3aWxsIHJlbW92ZSB0aGUgdm5vZGUuX2RvbVxuXHRpZiAoY29tcG9uZW50ICYmIHZub2RlLl9oeWRyYXRpbmcgPT09IHRydWUpIHtcblx0XHR2bm9kZS50eXBlID0gbnVsbDtcblx0fVxuXG5cdGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgJiYgdm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzKSB7XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZm9yRWFjaChlZmZlY3QgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVmZmVjdC5fY2xlYW51cCA9PSAnZnVuY3Rpb24nKSBlZmZlY3QuX2NsZWFudXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IGRldGFjaGVkUGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRkZXRhY2hlZENsb25lKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3JpZ2luYWwodm5vZGUsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudCkge1xuXHRpZiAodm5vZGUpIHtcblx0XHR2bm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0cmVtb3ZlT3JpZ2luYWwoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudClcblx0XHRcdCk7XG5cblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gZGV0YWNoZWRQYXJlbnQpIHtcblx0XHRcdFx0aWYgKHZub2RlLl9kb20pIHtcblx0XHRcdFx0XHRvcmlnaW5hbFBhcmVudC5pbnNlcnRCZWZvcmUodm5vZGUuX2RvbSwgdm5vZGUuX25leHREb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gb3JpZ2luYWxQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGU8YW55LCBhbnk+fSBzdXNwZW5kaW5nVk5vZGUgVGhlIHN1c3BlbmRpbmcgY29tcG9uZW50XG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5fY2hpbGREaWRTdXNwZW5kID0gZnVuY3Rpb24ocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBbXTtcbn07XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudFtcInByb3BzXCJdfSBwcm9wc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZVN0YXRlfSBzdGF0ZVxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHQvLyBXaGVuIHRoZSBTdXNwZW5zZSdzIF92bm9kZSB3YXMgY3JlYXRlZCBieSBhIGNhbGwgdG8gY3JlYXRlVk5vZGVcblx0XHQvLyAoaS5lLiBkdWUgdG8gYSBzZXRTdGF0ZSBmdXJ0aGVyIHVwIGluIHRoZSB0cmVlKVxuXHRcdC8vIGl0J3MgX2NoaWxkcmVuIHByb3AgaXMgbnVsbCwgaW4gdGhpcyBjYXNlIHdlIFwiZm9yZ2V0XCIgYWJvdXQgdGhlIHBhcmtlZCB2bm9kZXMgdG8gZGV0YWNoXG5cdFx0aWYgKHRoaXMuX3Zub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnN0IGRldGFjaGVkQ29tcG9uZW50ID0gdGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdLl9jb21wb25lbnQ7XG5cdFx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKFxuXHRcdFx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIsXG5cdFx0XHRcdGRldGFjaGVkUGFyZW50LFxuXHRcdFx0XHQoZGV0YWNoZWRDb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tID0gZGV0YWNoZWRDb21wb25lbnQuX3BhcmVudERvbSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdC8vIFdyYXAgZmFsbGJhY2sgdHJlZSBpbiBhIFZOb2RlIHRoYXQgcHJldmVudHMgaXRzZWxmIGZyb20gYmVpbmcgbWFya2VkIGFzIGFib3J0aW5nIG1pZC1oeWRyYXRpb246XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9ICovXG5cdGNvbnN0IGZhbGxiYWNrID1cblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmZhbGxiYWNrKTtcblx0aWYgKGZhbGxiYWNrKSBmYWxsYmFjay5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdGZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7KCh1bnN1c3BlbmQ6ICgpID0+IHZvaWQpID0+IHZvaWQpP31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1c3BlbmRlZCh2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzdXNwZW5kZWQgfSBmcm9tICcuL3N1c3BlbnNlLmpzJztcblxuLy8gSW5kZXhlcyB0byBsaW5rZWQgbGlzdCBub2RlcyAobm9kZXMgYXJlIHN0b3JlZCBhcyBhcnJheXMgdG8gc2F2ZSBieXRlcykuXG5jb25zdCBTVVNQRU5ERURfQ09VTlQgPSAwO1xuY29uc3QgUkVTT0xWRURfQ09VTlQgPSAxO1xuY29uc3QgTkVYVF9OT0RFID0gMjtcblxuLy8gSGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZUxpc3QoKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBudWxsO1xufVxuXG4vLyBNYXJrIG9uZSBvZiBjaGlsZCdzIGVhcmxpZXIgc3VzcGVuc2lvbnMgYXMgcmVzb2x2ZWQuXG4vLyBTb21lIHBlbmRpbmcgY2FsbGJhY2tzIG1heSBiZWNvbWUgY2FsbGFibGUgZHVlIHRvIHRoaXNcbi8vIChlLmcuIHRoZSBsYXN0IHN1c3BlbmRlZCBkZXNjZW5kYW50IGdldHMgcmVzb2x2ZWQgd2hlblxuLy8gcmV2ZWFsT3JkZXIgPT09ICd0b2dldGhlcicpLiBQcm9jZXNzIHRob3NlIGNhbGxiYWNrcyBhcyB3ZWxsLlxuY29uc3QgcmVzb2x2ZSA9IChsaXN0LCBjaGlsZCwgbm9kZSkgPT4ge1xuXHRpZiAoKytub2RlW1JFU09MVkVEX0NPVU5UXSA9PT0gbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0Ly8gVGhlIG51bWJlciBhIGNoaWxkIChvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYmVlbiBzdXNwZW5kZWRcblx0XHQvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgdGltZXMgaXQncyBiZWVuIHJlc29sdmVkLiBUaGVyZWZvcmUgd2Vcblx0XHQvLyBtYXJrIHRoZSBjaGlsZCBhcyBjb21wbGV0ZWx5IHJlc29sdmVkIGJ5IGRlbGV0aW5nIGl0IGZyb20gLl9tYXAuXG5cdFx0Ly8gVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hlbiAqYWxsKiBjaGlsZHJlbiBoYXZlIGJlZW4gY29tcGxldGVseVxuXHRcdC8vIHJlc29sdmVkIHdoZW4gcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJy5cblx0XHRsaXN0Ll9tYXAuZGVsZXRlKGNoaWxkKTtcblx0fVxuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzIGZhbHN5IHRoZW4gd2UgY2FuIGRvIGFuIGVhcmx5IGV4aXQsIGFzIHRoZVxuXHQvLyBjYWxsYmFja3Mgd29uJ3QgZ2V0IHF1ZXVlZCBpbiB0aGUgbm9kZSBhbnl3YXkuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicgdGhlbiBhbHNvIGRvIGFuIGVhcmx5IGV4aXRcblx0Ly8gaWYgYWxsIHN1c3BlbmRlZCBkZXNjZW5kYW50cyBoYXZlIG5vdCB5ZXQgYmVlbiByZXNvbHZlZC5cblx0aWYgKFxuXHRcdCFsaXN0LnByb3BzLnJldmVhbE9yZGVyIHx8XG5cdFx0KGxpc3QucHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICd0JyAmJiBsaXN0Ll9tYXAuc2l6ZSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gV2FsayB0aGUgY3VycmVudGx5IHN1c3BlbmRlZCBjaGlsZHJlbiBpbiBvcmRlciwgY2FsbGluZyB0aGVpclxuXHQvLyBzdG9yZWQgY2FsbGJhY2tzIG9uIHRoZSB3YXkuIFN0b3AgaWYgd2UgZW5jb3VudGVyIGEgY2hpbGQgdGhhdFxuXHQvLyBoYXMgbm90IGJlZW4gY29tcGxldGVseSByZXNvbHZlZCB5ZXQuXG5cdG5vZGUgPSBsaXN0Ll9uZXh0O1xuXHR3aGlsZSAobm9kZSkge1xuXHRcdHdoaWxlIChub2RlLmxlbmd0aCA+IDMpIHtcblx0XHRcdG5vZGUucG9wKCkoKTtcblx0XHR9XG5cdFx0aWYgKG5vZGVbUkVTT0xWRURfQ09VTlRdIDwgbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0bGlzdC5fbmV4dCA9IG5vZGUgPSBub2RlW05FWFRfTk9ERV07XG5cdH1cbn07XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlTGlzdC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuX3N1c3BlbmRlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRjb25zdCBkZWxlZ2F0ZWQgPSBzdXNwZW5kZWQobGlzdC5fdm5vZGUpO1xuXG5cdGxldCBub2RlID0gbGlzdC5fbWFwLmdldChjaGlsZCk7XG5cdG5vZGVbU1VTUEVOREVEX0NPVU5UXSsrO1xuXG5cdHJldHVybiB1bnN1c3BlbmQgPT4ge1xuXHRcdGNvbnN0IHdyYXBwZWRVbnN1c3BlbmQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIWxpc3QucHJvcHMucmV2ZWFsT3JkZXIpIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRoZSB1bmRlZmluZWQgKGZhbHN5KSByZXZlYWxPcmRlciwgYXMgdGhlcmVcblx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBjb29yZGluYXRlIGEgc3BlY2lmaWMgb3JkZXIgb3IgdW5zdXNwZW5kcy5cblx0XHRcdFx0dW5zdXNwZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnB1c2godW5zdXNwZW5kKTtcblx0XHRcdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRkZWxlZ2F0ZWQod3JhcHBlZFVuc3VzcGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdyYXBwZWRVbnN1c3BlbmQoKTtcblx0XHR9XG5cdH07XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG5cblx0Y29uc3QgY2hpbGRyZW4gPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXHRpZiAocHJvcHMucmV2ZWFsT3JkZXIgJiYgcHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICdiJykge1xuXHRcdC8vIElmIG9yZGVyID09PSAnYmFja3dhcmRzJyAob3IsIHdlbGwsIGFueXRoaW5nIHN0YXJ0aW5nIHdpdGggYSAnYicpXG5cdFx0Ly8gdGhlbiBmbGlwIHRoZSBjaGlsZCBsaXN0IGFyb3VuZCBzbyB0aGF0IHRoZSBsYXN0IGNoaWxkIHdpbGwgYmVcblx0XHQvLyB0aGUgZmlyc3QgaW4gdGhlIGxpbmtlZCBsaXN0LlxuXHRcdGNoaWxkcmVuLnJldmVyc2UoKTtcblx0fVxuXHQvLyBCdWlsZCB0aGUgbGlua2VkIGxpc3QuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2hpbGRyZW4gaW4gcmV2ZXJzZSBvcmRlclxuXHQvLyBzbyB0aGF0IGBfbmV4dGAgcG9pbnRzIHRvIHRoZSBmaXJzdCBsaW5rZWQgbGlzdCBub2RlIHRvIGJlIHJlc29sdmVkLlxuXHRmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBsaW5rZWQgbGlzdCBub2RlIGFzIGFuIGFycmF5IG9mIGZvcm06XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlXVxuXHRcdC8vIHdoZXJlIHN1c3BlbmRlZF9jb3VudCBhbmQgcmVzb2x2ZWRfY291bnQgYXJlIG51bWVyaWMgY291bnRlcnMgZm9yXG5cdFx0Ly8ga2VlcGluZyB0cmFjayBob3cgbWFueSB0aW1lcyBhIG5vZGUgaGFzIGJlZW4gc3VzcGVuZGVkIGFuZCByZXNvbHZlZC5cblx0XHQvL1xuXHRcdC8vIE5vdGUgdGhhdCBzdXNwZW5kZWRfY291bnQgc3RhcnRzIGZyb20gMSBpbnN0ZWFkIG9mIDAsIHNvIHdlIGNhbiBibG9ja1xuXHRcdC8vIHByb2Nlc3NpbmcgY2FsbGJhY2tzIHVudGlsIGNvbXBvbmVudERpZE1vdW50IGhhcyBiZWVuIGNhbGxlZC4gSW4gYSBzZW5zZVxuXHRcdC8vIG5vZGUgaXMgc3VzcGVuZGVkIGF0IGxlYXN0IHVudGlsIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkIVxuXHRcdC8vXG5cdFx0Ly8gUGVuZGluZyBjYWxsYmFja3MgYXJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGU6XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlLCBjYWxsYmFja18wLCBjYWxsYmFja18xLCAuLi5dXG5cdFx0dGhpcy5fbWFwLnNldChjaGlsZHJlbltpXSwgKHRoaXMuX25leHQgPSBbMSwgMCwgdGhpcy5fbmV4dF0pKTtcblx0fVxuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IFN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZnRlciBtb3VudGluZyBmb3IgdHdvIHJlYXNvbnM6XG5cdC8vIDEuIEFzIGVhY2ggbm9kZVtTVVNQRU5ERURfQ09VTlRdIHN0YXJ0cyBmcm9tIDEsIHRoaXMgaXRlcmF0aW9uIGluY3JlYXNlc1xuXHQvLyAgICBlYWNoIG5vZGVbUkVMRUFTRURfQ09VTlRdIGJ5IDEsIHRoZXJlZm9yZSBiYWxhbmNpbmcgdGhlIGNvdW50ZXJzLlxuXHQvLyAgICBUaGUgbm9kZXMgY2FuIG5vdyBiZSBjb21wbGV0ZWx5IGNvbnN1bWVkIGZyb20gdGhlIGxpbmtlZCBsaXN0LlxuXHQvLyAyLiBIYW5kbGUgbm9kZXMgdGhhdCBtaWdodCBoYXZlIGdvdHRlbiByZXNvbHZlZCBiZXR3ZWVuIHJlbmRlciBhbmRcblx0Ly8gICAgY29tcG9uZW50RGlkTW91bnQuXG5cdHRoaXMuX21hcC5mb3JFYWNoKChub2RlLCBjaGlsZCkgPT4ge1xuXHRcdHJlc29sdmUodGhpcywgY2hpbGQsIG5vZGUpO1xuXHR9KTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9zcmMvaW5kZXgnKS5SZW5kZXJhYmxlUHJvcHM8eyBjb250ZXh0OiBhbnkgfT59IHByb3BzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihwcm9wcykge1xuXHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHByb3BzLmNvbnRleHQ7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBQb3J0YWwgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBwcm9wc1xuICpcbiAqIFRPRE86IHVzZSBjcmVhdGVSb290KCkgaW5zdGVhZCBvZiBmYWtlIHJvb3RcbiAqL1xuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG5cdGNvbnN0IF90aGlzID0gdGhpcztcblx0bGV0IGNvbnRhaW5lciA9IHByb3BzLl9jb250YWluZXI7XG5cblx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZW5kZXIobnVsbCwgX3RoaXMuX3RlbXApO1xuXHRcdF90aGlzLl90ZW1wID0gbnVsbDtcblx0XHRfdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0fTtcblxuXHQvLyBXaGVuIHdlIGNoYW5nZSBjb250YWluZXIgd2Ugc2hvdWxkIGNsZWFyIG91ciBvbGQgY29udGFpbmVyIGFuZFxuXHQvLyBpbmRpY2F0ZSBhIG5ldyBtb3VudC5cblx0aWYgKF90aGlzLl9jb250YWluZXIgJiYgX3RoaXMuX2NvbnRhaW5lciAhPT0gY29udGFpbmVyKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxuXG5cdC8vIFdoZW4gcHJvcHMudm5vZGUgaXMgdW5kZWZpbmVkL2ZhbHNlL251bGwgd2UgYXJlIGRlYWxpbmcgd2l0aCBzb21lIGtpbmQgb2Zcblx0Ly8gY29uZGl0aW9uYWwgdm5vZGUuIFRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGEgcmVuZGVyLlxuXHRpZiAocHJvcHMuX3Zub2RlKSB7XG5cdFx0aWYgKCFfdGhpcy5fdGVtcCkge1xuXHRcdFx0X3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgZmFrZSBET00gcGFyZW50IG5vZGUgdGhhdCBtYW5hZ2VzIGEgc3Vic2V0IG9mIGBjb250YWluZXJgJ3MgY2hpbGRyZW46XG5cdFx0XHRfdGhpcy5fdGVtcCA9IHtcblx0XHRcdFx0bm9kZVR5cGU6IDEsXG5cdFx0XHRcdHBhcmVudE5vZGU6IGNvbnRhaW5lcixcblx0XHRcdFx0Y2hpbGROb2RlczogW10sXG5cdFx0XHRcdGFwcGVuZENoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKSA+Pj4gMSwgMSk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIG91ciB3cmFwcGluZyBlbGVtZW50IGludG8gdGVtcC5cblx0XHRyZW5kZXIoXG5cdFx0XHRjcmVhdGVFbGVtZW50KENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBfdGhpcy5jb250ZXh0IH0sIHByb3BzLl92bm9kZSksXG5cdFx0XHRfdGhpcy5fdGVtcFxuXHRcdCk7XG5cdH1cblx0Ly8gV2hlbiB3ZSBjb21lIGZyb20gYSBjb25kaXRpb25hbCByZW5kZXIsIG9uIGEgbW91bnRlZFxuXHQvLyBwb3J0YWwgd2Ugc2hvdWxkIGNsZWFyIHRoZSBET00uXG5cdGVsc2UgaWYgKF90aGlzLl90ZW1wKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBQb3J0YWxgIHRvIGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgdm5vZGUgdHJlZSBhdCBhIGRpZmZlcmVudCBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBub2RlIHRvIGNvbnRpbnVlIHJlbmRlcmluZyBpbiB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgX3Zub2RlOiB2bm9kZSwgX2NvbnRhaW5lcjogY29udGFpbmVyIH0pO1xuXHRlbC5jb250YWluZXJJbmZvID0gY29udGFpbmVyO1xuXHRyZXR1cm4gZWw7XG59XG4iLCJpbXBvcnQge1xuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRoeWRyYXRlIGFzIHByZWFjdEh5ZHJhdGUsXG5cdG9wdGlvbnMsXG5cdHRvQ2hpbGRBcnJheSxcblx0Q29tcG9uZW50XG59IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuY29uc3QgT05fQU5JID0gL15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnB8Q29tcG8pLztcbmNvbnN0IENBTUVMX1JFUExBQ0UgPSAvW0EtWjAtOV0vZztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvXG5cdFx0OiAvZmlsfGNoZXxyYS9cblx0KS50ZXN0KHR5cGUpO1xuXG4vLyBTb21lIGxpYnJhcmllcyBsaWtlIGByZWFjdC12aXJ0dWFsaXplZGAgZXhwbGljaXRseSBjaGVjayBmb3IgdGhpcy5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vLyBgVU5TQUZFXypgIGxpZmVjeWNsZSBob29rc1xuLy8gUHJlYWN0IG9ubHkgZXZlciBpbnZva2VzIHRoZSB1bnByZWZpeGVkIG1ldGhvZHMuXG4vLyBIZXJlIHdlIHByb3ZpZGUgYSBiYXNlIFwiZmFsbGJhY2tcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbGxzIGFueSBkZWZpbmVkIFVOU0FGRV8gcHJlZml4ZWQgbWV0aG9kLlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGl0cyBvd24gYGNvbXBvbmVudERpZE1vdW50KClgIChpbmNsdWRpbmcgdmlhIGRlZmluZVByb3BlcnR5KSwgdXNlIHRoYXQuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgYFVOU0FGRV9jb21wb25lbnREaWRNb3VudCgpYCwgYGNvbXBvbmVudERpZE1vdW50YCBpcyB0aGUgYWxpYXMgZ2V0dGVyL3NldHRlci5cbi8vIC0gSWYgYW55dGhpbmcgYXNzaWducyB0byBhbiBgVU5TQUZFXypgIHByb3BlcnR5LCB0aGUgYXNzaWdubWVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIHVucHJlZml4ZWQgcHJvcGVydHkuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTk0MVxuW1xuXHQnY29tcG9uZW50V2lsbE1vdW50Jyxcblx0J2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuXHQnY29tcG9uZW50V2lsbFVwZGF0ZSdcbl0uZm9yRWFjaChrZXkgPT4ge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwga2V5LCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzWydVTlNBRkVfJyArIGtleV07XG5cdFx0fSxcblx0XHRzZXQodikge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdlxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG4vKipcbiAqIFByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVk5vZGUgdHJlZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50IERPTSBub2RlIHRvIHJlbmRlciB2bm9kZSB0cmVlIGludG9cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHJlbmRlcmluZ1xuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudCB8IG51bGx9IFRoZSByb290IGNvbXBvbmVudCByZWZlcmVuY2Ugb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdC8vIFJlYWN0IGRlc3Ryb3lzIGFueSBleGlzdGluZyBET00gbm9kZXMsIHNlZSAjMTcyN1xuXHQvLyAuLi5idXQgb25seSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgIzE4Mjhcblx0aWYgKHBhcmVudC5fY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdHBhcmVudC50ZXh0Q29udGVudCA9ICcnO1xuXHR9XG5cblx0cHJlYWN0UmVuZGVyKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdHByZWFjdEh5ZHJhdGUodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxubGV0IG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZSA9PiB7XG5cdGlmIChvbGRFdmVudEhvb2spIGUgPSBvbGRFdmVudEhvb2soZSk7XG5cdGUucGVyc2lzdCA9IGVtcHR5O1xuXHRlLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gaXNQcm9wYWdhdGlvblN0b3BwZWQ7XG5cdGUuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXHRyZXR1cm4gKGUubmF0aXZlRXZlbnQgPSBlKTtcbn07XG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuZnVuY3Rpb24gaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB7XG5cdHJldHVybiB0aGlzLmNhbmNlbEJ1YmJsZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZhdWx0UHJldmVudGVkKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkO1xufVxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3M7XG5cdH1cbn07XG5cbmxldCBvbGRWTm9kZUhvb2sgPSBvcHRpb25zLnZub2RlO1xub3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0bGV0IHR5cGUgPSB2bm9kZS50eXBlO1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzO1xuXG5cdC8vIG9ubHkgbm9ybWFsaXplIHByb3BzIG9uIEVsZW1lbnQgbm9kZXNcblx0aWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChcblx0XHRcdFx0KGkgPT09ICd2YWx1ZScgJiYgJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMgJiYgdmFsdWUgPT0gbnVsbCkgfHxcblx0XHRcdFx0Ly8gRW11bGF0ZSBSZWFjdCdzIGJlaGF2aW9yIG9mIG5vdCByZW5kZXJpbmcgdGhlIGNvbnRlbnRzIG9mIG5vc2NyaXB0IHRhZ3Mgb24gdGhlIGNsaWVudC5cblx0XHRcdFx0KElTX0RPTSAmJiBpID09PSAnY2hpbGRyZW4nICYmIHR5cGUgPT09ICdub3NjcmlwdCcpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbG93ZXJDYXNlZCA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChpID09PSAnZGVmYXVsdFZhbHVlJyAmJiAndmFsdWUnIGluIHByb3BzICYmIHByb3BzLnZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmIChsb3dlckNhc2VkID09PSAnb25kb3VibGVjbGljaycpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGxvd2VyQ2FzZWQgPT09ICdvbmNoYW5nZScgJiZcblx0XHRcdFx0KHR5cGUgPT09ICdpbnB1dCcgfHwgdHlwZSA9PT0gJ3RleHRhcmVhJykgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0bG93ZXJDYXNlZCA9IGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWQgPT09ICdvbmZvY3VzJykge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNpbic7XG5cdFx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWQgPT09ICdvbmJsdXInKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKE9OX0FOSS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBsb3dlckNhc2VkO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTEgJiYgQ0FNRUxfUFJPUFMudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS5yZXBsYWNlKENBTUVMX1JFUExBQ0UsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAobG93ZXJDYXNlZCA9PT0gJ29uaW5wdXQnKSB7XG5cdFx0XHRcdGkgPSBsb3dlckNhc2VkO1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldKSB7XG5cdFx0XHRcdFx0aSA9ICdvbmlucHV0Q2FwdHVyZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIGFycmF5IHNlbGVjdCB2YWx1ZXM6IDxzZWxlY3QgbXVsdGlwbGUgdmFsdWU9e1tdfSAvPlxuXHRcdGlmIChcblx0XHRcdHR5cGUgPT0gJ3NlbGVjdCcgJiZcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSAmJlxuXHRcdFx0QXJyYXkuaXNBcnJheShub3JtYWxpemVkUHJvcHMudmFsdWUpXG5cdFx0KSB7XG5cdFx0XHQvLyBmb3JFYWNoKCkgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB3aGljaCB3ZSBhYnVzZSBoZXJlIHRvIHVuc2V0IHRoZSB2YWx1ZSBwcm9wLlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZGluZyBzdXBwb3J0IGZvciBkZWZhdWx0VmFsdWUgaW4gc2VsZWN0IHRhZ1xuXHRcdGlmICh0eXBlID09ICdzZWxlY3QnICYmIG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSkge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSA9PSBjaGlsZC5wcm9wcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dm5vZGUucHJvcHMgPSBub3JtYWxpemVkUHJvcHM7XG5cblx0XHRpZiAocHJvcHMuY2xhc3MgIT0gcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBwcm9wcztcblx0XHRcdGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkgbm9ybWFsaXplZFByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3NOYW1lO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wcywgJ2NsYXNzTmFtZScsIGNsYXNzTmFtZURlc2NyaXB0b3IpO1xuXHRcdH1cblx0fVxuXG5cdHZub2RlLiQkdHlwZW9mID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cdGlmIChvbGRWTm9kZUhvb2spIG9sZFZOb2RlSG9vayh2bm9kZSk7XG59O1xuXG4vLyBPbmx5IG5lZWRlZCBmb3IgcmVhY3QtcmVsYXlcbmxldCBjdXJyZW50Q29tcG9uZW50O1xuY29uc3Qgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xub3B0aW9ucy5fcmVuZGVyID0gZnVuY3Rpb24odm5vZGUpIHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikge1xuXHRcdG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cdH1cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG59O1xuXG5jb25zdCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcbi8qKiBAdHlwZSB7KHZub2RlOiBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZSl9ICovXG5vcHRpb25zLmRpZmZlZCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGREaWZmZWQpIHtcblx0XHRvbGREaWZmZWQodm5vZGUpO1xuXHR9XG5cblx0Y29uc3QgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0Y29uc3QgZG9tID0gdm5vZGUuX2RvbTtcblx0aWYgKFxuXHRcdGRvbSAhPSBudWxsICYmXG5cdFx0dm5vZGUudHlwZSA9PT0gJ3RleHRhcmVhJyAmJlxuXHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRwcm9wcy52YWx1ZSAhPT0gZG9tLnZhbHVlXG5cdCkge1xuXHRcdGRvbS52YWx1ZSA9IHByb3BzLnZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLnZhbHVlO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG4vLyBUaGlzIGlzIGEgdmVyeSB2ZXJ5IHByaXZhdGUgaW50ZXJuYWwgZnVuY3Rpb24gZm9yIFJlYWN0IGl0XG4vLyBpcyB1c2VkIHRvIHNvcnQtb2YgZG8gcnVudGltZSBkZXBlbmRlbmN5IGluamVjdGlvbi4gU28gZmFyXG4vLyBvbmx5IGByZWFjdC1yZWxheWAgbWFrZXMgdXNlIG9mIGl0LiBJdCB1c2VzIGl0IHRvIHJlYWQgdGhlXG4vLyBjb250ZXh0IHZhbHVlLlxuZXhwb3J0IGNvbnN0IF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0ge1xuXHRSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiB7XG5cdFx0Y3VycmVudDoge1xuXHRcdFx0cmVhZENvbnRleHQoY29udGV4dCkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudENvbXBvbmVudC5fZ2xvYmFsQ29udGV4dFtjb250ZXh0Ll9pZF0ucHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwiaW1wb3J0IHsgUmVmLCBSZW5kZXJhYmxlUHJvcHMsIGNyZWF0ZUVsZW1lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wcy5qc1wiO1xuaW1wb3J0IHsgVXNlUmVmRWxlbWVudFJldHVyblR5cGUsIHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnQuanNcIjtcblxuZXhwb3J0IHR5cGUgU2V0Q2hpbGRyZW4gPSAoKGNoaWxkcmVuOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIEdldENsYXNzID0gKGNsczogc3RyaW5nKSA9PiBib29sZWFuO1xuZXhwb3J0IHR5cGUgU2V0Q2xhc3MgPSAoY2xzOiBzdHJpbmcsIGVuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBTZXRTdHlsZSA9IDxUIGV4dGVuZHMgKGtleW9mIENTU1N0eWxlRGVjbGFyYXRpb24pICYgc3RyaW5nPihwcm9wOiBULCB2YWx1ZTogaC5KU1guQ1NTUHJvcGVydGllc1tUXSB8IG51bGwpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBHZXRBdHRyaWJ1dGU8VCBleHRlbmRzIEVsZW1lbnQ+ID0gPEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4ocHJvcDogSykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD5bS107XG5leHBvcnQgdHlwZSBTZXRBdHRyaWJ1dGU8VCBleHRlbmRzIEVsZW1lbnQ+ID0gPEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4ocHJvcDogSywgdmFsdWU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+W0tdIHwgbnVsbCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFNldEV2ZW50SGFuZGxlciA9IDxLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcD4odHlwZTogSywgbGlzdGVuZXI6IG51bGwgfCAoKHRoaXM6IEhUTUxFbGVtZW50LCBldjogSFRNTEVsZW1lbnRFdmVudE1hcFtLXSkgPT4gdm9pZCksIG9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIEltcGVyYXRpdmVIYW5kbGU8VCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBoYXNDbGFzczogR2V0Q2xhc3M7XG4gICAgc2V0Q2xhc3M6IFNldENsYXNzO1xuICAgIHNldFN0eWxlOiBTZXRTdHlsZTtcbiAgICBnZXRBdHRyaWJ1dGU6IEdldEF0dHJpYnV0ZTxUPjtcbiAgICBzZXRBdHRyaWJ1dGU6IFNldEF0dHJpYnV0ZTxUPjtcbiAgICBzZXRDaGlsZHJlbjogU2V0Q2hpbGRyZW47XG4gICAgc2V0RXZlbnRIYW5kbGVyOiBTZXRFdmVudEhhbmRsZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlSW1wZXJhdGl2ZVByb3BzUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wZXJhdGl2ZUVsZW1lbnRQcm9wczxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPiBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4ge1xuICAgIHRhZzogVDtcbiAgICBoYW5kbGU6IFJlZjxJbXBlcmF0aXZlSGFuZGxlPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4+O1xufVxuXG4vKipcbiAqIEVhc3kgYWNjZXNzIHRvIGFuIEhUTUxFbGVtZW50IHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQgaW1wZXJhdGl2ZWx5LlxuICogXG4gKiBUaGUgSFRNTEVsZW1lbnQgcmVuZGVyZWQgaXMgY29udHJvbGxlZCBieSB0aGUgYHRhZ2AgcHJvcCAoZS5nLiBcInNwYW5cIiwgXCJkaXZcIikuXG4gKiBcbiAqIFRoZSBgaGFuZGxlYCBwcm9wIHNob3VsZCBiZSBlLmcuIGB1c2VSZWY8SW1wZXJhdGl2ZUhhbmRsZTxIVE1MRGl2RWxlbWVudD4+KG51bGwpYFxuICovXG5leHBvcnQgY29uc3QgSW1wZXJhdGl2ZUVsZW1lbnQgPSBtZW1vKGZvcndhcmRSZWYoSW1wZXJhdGl2ZUVsZW1lbnRVKSkgYXMgdHlwZW9mIEltcGVyYXRpdmVFbGVtZW50VTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4oeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSB9OiBVc2VJbXBlcmF0aXZlUHJvcHNQYXJhbWV0ZXJzPEU+KSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VJbXBlcmF0aXZlUHJvcHMpO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMgPSB1c2VSZWY8eyBjbGFzc05hbWU6IFNldDxzdHJpbmc+LCBzdHlsZTogaC5KU1guQ1NTUHJvcGVydGllcywgY2hpbGRyZW46IHN0cmluZyB8IG51bGwsIG90aGVyczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfT4oeyBjbGFzc05hbWU6IG5ldyBTZXQoKSwgc3R5bGU6IHt9LCBjaGlsZHJlbjogbnVsbCwgb3RoZXJzOiB7fSB9KTtcblxuXG4gICAgY29uc3QgaGFzQ2xhc3MgPSB1c2VDYWxsYmFjazxHZXRDbGFzcz4oKGNsczogc3RyaW5nKSA9PiB7IHJldHVybiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lLmhhcyhjbHMpOyB9LCBbXSlcbiAgICBjb25zdCBzZXRDbGFzcyA9IHVzZUNhbGxiYWNrPFNldENsYXNzPigoY2xzLCBlbmFibGVkKSA9PiB7XG4gICAgICAgIGlmIChoYXNDbGFzcyhjbHMpID09ICFlbmFibGVkKSB7XG4gICAgICAgICAgICBnZXRFbGVtZW50KCk/LmNsYXNzTGlzdFtlbmFibGVkID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKGNscyk7XG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lW2VuYWJsZWQgPyBcImFkZFwiIDogXCJkZWxldGVcIl0oY2xzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldFN0eWxlID0gdXNlQ2FsbGJhY2s8U2V0U3R5bGU+KChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gKGdldEVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuc3R5bGVbcHJvcF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3AgYXMgc3RyaW5nKS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlID8/IChcIlwiIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2hpbGRyZW4gPSB1c2VDYWxsYmFjazxTZXRDaGlsZHJlbj4oKGNoaWxkcmVuOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIGxldCBlID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZSAmJiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2hpbGRyZW4gIT0gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0QXR0cmlidXRlID0gdXNlQ2FsbGJhY2s8R2V0QXR0cmlidXRlPEU+PigocHJvcCkgPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRBdHRyaWJ1dGUgPSB1c2VDYWxsYmFjazxTZXRBdHRyaWJ1dGU8RT4+KChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgZ2V0RWxlbWVudCgpPy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbcHJvcF07XG4gICAgICAgICAgICBnZXRFbGVtZW50KCk/LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldEV2ZW50SGFuZGxlciA9IHVzZUNhbGxiYWNrPFNldEV2ZW50SGFuZGxlcj4oKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChnZXRFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG1hcHBlZEtleSA9IEV2ZW50TWFwcGluZ1t0eXBlXSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbbWFwcGVkS2V5XSA9IGhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW21hcHBlZEtleV0pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW21hcHBlZEtleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGltcGVyYXRpdmVIYW5kbGU6IHVzZVJlZjxJbXBlcmF0aXZlSGFuZGxlPEU+Pih7XG4gICAgICAgICAgICBoYXNDbGFzcyxcbiAgICAgICAgICAgIHNldENsYXNzLFxuICAgICAgICAgICAgc2V0U3R5bGUsXG4gICAgICAgICAgICBnZXRBdHRyaWJ1dGUsXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUsXG4gICAgICAgICAgICBzZXRFdmVudEhhbmRsZXIsXG4gICAgICAgICAgICBzZXRDaGlsZHJlblxuICAgICAgICB9KS5jdXJyZW50LFxuICAgICAgICBwcm9wczogdXNlTWVyZ2VkUHJvcHM8RT4oXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogWy4uLmN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jbGFzc05hbWVdLmpvaW4oXCIgXCIpLCBzdHlsZTogY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LnN0eWxlIH0sXG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzXG4gICAgICAgIClcblxuICAgIH1cbn1cblxuZnVuY3Rpb24gSW1wZXJhdGl2ZUVsZW1lbnRVPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXA+KHsgdGFnOiBUYWcsIGhhbmRsZSwgLi4ucHJvcHMgfTogUmVuZGVyYWJsZVByb3BzPEltcGVyYXRpdmVFbGVtZW50UHJvcHM8VD4+LCByZWY6IFJlZjxIVE1MRWxlbWVudFRhZ05hbWVNYXBbVF0+KSB7XG4gICAgY29uc3QgeyBwcm9wc1N0YWJsZSwgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxIVE1MRWxlbWVudFRhZ05hbWVNYXBbVF0+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pXG4gICAgY29uc3QgeyBwcm9wczogaXByb3BzLCBpbXBlcmF0aXZlSGFuZGxlIH0gPSB1c2VJbXBlcmF0aXZlUHJvcHM8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPih7IHJlZkVsZW1lbnRSZXR1cm4gfSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShoYW5kbGUsICgpID0+IGltcGVyYXRpdmVIYW5kbGUpO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWcsIHVzZU1lcmdlZFByb3BzKHByb3BzU3RhYmxlLCBpcHJvcHMsIHByb3BzLCB7IHJlZiB9KSkpO1xufVxuXG5cbmNvbnN0IEV2ZW50TWFwcGluZzogUGFydGlhbDx7IFtLIGluIGtleW9mIEhUTUxFbGVtZW50RXZlbnRNYXBdOiAoa2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiAmIGBvbiR7c3RyaW5nfWApIH0+ID0ge1xuICAgIGFib3J0OiBcIm9uQWJvcnRcIixcbiAgICBhbmltYXRpb25lbmQ6IFwib25BbmltYXRpb25FbmRcIixcbiAgICBhbmltYXRpb25zdGFydDogXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgYW5pbWF0aW9uaXRlcmF0aW9uOiBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIsXG4gICAgYmVmb3JlaW5wdXQ6IFwib25CZWZvcmVJbnB1dFwiLFxuICAgIGJsdXI6IFwib25CbHVyXCIsXG4gICAgY2FucGxheTogXCJvbkNhblBsYXlcIixcbiAgICBjYW5wbGF5dGhyb3VnaDogXCJvbkNhblBsYXlUaHJvdWdoXCIsXG4gICAgY2hhbmdlOiBcIm9uQ2hhbmdlXCIsXG4gICAgY2xpY2s6IFwib25DbGlja1wiLFxuICAgIGNvbXBvc2l0aW9uZW5kOiBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgICBjb21wb3NpdGlvbnN0YXJ0OiBcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuICAgIGNvbXBvc2l0aW9udXBkYXRlOiBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgICBjb250ZXh0bWVudTogXCJvbkNvbnRleHRNZW51XCIsXG4gICAgY3V0OiBcIm9uQ3V0XCIsXG4gICAgZGJsY2xpY2s6IFwib25EYmxDbGlja1wiLFxuICAgIGRyYWc6IFwib25EcmFnXCIsXG4gICAgZHJhZ2VuZDogXCJvbkRyYWdFbmRcIixcbiAgICBkcmFnZW50ZXI6IFwib25EcmFnRW50ZXJcIixcbiAgICBkcmFnbGVhdmU6IFwib25EcmFnTGVhdmVcIixcbiAgICBkcmFnb3ZlcjogXCJvbkRyYWdPdmVyXCIsXG4gICAgZHJhZ3N0YXJ0OiBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgZHJvcDogXCJvbkRyb3BcIixcbiAgICBkdXJhdGlvbmNoYW5nZTogXCJvbkR1cmF0aW9uQ2hhbmdlXCIsXG4gICAgZW1wdGllZDogXCJvbkVtcHRpZWRcIixcbiAgICBlbmRlZDogXCJvbkVuZGVkXCIsXG4gICAgZXJyb3I6IFwib25FcnJvclwiLFxuICAgIGZvY3VzOiBcIm9uRm9jdXNcIixcbiAgICBmb2N1c2luOiBcIm9uZm9jdXNpblwiLFxuICAgIGZvY3Vzb3V0OiBcIm9uZm9jdXNvdXRcIixcbiAgICBmb3JtZGF0YTogXCJvbkZvcm1EYXRhXCIsXG4gICAgZ290cG9pbnRlcmNhcHR1cmU6IFwib25Hb3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIGlucHV0OiBcIm9uSW5wdXRcIixcbiAgICBpbnZhbGlkOiBcIm9uSW52YWxpZFwiLFxuICAgIGtleWRvd246IFwib25LZXlEb3duXCIsXG4gICAga2V5cHJlc3M6IFwib25LZXlQcmVzc1wiLFxuICAgIGtleXVwOiBcIm9uS2V5VXBcIixcbiAgICBsb2FkOiBcIm9uTG9hZFwiLFxuICAgIGxvYWRlZGRhdGE6IFwib25Mb2FkZWREYXRhXCIsXG4gICAgbG9hZGVkbWV0YWRhdGE6IFwib25Mb2FkZWRNZXRhZGF0YVwiLFxuICAgIGxvYWRzdGFydDogXCJvbkxvYWRTdGFydFwiLFxuICAgIGxvc3Rwb2ludGVyY2FwdHVyZTogXCJvbkxvc3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIG1vdXNlZG93bjogXCJvbk1vdXNlRG93blwiLFxuICAgIG1vdXNlZW50ZXI6IFwib25Nb3VzZUVudGVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJvbk1vdXNlTGVhdmVcIixcbiAgICBtb3VzZW1vdmU6IFwib25Nb3VzZU1vdmVcIixcbiAgICBtb3VzZW91dDogXCJvbk1vdXNlT3V0XCIsXG4gICAgbW91c2VvdmVyOiBcIm9uTW91c2VPdmVyXCIsXG4gICAgbW91c2V1cDogXCJvbk1vdXNlVXBcIixcbiAgICBwYXN0ZTogXCJvblBhc3RlXCIsXG4gICAgcGF1c2U6IFwib25QYXVzZVwiLFxuICAgIHBsYXk6IFwib25QbGF5XCIsXG4gICAgcGxheWluZzogXCJvblBsYXlpbmdcIixcbiAgICBwb2ludGVyY2FuY2VsOiBcIm9uUG9pbnRlckNhbmNlbFwiLFxuICAgIHBvaW50ZXJkb3duOiBcIm9uUG9pbnRlckRvd25cIixcbiAgICBwb2ludGVyZW50ZXI6IFwib25Qb2ludGVyRW50ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwib25Qb2ludGVyTGVhdmVcIixcbiAgICBwb2ludGVybW92ZTogXCJvblBvaW50ZXJNb3ZlXCIsXG4gICAgcG9pbnRlcm91dDogXCJvblBvaW50ZXJPdXRcIixcbiAgICBwb2ludGVyb3ZlcjogXCJvblBvaW50ZXJPdmVyXCIsXG4gICAgcG9pbnRlcnVwOiBcIm9uUG9pbnRlclVwXCIsXG4gICAgcHJvZ3Jlc3M6IFwib25Qcm9ncmVzc1wiLFxuICAgIHJlc2V0OiBcIm9uUmVzZXRcIixcbiAgICBzY3JvbGw6IFwib25TY3JvbGxcIixcbiAgICBzZWVrZWQ6IFwib25TZWVrZWRcIixcbiAgICBzZWVraW5nOiBcIm9uU2Vla2luZ1wiLFxuICAgIHNlbGVjdDogXCJvblNlbGVjdFwiLFxuICAgIHN0YWxsZWQ6IFwib25TdGFsbGVkXCIsXG4gICAgc3VibWl0OiBcIm9uU3VibWl0XCIsXG4gICAgc3VzcGVuZDogXCJvblN1c3BlbmRcIixcbiAgICB0aW1ldXBkYXRlOiBcIm9uVGltZVVwZGF0ZVwiLFxuICAgIHRvZ2dsZTogXCJvblRvZ2dsZVwiLFxuICAgIHRvdWNoY2FuY2VsOiBcIm9uVG91Y2hDYW5jZWxcIixcbiAgICB0b3VjaGVuZDogXCJvblRvdWNoRW5kXCIsXG4gICAgdG91Y2htb3ZlOiBcIm9uVG91Y2hNb3ZlXCIsXG4gICAgdG91Y2hzdGFydDogXCJvblRvdWNoU3RhcnRcIixcbiAgICB0cmFuc2l0aW9uZW5kOiBcIm9uVHJhbnNpdGlvbkVuZFwiLFxuICAgIHZvbHVtZWNoYW5nZTogXCJvblZvbHVtZUNoYW5nZVwiLFxuICAgIHdhaXRpbmc6IFwib25XYWl0aW5nXCIsXG4gICAgd2hlZWw6IFwib25XaGVlbFwiXG59XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG4vKipcbiAqIFdoZW4gYSBidW5jaCBvZiB1bnJlbGF0ZWQgY29tcG9uZW50cyBhbGwgdXNlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLFxuICogeWVzLCB0aGlzIGFjdHVhbGx5IGlzIGZhc3Rlci4gSSB3aXNoIGl0IHdhc24ndC4gSXQncyBsYW1lLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUFuaW1hdGlvbkZyYW1lKTtcbiAgICBcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gXCJsb2Rhc2gtZXNcIlxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgY29uc3QgcHJvY2VzczogeyBlbnY6IHsgTk9ERV9FTlY/OiBzdHJpbmcgfCB1bmRlZmluZWQgfSB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIHJldHVybiAncHJvZHVjdGlvbic7XG4gICAgfVxuICAgIGNhdGNoIChfZSkge1xuICAgICAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCI7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QnVpbGRNb2RlID0gbWVtb2l6ZShnZXRCdWlsZE1vZGVVbm1lbW9pemVkKSBhcyB0eXBlb2YgZ2V0QnVpbGRNb2RlVW5tZW1vaXplZDsiLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0QnVpbGRNb2RlIH0gZnJvbSBcIi4uL3V0aWwvbW9kZS5qc1wiO1xuXG4vKiogVGFrZXMgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgYSB2YWx1ZSwgdW5saWtlIGBPblBhc3NpdmVTdGF0ZUNoYW5nZWAgd2hpY2ggcmVhY3RzIHRvIHRob3NlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8UywgUj4gPSAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpIDogKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uOiBSKSA9PiB2b2lkKTtcbi8qKiBSZXNwb25kcyB0byBhIGNoYW5nZSBpbiBhIHZhbHVlLCB1bmxpa2UgYFBhc3NpdmVTdGF0ZVVwZGF0ZXJgIHdoaWNoIGNhdXNlcyB0aGUgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8UywgUj4gPSAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSkgOiAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbjogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuXG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIGlmIChnZXRCdWlsZE1vZGUoKSA9PSAncHJvZHVjdGlvbicpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZjxBcnJheTxUPj4oW10pO1xuICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWY8QXJyYXk8Ym9vbGVhbj4+KFtdKTtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCBhcyBhbnksIC0xKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFUgZXh0ZW5kcyBUPih2YWx1ZTogVSwgaTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSArIDE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpfS1pbmRleGVkIGFyZ3VtZW50ICgke2kgPj0gMD8gSlNPTi5zdHJpbmdpZnkodmFsdWVzW2ldKSA6IFwidGhlIG51bWJlciBvZiBzdXBwb3NlZGx5IHN0YWJsZSBlbGVtZW50c1wifSkuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gcXVldWVNaWNyb3Rhc2spKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHJlYXNvblJlZiA9IHVzZVJlZjxSIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QgPSB1c2VSZWY8VCB8ICh0eXBlb2YgVW5zZXQpPihVbnNldCk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQhKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+KChhcmc6IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMF0sIHJlYXNvbjogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlsxXSkgPT4ge1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9PT0gVW5zZXQgJiYgbmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZXF1ZXN0IHRvIGNoYW5nZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHksIHRoZW4gcXVldWUgdXAgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgdmFsdWUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGl0IGxhdGVyXG4gICAgICAgICAgICAvLyAoaWYgd2UgZmxpcCBiYWNrIHRvIHRoaXMgc3RhdGUsIHRoZW4gd2Ugd29uJ3Qgc2VuZCB0aGUgb25DaGFuZ2UgZnVuY3Rpb24pXG4gICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gdmFsdWVSZWYuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoaXMgaGVyZSAoYXMgd2VsbCBhcyBiZWxvdykgaW4gY2FzZSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBpbnZva2VzIHRoaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICByZWFzb25SZWYuY3VycmVudCA9IHJlYXNvbiBhcyBSO1xuXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgYWN0dWFsIGNoZWNrIGFuZCBpbnZvY2F0aW9uIG9mIG9uQ2hhbmdlIGxhdGVyIHRvIGxldCBlZmZlY3RzIHNldHRsZVxuICAgICAgICAgICAgKGN1c3RvbURlYm91bmNlUmVuZGVyaW5nID8/IGRlYm91bmNlUmVuZGVyaW5nKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFJlYXNvbiA9IHJlYXNvblJlZi5jdXJyZW50ISBhcyBSO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREZXAgPSB2YWx1ZVJlZi5jdXJyZW50ISBhcyBUO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEZXAgPSBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ICE9IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiBwcmV2RGVwLCBuZXh0UmVhc29uKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHREZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLCBzbyBtYXJrIHVzIGFzIGJlaW5nIG9uIGEgY2xlYW4gc2xhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IFVuc2V0O1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgcHJldkRlcCB0byBzZWUgaWYgd2Ugc2hvdWxkIGFjdHVhbGx5IGNhbGwgb25DaGFuZ2VcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH1cblxuLyoqIFxuICogQW4gYWx0ZXJuYXRpdmUgdG8gdXNlIGZvciBgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmdgIHRoYXQgY2F1c2VzIGB1c2VQYXNzaXZlU3RhdGVgIHRvIHJ1biBjaGFuZ2VzIHdpdGhvdXQgd2FpdGluZyBhIHRpY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7IGYoKTsgfSIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjayB8IG51bGwsIGlucHV0cz86IElucHV0cykge1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0pLCBbdmFsdWVdKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xufVxuXG5cbi8qKlxuICogTGlrZSBgdXNlU3RhYmxlR2V0dGVyYCwgYnV0ICoqKnJlcXVpcmVzKioqIHRoYXQgZXZlcnl0aGluZyBpbiB0aGUgb2JqZWN0IGlzIGFsc28gc3RhYmxlLFxuICogYW5kIGluIHR1cm4gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaXMgc3RhYmxlLlxuICogQHBhcmFtIHQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZU9iamVjdDxUIGV4dGVuZHMge30+KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModCk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlT2JqZWN0XCIsIGUubGVuZ3RoLCAuLi5lLm1hcCgoW19rLCB2XSkgPT4gdikpO1xuICAgIHJldHVybiB1c2VSZWYodCkuY3VycmVudDtcbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2tOYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbihsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdLCByaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xudHlwZSBDID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqIFxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxoc0NsYXNzOiBDLCBsaHNDbGFzc05hbWU6IEMsIHJoc0NsYXNzOiBDLCByaHNDbGFzc05hbWU6IEMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxuICogQHBhcmFtIGxocyBcbiAqIEBwYXJhbSByaHMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihyaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdLCBsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdKSB7XG4gICAgXG4gICAgLy8gVGhpcyAqbXVzdCogYmUgc3RhYmxlIGluIG9yZGVyIHRvIHByZXZlbnQgcmVwZWF0ZWQgcmVzZXQgYG51bGxgIGNhbGxzIGFmdGVyIGV2ZXJ5IHJlbmRlci5cbiAgICBjb25zdCBjb21iaW5lZCA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uIGNvbWJpbmVkKGN1cnJlbnQ6IEUgfCBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzITtcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocyE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcblxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cbiAgICAgICAgaWYgKGxocyAmJiAhcmhzKVxuICAgICAgICAgICAgcmV0dXJuIGxocztcbiAgICAgICAgaWYgKCFsaHMgJiYgcmhzKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXG4gICAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoc3R5bGVTdHJpbmdUb09iamVjdChsaHMgYXMgc3RyaW5nKSwgcmhzKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgc3R5bGVTdHJpbmdUb09iamVjdChyaHMgYXMgc3RyaW5nKSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZ2ljPz8/XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihsaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXG4gICAgICAgIC4uLihyaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW4uanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzLmpzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPiksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPik+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5LCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBzYWtlIG9mIGNvbnZlbmllbmNlLFxuICAgICAqIHRoaXMgb25lIGlzIG9wdGlvbmFsLCBzaW5jZSB1c2luZyB0aGlzIGhvb2sgaXMgc28gY29tbW9uLFxuICAgICAqIGJ1dCB1c2luZyBpdHMgcGFyYW1ldGVyIG9wdGlvbnMgaXMgc28gdW5jb21tb24sIGFuZCBpdCdzXG4gICAgICogYWJzZW5zZSBpc24ndCB1c3VhbGx5IGJlY2F1c2UgaXQgd2FzIGZvcmdvdHRlbiwgaXQncyBiZWNhdXNlXG4gICAgICogaXQgZG9lc24ndCBtYXR0ZXIuXG4gICAgICovXG4gICAgcmVmRWxlbWVudFBhcmFtZXRlcnM/OiB7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj47XG4gICAgICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICAgICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncy5yZWZFbGVtZW50UGFyYW1ldGVycyB8fCB7fSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XG5cbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xuXG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGwsIG5ldmVyPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgcHJvcHNTdGFibGUgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHsgcmVmOiBzZXRFbGVtZW50IH0pO1xuXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvL21hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxuXG4gICAgbWFuYWdlZENoaWxkQ29udGV4dDoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5OiBJbnRlcm5hbENoaWxkSW5mbzxNPjtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSwgbW91bnRlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSkgPT4gKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IHtcbiAgICBpbmRleDogVDtcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUT0RPOiBUaGlzIGVuZGVkIHVwIG5vdCBiZWluZyBuZWVkZWQgYnkgYW55dGhpbmcuIElzIGl0IG5lY2Vzc2FyeT8gRG9lcyBpdCBjb3N0IGFueXRoaW5nP1xuICAgICAgICAgKi9cbiAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxNW1wiaW5kZXhcIl0+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8TVtcImluZGV4XCJdPjtcblxuICAgICAgICBvbkNoaWxkQ291bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgKChjb3VudDogbnVtYmVyKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cbi8vIE1DU3ViSW5mbyBjb250YWlucyB0aGUgZW50aXJldHkgb2YgdGhlIHNhdmVkIGRhdGEgZm9yIHRoaXMgY2hpbGQuICBBbGwgb2YgaXQuIEV2ZW4gdHlwZXMgdGhlIHVzZXIgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHBhc3MgaW4gYmVjYXVzZSB0aGV5J3JlIGludGVybmFsbHkgZGVyaXZlZC5cbi8vIFN1YmJlc3RJbmZvIHJlZmVycyB0byB0aGUgYWN0dWFsIHBhcmFtZXRlcnMgdGhlIHVzZXIgcGFzc2VzIGluIHRoYXQgY291bGQgYmUgdG90YWxseSB1bnJlbGF0ZWQuIFxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5IHNoYXJlZCBhbW9uZyBhbGwgbWFuYWdlZCBjaGlsZHJlbi5cbiAgICAvLyBUZWNobmljYWxseSB0aGlzIGlzIHJlZHVuZGFudCB3aXRoIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGlzLi4uZWguIEJ1dCB0aGUgdHlwZXMgYXJlIGNsZWFyLlxuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8TSwgXCJpbmRleFwiPjtcblxuICAgIC8qKlxuICAgICAqIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkbid0IGJlIG51bGwsIGJ1dCBmb3IgY29udmVuaWVuY2UncyBzYWtlIHlvdSBhcmUgYWxsb3dlZCB0bywgd2hpY2ggZGlzYWJsZXMgYWxsIGJlaGF2aW9yLCBhbmQgYWxzbyBtZWFucyBgZ2V0Q2hpbGRyZW5gIHdpbGwgYmUgYHVuZGVmaW5lZGAhXG4gICAgICovXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPiB8IG51bGw7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqICoqKlNUQUJMRSoqKlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgKipib3RoKiogYGdldENoaWxkcmVuYCBhbmQgdGhlIGBNYW5hZ2VkQ2hpbGRyZW5gIG9iamVjdCBpdCByZXR1cm5zIGFyZSBzdGFibGUhXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJlY2F1c2Ugd2hlbiBmdW5jdGlvbiBjYWxscyBoYXBwZW4gb3V0IG9mIG9yZGVyIGl0J3MgZWFzaWVyIHRvIGp1c3QgaGF2ZSBhbHdheXMgYmVlbiBwYXNzaW5nIGFuZCByZXR1cm4gZ2V0dGVycyBldmVyeXdoZXJlIFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG4gICAgfTtcblxuICAgIGNvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IE1bXCJpbmRleFwiXSk6IE0gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE0pID0+IHZvaWQpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiAqKlVOU1RBQkxFKiosIFxuICAgICAqIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIFxuICAgICAqIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4sXG4gICAgICogb3IgYXQgbGVhc3QgcHJvcGVybHkgbmFtZSBpdC5cbiAgICAgKiBcbiAgICAgKiBXSEFUIFRISVMgRE9FUzpcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBjaGlsZHJlbiwgc2xpY2VzIHRoZSBhcnJheSBjb250YWluaW5nIHRoZW0sIFxuICAgICAqIGFuZCwgKmNydXRpYWxseSosIGZpbGxzIGluIGFueSBob2xlcyBpbiB0aGUgYXJyYXkgd2l0aCBhIHBzZXVkby1jaGlsZCB0aGF0IGp1c3QgY29udGFpbnMgYW4gaW5kZXguXG4gICAgICogXG4gICAgICogVGhpcyBiZWhhdmlvciwgdG8gYmUgY2xlYXIsIGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyBiZWNhdXNlXG4gICAgICogc29ydGluZyBhbmQgcmVhcnJhbmdpbmcgcmVxdWlyZSBrbm93aW5nIHBlcmZlY3RseSB3aGljaCBpbmRleCBtYXBzIHRvIHdoaWNoLlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IG90aGVyIG1pc3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IGJlc2lkZXMgdGhlIG1pc3NpbmcgaW5kZXguXG4gICAgICogKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRDb3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZENvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEhpZ2hlc3RJbmRleCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2ldID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IHsgaW5kZXg6IGkgfSBhcyBNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChpbmZvLmNvbnRleHQgPz8geyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuQXJyYXkgPT0gbnVsbCB8fCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4hIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbiwgbmV3U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCwgcHJldlNlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwpOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH0sIFtdKTtcblxuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbi8qKlxuICogV2hlbiBhIGJ1bmNoIG9mIHVucmVsYXRlZCBjb21wb25lbnRzIGFsbCB1c2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsXG4gKiB5ZXMsIHRoaXMgYWN0dWFsbHkgaXMgZmFzdGVyLiBJIHdpc2ggaXQgd2Fzbid0LiBJdCdzIGxhbWUuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29udGV4dCwgY3JlYXRlQ29udGV4dCwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFeGNsdXNpdmVDb250ZXh0VHlwZSwgU3dhcHBhYmxlQ29udGV4dFR5cGUsIFRyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZSB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IHN0cmluZyk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPjtcbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IG51bGwgfCB1bmRlZmluZWQpOiBudWxsO1xuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbihleGNsdXNpdml0eUtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPiB8IG51bGw7XG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogQ29udGV4dDxFeGNsdXNpdmVDb250ZXh0VHlwZSB8IG51bGw+IHwgbnVsbCB7XG4gICAgaWYgKGV4Y2x1c2l2aXR5S2V5ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjcmVhdGVDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG59XG5cbmV4cG9ydCBjb25zdCBTd2FwcGFibGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTd2FwcGFibGVDb250ZXh0VHlwZT4oeyBnZXRBbmltYXRlT25Nb3VudDogKCkgPT4gZmFsc2UgfSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCBmb3IgYSBnaXZlbiBgZXhjbHVzaXZpdHlLZXlgLCBjcmVhdGluZyBvbmUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICogXG4gKiBJZiBcbiAqL1xuZXhwb3J0IGNvbnN0IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0OiB0eXBlb2YgZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbiA9IG1lbW9pemUoZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbik7XG5cbmludGVyZmFjZSBDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcyB7XG4gICAgYmFzZTogc3RyaW5nO1xuICAgIGVudGVyOiBzdHJpbmc7XG4gICAgZXhpdDogc3RyaW5nO1xuICAgIG1lYXN1cmU6IHN0cmluZztcbiAgICBpbml0OiBzdHJpbmc7XG4gICAgdHJhbnNpdGlvbjogc3RyaW5nO1xuICAgIGZpbmFsaXplOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDc3NDbGFzc0NvbnRleHRUeXBlIHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IHN0cmluZztcbiAgICBHZXRFbnRlckNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0SW5pdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gc3RyaW5nO1xufVxuXG5jb25zdCBDc3NDbGFzc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PENzc0NsYXNzQ29udGV4dFR5cGU+KHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IFwicHRsXCIsXG4gICAgR2V0RW50ZXJDbGFzczogKCkgPT4gXCJuXCIsXG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBcInhcIixcbiAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IFwibVwiLFxuICAgIEdldEluaXRDbGFzczogKCkgPT4gXCJpXCIsXG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBcInRcIixcbiAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBcImZcIixcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBDc3NDbGFzc2VzUHJvdmlkZXIoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUsIGNoaWxkcmVuLCAuLi5yZXN0IH06IFJlbmRlcmFibGVQcm9wczxQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPj4pIHtcbiAgICBjb25zdCBjb250ZXh0T2JqZWN0ID0gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUgfSk7XG4gICAgcmV0dXJuICg8Q3NzQ2xhc3NDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0T2JqZWN0fSAgey4uLnJlc3R9IGNoaWxkcmVuPXtjaGlsZHJlbn0gLz4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDc3NDbGFzc2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgR2V0QmFzZUNsYXNzLFxuICAgICAgICBHZXRFbnRlckNsYXNzLFxuICAgICAgICBHZXRFeGl0Q2xhc3MsXG4gICAgICAgIEdldE1lYXN1cmVDbGFzcyxcbiAgICAgICAgR2V0SW5pdENsYXNzLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3MsXG4gICAgICAgIEdldEZpbmFsaXplQ2xhc3NcbiAgICB9ID0gdXNlQ29udGV4dChDc3NDbGFzc0NvbnRleHQpO1xuICAgIGNvbnN0IEdldERpcmVjdGlvbkNsYXNzID0gdXNlQ2FsbGJhY2soKGRpcmVjdGlvbjogVHJhbnNpdGlvbkRpcmVjdGlvbik6IHN0cmluZyA9PiB7IHN3aXRjaCAoZGlyZWN0aW9uKSB7IGNhc2UgXCJlbnRlclwiOiByZXR1cm4gR2V0RW50ZXJDbGFzcygpOyBjYXNlIFwiZXhpdFwiOiByZXR1cm4gR2V0RXhpdENsYXNzKCk7IH0gfSwgW10pO1xuICAgIGNvbnN0IEdldFBoYXNlQ2xhc3MgPSB1c2VDYWxsYmFjaygocGhhc2U6IFRyYW5zaXRpb25QaGFzZSk6IHN0cmluZyA9PiB7IHN3aXRjaCAocGhhc2UpIHsgY2FzZSBcIm1lYXN1cmVcIjogcmV0dXJuIEdldE1lYXN1cmVDbGFzcygpOyBjYXNlIFwiaW5pdFwiOiByZXR1cm4gR2V0SW5pdENsYXNzKCk7IGNhc2UgXCJ0cmFuc2l0aW9uXCI6IHJldHVybiBHZXRUcmFuc2l0aW9uQ2xhc3MoKTsgY2FzZSBcImZpbmFsaXplXCI6IHJldHVybiBHZXRGaW5hbGl6ZUNsYXNzKCk7IH0gfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIEdldEJhc2VDbGFzcyxcbiAgICAgICAgR2V0RW50ZXJDbGFzcyxcbiAgICAgICAgR2V0RXhpdENsYXNzLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3MsXG4gICAgICAgIEdldEluaXRDbGFzcyxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzLFxuICAgICAgICBHZXREaXJlY3Rpb25DbGFzcyxcbiAgICAgICAgR2V0UGhhc2VDbGFzc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUobmV3VmFsdWVzOiBQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPik6IENzc0NsYXNzQ29udGV4dFR5cGUge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHVzZUNvbnRleHQoQ3NzQ2xhc3NDb250ZXh0KTtcbiAgICBjb25zdCBiYXNlID0gKG5ld1ZhbHVlcz8uYmFzZSA/PyBvbGRWYWx1ZXMuR2V0QmFzZUNsYXNzKCkpO1xuICAgIGNvbnN0IGVudGVyID0gKG5ld1ZhbHVlcz8uZW50ZXIgPz8gb2xkVmFsdWVzLkdldEVudGVyQ2xhc3MoKSk7XG4gICAgY29uc3QgZXhpdCA9IChuZXdWYWx1ZXM/LmV4aXQgPz8gb2xkVmFsdWVzLkdldEV4aXRDbGFzcygpKTtcbiAgICBjb25zdCBtZWFzdXJlID0gKG5ld1ZhbHVlcz8ubWVhc3VyZSA/PyBvbGRWYWx1ZXMuR2V0TWVhc3VyZUNsYXNzKCkpO1xuICAgIGNvbnN0IGluaXQgPSAobmV3VmFsdWVzPy5pbml0ID8/IG9sZFZhbHVlcy5HZXRJbml0Q2xhc3MoKSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IChuZXdWYWx1ZXM/LnRyYW5zaXRpb24gPz8gb2xkVmFsdWVzLkdldFRyYW5zaXRpb25DbGFzcygpKTtcbiAgICBjb25zdCBmaW5hbGl6ZSA9IChuZXdWYWx1ZXM/LmZpbmFsaXplID8/IG9sZFZhbHVlcy5HZXRGaW5hbGl6ZUNsYXNzKCkpO1xuXG4gICAgcmV0dXJuIHVzZU1lbW88Q3NzQ2xhc3NDb250ZXh0VHlwZT4oKCkgPT4gKHtcbiAgICAgICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBiYXNlISxcbiAgICAgICAgR2V0RW50ZXJDbGFzczogKCkgPT4gZW50ZXIhLFxuICAgICAgICBHZXRFeGl0Q2xhc3M6ICgpID0+IGV4aXQhLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IG1lYXN1cmUhLFxuICAgICAgICBHZXRJbml0Q2xhc3M6ICgpID0+IGluaXQhLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3M6ICgpID0+IHRyYW5zaXRpb24hLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBmaW5hbGl6ZSEsXG4gICAgfSksIFtiYXNlLCBlbnRlciwgZXhpdCwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemVdKVxufVxuXG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgaCwgUmVuZGVyYWJsZVByb3BzLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuRmxhZywgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVPYmplY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgRXhjbHVzaXZlQ29udGV4dFR5cGUsIEV4Y2x1c2l2ZUluZm8sIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcblxuXG5cbmxldCBnbG9iYWxDb3VudCA9IC0xO1xuXG5leHBvcnQgZnVuY3Rpb24gRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyKHsgZXhjbHVzaXZpdHlLZXksIGNoaWxkcmVuIH06IFJlbmRlcmFibGVQcm9wczx7IGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB9Pikge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcIkV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlclwiLCBleGNsdXNpdml0eUtleSk7XG5cbiAgICBjb25zdCBbZ2V0TmV4dEluZGV4SW5MaW5lLCBzZXROZXh0SW5kZXhJbkxpbmVdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZyB8IG51bGwsIG5ldmVyPihudWxsKTtcblxuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuLCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPEV4Y2x1c2l2ZUluZm8+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgZ2V0Q3VycmVudEluZGV4IH0gPSB1c2VDaGlsZHJlbkZsYWc8RXhjbHVzaXZlSW5mbywgbmV2ZXI+KHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4sXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlLFxuICAgICAgICBpbml0aWFsSW5kZXg6IG51bGwsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIHNldEF0OiB1c2VDYWxsYmFjaygobSwgdikgPT4geyBtLnNldEV4Y2x1c2l2ZWx5T3Blbih2KTsgfSwgW10pLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKG0pID0+IG0uZ2V0RXhjbHVzaXZlbHlPcGVuKCksIFtdKSxcbiAgICAgICAgaXNWYWxpZDogdXNlQ2FsbGJhY2soKG0pID0+IHsgcmV0dXJuIHRydWUgfSwgW10pLFxuICAgIH0pXG5cbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgdmlzaWJsZTogXCJzaG93XCIgfCBcImhpZGRlblwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRJbkxpbmUgPSBnZXROZXh0SW5kZXhJbkxpbmUoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluTGluZSA9IGdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgICAgIGlmICh2aXNpYmxlID09IFwic2hvd1wiICYmIGluZGV4ICE9IGN1cnJlbnRJbkxpbmUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIGNoaWxkIHRyYW5zaXRpb24gc2hvd3MgaXRzZWxmIGluaXRpYWxseVxuICAgICAgICAgICAgICogKGkuZS4gcmVxdWVzdHMgaXRzZWxmIHRvIGJlIHRoZSBleGNsdXNpdmUgdHJhbnNpdGlvbilcbiAgICAgICAgICAgICAqIHdlIGVpdGhlciBsZXQgaXQgb3BlbiBpbW1lZGlhdGVseSBpZiB0aGVyZSdzIG5vIG9uZSBmaW5pc2hpbmcgdGhlaXIgZXhpdCxcbiAgICAgICAgICAgICAqIG9yIHdhaXQgdW50aWwgdGhhdCBhZm9yZW1lbnRpb25lZCBleGl0IGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbkxpbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuKCkuZ2V0QXQoY3VycmVudEluTGluZSk/LmZvcmNlQ2xvc2U/LigpO1xuICAgICAgICAgICAgICAgIHNldE5leHRJbmRleEluTGluZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlzaWJsZSA9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBjaGlsZCB0cmFuc2l0aW9uIGhhcyBmaW5pc2hlZCBpdHMgZXhpdCB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICogbWFrZSBzdXJlIHRoYXQgaWYgc29tZW9uZSByZXF1ZXN0ZWQgdG8gYmUgc2hvd24gaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgKiB0aGF0IHdlIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmV4dEluTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlSW5kZXgobmV4dEluTGluZSk7XG4gICAgICAgICAgICAgICAgc2V0TmV4dEluZGV4SW5MaW5lKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb250ZXh0MjogRXhjbHVzaXZlQ29udGV4dFR5cGUgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIGV4Y2x1c2l2aXR5S2V5LFxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgY29uc3QgRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgPSBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dChleGNsdXNpdml0eUtleSk7XG5cbiAgICByZXR1cm4gKEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0ID09IG51bGwpID8gKChjaGlsZHJlbiBhcyBWTm9kZSkgPz8gbnVsbCkgOiA8RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHQyfT57Y2hpbGRyZW59PC9FeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlcj47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEV4Y2x1c2l2ZUluZm8+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIiB8IFwiY29udGV4dFwiPiB7XG4gICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IFBpY2s8VHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPGFueT4sIFwic2hvd1wiPjtcbiAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBmb3JjZUNsb3NlOiAoKSA9PiB2b2lkOyBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24oeyB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBzaG93IH0sIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGZvcmNlQ2xvc2UsIGV4Y2x1c2l2aXR5S2V5IH0gfTogVXNlRXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjID0gR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQoZXhjbHVzaXZpdHlLZXkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25cIiwgYyA9PSBudWxsKTtcbiAgICBjb25zdCBjb250ZXh0ID0gYz8gdXNlQ29udGV4dChjKSA6IG51bGw7XG5cbiAgICBjb25zdCBpbmRleCA9IHVzZU1lbW8oKCkgPT4geyBnbG9iYWxDb3VudCArPSAxOyByZXR1cm4gKGdsb2JhbENvdW50KS50b1N0cmluZygpIH0sIFtdKTtcbiAgICBjb25zdCBbZXhjbHVzaXZlbHlPcGVuLCBzZXRFeGNsdXNpdmVseU9wZW4sIGdldEV4Y2x1c2l2ZWx5T3Blbl0gPSB1c2VTdGF0ZTxib29sZWFuPighIXNob3cpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9ID0gdXNlTWFuYWdlZENoaWxkPEV4Y2x1c2l2ZUluZm8+KHsgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9IH0sIHsgaW5kZXgsIGdldEV4Y2x1c2l2ZWx5T3Blbiwgc2V0RXhjbHVzaXZlbHlPcGVuLCBmb3JjZUNsb3NlIH0pO1xuXG4gICAgY29uc3QgcGFyZW50T25WaXNDaGFuZ2UgPSBjb250ZXh0Py5leGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5vblZpc2liaWxpdHlDaGFuZ2U7XG5cbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8YW55PltcIm9uVmlzaWJpbGl0eUNoYW5nZVwiXT4+KCh2aXNpYmxlKSA9PiB7XG4gICAgICAgIHBhcmVudE9uVmlzQ2hhbmdlPy4oaW5kZXgsIHZpc2libGUgPT0gZmFsc2UgPyBcImhpZGRlblwiIDogXCJzaG93XCIpO1xuICAgIH0sIFtwYXJlbnRPblZpc0NoYW5nZSwgaW5kZXhdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG93KVxuICAgICAgICAgICAgcGFyZW50T25WaXNDaGFuZ2U/LihpbmRleCwgXCJzaG93XCIpO1xuICAgIH0sIFtzaG93LCBwYXJlbnRPblZpc0NoYW5nZSwgaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm46IHtcbiAgICAgICAgICAgIGlzRXhjbHVzaXZlOiAoY29udGV4dCAhPSBudWxsKSxcbiAgICAgICAgICAgIGV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIHNldEV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIGdldEV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4iLCJcclxuaW1wb3J0IHsgRnVuY3Rpb25hbENvbXBvbmVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxudHlwZSBGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50UHJvcHM8UCwgRT4gPSBPbWl0PFAsIFwicmVmXCI+ICYgeyByZWY/OiBSZWY8RT4gfVxyXG50eXBlIEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnQ8UCwgRT4gPSAocDogRm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+KSA9PiBWTm9kZTxGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50UHJvcHM8UCwgRT4+XHJcblxyXG50eXBlIEVsZW1lbnRGcm9tUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGluZmVyIEU+ID8gRSA6IEV2ZW50VGFyZ2V0O1xyXG50eXBlIFByb3BzRnJvbUNvbXBvbmVudDxDIGV4dGVuZHMgRnVuY3Rpb25hbENvbXBvbmVudDxhbnk+PiA9IEMgZXh0ZW5kcyBGdW5jdGlvbmFsQ29tcG9uZW50PGluZmVyIFA+ID8gUCA6IHVua25vd247XHJcblxyXG4vKipcclxuICogU2hvcnRjdXQgZm9yIHByZWFjdC9jb21wYXQncyBgZm9yd2FyZFJlZmAgdGhhdCBhdXRvLWFzc3VtZXMgc29tZSB0aGluZ3MgdGhhdCBhcmUgdXNlZnVsIGZvciBmb3J3YXJkaW5nIHJlZnMgdG8gYEhUTUxFbGVtZW50c2Agc3BlY2lmaWNhbGx5LlxyXG4gKiBOYW1lbHkgaXQgaW52b2x2ZXMgZGUtZ3Vua2luZyB0aGUgdHlwZSBzeXN0ZW0gYnkgbGV0dGluZyB1cyByZXR1cm4gKmdlbmVyaWMqIGZ1bmN0aW9uIGFuZCBwbGF5aW5nIG5pY2Ugd2l0aCBSZWFjdC4gSW4gYWxsIG90aGVyIHJlc3BlY3RzLCBpdCBhY3RzIGxpa2UgYGZvcndhcmRSZWZgLlxyXG4gKiBcclxuICogVE9ETzogU3RpbGwgbmVlZGVkP1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRFbGVtZW50UmVmPEMgZXh0ZW5kcyA8RSBleHRlbmRzIEhUTUxFbGVtZW50PihwOiBhbnksIHJlZjogUmVmPEU+KSA9PiAoVk5vZGU8YW55PiB8IG51bGwpPihDb21wb25lbnQ6IEMpIHtcclxuICAgIHR5cGUgUCA9IFByb3BzRnJvbUNvbXBvbmVudDxDPjtcclxuXHJcblxyXG4gICAgY29uc3QgRm9yd2FyZGVkQ29tcG9uZW50ID0gZm9yd2FyZFJlZihDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEZvcndhcmRlZENvbXBvbmVudCBhcyBDO1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZnVsIGluIHBhcnRpY3VsYXIgZm9yIFNsaWRlcyB3aXRoIGEgVGFiIFBhbmVsIC0tXHJcbiAqIGlmIHdlIGRvIE1hdGguc2lnbihjdXJyZW50SW5kZXggLSBzbGlkZUluZGV4KSwgaXRcclxuICogdHJhbnNpdGlvbnMgbmljZWx5IGluIHRoZSBleHBlY3RlZCBkaXJlY3Rpb24sXHJcbiAqIGJ1dCB3ZSBuZWVkIHRvIFwicmVtZW1iZXJcIiB3aGljaCBkaXJlY3Rpb24gdG8gdXNlXHJcbiAqIHdoZW4gaXQncyB0aGUgY3VycmVudCBwYW5lbCAoYW5kIHRoZSBkaWZmZXJlbmNlIGlzIDApXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGFzdE5vbk51bGxWYWx1ZTxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUIHwgbnVsbCB7XHJcbiAgICBjb25zdCBsYXN0Tm9uTnVsbFZhbHVlID0gdXNlUmVmPFQgfCBudWxsPihudWxsKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAgIGxhc3ROb25OdWxsVmFsdWUuY3VycmVudCA9IHZhbHVlO1xyXG4gICAgfSwgW3ZhbHVlXSk7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlID8/IGxhc3ROb25OdWxsVmFsdWUuY3VycmVudDtcclxufVxyXG4iLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBDb21wb25lbnRDaGlsZHJlbiwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlciB9IGZyb20gXCIuL2V4Y2x1c2l2ZS5qc1wiO1xyXG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0LCB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IE5vbkludHJ1c2l2ZUVsZW1lbnRBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTd2FwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFBhcnRpYWw8Q3JlYXRlU3dhcHBhYmxlUHJvcHM+LCBOb25JbnRydXNpdmVFbGVtZW50QXR0cmlidXRlczxFPiB7XHJcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBlYWNoIGNoaWxkIHRyYW5zaXRpb25zIGluL291dCBhdCB0aGUgc2FtZSB0aW1lLCBpbiBzeW5jIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAqIFxyXG4gICAgICogSWYgeW91IHdhbnQgdG8gZ3VhcmFudGVlIHRoYXQsIG5vIG1hdHRlciB3aGF0LCBvbmx5IG9uZSBpcyBldmVyIHZpc2libGUgYXQgYWxsLFxyXG4gICAgICogcGFzcyBhIHN0cmluZyB0byBgZXhjbHVzaXZpdHlLZXlgLCBhbmQgYWxsIHRyYW5zaXRpb25zIHRoYXQgdXNlIHRoYXQgc2FtZVxyXG4gICAgICogYGV4Y2x1c2l2aXR5S2V5YCB3aWxsIGNvb3JkaW5hdGUgdGhpcyBiZWhhdmlvciBhbW9uZyB0aGVtc2VsdmVzLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIGlzIGFsc28gYXZhaWxhYmxlIGFzIGEgc2VwYXJhdGUgY29tcG9uZW50IChgRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyYClcclxuICAgICAqIGlmIHlvdSBuZWVkIHRoaXMgYmVoYXZpb3IgaW4gdW5yZWxhdGVkIGNpcmN1bXN0YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTd2FwcGFibGVQcm9wcyB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgaXMgaW5saW5lLWdyaWQgb3IgZ3JpZC4gXHJcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjaGlsZCBlbGVtZW50IGlzIGxvb2tlZCBhdC4gSWYgaXQncyBhIHNwYW4gb3Igb3RoZXIgaW5saW5lIGVsZW1lbnQsIGlubGluZSBpcyBhc3N1bWVkLiBcclxuICAgICAqIChBIHNpbXBseS1mb29sZWQgaGV1cmlzdGljLS1wcm92aWRlIHRoaXMgcHJvcCBpZiBuZWNlc3NhcnkpXHJcbiAgICAgKi9cclxuICAgIGlubGluZTogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBkZWZhdWx0IHZhbHVlcyB0byBgdXNlVHJhbnNpdGlvbmAncyBgYW5pbWF0ZU9uTW91bnRgLiBJZiBudWxsLCB0aGUgZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5LCB0aGVuIGB0cnVlYCBhZnRlciB0aGUgYFN3YXBwYWJsZWAgaXRzZWxmIGhhcyBtb3VudGVkLlxyXG4gICAgICovXHJcbiAgICBjaGlsZHJlbkFuaW1hdGVPbk1vdW50PzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgc3dhcCBjb250YWluZXIuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHM8UCBleHRlbmRzIHt9Pih7IGlubGluZSB9OiBDcmVhdGVTd2FwcGFibGVQcm9wcywgb3RoZXJQcm9wczogUCkge1xyXG4gICAgdHlwZSBFID0gUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGluZmVyIEU+ID8gRSA6IEhUTUxFbGVtZW50O1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke0dldEJhc2VDbGFzcygpfS1zd2FwLWNvbnRhaW5lcmAsIGlubGluZSAmJiBgJHtHZXRCYXNlQ2xhc3MoKX0tc3dhcC1jb250YWluZXItaW5saW5lYClcclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGEgc2V0IG9mIGNoaWxkIDxUcmFuc2l0aW9uYWJsZT4gY29tcG9uZW50cyB0byBhbmltYXRlIGluICYgb3V0IGluLXBsYWNlLiBWZXJ5IHVzZWZ1bCBmb3IsIGUuZy4sIHRhYiBwYW5lbHMuXHJcbiAqIFxyXG4gKiBZb3UgbXVzdCBtYW5hZ2UgZWFjaCBjaGlsZCBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50J3MgYHNob3dgIHByb3AgLS0gdGhpcyBjb21wb25lbnQgKmRvZXMgbm90KiBtYW5hZ2UgYW55IHNvcnQgb2Ygc3RhdGUgaW4gdGhhdCByZWdhcmQuXHJcbiAqIFxyXG4gKiBJZiB5b3UgcGFzcyBhIHJlZ3VsYXIgZWxlbWVudCAobGlrZSBhIGRpdikgb3Igb3RoZXIgc2luZ2xlIGNvbXBvbmVudCwgdGhlbiB0aGVlIHByb3BzIGFuZCByZWYgd2lsbCBiZSBmb3J3YXJkZWQgb250byB0aGF0IGVsZW1lbnQuIE90aGVyd2lzZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIHdyYXBwZWQgaW4gYSBkaXYgb3Igc3BhbiBkZXBlbmRpbmcgb24gdGhlIGBpbmxpbmVgIHByb3AuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFN3YXBwYWJsZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU3dhcHBhYmxlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBjaGlsZHJlbjogYywgaW5saW5lLCBjaGlsZHJlbkFuaW1hdGVPbk1vdW50LCBleGNsdXNpdml0eUtleSwgLi4ucCB9OiBTd2FwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICBsZXQgY2hpbGRyZW4gPSBjIGFzIFZOb2RlO1xyXG4gICAgaWYgKCEoY2hpbGRyZW4gYXMgVk5vZGUpLnR5cGUpXHJcbiAgICAgICAgY2hpbGRyZW4gPSAoIWlubGluZSA/IDxkaXY+e2NoaWxkcmVufTwvZGl2PiA6IDxzcGFuPntjaGlsZHJlbn08L3NwYW4+KVxyXG4gICAgaW5saW5lID8/PSB0eXBlb2YgY2hpbGRyZW4udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBpbmxpbmVFbGVtZW50cy5oYXMoY2hpbGRyZW4udHlwZSk7XHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvblByb3BzID0gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHMoeyBpbmxpbmUgfSwgeyAuLi5wLCByZWYgfSk7XHJcbiAgICBjb25zdCBtZXJnZWRXaXRoQ2hpbGRyZW4gPSB1c2VNZXJnZWRQcm9wczxFPih0cmFuc2l0aW9uUHJvcHMsIGNoaWxkcmVuLnByb3BzKTtcclxuXHJcbiAgICBjb25zdCBhbmltYXRlT25Nb3VudCA9IHVzZVJlZihjaGlsZHJlbkFuaW1hdGVPbk1vdW50ID8/IGZhbHNlKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgYW5pbWF0ZU9uTW91bnQuY3VycmVudCA9IHRydWU7XHJcbiAgICB9LCBbXSlcclxuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZVJlZih7IGdldEFuaW1hdGVPbk1vdW50OiAoKSA9PiB7IHJldHVybiBhbmltYXRlT25Nb3VudC5jdXJyZW50OyB9IH0pO1xyXG4gICAgbGV0IHJldCA9IGNsb25lRWxlbWVudChjaGlsZHJlbiwgbWVyZ2VkV2l0aENoaWxkcmVuIGFzIHR5cGVvZiB0cmFuc2l0aW9uUHJvcHMpO1xyXG4gICAgcmV0ID0gKDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWUuY3VycmVudH0+e3JldH08L1N3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXI+KVxyXG4gICAgaWYgKGV4Y2x1c2l2aXR5S2V5KSB7XHJcbiAgICAgICAgcmV0ID0gKDxFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIga2V5PXtleGNsdXNpdml0eUtleX0gZXhjbHVzaXZpdHlLZXk9e2V4Y2x1c2l2aXR5S2V5fT57cmV0fTwvRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyPilcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn0pKVxyXG5cclxuLy8gSWYgXCJpbmxpbmVcIiBpc24ndCBleHBsaWNpdGx5IHByb3ZpZGVkLCB3ZSB0cnkgdG8gaW1wbGljaXRseSBkbyBpdCBiYXNlZCBvbiB0aGUgY2hpbGQncyB0YWcuXHJcbi8vIE5vdCBwZXJmZWN0LCBidXQgaXQncyBub3Qgc3VwcG9zZWQgdG8gYmUuIGBpbmxpbmVgIGlzIGZvciBwZXJmZWN0LlxyXG5jb25zdCBpbmxpbmVFbGVtZW50cyA9IG5ldyBTZXQoW1xyXG4gICAgXCJhXCIsXHJcbiAgICBcImFiYnJcIixcclxuICAgIFwiYWNyb255bVwiLFxyXG4gICAgXCJhdWRpb1wiLFxyXG4gICAgXCJiXCIsXHJcbiAgICBcImJkaVwiLFxyXG4gICAgXCJiZG9cIixcclxuICAgIFwiYmlnXCIsXHJcbiAgICBcImJyXCIsXHJcbiAgICBcImJ1dHRvblwiLFxyXG4gICAgXCJjYW52YXNcIixcclxuICAgIFwiY2l0ZVwiLFxyXG4gICAgXCJjb2RlXCIsXHJcbiAgICBcImRhdGFcIixcclxuICAgIFwiZGF0YWxpc3RcIixcclxuICAgIFwiZGVsXCIsXHJcbiAgICBcImRmblwiLFxyXG4gICAgXCJlbVwiLFxyXG4gICAgXCJlbWJlZFwiLFxyXG4gICAgXCJpXCIsXHJcbiAgICBcImlmcmFtZVwiLFxyXG4gICAgXCJpbWdcIixcclxuICAgIFwiaW5wdXRcIixcclxuICAgIFwiaW5zXCIsXHJcbiAgICBcImtiZFwiLFxyXG4gICAgXCJsYWJlbFwiLFxyXG4gICAgXCJtYXBcIixcclxuICAgIFwibWFya1wiLFxyXG4gICAgXCJtZXRlclwiLFxyXG4gICAgXCJub3NjcmlwdFwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwib3V0cHV0XCIsXHJcbiAgICBcInBpY3R1cmVcIixcclxuICAgIFwicHJvZ3Jlc3NcIixcclxuICAgIFwicVwiLFxyXG4gICAgXCJydWJ5XCIsXHJcbiAgICBcInNcIixcclxuICAgIFwic2FtcFwiLFxyXG4gICAgXCJzY3JpcHRcIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcInNsb3RcIixcclxuICAgIFwic21hbGxcIixcclxuICAgIFwic3BhblwiLFxyXG4gICAgXCJzdHJvbmdcIixcclxuICAgIFwic3ViXCIsXHJcbiAgICBcInN1cFwiLFxyXG4gICAgXCJzdmdcIixcclxuICAgIFwidGVtcGxhdGVcIixcclxuICAgIFwidGV4dGFyZWFcIixcclxuICAgIFwidGltZVwiLFxyXG4gICAgXCJ1XCIsXHJcbiAgICBcInR0XCIsXHJcbiAgICBcInZhclwiLFxyXG4gICAgXCJ2aWRlb1wiLFxyXG4gICAgXCJ3YnJcIlxyXG5dKTtcclxuIiwiaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHJ1bkltbWVkaWF0ZWx5IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRXhjbHVzaXZlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2V4Y2x1c2l2ZS5qc1wiO1xuaW1wb3J0IHsgR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQsIHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IFN3YXBwYWJsZUNvbnRleHRUeXBlLCBUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2UsIFRyYW5zaXRpb25TdGF0ZSwgVXNlVHJhbnNpdGlvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0IH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5cblxuZnVuY3Rpb24gZ2V0VGltZW91dER1cmF0aW9uPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oZWxlbWVudDogRSB8IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZShgdHJhbnNpdGlvbi1kdXJhdGlvbmApKS5zcGxpdChcIixcIikubWFwKHN0ciA9PiB7XG4gICAgICAgIGlmIChzdHIuZW5kc1dpdGgoXCJtc1wiKSlcbiAgICAgICAgICAgIHJldHVybiArc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICAgIGlmIChzdHIuZW5kc1dpdGgoXCJzXCIpKVxuICAgICAgICAgICAgcmV0dXJuICgrc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSkpICogMTAwMDtcbiAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlKG5leHRTdGF0ZTogVHJhbnNpdGlvblN0YXRlKSB7XG4gICAgcmV0dXJuIG5leHRTdGF0ZS5zcGxpdChcIi1cIikgYXMgW1RyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZV07XG59XG5cbi8qKlxuICogUHJvdmlkZSBwcm9wcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFuaW1hdGUgYSB0cmFuc2l0aW9uLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBwcm9wc0luY29taW5nOiB7IGNoaWxkcmVuLCAuLi5wIH0sIHNob3csIGFuaW1hdGVPbk1vdW50LCBtZWFzdXJlLCBleGl0VmlzaWJpbGl0eSwgZHVyYXRpb24sIGRlbGF5TW91bnRVbnRpbFNob3duLCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIG9uVmlzaWJpbGl0eUNoYW5nZSB9LCBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9IH06IFVzZVRyYW5zaXRpb25QYXJhbWV0ZXJzPEU+KTogVk5vZGU8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+IHwgbnVsbCB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlVHJhbnNpdGlvblwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuXG4gICAgY29uc3QgeyBnZXRBbmltYXRlT25Nb3VudCB9ID0gdXNlQ29udGV4dChTd2FwcGFibGVDb250ZXh0KTtcbiAgICBleGl0VmlzaWJpbGl0eSB8fD0gXCJoaWRkZW5cIlxuICAgIGFuaW1hdGVPbk1vdW50ID8/PSBnZXRBbmltYXRlT25Nb3VudCgpO1xuICAgIG1lYXN1cmUgPz89IGZhbHNlO1xuXG4gICAgY29uc3QgZ2V0RXhpdFZpc2liaWxpdHkgPSB1c2VTdGFibGVHZXR0ZXIoZXhpdFZpc2liaWxpdHkpO1xuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzLCBHZXRFbnRlckNsYXNzLCBHZXRFeGl0Q2xhc3MsIEdldE1lYXN1cmVDbGFzcywgR2V0SW5pdENsYXNzLCBHZXRUcmFuc2l0aW9uQ2xhc3MsIEdldEZpbmFsaXplQ2xhc3MsIEdldERpcmVjdGlvbkNsYXNzLCBHZXRQaGFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XG4gICAgY29uc3QgZ2V0TWVhc3VyZSA9IHVzZVN0YWJsZUdldHRlcihtZWFzdXJlKTtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm46IHsgZXhjbHVzaXZlbHlPcGVuLCBpc0V4Y2x1c2l2ZSwgb25WaXNpYmlsaXR5Q2hhbmdlOiBleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZSB9IH0gPSB1c2VFeGNsdXNpdmVUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgc2hvdyB9LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSwgZm9yY2VDbG9zZTogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBpbnRlcm5hbE9uU2hvd0NoYW5nZWQoZmFsc2UsIGdldE1lYXN1cmUoKSk7IH0pIH1cbiAgICB9KTtcblxuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBzaG93ID0gKHNob3cgJiYgZXhjbHVzaXZlbHlPcGVuKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCwgcHJvcHNTdGFibGUgfSB9ID0gdXNlUmVmRWxlbWVudDxFPih7fSlcbiAgICBjb25zdCBjc3NQcm9wZXJ0aWVzID0gdXNlUmVmPGguSlNYLkNTU1Byb3BlcnRpZXM+KHt9KTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdXNlUmVmKG5ldyBTZXQ8c3RyaW5nPihbXG4gICAgICAgIC8vIFRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBmaXJzdCByZW5kZXJcbiAgICAgICAgLy8gKGF0IGxlYXN0IG9uY2UgYHNob3dgIGlzIG5vbi1udWxsKVxuICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tcGVuZGluZ2AsXG4gICAgXSkpO1xuICAgIGNvbnN0IGhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCghIXN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBbZGlyZWN0aW9uLCBwaGFzZV0gPSBwYXJzZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChwaGFzZSA9PSBcInRyYW5zaXRpb25cIikge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKGAke2RpcmVjdGlvbn0tZmluYWxpemVgKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZS5jdXJyZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50Py4odGltZW91dEhhbmRsZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG4gICAgY29uc3Qgb3RoZXJQcm9wcyA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oe1xuICAgICAgICBvblRyYW5zaXRpb25FbmQ6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT0gZ2V0RWxlbWVudCgpICYmIGUuZWxhcHNlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUcmFuc2l0aW9uRmluaXNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBoYXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsZW1lbnQncyBDU1MgY2xhc3MgdG8gbWF0Y2ggdGhlIGdpdmVuIGRpcmVjdGlvbiBhbmQgcGhhc2UuXG4gICAgICovXG4gICAgY29uc3QgdXBkYXRlQ2xhc3NlcyA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCwgZGlyZWN0aW9uOiBUcmFuc2l0aW9uRGlyZWN0aW9uLCBwaGFzZT86IFRyYW5zaXRpb25QaGFzZSkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgY29uc3QgZXhpdFZpc2liaWxpdHkgPSBnZXRFeGl0VmlzaWJpbGl0eSgpO1xuXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXNUb1JlbW92ZSA9IFtcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldE1lYXN1cmVDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRJbml0Q2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0VHJhbnNpdGlvbkNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldEZpbmFsaXplQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0TWVhc3VyZUNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0SW5pdENsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0VHJhbnNpdGlvbkNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0RmluYWxpemVDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcImluZXJ0XCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke1wicmVtb3ZlZFwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcImhpZGRlblwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcInZpc2libGVcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LXBlbmRpbmdgLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXNUb0FkZCA9IFtcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXREaXJlY3Rpb25DbGFzcyhkaXJlY3Rpb24pfWAsXG4gICAgICAgICAgICBwaGFzZSA/IGAke0dldEJhc2VDbGFzcygpfS0ke0dldERpcmVjdGlvbkNsYXNzKGRpcmVjdGlvbil9LSR7R2V0UGhhc2VDbGFzcyhwaGFzZSl9YCA6IFwiXCIsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtleGl0VmlzaWJpbGl0eX1gXG4gICAgICAgIF07XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmFsbENsYXNzZXNUb1JlbW92ZSk7XG4gICAgICAgIGFsbENsYXNzZXNUb1JlbW92ZS5tYXAodiA9PiBjbGFzc05hbWVzLmN1cnJlbnQuZGVsZXRlKHYpKTtcblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uYWxsQ2xhc3Nlc1RvQWRkKTtcbiAgICAgICAgYWxsQ2xhc3Nlc1RvQWRkLm1hcCh2ID0+IGNsYXNzTmFtZXMuY3VycmVudC5hZGQodikpO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHNpbmdsZSBcIm1lYXN1cmVcIiB2YXJpYWJsZSAob3IgcmVtb3ZlcyBpdClcbiAgICAgKi9cbiAgICBjb25zdCB1cGRhdGVTaXplUHJvcGVydHkgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSwgdmFyTmFtZTogKGtleW9mIGguSlNYLkNTU1Byb3BlcnRpZXMpICYgc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZX1weGA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFt2YXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh2YXJOYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbdmFyTmFtZV07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBcIm1lYXN1cmVcIiB2YXJpdXBkYXRlQ2xhc3Nlc2FibGVzIHRvIHRoZSBlbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICBjb25zdCBtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIG1lYXN1cmU6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBzaXplOiBET01SZWN0UmVhZE9ubHkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLXRvcGAsIHNpemU/LnRvcCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS1sZWZ0YCwgc2l6ZT8ubGVmdCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS13aWR0aGAsIHNpemU/LndpZHRoKTtcbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLWhlaWdodGAsIHNpemU/LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBXZSB1c2UgYm90aCB1c2VUaW1lb3V0IGFuZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIHRpbWluZyBjZXJ0YWluIHRoaW5ncyAtLVxuICAgIC8vIHJhZiBpcyB1c2VkIGZvciBjaGFuZ2luZyBmcm9tIGluaXQgdG8gdHJhbnNpdGlvbiAod291bGQgdXNlIHF1ZXVlTWljcm90YXNrIGJ1dCBpdCBjYW4ndCBiZSBjYW5jZWxsZWQpXG4gICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIGZvciBjaGFuZ2luZyBmcm9tIHRyYW5zaXRpb24gdG8gZmluYWxpemUgKGFzIGEgYmFja3VwIGluIGNhc2UgdHJhbnNpdGlvbmVuZCBkb2Vzbid0IGZpcmUpXG4gICAgLy9cbiAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBzdGFsZSBjYWxsYmFja3MgcnVubmluZyAoaS5lLiB3aGVuIHdlIHJhcGlkbHkgc3dpdGNoIGJldHdlZW4gdmlzaWJsZSBhbmQgbm90KVxuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFjY3VyYXRlbHkgY2FuY2VsIGFueXRoaW5nIHRoYXQgY2FuIGNoYW5nZSBvdXIgc3RhdGUgb24gYSBkZWxheS5cbiAgICAvL1xuICAgIC8vIEFsc28gb2Ygbm90ZSwgd2Ugc3RvcmUgXCIoZikgPT4gd2luZG93LmNsZWFyVGltZW91dChmKVwiIGluc3RlYWQgb2YganVzdCBcIndpbmRvdy5jbGVhclRpbWVvdXRcIiBiZWNhdXNlXG4gICAgLy8gb2YgdGhlIGltcGxpY2l0IHdpbmRvdyBvYmplY3QgLS0gcHJvYmxlbXMgd2l0aCBhIG1pc3NpbmcgYHRoaXNgIG9iamVjdCBhbmQgYWxsIHRoYXQgbm9uc2Vuc2UuXG4gICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHVzZVJlZjxudW1iZXI+KC0xKTtcbiAgICBjb25zdCB0aW1lb3V0Q2xlYXJGdW5jdGlvbiA9IHVzZVJlZjwodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lKSB8ICh0eXBlb2YgY2xlYXJUaW1lb3V0KSB8IG51bGw+KG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgdGhlIHN0YXRlIGNoYW5nZXMsIHRoZXJlJ3Mgc29tZSBsb2dpYyB3ZSBuZWVkIHRvIHJ1bjpcbiAgICAgKiBcbiAgICAgKiAqIElmIHdlJ3JlIGNoYW5naW5nIHRvIGFuIGBpbml0YCBwaGFzZSwgdXBkYXRlIHRoZSBjbGFzc2VzLCB0aGVuIHdhaXQgYSBtb21lbnQgYW5kIHRoZW4gY2hhbmdlIHRvIHRoZSBgdHJhbnNpdGlvbmAgcGhhc2UuXG4gICAgICogKiBJZiB3ZSdyZSBjaGFuZ2luZyB0byBhIGB0cmFuc2l0aW9uYCBwaGFzZSwgdXBkYXRlIHRoZSBjbGFzc2VzLCB0aGVuIHdhaXQgdW50aWwgdGhlIHRyYW5zaXRpb24gY29tcGxldGVzLCB0aGVuIGNoYW5nZSB0byB0aGUgYGZpbmFsaXplYCBwaGFzZS5cbiAgICAgKiBcbiAgICAgKiBBbnkgY2hhbmdlIGluIHN0YXRlIG9yIGNsYXNzZXMvc3R5bGVzIGRvZXMgbm90IGltcGxpY2l0bHkgY2F1c2UgYSByZS1yZW5kZXIuXG4gICAgICovXG4gICAgY29uc3Qgb25TdGF0ZUNoYW5nZSA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFRyYW5zaXRpb25TdGF0ZSB8IG51bGwsIHVuZGVmaW5lZD4+KChuZXh0U3RhdGUsIHByZXZTdGF0ZSwgcmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBbbmV4dERpcmVjdGlvbiwgbmV4dFBoYXNlXSA9IHBhcnNlU3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgbm8gc3RhbGUgY2hhbmdlIGNvZGUgZXZlciBydW5zXG4gICAgICAgIGlmICh0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPj0gMCAmJiB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50KVxuICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCh0aW1lb3V0SGFuZGxlLmN1cnJlbnQpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBpbmVydCBwcm9wcy9wcm9wZXJ0eVxuICAgICAgICBjb25zdCBleGl0VmlzaWJpbGl0eSA9IGdldEV4aXRWaXNpYmlsaXR5KCk7XG4gICAgICAgIGlmIChleGl0VmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgY29uc3QgaW5lcnQgPSAoZXhpdFZpc2liaWxpdHkgPT0gXCJpbmVydFwiICYmIChuZXh0RGlyZWN0aW9uID09IFwiZXhpdFwiICYmIG5leHRQaGFzZSA9PSBcImZpbmFsaXplXCIpID8gdHJ1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoaW5lcnQpXG4gICAgICAgICAgICAgICAgKG90aGVyUHJvcHMuY3VycmVudCBhcyBhbnkpLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgb3RoZXJQcm9wcy5jdXJyZW50W1wiaW5lcnRcIiBhcyBuZXZlcl07XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5lcnQgPSAoaW5lcnQgfHwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNCZWluZ1BhaW50ZWQgPSAobmV4dERpcmVjdGlvbiA9PSBcImVudGVyXCIgfHwgKG5leHREaXJlY3Rpb24gPT0gXCJleGl0XCIgJiYgbmV4dFBoYXNlICE9IFwiZmluYWxpemVcIikpO1xuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2U/Lihpc0JlaW5nUGFpbnRlZCk7XG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25WaXNpYmlsaXR5Q2hhbmdlPy4oaXNCZWluZ1BhaW50ZWQpO1xuXG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoZWxlbWVudCwgbmV4dERpcmVjdGlvbiwgbmV4dFBoYXNlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgKG5leHRQaGFzZSA9PSBcImluaXRcIiB8fCBuZXh0UGhhc2UgPT0gXCJ0cmFuc2l0aW9uXCIpKVxuICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG5cblxuXG4gICAgICAgIHN3aXRjaCAobmV4dFBoYXNlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVhc3VyZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50QW5kVXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvL3NldFN0YXRlKGAke25leHREaXJlY3Rpb259LWluaXRgKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDbGFzc2VzKGVsZW1lbnQsIG5leHREaXJlY3Rpb24sIFwiaW5pdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyAhIUludGVudGlvbmFsIGZhbGwtdGhyb3VnaCEhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW5pdFwiOiB7XG4gICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgc2V0U3RhdGUoYCR7bmV4dERpcmVjdGlvbn0tdHJhbnNpdGlvbmApOyB9KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50ID0gKGY6IG51bWJlcikgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfSwgZ2V0VGltZW91dER1cmF0aW9uKGVsZW1lbnQpICogMS41KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50ID0gKGY6IG51bWJlcikgPT4gY2xlYXJUaW1lb3V0KGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVcIjoge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gb3Igc2NoZWR1bGUgb3IgYW55dGhpbmcgLS0gd2UganVzdCB1cGRhdGUgb3VyIGNsYXNzZXMgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IG51bGw7ICAgIC8vIERvZXMgdGhpcyBtYWtlIGl0IG1vcmUgb3IgbGVzcyBjbGVhcj9cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBJbnRlbnRpb25hbFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkIHN0YXRlIHVzZWQgaW4gdHJhbnNpdGlvbjogJHtuZXh0U3RhdGV9LiBQcmV2aW91cyBzdGF0ZSB3YXMgJHtwcmV2U3RhdGUgPz8gXCJudWxsXCJ9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cblxuICAgIGNvbnN0IFtnZXRTdGF0ZSwgc2V0U3RhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPFRyYW5zaXRpb25TdGF0ZSB8IG51bGwsIHVuZGVmaW5lZD4ob25TdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgYW5kIGV2ZXJ5IHRpbWUgdGhlcmVhZnRlciB0aGF0IGBzaG93YCBjaGFuZ2VzLFxuICAgIC8vIGNoYW5nZSBvdXIgY3VycmVudCBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhhdCBgc2hvd2AgdmFsdWUuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IGludGVybmFsT25TaG93Q2hhbmdlZChzaG93LCBtZWFzdXJlKSwgW21lYXN1cmUsIHNob3ddKTtcblxuXG4gICAgLy8gVGhpcyBoYXMgbm8gZGVwZW5kZW5jZXMgYW5kIGlzIHJlbGllZCBvbiBpbiB0d28gZGlmZmVyZW50IGFyZWFzXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxPblNob3dDaGFuZ2VkKHNob3c6IGJvb2xlYW4gfCBudWxsLCBtZWFzdXJlOiBib29sZWFuKSB7XG5cbiAgICAgICAgLy8gSWYgYHNob3dgIGlzIG51bGwsIHRoZW4gd2UgZG9uJ3QgY2hhbmdlIGFueXRoaW5nLlxuICAgICAgICBpZiAoc2hvdyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIChJZiBgc2hvd2AgaXMgdHJ1ZS9mYWxzZSwgd2UnbGwgcmVtb3ZlIHRoZSBDU1MgY2xhc3NlcyBkdXJpbmcgYG9uQ2hhbmdlYClcblxuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICBsZXQgbmV4dFBoYXNlOiBUcmFuc2l0aW9uUGhhc2UgPSBtZWFzdXJlID8gXCJtZWFzdXJlXCIgOiBcImluaXRcIjtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgW2N1cnJlbnREaXJlY3Rpb24sIGN1cnJlbnRQaGFzZV0gPSBwYXJzZVN0YXRlKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBoYXNlICE9IFwiZmluYWxpemVcIilcbiAgICAgICAgICAgICAgICBuZXh0UGhhc2UgPSBcInRyYW5zaXRpb25cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHRoZSBzZXRTdGF0ZSBjaGFuZ2UgaGFuZGxlciBydW5zIGltbWVkaWF0ZWx5IHdpdGggbm8gZGVib3VuY2UuXG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBpZiAoaGFzTW91bnRlZC5jdXJyZW50IHx8IGFuaW1hdGVPbk1vdW50KVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKGBlbnRlci0ke25leHRQaGFzZX1gKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKFwiZW50ZXItZmluYWxpemVcIik7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNNb3VudGVkLmN1cnJlbnQgfHwgYW5pbWF0ZU9uTW91bnQpXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoYGV4aXQtJHtuZXh0UGhhc2V9YCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoXCJleGl0LWZpbmFsaXplXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZHVyYXRpb24gIT0gbnVsbClcbiAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LWR1cmF0aW9uYF0gPSBkdXJhdGlvbiArIFwibXNcIjtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZHVyYXRpb25gXTtcblxuICAgIGVhc2luZ0luID8/PSBlYXNpbmc7XG4gICAgZWFzaW5nT3V0ID8/PSBlYXNpbmc7XG5cbiAgICBpZiAoZWFzaW5nT3V0ICE9IG51bGwpXG4gICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXSA9IGVhc2luZ091dDtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF07XG5cblxuICAgIGlmIChlYXNpbmdJbiAhPSBudWxsKVxuICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdID0gZWFzaW5nSW47XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXTtcblxuXG5cbiAgICAvLyBUT0RPXG4gICAgY29uc3QgaW5saW5lRGlyZWN0aW9uID0gbnVsbDtcbiAgICBjb25zdCBibG9ja0RpcmVjdGlvbiA9IG51bGw7XG5cblxuXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQgZGVsYXlNb3VudFVudGlsU2hvd24gaXMsXG4gICAgLy8gb25jZSB3ZSd2ZSByZW5kZXJlZCBvdXIgY2hpbGRyZW4gb25jZSwgXG4gICAgLy8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVtIGFnYWluIGFuZCB3YXN0ZSBhbGwgdGhhdCB3b3JrLlxuICAgIC8vIChJZiB5b3UgcmVhbGx5IG5lZWQgdGhpcyB5b3UgY2FuIGp1c3QgdW5tb3VudCB0aGUgZW50aXJlIHRyYW5zaXRpb24gaXRzZWxmKVxuICAgIGNvbnN0IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuID0gKHNob3cgfHwgIWRlbGF5TW91bnRVbnRpbFNob3duKTtcbiAgICBjb25zdCBoYXNSZW5kZXJlZENoaWxkcmVuID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCByZW5kZXJDaGlsZHJlbiA9IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuIHx8IGhhc1JlbmRlcmVkQ2hpbGRyZW4uY3VycmVudDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW4pXG4gICAgICAgICAgICBoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQgfHw9IHRydWU7XG4gICAgfSwgW2hhc1JlbmRlcmVkQ2hpbGRyZW4uY3VycmVudCA/IGZhbHNlIDogZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW5dKTtcblxuXG4gICAgY29uc3QgY2hpbGRyZW5Jc1Zub2RlID0gKGNoaWxkcmVuICYmIChjaGlsZHJlbiBhcyBWTm9kZSkudHlwZSAmJiAoY2hpbGRyZW4gYXMgVk5vZGUpLnByb3BzKTtcbiAgICBjb25zdCBmaW5hbFByb3BzID0gdXNlTWVyZ2VkUHJvcHM8RT4ocCwgcHJvcHNTdGFibGUsIG90aGVyUHJvcHMuY3VycmVudCwge1xuICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgIC4uLmNsYXNzTmFtZXMuY3VycmVudCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtleGl0VmlzaWJpbGl0eX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWlubGluZS1kaXJlY3Rpb24tJHtpbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWJsb2NrLWRpcmVjdGlvbi0ke2Jsb2NrRGlyZWN0aW9uID8/IFwidHRiXCJ9YFxuICAgICAgICBdLmpvaW4oXCIgXCIpLFxuICAgICAgICBzdHlsZTogY3NzUHJvcGVydGllcy5jdXJyZW50XG4gICAgfSwgY2hpbGRyZW5Jc1Zub2RlID8geyByZWY6IChjaGlsZHJlbiBhcyBWTm9kZSkucmVmLCAuLi4oY2hpbGRyZW4gYXMgVk5vZGUpLnByb3BzIH0gOiB7fSk7XG5cblxuXG4gICAgY29uc3QgcmVzZXRDb250ZXh0ID0gdXNlUmVmPFN3YXBwYWJsZUNvbnRleHRUeXBlPih7IGdldEFuaW1hdGVPbk1vdW50OiByZXR1cm5GYWxzZSB9KS5jdXJyZW50O1xuXG4gICAgbGV0IG1vZGlmaWVkQ2hpbGRyZW46IFZOb2RlO1xuXG4gICAgaWYgKGNoaWxkcmVuSXNWbm9kZSkge1xuICAgICAgICBtb2RpZmllZENoaWxkcmVuID0gPFN3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Jlc2V0Q29udGV4dH0+e2Nsb25lRWxlbWVudChjaGlsZHJlbiBhcyBWTm9kZSwgZmluYWxQcm9wcyl9PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW9kaWZpZWRDaGlsZHJlbiA9IDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyZXNldENvbnRleHR9PjxzcGFuIHsuLi5maW5hbFByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT59PntjaGlsZHJlbn08L3NwYW4+PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPlxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJDaGlsZHJlbiA/IG1vZGlmaWVkQ2hpbGRyZW4gOiBudWxsO1xufVxuXG5cblxuZnVuY3Rpb24gZm9yY2VSZWZsb3c8RSBleHRlbmRzIEhUTUxFbGVtZW50PihlOiBFKSB7XG5cbiAgICAvLyBUcnkgcmVhbGx5IGhhcmQgdG8gbWFrZSBzdXJlIHRoaXMgaXNuJ3Qgb3B0aW1pemVkIG91dCBieSBhbnl0aGluZy5cbiAgICAvLyBXZSBuZWVkIGl0IGZvciBpdHMgZG9jdW1lbnQgcmVmbG93IHNpZGUgZWZmZWN0LlxuICAgIGNvbnN0IHAgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLnN0eWxlLm9wYWNpdHk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IHA7XG4gICAgcmV0dXJuIGU7XG59XG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBtaW5pbXVtIG9yIG1heGltdW0gb3BhY2l0eSB2YWx1ZXMgdG8gdXNlIGZvciB0aGUgZmFkZSBlZmZlY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIGZhZGVQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wYWNpdHkgdG8gdXNlIHdoZW4gZmFkZWQgb3V0LlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmYWRlTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3BhY2l0eSB0byB1c2Ugd2hlbiBmYWRlZCBpbi5cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmFkZU1heDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBGYWRlIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNGYWRlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNaW4sIGZhZGVNYXggfSB9OiBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tZmFkZWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZhZGUtbWluYF06IChmYWRlTWluID8/IDApLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmFkZS1tYXhgXTogKGZhZGVNYXggPz8gMSksXHJcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZhZGVQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGYWRlIGVmZmVjdC5cclxuICogXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc3NpYmxlIHRvIHdyYXAgYW5vdGhlciB0cmFuc2l0aW9uIHdpdGggYDxGYWRlPmAsXHJcbiAqIHRoZXJlIHdpbGwgYmUgc29tZSBkdXBsaWNhdGUgY29kZSBydW4gYXMgdHdvIGA8VHJhbnNpdGlvbmFibGU+YCBjb21wb25lbnRzIGVuZCB1cCBvcGVyYXRpbmcgb24gdGhlIHNhbWUgZWxlbWVudC5cclxuICogSXQncyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgdG8gZWl0aGVyIHVzZSB0aGUgY29tcG9uZW50cyB0aGF0IGluY2x1ZGUgYSBjb21iaW5lZCBmYWRlIGVmZmVjdCxcclxuICogb3IganVzdCBkaXJlY3RseSBhIGA8VHJhbnNpdGlvbmFibGU+YCBvbiB5b3VyIG93bi5cclxuICogXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPih7IHJlZiwgLi4ucmVzdCB9LCB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBjbGlwUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE9yaWdpbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBjbGlwIGFyb3VuZCAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE9yaWdpbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBNaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gY2xpcCB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE1pbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzQ2xpcDxFIGV4dGVuZHMgRWxlbWVudD4oeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluQmxvY2ssIGNsaXBNaW5JbmxpbmUsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5CbG9jaywgY2xpcE9yaWdpbklubGluZSB9IH06IFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcGApLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtb3JpZ2luLWlubGluZWBdOiAoY2xpcE9yaWdpbklubGluZSA/PyBjbGlwT3JpZ2luID8/IDAuNSksXHJcbiAgICAgICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcC1vcmlnaW4tYmxvY2tgXTogKGNsaXBPcmlnaW5CbG9jayA/PyBjbGlwT3JpZ2luID8/IDApLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtbWluLWlubGluZWBdOiAoY2xpcE1pbklubGluZSA/PyBjbGlwTWluID8/IDEpLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtbWluLWJsb2NrYF06IChjbGlwTWluQmxvY2sgPz8gY2xpcE1pbiA/PyAwKSxcclxuICAgICAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIH1cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbGlwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RT4sIFwiY2xpcFBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDbGlwID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jaywgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDbGlwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcblxyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ2xpcCh7IGNsaXBQYXJhbWV0ZXJzOiB7IGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSlcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNDbGlwLCBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVycyB9IGZyb20gXCIuL2NsaXAuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENsaXBGYWRlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RT4sIFwiY2xpcFBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IENsaXBGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZGVsYXlNb3VudFVudGlsU2hvd24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGR1cmF0aW9uLCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgY2xpcE1pbiwgY2xpcE1pbkJsb2NrLCBjbGlwTWluSW5saW5lLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBPcmlnaW5JbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ2xpcEZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NsaXAoeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jayB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuXHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29sbGFwc2UgZWZmZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG5cclxuICAgIGNvbGxhcHNlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHNtYWxsZXN0IHNpemUgdGhlIGNvbXBvbmVudCBjb2xsYXBzZXMgdG8uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBtaW5CbG9ja1NpemU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgWm9vbSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqIFxyXG4gKiBJTVBPUlRBTlQ6IElmIHVzZWQgb3V0c2lkZSBvZiBhIGA8Q29sbGFwc2UgLz5gLCB5b3UgbXVzdCBpbmNsdWRlIHRoZSBgbWVhc3VyZWAgcHJvcCBvbiB0aGUgYDxUcmFuc2l0aW9uYWJsZT5gIHRoYXQgeW91IHVzZS5cclxuICogXHJcbiAqIEBleGFtcGxlIDxUcmFuc2l0aW9uYWJsZSBtZWFzdXJlIHsuLi51c2VDcmVhdGVDb2xsYXBzZVByb3BzKC4uLil9IC8+XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzQ29sbGFwc2U8RSBleHRlbmRzIEVsZW1lbnQ+KHsgY29sbGFwc2VQYXJhbWV0ZXJzOiB7IG1pbkJsb2NrU2l6ZSB9IH06IFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tY29sbGFwc2VgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jb2xsYXBzZS1taW4tYmxvY2tgXTogbWluQmxvY2tTaXplID8/IDBcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbGxhcHNlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEU+LCBcImNvbGxhcHNlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBDb2xsYXBzZSBlZmZlY3QuXHJcbiAqIFxyXG4gKiAqSW1wb3J0YW50KjogVGhpcyBjb21wb25lbnQgaXMgKm5vdCogZWZmaWNpZW50IGZvciB0aGUgYnJvd3NlciB0byBhbmltYXRlISBcclxuICogTWFrZSBzdXJlIHlvdSBkbyB0ZXN0aW5nIG9uIGxvd2VyIHBvd2VyIGRldmljZXMsIG9yIHByZWZlciBhIGxpZ2h0ZXJcclxuICogYWx0ZXJuYXRpdmUsIGxpa2UgYDxDbGlwPmAuXHJcbiAqIFxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2U8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHNob3csIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGR1cmF0aW9uLCBkZWxheU1vdW50VW50aWxTaG93biwgbWluQmxvY2tTaXplLCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDb2xsYXBzZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ29sbGFwc2UoeyBjb2xsYXBzZVBhcmFtZXRlcnM6IHsgbWluQmxvY2tTaXplIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0NvbGxhcHNlLCBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jb2xsYXBzZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2xsYXBzZUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEU+LCBcImNvbGxhcHNlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IENvbGxhcHNlRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2VGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzaG93LCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBmYWRlTWluLCBmYWRlTWF4LCBleGl0VmlzaWJpbGl0eSwgbWluQmxvY2tTaXplLCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ29sbGFwc2VGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDb2xsYXBzZSh7IGNvbGxhcHNlUGFyYW1ldGVyczogeyBtaW5CbG9ja1NpemUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmLCB1c2VMYXN0Tm9uTnVsbFZhbHVlIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XG5cbi8qKlxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgZGlyZWN0aW9uIGFuZCBleHRlbnQgb2YgdGhlIGZsaXAgZWZmZWN0LiBcbiAqIFZhbHVlcyBhcmUgcmVsYXRpdmUsIHdpdGggMSBvciAtMSBiZWluZyB0aGUgc2l6ZSBvZiB0aGUgY29tcG9uZW50IGluIHRoYXQgZGlyZWN0aW9uLlxuICogYDAuNWAsIGZvciBleGFtcGxlLCB3b3VsZCBmbGlwIHRvIHRoZSByaWdodCBieSA1MCUgb2YgdGhlIGVsZW1lbnQncyB3aWR0aC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNGbGlwUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XG4gICAgZmxpcFBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgYW5nbGUgKGluIGRlZ3JlZXMpIHRvIHJvdGF0ZSB0b3dhcmRzIG9uIHRoZSBpbmxpbmUgYXhpcyAoWCBheGlzIGZvciBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcEFuZ2xlSW5saW5lOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGFuZ2xlIChpbiBkZWdyZWVzKSB0byByb3RhdGUgdG93YXJkcyBvbiB0aGUgYmxvY2sgYXhpcyAoWCBheGlzIGZvciBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcEFuZ2xlQmxvY2s6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmNlIHRoaXMgaXMgYSAzRCBlZmZlY3QsIGEgcGVyc3BlY3RpdmUgdmFsdWUgaXMgbmVlZGVkLlxuICAgICAgICAgKiBAZGVmYXVsdCA4MDBweFxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcFBlcnNwZWN0aXZlOiBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBGbGlwIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0ZsaXA8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZmxpcFBhcmFtZXRlcnM6IHsgZmxpcEFuZ2xlQmxvY2ssIGZsaXBBbmdsZUlubGluZSwgZmxpcFBlcnNwZWN0aXZlIH0gfTogVXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RT4pIHtcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWZsaXBgLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZsaXAtYW5nbGUtaW5saW5lYF06IGAkeyh1c2VMYXN0Tm9uTnVsbFZhbHVlKGZsaXBBbmdsZUlubGluZSkgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mbGlwLWFuZ2xlLWJsb2NrYF06IGAkeyh1c2VMYXN0Tm9uTnVsbFZhbHVlKGZsaXBBbmdsZUJsb2NrKSA/PyAwKX1kZWdgLFxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXBlcnNwZWN0aXZlYF06IGAkeyhmbGlwUGVyc3BlY3RpdmUgPz8gODAwKX1weGBcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZsaXBQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGbGlwUGFyYW1ldGVyczxFPiwgXCJmbGlwUGFyYW1ldGVyc1wiPj4geyB9O1xuXG4vKipcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGbGlwIGVmZmVjdC5cbiAqIFxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYGZsaXBJbmxpbmVgIGFuZCBgZmxpcEJsb2NrYCxcbiAqIHdpdGggYDFgIGJlaW5nIGAxMDAlYCBvZiB0aGUgZWxlbWVudCdzIHdpZHRoIG9yIGhlaWdodC5cbiAqIFxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcbiAqIGV4Y2x1c2l2aXR5S2V5IGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgIFxuICogKGBmbGlwSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLikgXG4gKiBcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxuICovXG5leHBvcnQgY29uc3QgRmxpcCA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRmxpcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBBbmdsZUJsb2NrLCBmbGlwUGVyc3BlY3RpdmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IEZsaXBQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3csXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGVhc2luZ0luLFxuICAgICAgICAgICAgZWFzaW5nT3V0LFxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmxpcCh7IGZsaXBQYXJhbWV0ZXJzOiB7IGZsaXBBbmdsZUJsb2NrLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBQZXJzcGVjdGl2ZSB9IH0pLFxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXG4gICAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cbiAgICB9KTtcbn0pKTtcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiwgdXNlTGFzdE5vbk51bGxWYWx1ZSB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBhbmQgZXh0ZW50IG9mIHRoZSBzbGlkZSBlZmZlY3QuIFxyXG4gKiBWYWx1ZXMgYXJlIHJlbGF0aXZlLCB3aXRoIDEgb3IgLTEgYmVpbmcgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGF0IGRpcmVjdGlvbi5cclxuICogYDAuNWAsIGZvciBleGFtcGxlLCB3b3VsZCBzbGlkZSB0byB0aGUgcmlnaHQgYnkgNTAlIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBzbGlkZVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHNsaWRlIHRvL2Zyb20gKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2xpZGVUYXJnZXRJbmxpbmU6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gc2xpZGUgdG8vZnJvbSAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzbGlkZVRhcmdldEJsb2NrOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFNsaWRlIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNTbGlkZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2sgfSB9OiBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIHNsaWRlVGFyZ2V0SW5saW5lID0gdXNlTGFzdE5vbk51bGxWYWx1ZShzbGlkZVRhcmdldElubGluZSk7XHJcbiAgICBzbGlkZVRhcmdldEJsb2NrID0gdXNlTGFzdE5vbk51bGxWYWx1ZShzbGlkZVRhcmdldEJsb2NrKTtcclxuXHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1zbGlkZWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXNsaWRlLXRhcmdldC1pbmxpbmVgXTogYCR7KHNsaWRlVGFyZ2V0SW5saW5lID8/IDApfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1zbGlkZS10YXJnZXQtYmxvY2tgXTogYCR7KHNsaWRlVGFyZ2V0QmxvY2sgPz8gMCl9YFxyXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgU2xpZGUgZWZmZWN0LlxyXG4gKiBcclxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYHNsaWRlSW5saW5lYCBhbmQgYHNsaWRlQmxvY2tgLFxyXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXHJcbiAqIFxyXG4gKiBBIHZhbHVlIG9mIGAwYCBpcyBoYW5kbGVkIHNwZWNpYWxseSwgZWZmZWN0aXZlbHkgbWVhbmluZyBcInVzZSB0aGUgbGFzdCBub24temVybyB2YWx1ZVwiLFxyXG4gKiB3aGljaCBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYCBcclxuICogKGBzbGlkZUlubGluZT17aW5kZXggLSBzZWxlY3RlZEluZGV4fWAgb3Igc2ltaWxhci4pIFxyXG4gKiBcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgb25WaXNpYmlsaXR5Q2hhbmdlLCBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBkZWxheU1vdW50VW50aWxTaG93biwgLi4ucmVzdCB9OiBTbGlkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1NsaWRlLCBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9zbGlkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIG9yaWdpbiwgbWluaW11bSBzaXplLCBhbmQgZGlyZWN0aW9uIG9mIHRoZSB6b29tIGVmZmVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgem9vbVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gb3V0IG9mL2ludG8gKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU9yaWdpbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvIChYIGNvbXBvbmVudClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tT3JpZ2luSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gb3V0IG9mL2ludG8gKFkgY29tcG9uZW50KVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21PcmlnaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIHNocmluayB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU1pbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21NaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNab29tPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrIH0gfTogVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS16b29tYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1vcmlnaW4taW5saW5lYF06IGAkeyh6b29tT3JpZ2luSW5saW5lID8/IHpvb21PcmlnaW4gPz8gMC41KX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1vcmlnaW4tYmxvY2tgXTogYCR7KHpvb21PcmlnaW5CbG9jayA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tbWluLWlubGluZWBdOiBgJHsoem9vbU1pbklubGluZSA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW1pbi1ibG9ja2BdOiBgJHsoem9vbU1pbkJsb2NrID8/IHpvb21NaW4gPz8gMCl9YCxcclxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab29tUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgWm9vbSBlZmZlY3QuXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbUZhZGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWm9vbSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogWm9vbVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG59KSk7XHJcblxyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1NsaWRlLCBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9zbGlkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1pvb20sIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vem9vbS5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVpvb21Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNsaWRlWm9vbSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogU2xpZGVab29tUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVab29tRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZVpvb21GYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZVpvb21GYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUsIGZhZGVNYXgsIGZhZGVNaW4sIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogU2xpZGVab29tRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9vbUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBab29tRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFpvb21GYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IG9wdGlvbnMsIEZyYWdtZW50LCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdERldlRvb2xzKCkge1xuXHRpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19QUkVBQ1RfREVWVE9PTFNfXykge1xuXHRcdHdpbmRvdy5fX1BSRUFDVF9ERVZUT09MU19fLmF0dGFjaFByZWFjdCgnMTAuMTMuMScsIG9wdGlvbnMsIHtcblx0XHRcdEZyYWdtZW50LFxuXHRcdFx0Q29tcG9uZW50XG5cdFx0fSk7XG5cdH1cbn1cbiIsImNvbnN0IFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubGV0IGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBoaXN0b3J5IG9mIHdoaWNoIHByb3AgdHlwZSB3YXJuaW5ncyBoYXZlIGJlZW4gbG9nZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRQcm9wV2FybmluZ3MoKSB7XG5cdGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcHJvcC10eXBlcy9ibG9iL21hc3Rlci9jaGVja1Byb3BUeXBlcy5qc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMoXG5cdHR5cGVTcGVjcyxcblx0dmFsdWVzLFxuXHRsb2NhdGlvbixcblx0Y29tcG9uZW50TmFtZSxcblx0Z2V0U3RhY2tcbikge1xuXHRPYmplY3Qua2V5cyh0eXBlU3BlY3MpLmZvckVhY2godHlwZVNwZWNOYW1lID0+IHtcblx0XHRsZXQgZXJyb3I7XG5cdFx0dHJ5IHtcblx0XHRcdGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0oXG5cdFx0XHRcdHZhbHVlcyxcblx0XHRcdFx0dHlwZVNwZWNOYW1lLFxuXHRcdFx0XHRjb21wb25lbnROYW1lLFxuXHRcdFx0XHRsb2NhdGlvbixcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0UmVhY3RQcm9wVHlwZXNTZWNyZXRcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZXJyb3IgPSBlO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0XHRcdGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRgRmFpbGVkICR7bG9jYXRpb259IHR5cGU6ICR7ZXJyb3IubWVzc2FnZX0keyhnZXRTdGFjayAmJlxuXHRcdFx0XHRcdGBcXG4ke2dldFN0YWNrKCl9YCkgfHxcblx0XHRcdFx0XHQnJ31gXG5cdFx0XHQpO1xuXHRcdH1cblx0fSk7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogR2V0IGh1bWFuIHJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC9kb20gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUodm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG5cdFx0cmV0dXJuICdGcmFnbWVudCc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiB2bm9kZS50eXBlLmRpc3BsYXlOYW1lIHx8IHZub2RlLnR5cGUubmFtZTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB2bm9kZS50eXBlO1xuXHR9XG5cblx0cmV0dXJuICcjdGV4dCc7XG59XG5cbi8qKlxuICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgYHZub2RlYCBhbmQgcHJpbnQgaXRcbiAqIGluIGRlYnVnIG1lc3NhZ2VzLlxuICovXG5sZXQgcmVuZGVyU3RhY2sgPSBbXTtcblxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVycy4gQW4gb3duZXIgZGVzY3JpYmVzIGEgY29tcG9uZW50XG4gKiB3aGljaCB3YXMgcmVzcG9uc2libGUgdG8gcmVuZGVyIGEgc3BlY2lmaWMgYHZub2RlYC4gVGhpcyBleGNsdWRlXG4gKiBjaGlsZHJlbiB0aGF0IGFyZSBwYXNzZWQgdmlhIGBwcm9wcy5jaGlsZHJlbmAsIGJlY2F1c2UgdGhleSBiZWxvbmdcbiAqIHRvIHRoZSBwYXJlbnQgb3duZXIuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBGb28gPSBwcm9wcyA9PiA8ZGl2Pntwcm9wcy5jaGlsZHJlbn08L2Rpdj4gLy8gZGl2J3Mgb3duZXIgaXMgRm9vXG4gKiBjb25zdCBCYXIgPSBwcm9wcyA9PiB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvbz48c3BhbiAvPjwvRm9vPiAvLyBGb28ncyBvd25lciBpcyBCYXIsIHNwYW4ncyBvd25lciBpcyBCYXJcbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogTm90ZTogQSBgdm5vZGVgIG1heSBiZSBob2lzdGVkIHRvIHRoZSByb290IHNjb3BlIGR1ZSB0byBjb21waWxlclxuICogb3B0aW1penRpb25zLiBJbiB0aGVzZSBjYXNlcyB0aGUgYF9vd25lcmAgd2lsbCBiZSBkaWZmZXJlbnQuXG4gKi9cbmxldCBvd25lclN0YWNrID0gW107XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgYHZub2RlYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRWTm9kZSgpIHtcblx0cmV0dXJuIHJlbmRlclN0YWNrLmxlbmd0aCA+IDAgPyByZW5kZXJTdGFja1tyZW5kZXJTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG59XG5cbi8qKlxuICogSWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIGBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gtc291cmNlYFxuICogc29tZXdoZXJlIGluIGhpcyB0b29sIGNoYWluIHdlIGNhbid0IHByaW50IHRoZSBmaWxlbmFtZSBhbmQgc291cmNlXG4gKiBsb2NhdGlvbiBvZiBhIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIGp1c3Qgb21pdCB0aGF0LCBidXQgd2UnbGxcbiAqIHByaW50IGEgaGVscGZ1bCBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLCBub3RpZnlpbmcgdGhlIHVzZXIgb2YgaXQuXG4gKi9cbmxldCBoYXNCYWJlbFBsdWdpbiA9IGZhbHNlO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYHZub2RlYCBpcyBhIHBvc3NpYmxlIG93bmVyLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gaXNQb3NzaWJsZU93bmVyKHZub2RlKSB7XG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmIHZub2RlLnR5cGUgIT0gRnJhZ21lbnQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb21wb25lbnQgc3RhY2sgdGhhdCB3YXMgY2FwdHVyZWQgdXAgdG8gdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJTdGFjayh2bm9kZSkge1xuXHRjb25zdCBzdGFjayA9IFt2bm9kZV07XG5cdGxldCBuZXh0ID0gdm5vZGU7XG5cdHdoaWxlIChuZXh0Ll9vd25lciAhPSBudWxsKSB7XG5cdFx0c3RhY2sucHVzaChuZXh0Ll9vd25lcik7XG5cdFx0bmV4dCA9IG5leHQuX293bmVyO1xuXHR9XG5cblx0cmV0dXJuIHN0YWNrLnJlZHVjZSgoYWNjLCBvd25lcikgPT4ge1xuXHRcdGFjYyArPSBgICBpbiAke2dldERpc3BsYXlOYW1lKG93bmVyKX1gO1xuXG5cdFx0Y29uc3Qgc291cmNlID0gb3duZXIuX19zb3VyY2U7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0YWNjICs9IGAgKGF0ICR7c291cmNlLmZpbGVOYW1lfToke3NvdXJjZS5saW5lTnVtYmVyfSlgO1xuXHRcdH0gZWxzZSBpZiAoIWhhc0JhYmVsUGx1Z2luKSB7XG5cdFx0XHRoYXNCYWJlbFBsdWdpbiA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdBZGQgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcmVhY3QtanN4LXNvdXJjZSB0byBnZXQgYSBtb3JlIGRldGFpbGVkIGNvbXBvbmVudCBzdGFjay4gTm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IGFkZCBpdCB0byBwcm9kdWN0aW9uIGJ1aWxkcyBvZiB5b3VyIEFwcCBmb3IgYnVuZGxlIHNpemUgcmVhc29ucy4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoYWNjICs9ICdcXG4nKTtcblx0fSwgJycpO1xufVxuXG4vKipcbiAqIFNldHVwIGNvZGUgdG8gY2FwdHVyZSB0aGUgY29tcG9uZW50IHRyYWNlIHdoaWxlIHJlbmRlcmluZy4gTm90ZSB0aGF0XG4gKiB3ZSBjYW5ub3Qgc2ltcGx5IHRyYXZlcnNlIGB2bm9kZS5fcGFyZW50YCB1cHdhcmRzLCBiZWNhdXNlIHdlIGhhdmUgc29tZVxuICogZGVidWcgbWVzc2FnZXMgZm9yIGB0aGlzLnNldFN0YXRlYCB3aGVyZSB0aGUgYHZub2RlYCBpcyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQ29tcG9uZW50U3RhY2soKSB7XG5cdGxldCBvbGREaWZmID0gb3B0aW9ucy5fZGlmZjtcblx0bGV0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuXHRsZXQgb2xkUm9vdCA9IG9wdGlvbnMuX3Jvb3Q7XG5cdGxldCBvbGRWTm9kZSA9IG9wdGlvbnMudm5vZGU7XG5cdGxldCBvbGRSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5cblx0b3B0aW9ucy5kaWZmZWQgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdG93bmVyU3RhY2sucG9wKCk7XG5cdFx0fVxuXHRcdHJlbmRlclN0YWNrLnBvcCgpO1xuXHRcdGlmIChvbGREaWZmZWQpIG9sZERpZmZlZCh2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0XHRpZiAoaXNQb3NzaWJsZU93bmVyKHZub2RlKSkge1xuXHRcdFx0cmVuZGVyU3RhY2sucHVzaCh2bm9kZSk7XG5cdFx0fVxuXHRcdGlmIChvbGREaWZmKSBvbGREaWZmKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9yb290ID0gKHZub2RlLCBwYXJlbnQpID0+IHtcblx0XHRvd25lclN0YWNrID0gW107XG5cdFx0aWYgKG9sZFJvb3QpIG9sZFJvb3Qodm5vZGUsIHBhcmVudCk7XG5cdH07XG5cblx0b3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0XHR2bm9kZS5fb3duZXIgPVxuXHRcdFx0b3duZXJTdGFjay5sZW5ndGggPiAwID8gb3duZXJTdGFja1tvd25lclN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcblx0XHRpZiAob2xkVk5vZGUpIG9sZFZOb2RlKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdG93bmVyU3RhY2sucHVzaCh2bm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFJlbmRlcikgb2xkUmVuZGVyKHZub2RlKTtcblx0fTtcbn1cbiIsImltcG9ydCB7IGNoZWNrUHJvcFR5cGVzIH0gZnJvbSAnLi9jaGVjay1wcm9wcyc7XG5pbXBvcnQgeyBvcHRpb25zLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcblx0RUxFTUVOVF9OT0RFLFxuXHRET0NVTUVOVF9OT0RFLFxuXHRET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdGdldE93bmVyU3RhY2ssXG5cdHNldHVwQ29tcG9uZW50U3RhY2ssXG5cdGdldEN1cnJlbnRWTm9kZSxcblx0Z2V0RGlzcGxheU5hbWVcbn0gZnJvbSAnLi9jb21wb25lbnQtc3RhY2snO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgaXNXZWFrTWFwU3VwcG9ydGVkID0gdHlwZW9mIFdlYWtNYXAgPT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQocGFyZW50KSB7XG5cdGlmICghcGFyZW50KSByZXR1cm4ge307XG5cdGlmICh0eXBlb2YgcGFyZW50LnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBnZXRDbG9zZXN0RG9tTm9kZVBhcmVudChwYXJlbnQuX3BhcmVudCk7XG5cdH1cblx0cmV0dXJuIHBhcmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXREZWJ1ZygpIHtcblx0c2V0dXBDb21wb25lbnRTdGFjaygpO1xuXG5cdGxldCBob29rc0FsbG93ZWQgPSBmYWxzZTtcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdGxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcblx0bGV0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuXHRsZXQgb2xkVm5vZGUgPSBvcHRpb25zLnZub2RlO1xuXHRsZXQgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5cdGxldCBvbGRSb290ID0gb3B0aW9ucy5fcm9vdDtcblx0bGV0IG9sZEhvb2sgPSBvcHRpb25zLl9ob29rO1xuXHRjb25zdCB3YXJuZWRDb21wb25lbnRzID0gIWlzV2Vha01hcFN1cHBvcnRlZFxuXHRcdD8gbnVsbFxuXHRcdDoge1xuXHRcdFx0XHR1c2VFZmZlY3Q6IG5ldyBXZWFrTWFwKCksXG5cdFx0XHRcdHVzZUxheW91dEVmZmVjdDogbmV3IFdlYWtNYXAoKSxcblx0XHRcdFx0bGF6eVByb3BUeXBlczogbmV3IFdlYWtNYXAoKVxuXHRcdCAgfTtcblx0Y29uc3QgZGVwcmVjYXRpb25zID0gW107XG5cblx0b3B0aW9ucy5fY2F0Y2hFcnJvciA9IChlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pID0+IHtcblx0XHRsZXQgY29tcG9uZW50ID0gdm5vZGUgJiYgdm5vZGUuX2NvbXBvbmVudDtcblx0XHRpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBlcnJvci50aGVuID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnN0IHByb21pc2UgPSBlcnJvcjtcblx0XHRcdGVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRgTWlzc2luZyBTdXNwZW5zZS4gVGhlIHRocm93aW5nIGNvbXBvbmVudCB3YXM6ICR7Z2V0RGlzcGxheU5hbWUodm5vZGUpfWBcblx0XHRcdCk7XG5cblx0XHRcdGxldCBwYXJlbnQgPSB2bm9kZTtcblx0XHRcdGZvciAoOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQuX2NvbXBvbmVudCAmJiBwYXJlbnQuX2NvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBwcm9taXNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGhhdmVuJ3QgcmVjb3ZlcmVkIGFuZCB3ZSBrbm93IGF0IHRoaXMgcG9pbnQgdGhhdCB0aGVyZSBpcyBub1xuXHRcdFx0Ly8gU3VzcGVuc2UgY29tcG9uZW50IGhpZ2hlciB1cCBpbiB0aGUgdHJlZVxuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGVycm9ySW5mbyA9IGVycm9ySW5mbyB8fCB7fTtcblx0XHRcdGVycm9ySW5mby5jb21wb25lbnRTdGFjayA9IGdldE93bmVyU3RhY2sodm5vZGUpO1xuXHRcdFx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xuXG5cdFx0XHQvLyB3aGVuIGFuIGVycm9yIHdhcyBoYW5kbGVkIGJ5IGFuIEVycm9yQm91bmRhcnkgd2Ugd2lsbCBub25ldGhlbGVzcyBlbWl0IGFuIGVycm9yXG5cdFx0XHQvLyBldmVudCBvbiB0aGUgd2luZG93IG9iamVjdC4gVGhpcyBpcyB0byBtYWtlIHVwIGZvciByZWFjdCBjb21wYXRpYmlsaXR5IGluIGRldiBtb2RlXG5cdFx0XHQvLyBhbmQgdGh1cyBtYWtlIHRoZSBOZXh0LmpzIGRldiBvdmVybGF5IHdvcmsuXG5cdFx0XHRpZiAodHlwZW9mIGVycm9yLnRoZW4gIT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH07XG5cblx0b3B0aW9ucy5fcm9vdCA9ICh2bm9kZSwgcGFyZW50Tm9kZSkgPT4ge1xuXHRcdGlmICghcGFyZW50Tm9kZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnVW5kZWZpbmVkIHBhcmVudCBwYXNzZWQgdG8gcmVuZGVyKCksIHRoaXMgaXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG4nICtcblx0XHRcdFx0XHQnQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYXZhaWxhYmxlIGluIHRoZSBET00vaGFzIHRoZSBjb3JyZWN0IGlkLidcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGlzVmFsaWQ7XG5cdFx0c3dpdGNoIChwYXJlbnROb2RlLm5vZGVUeXBlKSB7XG5cdFx0XHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHRcdGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcblx0XHRcdGNhc2UgRE9DVU1FTlRfTk9ERTpcblx0XHRcdFx0aXNWYWxpZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghaXNWYWxpZCkge1xuXHRcdFx0bGV0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZSh2bm9kZSk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBFeHBlY3RlZCBhIHZhbGlkIEhUTUwgbm9kZSBhcyBhIHNlY29uZCBhcmd1bWVudCB0byByZW5kZXIuXHRSZWNlaXZlZCAke3BhcmVudE5vZGV9IGluc3RlYWQ6IHJlbmRlcig8JHtjb21wb25lbnROYW1lfSAvPiwgJHtwYXJlbnROb2RlfSk7YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkUm9vdCkgb2xkUm9vdCh2bm9kZSwgcGFyZW50Tm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0XHRsZXQgeyB0eXBlLCBfcGFyZW50OiBwYXJlbnQgfSA9IHZub2RlO1xuXHRcdGxldCBwYXJlbnRWTm9kZSA9IGdldENsb3Nlc3REb21Ob2RlUGFyZW50KHBhcmVudCk7XG5cblx0XHRob29rc0FsbG93ZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnVW5kZWZpbmVkIGNvbXBvbmVudCBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCgpXFxuXFxuJyArXG5cdFx0XHRcdFx0J1lvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBvciBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMnICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICh0eXBlLl9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHR5cGUuX2RvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRgSW52YWxpZCB0eXBlIHBhc3NlZCB0byBjcmVhdGVFbGVtZW50KCk6ICR7dHlwZX1cXG5cXG5gICtcblx0XHRcdFx0XHRcdCdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgSlNYIGxpdGVyYWwgYXMgSlNYIHR3aWNlP1xcblxcbicgK1xuXHRcdFx0XHRcdFx0YCAgbGV0IE15JHtnZXREaXNwbGF5TmFtZSh2bm9kZSl9ID0gJHtzZXJpYWxpemVWTm9kZSh0eXBlKX07XFxuYCArXG5cdFx0XHRcdFx0XHRgICBsZXQgdm5vZGUgPSA8TXkke2dldERpc3BsYXlOYW1lKHZub2RlKX0gLz47XFxuXFxuYCArXG5cdFx0XHRcdFx0XHQnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiB5b3UgZXhwb3J0IGEgSlNYIGxpdGVyYWwgYW5kIG5vdCB0aGUgY29tcG9uZW50LicgK1xuXHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdJbnZhbGlkIHR5cGUgcGFzc2VkIHRvIGNyZWF0ZUVsZW1lbnQoKTogJyArXG5cdFx0XHRcdFx0KEFycmF5LmlzQXJyYXkodHlwZSkgPyAnYXJyYXknIDogdHlwZSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0KHR5cGUgPT09ICd0aGVhZCcgfHwgdHlwZSA9PT0gJ3Rmb290JyB8fCB0eXBlID09PSAndGJvZHknKSAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RhYmxlJ1xuXHRcdCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRoZWFkL3Rib2R5L3Rmb290PiBzaG91bGQgaGF2ZSBhIDx0YWJsZT4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dHlwZSA9PT0gJ3RyJyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RoZWFkJyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3Rmb290JyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3Rib2R5JyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RhYmxlJ1xuXHRcdCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRyPiBzaG91bGQgaGF2ZSBhIDx0aGVhZC90Ym9keS90Zm9vdC90YWJsZT4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZCcgJiYgcGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RyJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRkPiBzaG91bGQgaGF2ZSBhIDx0cj4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0aCcgJiYgcGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RyJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRoPiBzaG91bGQgaGF2ZSBhIDx0cj4uJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdHZub2RlLnJlZiAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHR0eXBlb2Ygdm5vZGUucmVmICE9ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiB2bm9kZS5yZWYgIT0gJ29iamVjdCcgJiZcblx0XHRcdCEoJyQkdHlwZW9mJyBpbiB2bm9kZSkgLy8gYWxsb3cgc3RyaW5nIHJlZnMgd2hlbiBwcmVhY3QtY29tcGF0IGlzIGluc3RhbGxlZFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgQ29tcG9uZW50J3MgXCJyZWZcIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IGNyZWF0ZWQgYCArXG5cdFx0XHRcdFx0YGJ5IGNyZWF0ZVJlZigpLCBidXQgZ290IFske3R5cGVvZiB2bm9kZS5yZWZ9XSBpbnN0ZWFkXFxuYCArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdm5vZGUucHJvcHMpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGtleVswXSA9PT0gJ28nICYmXG5cdFx0XHRcdFx0a2V5WzFdID09PSAnbicgJiZcblx0XHRcdFx0XHR0eXBlb2Ygdm5vZGUucHJvcHNba2V5XSAhPSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdFx0dm5vZGUucHJvcHNba2V5XSAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdGBDb21wb25lbnQncyBcIiR7a2V5fVwiIHByb3BlcnR5IHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBgICtcblx0XHRcdFx0XHRcdFx0YGJ1dCBnb3QgWyR7dHlwZW9mIHZub2RlLnByb3BzW2tleV19XSBpbnN0ZWFkXFxuYCArXG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgcHJvcC10eXBlcyBpZiBhdmFpbGFibGVcblx0XHRpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB2bm9kZS50eXBlLnByb3BUeXBlcykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR2bm9kZS50eXBlLmRpc3BsYXlOYW1lID09PSAnTGF6eScgJiZcblx0XHRcdFx0d2FybmVkQ29tcG9uZW50cyAmJlxuXHRcdFx0XHQhd2FybmVkQ29tcG9uZW50cy5sYXp5UHJvcFR5cGVzLmhhcyh2bm9kZS50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IG0gPVxuXHRcdFx0XHRcdCdQcm9wVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gbGF6eSgpLiBVc2UgcHJvcFR5cGVzIG9uIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpdHNlbGYuICc7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgbGF6eVZOb2RlID0gdm5vZGUudHlwZSgpO1xuXHRcdFx0XHRcdHdhcm5lZENvbXBvbmVudHMubGF6eVByb3BUeXBlcy5zZXQodm5vZGUudHlwZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0bSArIGBDb21wb25lbnQgd3JhcHBlZCBpbiBsYXp5KCkgaXMgJHtnZXREaXNwbGF5TmFtZShsYXp5Vk5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGNhdGNoIChwcm9taXNlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0bSArIFwiV2Ugd2lsbCBsb2cgdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgbmFtZSBvbmNlIGl0IGlzIGxvYWRlZC5cIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHZhbHVlcyA9IHZub2RlLnByb3BzO1xuXHRcdFx0aWYgKHZub2RlLnR5cGUuX2ZvcndhcmRlZCkge1xuXHRcdFx0XHR2YWx1ZXMgPSBhc3NpZ24oe30sIHZhbHVlcyk7XG5cdFx0XHRcdGRlbGV0ZSB2YWx1ZXMucmVmO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja1Byb3BUeXBlcyhcblx0XHRcdFx0dm5vZGUudHlwZS5wcm9wVHlwZXMsXG5cdFx0XHRcdHZhbHVlcyxcblx0XHRcdFx0J3Byb3AnLFxuXHRcdFx0XHRnZXREaXNwbGF5TmFtZSh2bm9kZSksXG5cdFx0XHRcdCgpID0+IGdldE93bmVyU3RhY2sodm5vZGUpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9ob29rID0gKGNvbXAsIGluZGV4LCB0eXBlKSA9PiB7XG5cdFx0aWYgKCFjb21wIHx8ICFob29rc0FsbG93ZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSG9vayBjYW4gb25seSBiZSBpbnZva2VkIGZyb20gcmVuZGVyIG1ldGhvZHMuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZEhvb2spIG9sZEhvb2soY29tcCwgaW5kZXgsIHR5cGUpO1xuXHR9O1xuXG5cdC8vIElkZWFsbHkgd2UnZCB3YW50IHRvIHByaW50IGEgd2FybmluZyBvbmNlIHBlciBjb21wb25lbnQsIGJ1dCB3ZVxuXHQvLyBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgdm5vZGUgdGhhdCB0cmlnZ2VyZWQgaXQgaGVyZS4gQXMgYVxuXHQvLyBjb21wcm9taXNlIGFuZCB0byBhdm9pZCBmbG9vZGluZyB0aGUgY29uc29sZSB3aXRoIHdhcm5pbmdzIHdlXG5cdC8vIHByaW50IGVhY2ggZGVwcmVjYXRpb24gd2FybmluZyBvbmx5IG9uY2UuXG5cdGNvbnN0IHdhcm4gPSAocHJvcGVydHksIG1lc3NhZ2UpID0+ICh7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qga2V5ID0gJ2dldCcgKyBwcm9wZXJ0eSArIG1lc3NhZ2U7XG5cdFx0XHRpZiAoZGVwcmVjYXRpb25zICYmIGRlcHJlY2F0aW9ucy5pbmRleE9mKGtleSkgPCAwKSB7XG5cdFx0XHRcdGRlcHJlY2F0aW9ucy5wdXNoKGtleSk7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgZ2V0dGluZyB2bm9kZS4ke3Byb3BlcnR5fSBpcyBkZXByZWNhdGVkLCAke21lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXQoKSB7XG5cdFx0XHRjb25zdCBrZXkgPSAnc2V0JyArIHByb3BlcnR5ICsgbWVzc2FnZTtcblx0XHRcdGlmIChkZXByZWNhdGlvbnMgJiYgZGVwcmVjYXRpb25zLmluZGV4T2Yoa2V5KSA8IDApIHtcblx0XHRcdFx0ZGVwcmVjYXRpb25zLnB1c2goa2V5KTtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBzZXR0aW5nIHZub2RlLiR7cHJvcGVydHl9IGlzIG5vdCBhbGxvd2VkLCAke21lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRjb25zdCBkZXByZWNhdGVkQXR0cmlidXRlcyA9IHtcblx0XHRub2RlTmFtZTogd2Fybignbm9kZU5hbWUnLCAndXNlIHZub2RlLnR5cGUnKSxcblx0XHRhdHRyaWJ1dGVzOiB3YXJuKCdhdHRyaWJ1dGVzJywgJ3VzZSB2bm9kZS5wcm9wcycpLFxuXHRcdGNoaWxkcmVuOiB3YXJuKCdjaGlsZHJlbicsICd1c2Ugdm5vZGUucHJvcHMuY2hpbGRyZW4nKVxuXHR9O1xuXG5cdGNvbnN0IGRlcHJlY2F0ZWRQcm90byA9IE9iamVjdC5jcmVhdGUoe30sIGRlcHJlY2F0ZWRBdHRyaWJ1dGVzKTtcblxuXHRvcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRcdGNvbnN0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdFx0aWYgKFxuXHRcdFx0dm5vZGUudHlwZSAhPT0gbnVsbCAmJlxuXHRcdFx0cHJvcHMgIT0gbnVsbCAmJlxuXHRcdFx0KCdfX3NvdXJjZScgaW4gcHJvcHMgfHwgJ19fc2VsZicgaW4gcHJvcHMpXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBuZXdQcm9wcyA9ICh2bm9kZS5wcm9wcyA9IHt9KTtcblx0XHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdFx0Y29uc3QgdiA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAoaSA9PT0gJ19fc291cmNlJykgdm5vZGUuX19zb3VyY2UgPSB2O1xuXHRcdFx0XHRlbHNlIGlmIChpID09PSAnX19zZWxmJykgdm5vZGUuX19zZWxmID0gdjtcblx0XHRcdFx0ZWxzZSBuZXdQcm9wc1tpXSA9IHY7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdFx0dm5vZGUuX19wcm90b19fID0gZGVwcmVjYXRlZFByb3RvO1xuXHRcdGlmIChvbGRWbm9kZSkgb2xkVm5vZGUodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRcdC8vIENoZWNrIGlmIHRoZSB1c2VyIHBhc3NlZCBwbGFpbiBvYmplY3RzIGFzIGNoaWxkcmVuLiBOb3RlIHRoYXQgd2UgY2Fubm90XG5cdFx0Ly8gbW92ZSB0aGlzIGNoZWNrIGludG8gYG9wdGlvbnMudm5vZGVgIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gcmVjZWl2ZVxuXHRcdC8vIGNoaWxkcmVuIGluIGFueSBzaGFwZSB0aGV5IHdhbnQgKGUuZy5cblx0XHQvLyBgPE15SlNPTkZvcm1hdHRlcj57eyBmb286IDEyMywgYmFyOiBcImFiY1wiIH19PC9NeUpTT05Gb3JtYXR0ZXI+YCkuXG5cdFx0Ly8gUHV0dGluZyB0aGlzIGNoZWNrIGluIGBvcHRpb25zLmRpZmZlZGAgZW5zdXJlcyB0aGF0XG5cdFx0Ly8gYHZub2RlLl9jaGlsZHJlbmAgaXMgc2V0IGFuZCB0aGF0IHdlIG9ubHkgdmFsaWRhdGUgdGhlIGNoaWxkcmVuXG5cdFx0Ly8gdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHRcdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQgJiYgY2hpbGQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkKS5qb2luKCcsJyk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0YE9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIGNoaWxkLiBFbmNvdW50ZXJlZCBhbiBvYmplY3Qgd2l0aCB0aGUga2V5cyB7JHtrZXlzfX0uYCArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRob29rc0FsbG93ZWQgPSBmYWxzZTtcblxuXHRcdGlmIChvbGREaWZmZWQpIG9sZERpZmZlZCh2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2NoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoIWNoaWxkIHx8IGNoaWxkLmtleSA9PSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG5cdFx0XHRcdGlmIChrZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0J0ZvbGxvd2luZyBjb21wb25lbnQgaGFzIHR3byBvciBtb3JlIGNoaWxkcmVuIHdpdGggdGhlICcgK1xuXHRcdFx0XHRcdFx0XHRgc2FtZSBrZXkgYXR0cmlidXRlOiBcIiR7a2V5fVwiLiBUaGlzIG1heSBjYXVzZSBnbGl0Y2hlcyBhbmQgbWlzYmVoYXZpb3IgYCArXG5cdFx0XHRcdFx0XHRcdCdpbiByZW5kZXJpbmcgcHJvY2Vzcy4gQ29tcG9uZW50OiBcXG5cXG4nICtcblx0XHRcdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBCcmVhayBlYXJseSB0byBub3Qgc3BhbSB0aGUgY29uc29sZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBzZXRTdGF0ZSA9IENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGU7XG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUgPT0gbnVsbCkge1xuXHRcdC8vIGB0aGlzLl92bm9kZWAgd2lsbCBiZSBgbnVsbGAgZHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudC4gQnV0IGl0XG5cdFx0Ly8gaXMgcGVyZmVjdGx5IHZhbGlkIHRvIGNhbGwgYHNldFN0YXRlYCBkdXJpbmcgY1dNLiBTbyB3ZVxuXHRcdC8vIG5lZWQgYW4gYWRkaXRpb25hbCBjaGVjayB0byB2ZXJpZnkgdGhhdCB3ZSBhcmUgZGVhbGluZyB3aXRoIGFcblx0XHQvLyBjYWxsIGluc2lkZSBjb25zdHJ1Y3Rvci5cblx0XHRpZiAodGhpcy5zdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdGBDYWxsaW5nIFwidGhpcy5zZXRTdGF0ZVwiIGluc2lkZSB0aGUgY29uc3RydWN0b3Igb2YgYSBjb21wb25lbnQgaXMgYSBgICtcblx0XHRcdFx0XHRgbm8tb3AgYW5kIG1pZ2h0IGJlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIHNldCBgICtcblx0XHRcdFx0XHRgXCJ0aGlzLnN0YXRlID0ge31cIiBkaXJlY3RseS5cXG5cXG4ke2dldE93bmVyU3RhY2soZ2V0Q3VycmVudFZOb2RlKCkpfWBcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNldFN0YXRlLmNhbGwodGhpcywgdXBkYXRlLCBjYWxsYmFjayk7XG59O1xuXG5jb25zdCBmb3JjZVVwZGF0ZSA9IENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGU7XG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlID09IG51bGwpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgQ2FsbGluZyBcInRoaXMuZm9yY2VVcGRhdGVcIiBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGEgY29tcG9uZW50IGlzIGEgYCArXG5cdFx0XHRcdGBuby1vcCBhbmQgbWlnaHQgYmUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi5cXG5cXG4ke2dldE93bmVyU3RhY2soXG5cdFx0XHRcdFx0Z2V0Q3VycmVudFZOb2RlKClcblx0XHRcdFx0KX1gXG5cdFx0KTtcblx0fSBlbHNlIGlmICh0aGlzLl9wYXJlbnREb20gPT0gbnVsbCkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGBDYW4ndCBjYWxsIFwidGhpcy5mb3JjZVVwZGF0ZVwiIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcCwgYCArXG5cdFx0XHRcdGBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gZml4LCBjYW5jZWwgYWxsIGAgK1xuXHRcdFx0XHRgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuYCArXG5cdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodGhpcy5fdm5vZGUpfWBcblx0XHQpO1xuXHR9XG5cdHJldHVybiBmb3JjZVVwZGF0ZS5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgdm5vZGUgdHJlZSB0byBhIHN0cmluZ1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVWTm9kZSh2bm9kZSkge1xuXHRsZXQgeyBwcm9wcyB9ID0gdm5vZGU7XG5cdGxldCBuYW1lID0gZ2V0RGlzcGxheU5hbWUodm5vZGUpO1xuXG5cdGxldCBhdHRycyA9ICcnO1xuXHRmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG5cdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdjaGlsZHJlbicpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG5cdFx0XHQvLyBJZiBpdCBpcyBhbiBvYmplY3QgYnV0IGRvZXNuJ3QgaGF2ZSB0b1N0cmluZygpLCB1c2UgT2JqZWN0LnRvU3RyaW5nXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSBgZnVuY3Rpb24gJHt2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lfSgpIHt9YDtcblx0XHRcdH1cblxuXHRcdFx0dmFsdWUgPVxuXHRcdFx0XHRPYmplY3QodmFsdWUpID09PSB2YWx1ZSAmJiAhdmFsdWUudG9TdHJpbmdcblx0XHRcdFx0XHQ/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHZhbHVlICsgJyc7XG5cblx0XHRcdGF0dHJzICs9IGAgJHtwcm9wfT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuXHRcdH1cblx0fVxuXG5cdGxldCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXHRyZXR1cm4gYDwke25hbWV9JHthdHRyc30ke1xuXHRcdGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/ICc+Li48LycgKyBuYW1lICsgJz4nIDogJyAvPidcblx0fWA7XG59XG4iLCJleHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gOTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG4iLCJpbXBvcnQgeyBpbml0RGVidWcgfSBmcm9tICcuL2RlYnVnJztcbmltcG9ydCAncHJlYWN0L2RldnRvb2xzJztcblxuaW5pdERlYnVnKCk7XG5cbmV4cG9ydCB7IHJlc2V0UHJvcFdhcm5pbmdzIH0gZnJvbSAnLi9jaGVjay1wcm9wcyc7XG4iLCJpbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFJlbGF0aXZlbHkgbG93LWxldmVsIGhvb2sgdGhhdCBhbGxvd3MgeW91IHRvIGluc3BlY3RcbiAqIHdoZW4gdGhlIGVudGlyZSBVUkwgY2hhbmdlcywgZWl0aGVyIGJlY2F1c2UgdGhlIGhhc2ggY2hhbmdlZCxcbiAqIG9yIGJlY2F1c2UgdGhlIEJhY2svRm9yd2FyZCBicm93c2VyIGJ1dHRvbnMgd2VyZSBwcmVzc2VkLlxuICogXG4gKiAoQ2hhbmdpbmcgcXVlcnkgcGFyYW1ldGVycyByZWxvYWRzIHRoZSBwYWdlIGFuZCBzbyBpc24ndFxuICogdHJhY2tlZCwgdW5sZXNzIG9mIGNvdXJzZSBpdCdzIGJlY2F1c2Ugb2YgdGhlIGJyb3dzZXJcbiAqIG5hdmlnYXRpbmcgYmFjay9mb3J3YXJkcykuXG4gKiBcbiAqIEluIGdlbmVyYWwsIHlvdSdsbCB3YW50IHRvIGluc3BlY3QgYSBzcGVjaWZpYyBkaXJlY3Rvcnkgb2ZcbiAqIGEgcGF0aCwgb3IgYSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXIgdmFsdWUsIG5vdCB0aGVcbiAqIGVudGlyZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcmwob25VcmxDaGFuZ2U6ICh1cmw6IHN0cmluZykgPT4gdm9pZCkge1xuXG4gICAgY29uc3QgW2dldFVybCwgc2V0VXJsXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhvblVybENoYW5nZSksIHVzZUNhbGxiYWNrKCgpID0+IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLCBbXSkpO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCBlID0+IHtcbiAgICAgICAgc2V0VXJsKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInBvcHN0YXRlXCIsIChlOiBQb3BTdGF0ZUV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvcG9wc3RhdGVfZXZlbnQjdGhlX2hpc3Rvcnlfc3RhY2tcbiAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBhc3NlcnQgbmV2ZXIgZmlyZXMsIGl0J3MgKnByb2JhYmx5KiBmaW5lPz9cbiAgICAgICAgY29uc29sZS5hc3NlcnQod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkgPT09IGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICBzZXRVcmwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtnZXRVcmwsIHNldFVybF0gYXMgY29uc3Q7XG59XG5cblxuIiwiaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5cblxuLy9leHBvcnQgY29uc3QgUm91dGVyTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gdHJpbSB0aGUgY3J1c3RzIG9mZiBvZiBhIGhhc2ggcGF0aC5cbiAqIEBwYXJhbSBoYXNoIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltSGFzaChoYXNoOiBzdHJpbmcpIHtcbiAgICBpZiAoaGFzaC5zdGFydHNXaXRoKFwiI1wiKSlcbiAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDEpO1xuICAgIGlmIChoYXNoLnN0YXJ0c1dpdGgoXCIvXCIpKVxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMSk7XG4gICAgaWYgKGhhc2guZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMCwgaGFzaC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gaGFzaDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUhhc2hUb1BhdGgoaGFzaDogc3RyaW5nKSB7XG4gICAgaGFzaCA9IHRyaW1IYXNoKGhhc2gpO1xuICAgIHJldHVybiBoYXNoLnNwbGl0KFwiL1wiKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeXBlTWFwIHtcbiAgICBcImJpZ2ludFwiOiBiaWdpbnQ7XG4gICAgXCJudW1iZXJcIjogbnVtYmVyO1xuICAgIFwic3RyaW5nXCI6IHN0cmluZztcbiAgICBcImJvb2xlYW5cIjogYm9vbGVhbjtcbiAgICBcInVua25vd25cIjogdW5rbm93bjtcbn1cblxuLy8gTm90IHB1YmxpYyAtLSBqdXN0IGNvbnRhaW5zIHNoYXJlZCBjb2RlIGZvciBoaXN0b3J5IG1vZGlmaWNhdGlvbi5cbi8vIFRoaXMgaXMgd2hhdCBhY3R1YWxseSBjaGFuZ2VzIEhpc3RvcnkgYW5kIHVwZGF0ZXMgdGhlIHdpbmRvdydzIFVSTC5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnRpcmVIYXNoKGhhc2g6IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSB7XG4gICAgYWN0aW9uID8/PSBcInB1c2hcIjtcbiAgICBoYXNoID0gdHJpbUhhc2goaGFzaCk7XG4gICAgbGV0IG9sZFVSTCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgIGxldCBuZXh0VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgbmV4dFVybC5oYXNoID0gYCMke2hhc2h9YDtcblxuICAgIGhpc3RvcnlbYCR7YWN0aW9ufVN0YXRlYF0oe30sIGRvY3VtZW50LnRpdGxlLCBuZXh0VXJsKTtcblxuICAgIC8vIE1vZGlmeWluZyBoaXN0b3J5IGRvZXNuJ3QgYWN0dWFsbHkgY2F1c2UgYSBoYXNoY2hhbmdlIGV2ZW50LlxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBIYXNoQ2hhbmdlRXZlbnQoJ2hhc2hjaGFuZ2UnLCB7IG9sZFVSTCwgbmV3VVJMOiBuZXh0VXJsLnRvU3RyaW5nKCkgfSkpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBnaXZlbiBTZWFyY2ggUGFyYW1zIG9iamVjdCB0byBoYXZlIGl0cyBrZXkgYmUgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIFxuICogU3BlY2lmaWNhbGx5IGZvciBib29sZWFuIHR5cGVzIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBwYXJhbSBpcyBzaW1wbHkgZXhpc3RhbnQvbm9uLWV4aXN0YW50LFxuICogYnV0IGZvciBvdGhlciB0eXBlcyB0aGlzIGlzIHByZXR0eSBzdHJhaWdodGZvcndhcmQuXG4gKiBAcGFyYW0gcGFyYW1zIFxuICogQHBhcmFtIGtleSBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEBwYXJhbSB0eXBlIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYXJzZVBhcmFtPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4ocGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMsIGtleTogc3RyaW5nLCB2YWx1ZTogVHlwZU1hcFtUXSwgdHlwZTogVCkge1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoa2V5LCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIGAke3ZhbHVlfWApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW0gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcGFyc2VkIHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYm9vbGVhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW08VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPih1cmw6IFVSTCwga2V5OiBzdHJpbmcsIHR5cGU6IFQpOiBUeXBlTWFwW1RdIHwgbnVsbCB7XG4gICAgbGV0IHZhbHVlID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGFzIFR5cGVNYXBbVF0pID8/IG51bGw7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCkgYXMgVHlwZU1hcFtUXTtcblxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBwYXJzZWQ6IG51bWJlciA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShwYXJzZWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQgYXMgVHlwZU1hcFtUXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKSBhcyBUeXBlTWFwW1RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGFzIFR5cGVNYXBbVF0gPz8gbnVsbDtcbn1cblxuXG5leHBvcnQgdHlwZSBSb3V0ZXJQYXRoVHlwZSA9IG51bGwgfCBzdHJpbmcgfCBSZWdFeHAgfCAoKGxvY2FsUGF0aDogc3RyaW5nKSA9PiBib29sZWFuKTtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250cm9scyB7XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byBgZGlyYC5cbiAgICAgKiBcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkLiAgXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBmYXJ0aGVyIGZyb20gdGhlIHJvb3QgYXJlIGRlbGV0ZWQgdW5sZXNzIHJlcXVlc3RlZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2V0TG9jYWxQYXRoKGRpcjogc3RyaW5nLCBhY3Rpb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEdvIG9uZSBsZXZlbCBkZWVwZXIgaW50byB0aGlzIGRpcmVjdG9yeSBieSBhcHBlbmRpbmcgYC9kaXJgIHRvIGl0LlxuICAgICAqIFxuICAgICAqICogVGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIG5vdCBhZmZlY3RlZFxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgY2xvc2VyIHRvIHRoZSByb290IGFyZSBub3QgYWZmZWN0ZWQuICBcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGZhcnRoZXIgZnJvbSB0aGUgcm9vdCBhcmUgZGVsZXRlZCB1bmxlc3MgcmVxdWVzdGVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdXNoTG9jYWxQYXRoKGRpcjogc3RyaW5nLCBhY3Rpb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEdvIGJhY2sgb25lIGxldmVsIGJ5IHNldHRpbmcgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHRvIGVtcHR5IGFuZCwgb3B0aW9uYWxseSwgY2hhbmdpbmcgdGhlIHBhcmVudCBkaXJlY3RvcnkgdG8gYGRpcmAgYXMgd2VsbC5cbiAgICAgKiBcbiAgICAgKiAqIFRoZSBjdXJyZW50IGRpcmVjdG9yeSBpcyBzZXQgdG8gZW1wdHlcbiAgICAgKiAqIEFsbCBkaXJlY3RvcmllcyBhZnRlciB0aGUgY3VycmVudCBkaXJlY3RvcnksIGlmIGFueSwgYXJlIGVtcHRpZWQuXG4gICAgICogKiBJZiBwcm92aWRlZCwgdGhlIHBhcmVudCBkaXJlY3RvcnkgdG8gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHNldCB0byBgZGlyYC5cbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkXG4gICAgICovXG4gICAgcG9wTG9jYWxQYXRoKGRpcj86IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIik6IHZvaWQ7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZz4ge1xuICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyhhbnlNYXRjaGVzOiBib29sZWFuKTogdm9pZDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRleHRUeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICByb3V0ZXJDb250ZXh0OiB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGxldmVsIHRoZSBjaGlsZCBzaG91bGQgY29uc2lkZXIgaXRzZWxmIGFzLS1cbiAgICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0aGlzIHRvIGtub3cgd2hhdCBwYXJ0IG9mIHRoZSBVUkwgdG8gcGFyc2VcbiAgICAgICAgLy8gYW5kIGFsc28gdG8gaW5mb3JtICp0aGVpciogY2hpbGRyZW4gd2hhdCBsZXZlbCB0aGV5IGFyZVxuICAgICAgICBsZXZlbDogbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGluIG9yZGVyIHRvIGZhY2lsaXRhdGUgc2hvd2luZyB0aGUgZGVmYXVsdCBjaGlsZCB3aGVuIG5vIG5vbi1kZWZhdWx0IGNoaWxkcmVuIGFyZSBiZWluZyBzaG93bi5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCBcbiAgICAgICAgICogQHBhcmFtIG1hdGNoZXMgXG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleDogc3RyaW5nLCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbCk6IHZvaWQ7XG4gICAgfTtcbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nPiB7XG4vLyAgICBub3RpZnlPZlNpYmxpbmdzSGF2ZU5vTWF0Y2hlcyhub01hdGNoZXM6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8vcGF0aDogUm91dGVyUGF0aFR5cGUgfCBudWxsO1xuLy8gICAgbWF0Y2hlczogYm9vbGVhbiB8IG51bGw7XG4vL31cbiIsImltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZU1hbmFnZWRDaGlsZCwgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIFJvdXRlckNoaWxkSW5mbywgUm91dGVyUGF0aFR5cGUsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9jYWxQYXRoUGFyYW1ldGVycyB7XG4gICAgY29uc3VtZVJvdXRlclJldHVybjogUGljazxVc2VDb25zdW1lUm91dGVyUmV0dXJuW1wiY29uc3VtZVJvdXRlclJldHVyblwiXSwgXCJsZXZlbFwiPjtcbiAgICBsb2NhbFJvdXRlUGFyYW1ldGVyczoge1xuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTogT25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nLCBuZXZlcj47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRleHRUeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICByb3V0ZXJDb250ZXh0OiB7XG4gICAgICAgIGxldmVsOiBudW1iZXI7XG4gICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4OiBzdHJpbmcsIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsKTogdm9pZDtcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdXRlckNvbnN1bWVyQXJndW1lbnRzIHtcbiAgICByb3V0ZXJDb25zdW1lclBhcmFtZXRlcnM6IHsgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZSB8IG51bGw7IH1cbn1cblxuLyoqXG4gKiBUaGUgXCJjaGlsZFwiIHBhcnQgb2YgYSByb3V0ZXIuXG4gKiBcbiAqIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIG9ic2VydmluZyB0aGUgY3VycmVudCBkaXJlY3RvcnkgaW4gdGhlIGhhc2gsXG4gKiBhbmQgbm90aWZ5aW5nIHRoZSBwYXJlbnQgYW55IHRpbWUgaXQgYmVjb21lcyB2YWxpZC9pbnZhbGlkLCBiZWNhdXNlXG4gKiBpZiB0aGlzIHBhdGggYW5kIGFsbCBpdHMgc2libGluZ3MgYXJlIGludmFsaWQgYXQgdGhlIHNhbWUgdGltZSxcbiAqIHRoZSBkZWZhdWx0IHBhdGggaXMgYWxsb3dlZCB0byBiZSBzaG93bi5cbiAqL1xuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICBjb250ZXh0OiBSb3V0ZXJDb250ZXh0VHlwZTtcbiAgICBjb25zdW1lUm91dGVyUGFyYW1ldGVyczoge1xuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcbiAgICAgICAgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29uc3VtZVJvdXRlclJldHVybiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgY29uc3VtZVJvdXRlclJldHVybjoge1xuICAgICAgICBsZXZlbDogbnVtYmVyO1xuICAgICAgICBtYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgZ2V0TG9jYWxQYXRoOiAoKSA9PiBzdHJpbmc7XG4gICAgICAgIHNldExvY2FsUGF0aDogKHBhdGg6IHN0cmluZykgPT4gdm9pZDtcbiAgICAgICAgcGF0aFdoZW5NYXRjaGluZzogc3RyaW5nIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb25zdW1lUm91dGVyKHsgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LCBjb25zdW1lUm91dGVyUGFyYW1ldGVyczogeyBvbkxvY2FsUGF0aENoYW5nZSwgbG9jYWxQYXRoOiB3YW50ZWRMb2NhbFBhdGggfSB9OiBVc2VDb25zdW1lUm91dGVyUGFyYW1ldGVycyk6IFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4ge1xuICAgIGNvbnN0IHsgcm91dGVyQ29udGV4dDogeyBsZXZlbCwgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQgfSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBbYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3NdID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgYm9vbGVhbik7XG5cbiAgICBjb25zdCBbcGF0aFdoZW5NYXRjaGluZywgc2V0UGF0aFdoZW5NYXRjaGluZ10gPSB1c2VTdGF0ZShudWxsIGFzIG51bGwgfCBzdHJpbmcpO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxSb3V0ZXJDaGlsZEluZm8+KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyc1xuICAgIH0sIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nczogdXNlU3RhYmxlQ2FsbGJhY2soKGFueU1hdGNoZXMpID0+IHtcbiAgICAgICAgICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyhhbnlNYXRjaGVzKTtcbiAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlMih3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXMsIGdldExvY2FsUGF0aCgpKTtcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlMih3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncywgZ2V0TG9jYWxQYXRoKCkpO1xuICAgIH0sIFt3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nc10pXG5cblxuICAgIGNvbnN0IG9uTG9jYWxQYXRoQ2hhbmdlMiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uICh3YW50ZWRMb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3M6IGJvb2xlYW4gfCBudWxsLCBwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhdGhDb21wYXJlKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcbiAgICAgICAgc2V0TWF0Y2hlcyhtYXRjaGVzKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7aW5kZXh9OiBvbkxvY2FsUGF0aENoYW5nZTIod2xwOiAkeyh3YW50ZWRMb2NhbFBhdGggPz8gXCJudWxsXCIpLnRvU3RyaW5nKCl9LCBhbWFuZHM6ICR7KGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyA/PyBcIm51bGxcIikudG9TdHJpbmcoKX0sIHA6ICR7cGF0aH0pOiAkeyhtYXRjaGVzID8/IFwibnVsbFwiKS50b1N0cmluZygpfWApXG4gICAgICAgIGlmIChtYXRjaGVzKVxuICAgICAgICAgICAgc2V0UGF0aFdoZW5NYXRjaGluZyhwYXRoKTtcblxuICAgICAgICBpZiAod2FudGVkTG9jYWxQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4LCBtYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4LCBudWxsKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgW21hdGNoZXMsIHNldE1hdGNoZXNdID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgYm9vbGVhbik7XG4gICAgY29uc3QgW2dldExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSA9IHVzZUxvY2FsUGF0aCh7XG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwgfSxcbiAgICAgICAgbG9jYWxSb3V0ZVBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygocGF0aCwgcHJldiwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZT8uKHBhdGgsIHByZXYsIHJlYXNvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHtcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGdldExvY2FsUGF0aCxcbiAgICAgICAgICAgIHNldExvY2FsUGF0aCxcbiAgICAgICAgICAgIHBhdGhXaGVuTWF0Y2hpbmdcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiB1c2VMb2NhbFBhdGgoeyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsIH0sIGxvY2FsUm91dGVQYXJhbWV0ZXJzOiB7IG9uTG9jYWxQYXRoQ2hhbmdlIH0gfTogVXNlTG9jYWxQYXRoUGFyYW1ldGVycykge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9jYWxQYXRoXCIsIGxldmVsKTtcblxuICAgIGNvbnN0IHVybFRvUGF0aCA9IHVzZUNhbGxiYWNrKCh1cmw6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh1cmwpLmhhc2gpKTtcbiAgICAgICAgcmV0dXJuIG9sZEhhc2hQYXRoW2xldmVsXTtcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gPSB1c2VQYXNzaXZlU3RhdGU8c3RyaW5nLCBuZXZlcj4odXNlU3RhYmxlQ2FsbGJhY2sob25Mb2NhbFBhdGhDaGFuZ2UpLCB1c2VDYWxsYmFjaygoKSA9PiB7IFxuICAgICAgICByZXR1cm4gdXJsVG9QYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9LCBbdXJsVG9QYXRoXSkpO1xuXG5cbiAgICAvLyBBbnkgdGltZSB0aGUgVVJMIGNoYW5nZXMsIGluc3BlY3QgdGhlIGhhc2hcbiAgICAvLyBhdCBvdXIgY3VycmVudCBsZXZlbCwgYW5kIGNoYW5nZSBvdXIgbG9jYWwgY29weSBvZiBvdXIgcGF0aFxuICAgIC8vIGluIG91ciBwYXNzaXZlIHN0YXRlLiBUaGlzIHdpbGwgdHJpZ2dlciBvdXIgY2FsbGJhY2sgaWYgdGhleSdyZSBkaWZmZXJlbnQuXG4gICAgdXNlVXJsKHVybCA9PiB7IHNldExvY2FsUGF0aCh1cmxUb1BhdGgodXJsKSk7IH0pO1xuXG4gICAgcmV0dXJuIFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gYXMgY29uc3Q7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhDb21wYXJlKHJlcXVlc3RlZExvY2FsSGFzaDogbnVsbCB8IHN0cmluZyB8IFJlZ0V4cCB8ICgobG9jYWxIYXNoOiBzdHJpbmcpID0+IGJvb2xlYW4pLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3M6IGJvb2xlYW4gfCBudWxsLCBsb2NhbFBhdGg6IHN0cmluZyB8IG51bGwpIHtcbiAgICBsZXQgbWF0Y2hlczogYm9vbGVhbiB8IG51bGw7XG4gICAgbG9jYWxQYXRoID8/PSBcIlwiO1xuXG4gICAgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2gudGVzdChsb2NhbFBhdGgpKTtcbiAgICBlbHNlIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2gobG9jYWxQYXRoKSk7XG5cbiAgICBlbHNlIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggPT0gbnVsbClcbiAgICAgICAgbWF0Y2hlcyA9IChhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MgPT0gbnVsbD8gbnVsbCA6ICFhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MpO1xuICAgIGVsc2VcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2ggPT09IGxvY2FsUGF0aCk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbn1cbiIsIlxuLyoqXG4gKiBFcnJvciBjbGFzcyB1c2VkIHdoZW4gYXR0ZW1wcyB0byBtb2RpZnkgdGhlIHJvb3QgZGlyZWN0b3J5IG9jY3VyLlxuICovXG5leHBvcnQgY2xhc3MgUm9vdFJvdXRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgVGhlIHJvb3QgUm91dGVyJ3MgcGF0aCBjYW4gb25seSBiZSBwdXNoZWQgdG8gYW5kIGNhbm5vdCBiZSBzZXQgb3IgcG9wcGVkIGZyb20uYCk7XG4gICAgfVxufSAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFJvb3RSb3V0ZXJFcnJvciB9IGZyb20gXCIuL3Jvb3Qtcm91dGVyLWVycm9yLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBzZXRFbnRpcmVIYXNoLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkaXJlY3RvcnkgYXQgdGhlIGN1cnJlbnQgbGV2ZWwsIGVmZmVjdGl2ZWx5IHJldHVybmluZ1xuICogdG8gdGhlIHByZXZpb3VzIGxldmVsLiAgWW91IGNhbiBhbHNvIHN3aXRjaCB0byBhIGRpZmZlcmVudFxuICogcHJldmlvdXMgbGV2ZWwgaWYgeW91IHdvdWxkIGxpa2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGRpcj86IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiID0gXCJwdXNoXCIpIHtcbiAgICAgICAgc2V0RW50aXJlSGFzaChwb3BMb2NhbFBhdGgobGV2ZWwsIGRpciksIGFjdGlvbik7XG4gICAgfSwgW2xldmVsXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BMb2NhbFBhdGgobGV2ZWw6IG51bWJlciwgZGlyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAobGV2ZWwgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUm9vdFJvdXRlckVycm9yKCk7XG4gICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcbiAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBsZXZlbCkubWFwKHMgPT4gKHMgPz8gXCJcIikpO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgZGlyID0gdHJpbUhhc2goZGlyKTtcbiAgICAgICAgbmV3SGFzaFBhdGhbbmV3SGFzaFBhdGgubGVuZ3RoIC0gMV0gPSBkaXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0hhc2hQYXRoLmpvaW4oXCIvXCIpO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBzZXRFbnRpcmVIYXNoLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuLyoqXG4gKiBBZGRzIGEgZGlyZWN0b3J5IGF0IG9uZSBsZXZlbCBkZWVwZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQdXNoTG9jYWxQYXRoKGxldmVsOiBudW1iZXIpIHtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiBwdXNoTG9jYWxIYXNoKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xuICAgICAgICBkaXIgPSB0cmltSGFzaChkaXIpO1xuICAgICAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xuICAgICAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBrZWVwVHJhaWxpbmcgPyB1bmRlZmluZWQgOiBsZXZlbCArIDEpLm1hcChzID0+IChzID8/IFwiXCIpKTtcbiAgICAgICAgbmV3SGFzaFBhdGguc3BsaWNlKGxldmVsICsgMSwgMSwgZGlyKTtcbiAgICAgICAgc2V0RW50aXJlSGFzaChuZXdIYXNoUGF0aC5qb2luKFwiL1wiKSwgYWN0aW9uKTtcbiAgICB9LCBbbGV2ZWxdKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUm9vdFJvdXRlckVycm9yIH0gZnJvbSBcIi4vcm9vdC1yb3V0ZXItZXJyb3IuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIHNldEVudGlyZUhhc2gsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBkaXJlY3RvcnkgYXQgdGhlIGN1cnJlbnQgbGV2ZWwgd2l0aCBhIG5ldyBvbmUuIFlvdSBjYW5cbiAqIGNob29zZSB3aGV0aGVyIG9yIG5vdCBhbnkgdHJhaWxpbmcgcGF0aHMgYXJlIGtlcHQgLS0gYnkgZGVmYXVsdCB0aGlzIGlzIGZhbHNlLlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNldExvY2FsUGF0aChsZXZlbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xuICAgICAgICBzZXRFbnRpcmVIYXNoKHNldExvY2FsUGF0aChsZXZlbCwgZGlyLCBrZWVwVHJhaWxpbmcgfHwgZmFsc2UpLCBhY3Rpb24pO1xuICAgIH0sIFtsZXZlbF0pO1xufVxuXG5mdW5jdGlvbiBzZXRMb2NhbFBhdGgobGV2ZWw6IG51bWJlciwgZGlyOiBzdHJpbmcsIGtlZXBUcmFpbGluZzogYm9vbGVhbikge1xuICAgIGlmIChsZXZlbCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSb290Um91dGVyRXJyb3IoKTtcblxuICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XG4gICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcbiAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBrZWVwVHJhaWxpbmcgPyB1bmRlZmluZWQgOiBsZXZlbCArIDEpLm1hcChzID0+IChzID8/IFwiXCIpKTtcbiAgICBuZXdIYXNoUGF0aC5zcGxpY2UobGV2ZWwsIDEsIGRpcik7XG4gICAgcmV0dXJuIG5ld0hhc2hQYXRoLmpvaW4oXCIvXCIpO1xufVxuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVBvcExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1wb3AtbG9jYWwtcGF0aC5qc1wiO1xuaW1wb3J0IHsgdXNlUHVzaExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1wdXNoLWxvY2FsLXBhdGguanNcIjtcbmltcG9ydCB7IHVzZVNldExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1zZXQtbG9jYWwtcGF0aC5qc1wiO1xuaW1wb3J0IHsgUm91dGVyQ29udHJvbHMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cblxuLyoqXG4gKiBBbGxvd3MgZWFzeSBhY2Nlc3MgdG8gdGhlIGNvbnRyb2xzIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICogXG4gKiBZb3UgY2FuIGFsc28gZ2V0IHRoaXMgaW5mb3JtYXRpb24gZnJvbSBhIGNoaWxkIDxSb3V0ZXIgLz5cbiAqIGJ5IHBhc3NpbmcgaW4gYSByZWYgKGUuZy4gPFJvdXRlciByZWY9e3NldENvbnRyb2xzfSAvPikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXJDb250cm9scyhsZXZlbDogbnVtYmVyKTogUm91dGVyQ29udHJvbHMge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggYXQgdGhpcyBsZXZlbCBzcGVjaWZpY2FsbHksIFxuICAgIC8vIHNvIGl0IGNvbnRhaW5zIG5vIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxuICAgIGNvbnN0IHBvcExvY2FsUGF0aCA9IHVzZVBvcExvY2FsUGF0aChsZXZlbCk7XG4gICAgY29uc3QgcHVzaExvY2FsUGF0aCA9IHVzZVB1c2hMb2NhbFBhdGgobGV2ZWwpO1xuICAgIGNvbnN0IHNldExvY2FsUGF0aCA9IHVzZVNldExvY2FsUGF0aChsZXZlbCk7XG5cbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBwb3BMb2NhbFBhdGgsXG4gICAgICAgIHB1c2hMb2NhbFBhdGgsXG4gICAgICAgIHNldExvY2FsUGF0aCxcbiAgICB9KSwgW3BvcExvY2FsUGF0aCwgcHVzaExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSk7XG59XG5cblxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFJvdXRlckNoaWxkSW5mbywgUm91dGVyQ29udGV4dFR5cGUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFJvdXRlckNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVByb3ZpZGVSb3V0ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxSb3V0ZXJDaGlsZEluZm8+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVByb3ZpZGVSb3V0ZXJSZXR1cm5UeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICBjb250ZXh0OiBSb3V0ZXJDb250ZXh0VHlwZTtcbn1cblxuLy9jb25zdCBSb3V0ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxSb3V0ZXJDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG4vKipcbiAqIFRoZSBcInBhcmVudFwiIHBhcnQgb2YgYSByb3V0ZXIuXG4gKiBcbiAqIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIGNvb3JkaW5hdGluZywgYW1vbmcgYWxsIGNoaWxkcmVuLCB3aGljaCByb3V0ZSB0byBzaG93LlxuICogVGhpcyBjb29yZGluYXRpb24gaXMgcmVhbGx5IG9ubHkgbmVlZGVkIGZvciB0aGUgXCJkZWZhdWx0XCIgcGF0aHdheSwgd2hpY2hcbiAqIG5lZWRzIHRvIGtub3cgYXMgcGFpbmxlc3NseSBhcyBwb3NzaWJsZSB3aGV0aGVyIGFueSBvZiBpdHMgc2libGluZ3MgYXJlIGN1cnJlbnRseSB2YWxpZC5cbiAqIFxuICogSXQgYWxzbyBpbmNyZWFzZXMgdGhlIGRlcHRoIGJ5IG9uZSwgc3RhcnRpbmcgYXQgZGVwdGg9LTEgZm9yIHRoZSByb290IHJvdXRlciBpcyAqanVzdCogYSBwYXJlbnQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByb3ZpZGVSb3V0ZXIoeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH06IFVzZVByb3ZpZGVSb3V0ZXJQYXJhbWV0ZXJzKTogVXNlUHJvdmlkZVJvdXRlclJldHVyblR5cGUge1xuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48Um91dGVyQ2hpbGRJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByb3V0ZXJDb250ZXh0OiB7IGxldmVsIH0gfSA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dCkgPz8geyByb3V0ZXJDb250ZXh0OiB7IGxldmVsOiAtMSB9IH1cblxuICAgIGNvbnN0IG1hdGNoaW5nSW5kaWNlcyA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKTtcbiAgICBjb25zdCBbZ2V0U2hvd2luZ0RlZmF1bHQsIHNldFNob3dpbmdEZWZhdWx0XSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuIHwgbnVsbCwgbmV2ZXI+KHVzZVN0YWJsZUNhbGxiYWNrKHNob3dpbmdEZWZhdWx0ID0+IHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoIXNob3dpbmdEZWZhdWx0KTtcbiAgICAgICAgfSlcbiAgICB9KSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3Qgb25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgbWF0Y2hlczogYm9vbGVhbiB8IG51bGwpID0+IHtcbiAgICAgICAgbWF0Y2hpbmdJbmRpY2VzLmN1cnJlbnRbbWF0Y2hlcyA/IFwiYWRkXCIgOiBcImRlbGV0ZVwiXShpbmRleCk7XG4gICAgICAgIHNldFNob3dpbmdEZWZhdWx0KG1hdGNoaW5nSW5kaWNlcy5jdXJyZW50LnNpemUgPT0gMCk7XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgcm91dGVyQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxuICAgICAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkOiBvbk5vbkRlZmF1bHRDaGlsZE1hdGNoQ2hhbmdlZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVyblxuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUNvbnN1bWVSb3V0ZXIsIFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4gfSBmcm9tIFwiLi91c2Utcm91dGVyLWNvbnN1bWVyLmpzXCI7XG5pbXBvcnQgeyB1c2VSb3V0ZXJDb250cm9scyB9IGZyb20gXCIuL3VzZS1yb3V0ZXItY29udHJvbHMuanNcIjtcbmltcG9ydCB7IFJvdXRlckNvbnRleHQsIHVzZVByb3ZpZGVSb3V0ZXIgfSBmcm9tIFwiLi91c2Utcm91dGVyLXByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBSb3V0ZXJDb250cm9scywgUm91dGVyUGF0aFR5cGUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjaGlsZHJlbiB0byBkaXNwbGF5LCBnaXZlbiB0aGUgY3VycmVudCBsb2NhbCBwYXRoLCBpZiBvbmUgbWF0Y2hlcy5cbiAgICAgKiBcbiAgICAgKiBgbnVsbGAgd2lsbCBiZSBwYXNzZWQgd2hlbiB5b3Ugc2hvdWxkIGhpZGUgdGhlIGNvbnRlbnRzLCBhbmQgdGhlIHN0cmluZyB0aGF0IG1hdGNoZWQgd2lsbCBiZSBwYXNzZWQgb3RoZXJ3aXNlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBwYXRoV2hlbk1hdGNoaW5nIFdoZW4gYG51bGxgLCBkb24ndCBzaG93LCBiZWNhdXNlIHRoZSBVUkwgaXNuJ3Qgb24gdGhpcyBwYXRoLiBBbnkgb3RoZXIgc3RyaW5nIHZhbHVlIGlzIHRoZSBjdXJyZW50IHBhdGggdGhhdCB0aGlzIGBSb3V0ZXJgIG1hdGNoZXMuXG4gICAgICogQHJldHVybnMgV2hhdCB5b3Ugd2FudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgY2hpbGRyZW46IChwYXRoV2hlbk1hdGNoaW5nOiBzdHJpbmcgfCBudWxsLCBjb250cm9sczogUm91dGVyQ29udHJvbHMpID0+IENvbXBvbmVudENoaWxkcmVuO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBwYXRoIG9yIHBhdGhzIHRoaXMgYFJvdXRlcmAgc2hvdWxkIHNob3cgaXRzZWxmIG9uLlxuICAgICAqIFxuICAgICAqIENhbiBiZSBhIHN0cmluZywgUmVnRXhwLCBvciBgKHA6IHN0cmluZykgPT4gYm9vbGVhbmAuIE9yIGBudWxsYCB0byBiZSBhIFwiZGVmYXVsdFwiIGBSb3V0ZXJgLlxuICAgICAqIFxuICAgICAqIFwiRGVmYXVsdFwiIGBSb3V0ZXJgcyAoYGxvY2FwUGF0aD17bnVsbH1gKSBhcmUgc2hvd24gd2hlbiBubyBvdGhlciBgUm91dGVyYCBhdCB0aGUgc2FtZSBsZXZlbCBtYXRjaGVzLlxuICAgICAqL1xuICAgIGxvY2FsUGF0aDogUm91dGVyUGF0aFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gSWYgeW91IHdvdWxkIGxpa2UgdG8ga25vdyB3aGF0IHRoZSBjdXJyZW50IHBhdGggaXMgZXZlbiB3aGVuIG5vdCBjdXJyZW50bHkgYmVpbmcgc2hvd24sIHlvdSBjYW4gZ2V0IHRoYXQgaW5mb3JtYXRpb24gaGVyZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBwYXNzIGEgbm9ybWFsIGBzZXRTdGF0ZWAgZnVuY3Rpb24gaGVyZS5cbiAgICAgKi9cbiAgICBvbkxvY2FsUGF0aENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZywgbmV2ZXI+O1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gY29uZGl0aW9uYWxseSBoaWRlL3Nob3cgY29udGVudCBiYXNlZCBvbiBhIHBhdGggaW4gdGhlIGhhc2ggY29tcG9uZW50IG9mIHRoZSBVUkwuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcGFyYW0gcmVmIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoeyBsb2NhbFBhdGgsIG9uTG9jYWxQYXRoQ2hhbmdlLCBjaGlsZHJlbiB9OiBSb3V0ZXJQcm9wcywgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KTtcblxuICAgIGNvbnN0IHsgY29udGV4dDogY29udGV4dEZyb21QYXJlbnQsIG1hbmFnZWRDaGlsZHJlblJldHVybiB9ID0gdXNlUHJvdmlkZVJvdXRlcih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IGluZGV4ID0gdXNlTWVtbygoKSA9PiAoKGxvY2FsUGF0aCA/PyBcIjxkZWZhdWx0PlwiKSArIGAtJHtNYXRoLnJhbmRvbSgpfWApLCBbbG9jYWxQYXRoXSk7XG4gICAgbGV0IGNvbnN1bWVSb3V0ZXJSZXR1cm46IFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4gfCBudWxsID0gbnVsbDtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJSb3V0ZXJcIiwgISFjb250ZXh0KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm4gPSB1c2VDb25zdW1lUm91dGVyKHsgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHsgbG9jYWxQYXRoLCBvbkxvY2FsUGF0aENoYW5nZSB9LCBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsLCBtYXRjaGVzLCBwYXRoV2hlbk1hdGNoaW5nIH0gfSA9IGNvbnN1bWVSb3V0ZXJSZXR1cm4gPz8geyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsOiAtMSwgbWF0Y2hlczogbnVsbCwgcGF0aFdoZW5NYXRjaGluZzogbnVsbCB9IH1cblxuICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlUm91dGVyQ29udHJvbHMobGV2ZWwpO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiAoe1xuICAgICAgICBsZXZlbCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGF0aFdoZW5NYXRjaGluZyxcbiAgICAgICAgLi4uY29udHJvbHNcbiAgICB9KSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0RnJvbVBhcmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW4obGV2ZWwgPT0gLTEgPyBcIi9cIiA6IG1hdGNoZXMgPyBwYXRoV2hlbk1hdGNoaW5nIDogbnVsbCwgdXNlUm91dGVyQ29udHJvbHMobGV2ZWwpKX1cbiAgICAgICAgPC9Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuIiwiXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcbmltcG9ydCB7IHBhcnNlUGFyYW0sIFR5cGVNYXAsIHVucGFyc2VQYXJhbSB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZXhwb3J0IHR5cGUgT25QYXJhbVZhbHVlQ2hhbmdlZDxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+ID0gT25QYXNzaXZlU3RhdGVDaGFuZ2U8VHlwZU1hcFtUXSB8IG51bGwsIG5ldmVyPjsgLy8odmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsLCByZWFzb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgU2V0UGFyYW1XaXRoSGlzdG9yeTxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+ID0gKHZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCB8ICgocHJldlZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCkgPT4gKFR5cGVNYXBbVF0gfCBudWxsKSksIHJlYXNvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpID0+IHZvaWQ7XG5cbi8qKlxuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtJ3MgdmFsdWVcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgbGlrZSB1c2VQYXNzaXZlU3RhdGUgKGl0c2VsZiBsaWtlIHVzZVN0YXRlIGFuZCB1c2VFZmZlY3QgY29tYmluZWQpLFxuICogdGhlIGBzZXRTdGF0ZWAgcmV0dXJuIGZ1bmN0aW9uIGlzLCBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9ucywgbm90IHN5bmNyb25vdXMsIGJ1dCB0aGF0J3NcbiAqIGxpa2UgbW9zdCBjYWxscyB0byBgc2V0U3RhdGVgIGFueXdheSBJIGd1ZXNzP1xuICogXG4gKiBAcGFyYW0gcGFyYW1LZXkgVGhlIG5hbWUgb2YgdGhlIFVSTCBzZWFyY2ggcGFyYW1ldGVyIHRvIHJlZmVyZW5jZSBcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGRhdGEgZW5jb2RlL2RlY29kZSAoYFwic3RyaW5nXCJgIHwgYFwiYm9vbGVhblwiYCB8IGBcIm51bWJlclwiYCB8IGBcImJpZ2ludFwiYClcbiAqIEBwYXJhbSBvblBhcmFtVmFsdWVDaGFuZ2VkIFdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtZXRlcidzIHZhbHVlIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXM8VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPihwYXJhbUtleTogc3RyaW5nLCB0eXBlOiBULCBvblBhcmFtVmFsdWVDaGFuZ2VkPzogT25QYXJhbVZhbHVlQ2hhbmdlZDxUPikge1xuXG4gICAgLy8gV2Uga2VlcCBhIGxvY2FsIGNvcHkgb2Ygb3VyIGN1cnJlbnQgU2VhcmNoIFBhcmFtIHZhbHVlXG4gICAgLy8gYmVjYXVzZSBjaGFuZ2luZyBpdCBpcyBhY3R1YWxseSBhbiBhc3luY3Jvbm91cyBvcGVyYXRpb25cbiAgICAvLyBhbmQgd2UgY2FuJ3Qga25vdyB3aGVuIGl0IGVuZHMgYXNpZGUgZnJvbSBqdXN0IFwiZGlkIHRoZSBVUkwgY2hhbmdlIG9yIG5vdFwiXG4gICAgLy8gc28gd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoaXMgc3RhdGUgYXJvdW5kIGxvY2FsbHkgdG8gY29tcGVuc2F0ZS5cbiAgICBjb25zdCBbZ2V0U2F2ZWRQYXJhbVZhbHVlLCBzZXRTYXZlZFBhcmFtVmFsdWVdID0gdXNlUGFzc2l2ZVN0YXRlPFR5cGVNYXBbVF0gfCBudWxsLCBuZXZlcj4ob25QYXJhbVZhbHVlQ2hhbmdlZCwgdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKSwgcGFyYW1LZXksIHR5cGUpO1xuICAgIH0sIFtdKSk7XG4gICAgY29uc3Qgc2V0UGFyYW1XaXRoSGlzdG9yeSA9IHVzZVN0YWJsZUNhbGxiYWNrPFNldFBhcmFtV2l0aEhpc3Rvcnk8VD4+KChuZXdWYWx1ZU9yVXBkYXRlciwgcmVhc29uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikgPT4ge1xuXG4gICAgICAgIGxldCBwcmV2VmFsdWUgPSBwYXJzZVBhcmFtKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLCBwYXJhbUtleSwgdHlwZSk7XG4gICAgICAgIGxldCBuZXh0VmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsID0gKHR5cGVvZiBuZXdWYWx1ZU9yVXBkYXRlciA9PSBcImZ1bmN0aW9uXCI/IG5ld1ZhbHVlT3JVcGRhdGVyKHByZXZWYWx1ZSkgOiBuZXdWYWx1ZU9yVXBkYXRlcik7XG5cbiAgICAgICAgbGV0IG5ld1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLnNlYXJjaFBhcmFtcykpO1xuICAgICAgICB1bnBhcnNlUGFyYW0obmV3UGFyYW1zLCBwYXJhbUtleSwgbmV4dFZhbHVlIGFzIFR5cGVNYXBbVF0sIHR5cGUpO1xuICAgICAgICBsZXQgbmV4dFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICBuZXh0VXJsLnNlYXJjaCA9IHByZXR0eVByaW50UGFyYW1zKG5ld1BhcmFtcyk7XG4gICAgICAgIGhpc3RvcnlbYCR7cmVhc29uID8/IFwicmVwbGFjZVwifVN0YXRlYF0oe30sIGRvY3VtZW50LnRpdGxlLCBuZXh0VXJsKTtcbiAgICAgICAgc2V0U2F2ZWRQYXJhbVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIEFueSB0aW1lIHRoZSBVUkwgY2hhbmdlcywgaXQgbWVhbnMgdGhlIFNlYXJjaCBQYXJhbSB3ZSBjYXJlIGFib3V0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgICAvLyBQYXJzZSBpdCBvdXQgYW5kIHNhdmUgaXQuXG4gICAgdXNlVXJsKHVzZVN0YWJsZUNhbGxiYWNrKHVybCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtID0gcGFyc2VQYXJhbShuZXcgVVJMKHVybCksIHBhcmFtS2V5LCB0eXBlKTtcbiAgICAgICAgc2V0U2F2ZWRQYXJhbVZhbHVlKG5ld1BhcmFtKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gW2dldFNhdmVkUGFyYW1WYWx1ZSwgc2V0UGFyYW1XaXRoSGlzdG9yeV0gYXMgY29uc3Q7XG59XG5cbmZ1bmN0aW9uIHByZXR0eVByaW50UGFyYW1zKHBhcmFtczogVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1BcnJheSA9IFsuLi5wYXJhbXMuZW50cmllcygpXS5maWx0ZXIoKGtleSwgdmFsdWUpID0+IHZhbHVlICE9IG51bGwpO1xuICAgIGlmIChwYXJhbUFycmF5Lmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gXCJcIjtcblxuXG4gICAgbGV0IHF1ZXJ5U3RyaW5nID0gcGFyYW1BcnJheS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIgfHwgKHZhbHVlIGFzIGFueSkgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9YDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcblxuICAgIHJldHVybiBgPyR7cXVlcnlTdHJpbmd9YDtcblxufVxuIixudWxsXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJkZWZlciIsImRlcHRoU29ydCIsImkiLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJhc3NpZ24iLCJvYmoiLCJwcm9wcyIsInJlbW92ZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJjaGlsZHJlbiIsImtleSIsInJlZiIsIm5vcm1hbGl6ZWRQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZSIsIm9yaWdpbmFsIiwidm5vZGUiLCJfX2siLCJfXyIsIl9fYiIsIl9fZSIsIl9fZCIsIl9fYyIsIl9faCIsImNvbnN0cnVjdG9yIiwiX192IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwidGhpcyIsImdldERvbVNpYmxpbmciLCJjaGlsZEluZGV4IiwiaW5kZXhPZiIsInNpYmxpbmciLCJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsImNoaWxkIiwiYmFzZSIsImVucXVldWVSZW5kZXIiLCJjIiwicHVzaCIsInByb2Nlc3MiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsInJlbmRlclF1ZXVlTGVuZ3RoIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsInNvcnQiLCJzaGlmdCIsIl9fUCIsImRpZmYiLCJfX24iLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJnZXRMYXN0RG9tIiwibmV4dFNpYmxpbmciLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJzb21lIiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJsYXN0RG9tIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIlByb21pc2UiLCJ0aGVuIiwiYmluZCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYSIsImIiLCJpc1N0YXRpY0NoaWxkcmVuIiwiX19zb3VyY2UiLCJfX3NlbGYiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldmlvdXNDb21wb25lbnQiLCJwcmV2UmFmIiwiY3VycmVudEhvb2siLCJhZnRlclBhaW50RWZmZWN0cyIsIkVNUFRZIiwib2xkQmVmb3JlRGlmZiIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJnZXRIb29rU3RhdGUiLCJpbmRleCIsImhvb2tzIiwiX19IIiwiX19WIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiaW52b2tlT3JSZXR1cm4iLCJyZWR1Y2VyIiwiaW5pdCIsImhvb2tTdGF0ZSIsIl9yZWR1Y2VyIiwiYWN0aW9uIiwiY3VycmVudFZhbHVlIiwiX19OIiwibmV4dFZhbHVlIiwiX2hhc1NjdUZyb21Ib29rcyIsInVwZGF0ZUhvb2tTdGF0ZSIsInAiLCJzdGF0ZUhvb2tzIiwiZmlsdGVyIiwieCIsImV2ZXJ5IiwicHJldlNjdSIsInNob3VsZFVwZGF0ZSIsImhvb2tJdGVtIiwicHJldkNXVSIsInVzZUVmZmVjdCIsImFyZ3MiLCJhcmdzQ2hhbmdlZCIsIl9wZW5kaW5nQXJncyIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZU1lbW8iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3JlYXRlSGFuZGxlIiwiY29uY2F0IiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJpbnZva2VDbGVhbnVwIiwiaW52b2tlRWZmZWN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWZ0ZXJOZXh0RnJhbWUiLCJoYXNFcnJvcmVkIiwiSEFTX1JBRiIsInJhZiIsImRvbmUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJob29rIiwiY29tcCIsImNsZWFudXAiLCJvbGRBcmdzIiwibmV3QXJncyIsImFyZyIsImYiLCJnZXRCdWlsZE1vZGVVbm1lbW9pemVkIiwiZW52IiwiTk9ERV9FTlYiLCJfZSIsImdldEJ1aWxkTW9kZSIsIm5vb3AiLCJ0aW1lb3V0SGFuZGxlIiwiY2FsbENvdW50VSIsImZpbHRlcnMiLCJoYXMiLCJ3aW5kb3ciLCJfaG9va0NhbGxDb3VudCIsImNhbGxDb3VudHNNb21lbnQiLCJjYWxsQ291bnRzVG90YWwiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY29uc29sZSIsImxvZyIsIlNldCIsIm1vbml0b3JDYWxsQ291bnQiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsInVzZUhlbHBlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWV1ZU1pY3JvdGFzayIsInVzZVBhc3NpdmVTdGF0ZSIsIm9uQ2hhbmdlIiwiZ2V0SW5pdGlhbFZhbHVlIiwiY3VzdG9tRGVib3VuY2VSZW5kZXJpbmciLCJ2YWx1ZVJlZiIsIlVuc2V0IiwicmVhc29uUmVmIiwid2FybmluZ1JlZiIsImRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0IiwiY2xlYW51cENhbGxiYWNrUmVmIiwib25TaG91bGRDbGVhblVwIiwiY2xlYW51cENhbGxiYWNrIiwidHJ5RW5zdXJlVmFsdWUiLCJleCIsImdldFZhbHVlIiwid2FybiIsInNldFZhbHVlIiwicmVhc29uIiwiRnVuY3Rpb24iLCJuZXh0UmVhc29uIiwibmV4dERlcCIsInByZXZEZXAiLCJTeW1ib2wiLCJyZXR1cm5OdWxsIiwicnVuSW1tZWRpYXRlbHkiLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tNjRCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsIm1hcCIsIm4iLCJqb2luIiwicHJldmlvdXNJbnB1dHMiLCJNYXAiLCJ0b1J1biIsImNvbW1pdE5hbWUiLCJvcmlnaW5hbENvbW1pdCIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsIm9sZElucHV0cyIsImdldCIsImlucHV0cyIsImVmZmVjdCIsInNldCIsImNsZWFyIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwiZGVsZXRlIiwidXNlU3RhYmxlR2V0dGVyIiwiRXJyb3IiLCJ1c2VTdGFibGVPYmplY3QiLCJ0IiwiT2JqZWN0IiwiZW50cmllcyIsIl9rIiwidiIsIldlYWtNYXAiLCJpc1N0YWJsZUdldHRlciIsInNldElzU3RhYmxlR2V0dGVyIiwidXNlU3RhYmxlQ2FsbGJhY2siLCJmbiIsIm5vRGVwcyIsImN1cnJlbnRDYWxsYmFja0dldHRlciIsInVzZUNhbGxiYWNrTmF0aXZlIiwiYXNzZXJ0IiwidXNlTWVyZ2VkQ2hpbGRyZW4iLCJsaHMiLCJyaHMiLCJjbHN4IiwidXNlTWVyZ2VkQ2xhc3NlcyIsImxoc0NsYXNzIiwibGhzQ2xhc3NOYW1lIiwicmhzQ2xhc3MiLCJyaHNDbGFzc05hbWUiLCJsaHNDbGFzc2VzIiwic3BsaXQiLCJyaHNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsImZyb20iLCJwcm9jZXNzUmVmIiwiaW5zdGFuY2UiLCJ1c2VNZXJnZWRSZWZzIiwiY29tYmluZWQiLCJzdHlsZVN0cmluZ1RvT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJ1c2VNZXJnZWRQcm9wcyIsImFsbFByb3BzIiwicmV0IiwibmV4dFByb3BzIiwidXNlTWVyZ2VkUHJvcHMyIiwia25vd25zIiwibWVyZ2VVbmtub3duIiwibGhzVmFsdWUiLCJyaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwibGhzQWxsIiwicmhzQWxsIiwiY2xhc3NOYW1lIiwibGhzS2V5VSIsImxoc0tleSIsInJoc0tleVUiLCJyaHNLZXkiLCJsdiIsInJ2IiwiYWxsIiwidXNlR2xvYmFsSGFuZGxlciIsInRhcmdldCIsImhhbmRsZXIiLCJtb2RlIiwidXNlR2xvYmFsSGFuZGxlckdyb3VwZWQiLCJ1c2VHbG9iYWxIYW5kbGVyU2luZ2xlIiwibWFwVGhpbmciLCJkb01hcFRoaW5nIiwib3AiLCJvcHRpb25zS2V5IiwiYnlUeXBlIiwiYnlPcHRpb25zIiwiaW5mbyIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYWRkVG9NYXBUaGluZyIsImgiLCJhZGQiLCJyZW1vdmVGcm9tTWFwVGhpbmciLCJzdGFibGVIYW5kbGVyIiwidXNlUmVmRWxlbWVudCIsIm9uRWxlbWVudENoYW5nZSIsIm9uTW91bnQiLCJvblVubW91bnQiLCJyZWZFbGVtZW50UGFyYW1ldGVycyIsInByZXZWYWx1ZSIsImdldEVsZW1lbnQiLCJzZXRFbGVtZW50IiwicHJvcHNTdGFibGUiLCJyZWZFbGVtZW50UmV0dXJuIiwiX2Jsb2NraW5nRWxlbWVudHMiLCJfYWxyZWFkeUluZXJ0RWxlbWVudHMiLCJfdG9wRWxQYXJlbnRzIiwiX3NpYmxpbmdzVG9SZXN0b3JlIiwiX3BhcmVudE1PIiwiX3RvcENoYW5nZWQiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwiX2luZXJ0U2libGluZ3MiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaXNJbmVydGFibGUiLCJfaGFuZGxlTXV0YXRpb25zIiwiQmxvY2tpbmdFbGVtZW50c0ltcGwiLCJfYSIsIl9iIiwiX2MiLCJkZXN0cnVjdG9yIiwibnVsbGFibGUiLCJ0b3AiLCJlbGVtcyIsImVsZW1lbnQiLCJyZW1vdmUiLCJwb3AiLCJuZXdUb3AiLCJ0b0tlZXBJbmVydCIsIm9sZFBhcmVudHMiLCJuZXdQYXJlbnRzIiwiYm9keSIsInRvU2tpcCIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsImluZXJ0IiwiZWxlbWVudHMiLCJtbyIsImRpc2Nvbm5lY3QiLCJzaWJsaW5ncyIsInBhcmVudCIsImluZXJ0ZWRTaWJsaW5ncyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJob3N0Iiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInJlbW92ZWROb2RlcyIsImFkZGVkTm9kZXMiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiYXNzaWduZWRTbG90Iiwic2hhZG93Um9vdCIsInJlc3VsdCIsIm5vZGVzIiwic2xvdHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCIkYmxvY2tpbmdFbGVtZW50cyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jbGFzc0NhbGxDaGVjayIsIlR5cGVFcnJvciIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiX29uTXV0YXRpb24iLCJzdWJ0cmVlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJzaXplIiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJfb25Eb2N1bWVudExvYWRlZCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwiaW5lcnRFbGVtZW50IiwiX3RoaXMiLCJ1bnNoaWZ0Iiwic2hhZG93Um9vdEFuY2VzdG9yIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiX2kiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJIVE1MRWxlbWVudCIsImhhc093blByb3BlcnR5IiwidXNlTWFuYWdlZENoaWxkcmVuIiwicGFyZW50UGFyYW1ldGVycyIsIm1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMiLCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QiLCJvbkNoaWxkcmVuTW91bnRDaGFuZ2UiLCJvbkNoaWxkQ291bnRDaGFuZ2UiLCJyZXN0IiwiZ2V0SGlnaGVzdEluZGV4IiwibWFuYWdlZENoaWxkcmVuQXJyYXkiLCJoaWdoZXN0SW5kZXgiLCJhcnIiLCJyZWMiLCJsb3dlc3RJbmRleCIsImZvckVhY2hDaGlsZCIsImZpZWxkIiwiZ2V0TWFuYWdlZENoaWxkSW5mbyIsImhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMiLCJyZW1vdGVVTEVDaGlsZENoYW5nZWQiLCJyZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJtb3VudGVkIiwibW91bnRzIiwidW5tb3VudHMiLCJnZXRDaGlsZHJlbiIsIm1heCIsInNoYXZlIiwibWFuYWdlZENoaWxkcmVuIiwiXyIsImdldEF0IiwiYXJyYXlTbGljZSIsIm1hbmFnZWRDaGlsZENvbnRleHQiLCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4iLCJ1c2VNYW5hZ2VkQ2hpbGQiLCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIiwiZmxhdCIsIm1hbmFnZWRDaGlsZFJldHVybiIsInNldFN0YXRlUCIsInVzZVN0YXRlUCIsImdldFN0YXRlIiwic2hhbGxvd0RpZmZlcnMiLCJQdXJlQ29tcG9uZW50IiwibWVtbyIsImNvbXBhcmVyIiwidXBkYXRlUmVmIiwiTWVtb2VkIiwiZGlzcGxheU5hbWUiLCJpc1JlYWN0Q29tcG9uZW50IiwiX19mIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJvbGREaWZmSG9vayIsIlJFQUNUX0ZPUldBUkRfU1lNQk9MIiwiZm9yIiwiZm9yd2FyZFJlZiIsIkZvcndhcmRlZCIsImNsb25lIiwiJCR0eXBlb2YiLCJvbGRDYXRjaEVycm9yIiwib2xkVW5tb3VudCIsImRldGFjaGVkQ2xvbmUiLCJkZXRhY2hlZFBhcmVudCIsInJlbW92ZU9yaWdpbmFsIiwib3JpZ2luYWxQYXJlbnQiLCJTdXNwZW5zZSIsIl9fdSIsIl9zdXNwZW5kZXJzIiwic3VzcGVuZGVkIiwiX19hIiwiU3VzcGVuc2VMaXN0IiwiX25leHQiLCJfbWFwIiwiX19SIiwicHJvbWlzZSIsInN1c3BlbmRpbmdWTm9kZSIsInN1c3BlbmRpbmdDb21wb25lbnQiLCJyZXNvbHZlZCIsIm9uUmVzb2x2ZWQiLCJvblN1c3BlbnNpb25Db21wbGV0ZSIsInN1c3BlbmRlZFZOb2RlIiwid2FzSHlkcmF0aW5nIiwiZGV0YWNoZWRDb21wb25lbnQiLCJfX08iLCJmYWxsYmFjayIsImxpc3QiLCJyZXZlYWxPcmRlciIsImRlbGVnYXRlZCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJyZXZlcnNlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiQ0FNRUxfUFJPUFMiLCJPTl9BTkkiLCJDQU1FTF9SRVBMQUNFIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJvbGRFdmVudEhvb2siLCJlbXB0eSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsImxvd2VyQ2FzZWQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwib2xkRGlmZmVkIiwiSW1wZXJhdGl2ZUVsZW1lbnRVIiwidXNlSW1wZXJhdGl2ZVByb3BzIiwiY3VycmVudEltcGVyYXRpdmVQcm9wcyIsIm90aGVycyIsImhhc0NsYXNzIiwiY2xzIiwic2V0Q2xhc3MiLCJlbmFibGVkIiwiY2xhc3NMaXN0IiwicHJvcCIsInN0YXJ0c1dpdGgiLCJyZW1vdmVQcm9wZXJ0eSIsInNldENoaWxkcmVuIiwic2V0RXZlbnRIYW5kbGVyIiwibWFwcGVkS2V5IiwiRXZlbnRNYXBwaW5nIiwiaW1wZXJhdGl2ZUhhbmRsZSIsInRhZyIsIlRhZyIsImhhbmRsZSIsImlwcm9wcyIsImFib3J0IiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uc3RhcnQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJiZWZvcmVpbnB1dCIsImNhbnBsYXkiLCJjYW5wbGF5dGhyb3VnaCIsImNoYW5nZSIsImNsaWNrIiwiY29tcG9zaXRpb25lbmQiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJjb250ZXh0bWVudSIsImN1dCIsImRibGNsaWNrIiwiZHJhZyIsImRyYWdlbmQiLCJkcmFnZW50ZXIiLCJkcmFnbGVhdmUiLCJkcmFnb3ZlciIsImRyYWdzdGFydCIsImRyb3AiLCJkdXJhdGlvbmNoYW5nZSIsImVtcHRpZWQiLCJlbmRlZCIsImZvY3VzaW4iLCJmb2N1c291dCIsImZvcm1kYXRhIiwiZ290cG9pbnRlcmNhcHR1cmUiLCJpbnB1dCIsImludmFsaWQiLCJrZXlkb3duIiwia2V5cHJlc3MiLCJrZXl1cCIsImxvYWQiLCJsb2FkZWRkYXRhIiwibG9hZGVkbWV0YWRhdGEiLCJsb2Fkc3RhcnQiLCJsb3N0cG9pbnRlcmNhcHR1cmUiLCJtb3VzZWRvd24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm1vdXNlbW92ZSIsIm1vdXNlb3V0IiwibW91c2VvdmVyIiwibW91c2V1cCIsInBhc3RlIiwicGF1c2UiLCJwbGF5IiwicGxheWluZyIsInBvaW50ZXJjYW5jZWwiLCJwb2ludGVyZG93biIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcm91dCIsInBvaW50ZXJvdmVyIiwicG9pbnRlcnVwIiwicHJvZ3Jlc3MiLCJyZXNldCIsInNjcm9sbCIsInNlZWtlZCIsInNlZWtpbmciLCJzZWxlY3QiLCJzdGFsbGVkIiwic3VibWl0Iiwic3VzcGVuZCIsInRpbWV1cGRhdGUiLCJ0b2dnbGUiLCJ0b3VjaGNhbmNlbCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hzdGFydCIsInRyYW5zaXRpb25lbmQiLCJ2b2x1bWVjaGFuZ2UiLCJ3YWl0aW5nIiwid2hlZWwiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZUdsb2JhbCQxIiwiZnJlZVNlbGYiLCJyb290JDEiLCJTeW1ib2wkMiIsIm9iamVjdFByb3RvIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInVubWFza2VkIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsImNvcmVKc0RhdGEkMSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwia2V5cyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsIm9iamVjdCIsImdldE5hdGl2ZSIsImVxIiwib3RoZXIiLCJuYXRpdmVDcmVhdGUiLCJuYXRpdmVDcmVhdGUkMSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsImVudHJ5IiwibGlzdENhY2hlQ2xlYXIiLCJhc3NvY0luZGV4T2YiLCJhcnJheSIsImFycmF5UHJvdG8iLCJsaXN0Q2FjaGVEZWxldGUiLCJsYXN0SW5kZXgiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJNYXAkMiIsIm1hcENhY2hlQ2xlYXIiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemUiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiYXBwbHkiLCJjYWNoZSIsIkNhY2hlIiwicmV0dXJuRmFsc2UiLCJ1c2VDaGlsZHJlbkZsYWciLCJpbml0aWFsSW5kZXgiLCJjbG9zZXN0Rml0Iiwib25JbmRleENoYW5nZSIsInNldEF0IiwiaXNWYWxpZCIsImdldEN1cnJlbnRJbmRleCIsInNldEN1cnJlbnRJbmRleCIsImdldFJlcXVlc3RlZEluZGV4Iiwic2V0UmVxdWVzdGVkSW5kZXgiLCJnZXRDbG9zZXN0Rml0IiwicmVxdWVzdGVkSW5kZXgiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsImNsb3Nlc3RJbmRleCIsIm5ld0Rpc3RhbmNlIiwiYWJzIiwicmVldmFsdWF0ZUNsb3Nlc3RGaXQiLCJjdXJyZW50Q2hpbGQiLCJjbG9zZXN0Rml0SW5kZXgiLCJjbG9zZXN0Rml0Q2hpbGQiLCJjaGFuZ2VJbmRleCIsIm5ld01hdGNoaW5nQ2hpbGQiLCJvbGRNYXRjaGluZ0NoaWxkIiwiY2hpbGRJc1ZhbGlkIiwiZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbiIsImV4Y2x1c2l2aXR5S2V5IiwiU3dhcHBhYmxlQ29udGV4dCIsImdldEFuaW1hdGVPbk1vdW50IiwiR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQiLCJDc3NDbGFzc0NvbnRleHQiLCJHZXRCYXNlQ2xhc3MiLCJHZXRFbnRlckNsYXNzIiwiR2V0RXhpdENsYXNzIiwiR2V0TWVhc3VyZUNsYXNzIiwiR2V0SW5pdENsYXNzIiwiR2V0VHJhbnNpdGlvbkNsYXNzIiwiR2V0RmluYWxpemVDbGFzcyIsInVzZUNzc0NsYXNzZXMiLCJHZXREaXJlY3Rpb25DbGFzcyIsImRpcmVjdGlvbiIsIkdldFBoYXNlQ2xhc3MiLCJwaGFzZSIsImdsb2JhbENvdW50IiwiRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyIiwiZ2V0TmV4dEluZGV4SW5MaW5lIiwic2V0TmV4dEluZGV4SW5MaW5lIiwibSIsInNldEV4Y2x1c2l2ZWx5T3BlbiIsImdldEV4Y2x1c2l2ZWx5T3BlbiIsIm9uVmlzaWJpbGl0eUNoYW5nZSIsInZpc2libGUiLCJuZXh0SW5MaW5lIiwiY3VycmVudEluTGluZSIsImZvcmNlQ2xvc2UiLCJjb250ZXh0MiIsImV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0IiwiRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQiLCJfanN4IiwidXNlRXhjbHVzaXZlVHJhbnNpdGlvbiIsInRyYW5zaXRpb25QYXJhbWV0ZXJzIiwic2hvdyIsImV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzIiwiZXhjbHVzaXZlbHlPcGVuIiwicGFyZW50T25WaXNDaGFuZ2UiLCJleGNsdXNpdmVUcmFuc2l0aW9uUmV0dXJuIiwiaXNFeGNsdXNpdmUiLCJmb3J3YXJkRWxlbWVudFJlZiIsIkZvcndhcmRlZENvbXBvbmVudCIsInVzZUxhc3ROb25OdWxsVmFsdWUiLCJsYXN0Tm9uTnVsbFZhbHVlIiwidXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHMiLCJvdGhlclByb3BzIiwiaW5saW5lIiwiU3dhcHBhYmxlIiwiY2hpbGRyZW5BbmltYXRlT25Nb3VudCIsImlubGluZUVsZW1lbnRzIiwidHJhbnNpdGlvblByb3BzIiwibWVyZ2VkV2l0aENoaWxkcmVuIiwiYW5pbWF0ZU9uTW91bnQiLCJnZXRUaW1lb3V0RHVyYXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInN0ciIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwicGFyc2VTdGF0ZSIsIm5leHRTdGF0ZSIsInVzZVRyYW5zaXRpb24iLCJwcm9wc0luY29taW5nIiwibWVhc3VyZSIsImV4aXRWaXNpYmlsaXR5IiwiZHVyYXRpb24iLCJkZWxheU1vdW50VW50aWxTaG93biIsImVhc2luZyIsImVhc2luZ0luIiwiZWFzaW5nT3V0IiwiZ2V0RXhpdFZpc2liaWxpdHkiLCJnZXRNZWFzdXJlIiwiZXhjbHVzaXZlVHJhbnNpdGlvblZpc2liaWxpdHlDaGFuZ2UiLCJpbnRlcm5hbE9uU2hvd0NoYW5nZWQiLCJjc3NQcm9wZXJ0aWVzIiwiY2xhc3NOYW1lcyIsImhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCIsInRpbWVvdXRDbGVhckZ1bmN0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwiZWxhcHNlZFRpbWUiLCJoYXNNb3VudGVkIiwidXBkYXRlQ2xhc3NlcyIsImFsbENsYXNzZXNUb1JlbW92ZSIsImFsbENsYXNzZXNUb0FkZCIsInVwZGF0ZVNpemVQcm9wZXJ0eSIsInZhck5hbWUiLCJtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJvblN0YXRlQ2hhbmdlIiwicHJldlN0YXRlIiwibmV4dERpcmVjdGlvbiIsIm5leHRQaGFzZSIsImlzQmVpbmdQYWludGVkIiwiZm9yY2VSZWZsb3ciLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50RGlyZWN0aW9uIiwiY3VycmVudFBoYXNlIiwiZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW4iLCJoYXNSZW5kZXJlZENoaWxkcmVuIiwicmVuZGVyQ2hpbGRyZW4iLCJjaGlsZHJlbklzVm5vZGUiLCJmaW5hbFByb3BzIiwicmVzZXRDb250ZXh0IiwibW9kaWZpZWRDaGlsZHJlbiIsImdsb2JhbFRoaXMiLCJfZHVtbXkiLCJvcGFjaXR5IiwidHJhbnNmb3JtIiwidXNlQmFzZVByb3BzRmFkZSIsImZhZGVQYXJhbWV0ZXJzIiwiZmFkZU1pbiIsImZhZGVNYXgiLCJGYWRlIiwidXNlQmFzZVByb3BzQ2xpcCIsImNsaXBQYXJhbWV0ZXJzIiwiY2xpcE1pbiIsImNsaXBNaW5CbG9jayIsImNsaXBNaW5JbmxpbmUiLCJjbGlwT3JpZ2luIiwiY2xpcE9yaWdpbkJsb2NrIiwiY2xpcE9yaWdpbklubGluZSIsIkNsaXAiLCJDbGlwRmFkZSIsInVzZUJhc2VQcm9wc0NvbGxhcHNlIiwiY29sbGFwc2VQYXJhbWV0ZXJzIiwibWluQmxvY2tTaXplIiwiQ29sbGFwc2UiLCJDb2xsYXBzZUZhZGUiLCJ1c2VCYXNlUHJvcHNGbGlwIiwiZmxpcFBhcmFtZXRlcnMiLCJmbGlwQW5nbGVCbG9jayIsImZsaXBBbmdsZUlubGluZSIsImZsaXBQZXJzcGVjdGl2ZSIsIkZsaXAiLCJ1c2VCYXNlUHJvcHNTbGlkZSIsInNsaWRlUGFyYW1ldGVycyIsInNsaWRlVGFyZ2V0SW5saW5lIiwic2xpZGVUYXJnZXRCbG9jayIsIlNsaWRlIiwiU2xpZGVGYWRlIiwidXNlQmFzZVByb3BzWm9vbSIsInpvb21QYXJhbWV0ZXJzIiwiem9vbU9yaWdpbiIsInpvb21PcmlnaW5JbmxpbmUiLCJ6b29tT3JpZ2luQmxvY2siLCJ6b29tTWluIiwiem9vbU1pbklubGluZSIsInpvb21NaW5CbG9jayIsIlpvb20iLCJTbGlkZVpvb20iLCJTbGlkZVpvb21GYWRlIiwiWm9vbUZhZGUiLCJfX1BSRUFDVF9ERVZUT09MU19fIiwiYXR0YWNoUHJlYWN0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwicmVzZXRQcm9wV2FybmluZ3MiLCJnZXREaXNwbGF5TmFtZSIsInJlbmRlclN0YWNrIiwib3duZXJTdGFjayIsImdldEN1cnJlbnRWTm9kZSIsImhhc0JhYmVsUGx1Z2luIiwiaXNQb3NzaWJsZU93bmVyIiwiZ2V0T3duZXJTdGFjayIsInN0YWNrIiwibmV4dCIsIl9fbyIsInJlZHVjZSIsImFjYyIsIm93bmVyIiwic291cmNlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiaXNXZWFrTWFwU3VwcG9ydGVkIiwiZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQiLCJzZXJpYWxpemVWTm9kZSIsImF0dHJzIiwib2xkRGlmZiIsIm9sZFJvb3QiLCJvbGRSZW5kZXIiLCJzZXR1cENvbXBvbmVudFN0YWNrIiwiaG9va3NBbGxvd2VkIiwib2xkVm5vZGUiLCJvbGRIb29rIiwid2FybmVkQ29tcG9uZW50cyIsImxhenlQcm9wVHlwZXMiLCJkZXByZWNhdGlvbnMiLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudE5hbWUiLCJwcm9wVHlwZXMiLCJsYXp5Vk5vZGUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJtZXNzYWdlIiwicHJvcGVydHkiLCJkZXByZWNhdGVkQXR0cmlidXRlcyIsIm5vZGVOYW1lIiwiZGVwcmVjYXRlZFByb3RvIiwiY3JlYXRlIiwiX19wcm90b19fIiwiaW5pdERlYnVnIiwidXNlVXJsIiwib25VcmxDaGFuZ2UiLCJnZXRVcmwiLCJzZXRVcmwiLCJ0cmltSGFzaCIsImhhc2giLCJzdWJzdHIiLCJub3JtYWxpemVIYXNoVG9QYXRoIiwic2V0RW50aXJlSGFzaCIsIm9sZFVSTCIsIm5leHRVcmwiLCJVUkwiLCJoaXN0b3J5IiwidGl0bGUiLCJkaXNwYXRjaEV2ZW50IiwiSGFzaENoYW5nZUV2ZW50IiwibmV3VVJMIiwidW5wYXJzZVBhcmFtIiwicGFyYW1zIiwicGFyc2VQYXJhbSIsInVybCIsInNlYXJjaFBhcmFtcyIsInBhcnNlZCIsImlzRmluaXRlIiwiQmlnSW50IiwidXNlQ29uc3VtZVJvdXRlciIsImNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzIiwib25Mb2NhbFBhdGhDaGFuZ2UiLCJsb2NhbFBhdGgiLCJ3YW50ZWRMb2NhbFBhdGgiLCJyb3V0ZXJDb250ZXh0IiwibGV2ZWwiLCJub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZCIsImFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyIsInNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyIsInBhdGhXaGVuTWF0Y2hpbmciLCJzZXRQYXRoV2hlbk1hdGNoaW5nIiwiYW55TWF0Y2hlcyIsIm9uTG9jYWxQYXRoQ2hhbmdlMiIsImdldExvY2FsUGF0aCIsInBhdGgiLCJwYXRoQ29tcGFyZSIsInNldE1hdGNoZXMiLCJzZXRMb2NhbFBhdGgiLCJ1c2VMb2NhbFBhdGgiLCJjb25zdW1lUm91dGVyUmV0dXJuIiwibG9jYWxSb3V0ZVBhcmFtZXRlcnMiLCJwcmV2IiwidXJsVG9QYXRoIiwib2xkSGFzaFBhdGgiLCJocmVmIiwicmVxdWVzdGVkTG9jYWxIYXNoIiwiUm9vdFJvdXRlckVycm9yIiwidXNlUG9wTG9jYWxQYXRoIiwiZGlyIiwicG9wTG9jYWxQYXRoIiwibmV3SGFzaFBhdGgiLCJ1c2VQdXNoTG9jYWxQYXRoIiwicHVzaExvY2FsSGFzaCIsImtlZXBUcmFpbGluZyIsInVzZVNldExvY2FsUGF0aCIsInVzZVJvdXRlckNvbnRyb2xzIiwicHVzaExvY2FsUGF0aCIsIlJvdXRlckNvbnRleHQiLCJ1c2VQcm92aWRlUm91dGVyIiwibWF0Y2hpbmdJbmRpY2VzIiwiZ2V0U2hvd2luZ0RlZmF1bHQiLCJzZXRTaG93aW5nRGVmYXVsdCIsInNob3dpbmdEZWZhdWx0Iiwib25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWQiLCJSb3V0ZXIiLCJjb250ZXh0RnJvbVBhcmVudCIsImNvbnRyb2xzIiwidXNlU2VhcmNoUGFyYW1zIiwicGFyYW1LZXkiLCJvblBhcmFtVmFsdWVDaGFuZ2VkIiwiZ2V0U2F2ZWRQYXJhbVZhbHVlIiwic2V0U2F2ZWRQYXJhbVZhbHVlIiwic2V0UGFyYW1XaXRoSGlzdG9yeSIsIm5ld1ZhbHVlT3JVcGRhdGVyIiwibmV3UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwicHJldHR5UHJpbnRQYXJhbXMiLCJuZXdQYXJhbSIsInBhcmFtQXJyYXkiLCJxdWVyeVN0cmluZyIsImVuY29kZVVSSUNvbXBvbmVudCIsImV4YW1wbGUiLCJzZXRFeGFtcGxlTG9jYWwiLCJnZXRFeGFtcGxlIiwic2V0RXhhbXBsZSIsIl9qc3hzIiwib25DbGljayIsImRpc2FibGVkIiwib25JbnB1dCIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZUFzTnVtYmVyIiwiTGV2ZWwxIiwiX0ZyYWdtZW50IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7OztFQTBCYUEsSUFBQUEsQ0FBQUE7SUNmUEMsR0NSRkM7SUFBQUEsR0FBQUE7SUN5S0FDLEdBQUFBO0lBV0FDO0lBRUVDLEdBMEJBQztJQUFBQSxHQUFBQTtJQ2pOS0MsR0NGRUM7SUFBQUEsR0FBQUEsR0FBWSxDQUFBLENBQ1pDO0lBQUFBLEdBQUFBLEdBQVksRUFDWkM7SUFBQUEsR0FBQUEsR0FBcUIsbUVBQUE7RUxPbEJDLFNBQUFBLEdBQUFBLENBQU9DLENBQUtDLEVBQUFBLENBQUFBLEVBQUFBO0lBRTNCLEtBQUssSUFBSU4sQ0FBQUEsSUFBS00sQ0FBT0QsRUFBQUEsQ0FBQUEsQ0FBSUwsS0FBS00sQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBQUE7SUFDcEMsT0FBNkJLLENBQzdCO0VBQUE7RUFRTSxTQUFTRSxHQUFBQSxDQUFXQyxDQUMxQixFQUFBO0lBQUEsSUFBSUMsSUFBYUQsQ0FBS0MsQ0FBQUEsVUFBQUE7SUFDbEJBLENBQVlBLElBQUFBLENBQUFBLENBQVdDLFdBQVlGLENBQUFBLENBQUFBO0VBQ3ZDO0VFWE0sU0FBU0csSUFBY0MsQ0FBTU4sRUFBQUEsQ0FBQUEsRUFBT08sQ0FDMUMsRUFBQTtJQUFBLElBQ0NDO01BQ0FDLENBQ0FmO01BQUFBLENBQUFBO01BSEdnQixDQUFrQixHQUFBO0lBSXRCLEtBQUtoQixDQUFBQSxJQUFLTSxDQUNBLEVBQUEsS0FBQSxJQUFMTixJQUFZYyxDQUFNUixHQUFBQSxDQUFBQSxDQUFNTixDQUNkLENBQUEsR0FBQSxLQUFBLElBQUxBLElBQVllLENBQU1ULEdBQUFBLENBQUFBLENBQU1OLENBQzVCZ0IsQ0FB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
