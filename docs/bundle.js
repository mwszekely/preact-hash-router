(function () {
  'use strict';

  var _window, _window$requestIdleCa, _window2, _window2$requestIdleC;
  var n,
    l$2,
    u$2,
    t$1,
    r$3,
    o$3,
    f$2,
    e$1,
    c$2 = {},
    s$2 = [],
    a$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h$2(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function v$2(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function y$2(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return p$2(l, f, t, r, null);
  }
  function p$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$2 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function _$2(n) {
    return n.children;
  }
  function k$2(n, l) {
    this.props = n, this.context = l;
  }
  function b$1(n, l) {
    if (null == l) return n.__ ? b$1(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? b$1(n) : null;
  }
  function g$2(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return g$2(n);
    }
  }
  function m$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !w$2.__r++ || r$3 !== l$2.debounceRendering) && ((r$3 = l$2.debounceRendering) || o$3)(w$2);
  }
  function w$2() {
    var n, l, u, i, r, o, e, c;
    for (t$1.sort(f$2); n = t$1.shift();) n.__d && (l = t$1.length, i = void 0, r = void 0, e = (o = (u = n).__v).__e, (c = u.__P) && (i = [], (r = h$2({}, o)).__v = o.__v + 1, L$1(c, o, r, u.__n, void 0 !== c.ownerSVGElement, null != o.__h ? [e] : null, i, null == e ? b$1(o) : e, o.__h), M(i, o), o.__e != e && g$2(o)), t$1.length > l && t$1.sort(f$2));
    w$2.__r = 0;
  }
  function x$1(n, l, u, i, t, r, o, f, e, a) {
    var h,
      v,
      y,
      d,
      k,
      g,
      m,
      w = i && i.__k || s$2,
      x = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (d = u.__k[h] = null == (d = l[h]) || "boolean" == typeof d || "function" == typeof d ? null : "string" == typeof d || "number" == typeof d || "bigint" == typeof d ? p$2(null, d, null, null, d) : Array.isArray(d) ? p$2(_$2, {
      children: d
    }, null, null, null) : d.__b > 0 ? p$2(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {
      if (d.__ = u, d.__b = u.__b + 1, null === (y = w[h]) || y && d.key == y.key && d.type === y.type) w[h] = void 0;else for (v = 0; v < x; v++) {
        if ((y = w[v]) && d.key == y.key && d.type === y.type) {
          w[v] = void 0;
          break;
        }
        y = null;
      }
      L$1(n, d, y = y || c$2, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (m || (m = []), y.ref && m.push(y.ref, null, d), m.push(v, d.__c || k, d)), null != k ? (null == g && (g = k), "function" == typeof d.type && d.__k === y.__k ? d.__d = e = A$1(d, e, n) : e = C$1(n, d, y, w, k, e), "function" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = b$1(y));
    }
    for (u.__e = g, h = x; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = $$1(i).nextSibling), S(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) O(m[h], m[++h], m[++h]);
  }
  function A$1(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? A$1(i, l, u) : C$1(u, i, i, t, i.__e, l));
    return l;
  }
  function P(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      P(n, l);
    }) : l.push(n)), l;
  }
  function C$1(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function $$1(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = $$1(u))) return i;
    return null;
  }
  function H$1(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || T$2(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || T$2(n, r, l[r], u[r], i);
  }
  function I$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a$2.test(l) ? u : u + "px";
  }
  function T$2(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || I$1(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || I$1(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? z$1 : j$1, r) : n.removeEventListener(l, r ? z$1 : j$1, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function j$1(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function z$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function L$1(n, u, i, t, r, o, f, e, c) {
    var s,
      a,
      v,
      y,
      p,
      d,
      b,
      g,
      m,
      w,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], w = s ? m ? m.props.value : s.__ : t, i.__c ? b = (a = u.__c = i.__c).__ = a.__E : ("prototype" in I && I.prototype.render ? u.__c = a = new I(g, w) : (u.__c = a = new k$2(g, w), a.constructor = I, a.render = q$2), m && m.sub(a), a.props = g, a.state || (a.state = {}), a.context = w, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != I.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h$2({}, a.__s)), h$2(a.__s, I.getDerivedStateFromProps(g, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == I.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(g, w), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(g, a.__s, w) || u.__v === i.__v) {
            for (u.__v !== i.__v && (a.props = g, a.state = a.__s, a.__d = !1), a.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < a._sb.length; A++) a.__h.push(a._sb[A]);
            a._sb = [], a.__h.length && f.push(a);
            break n;
          }
          null != a.componentWillUpdate && a.componentWillUpdate(g, a.__s, w), null != a.componentDidUpdate && a.__h.push(function () {
            a.componentDidUpdate(y, p, d);
          });
        }
        if (a.context = w, a.props = g, a.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (a.state = a.__s, a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), $ = 0; $ < a._sb.length; $++) a.__h.push(a._sb[$]);
          a._sb = [];
        } else do {
          a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;
        } while (a.__d && ++C < 25);
        a.state = a.__s, null != a.getChildContext && (t = h$2(h$2({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === _$2 && null == s.key ? s.props.children : s, x$1(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), b && (a.__E = a.__ = null), a.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = N$1(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function M(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function N$1(l, u, i, t, r, o, f, e) {
    var s,
      a,
      h,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, e = !1;
    }
    if (null === d) y === p || e && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || c$2).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || ""));
      }
      if (H$1(l, p, y, r, e), h) u.__k = [];else if (_ = u.props.children, x$1(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && b$1(i, 0), e), null != o) for (_ = o.length; _--;) null != o[_] && v$2(o[_]);
      e || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && T$2(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && T$2(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function O(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function S(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || O(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && S(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || v$2(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function q$2(n, l, u) {
    return this.constructor(n, u);
  }
  function B$2(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], L$1(i, u = (!r && t || i).__k = y$2(_$2, null, [u]), o || c$2, c$2, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), M(f, u);
  }
  function E(l, u, i) {
    var t,
      r,
      o,
      f = h$2({}, l.props);
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p$2(l.type, f, t || l.key, r || l.ref, null);
  }
  function F$2(n, l) {
    var u = {
      __c: l = "__cC" + e$1++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(function (n) {
            n.__e = !0, m$1(n);
          });
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = s$2.slice, l$2 = {
    __e: function (n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$2 = 0, k$2.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h$2({}, this.state), "function" == typeof n && (n = n(h$2({}, u), this.props)), n && h$2(u, n), null != n && this.__v && (l && this._sb.push(l), m$1(this));
  }, k$2.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
  }, k$2.prototype.render = _$2, t$1 = [], o$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$2 = function (n, l) {
    return n.__v.__b - l.__v.__b;
  }, w$2.__r = 0, e$1 = 0;
  var _$1 = 0;
  function o$2(o, e, n, t, f, l) {
    var s,
      u,
      a = {};
    for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
    var i = {
      type: o,
      props: a,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: l
    };
    if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
    return l$2.vnode && l$2.vnode(i), i;
  }
  var t,
    r$2,
    u$1,
    i$1,
    o$1 = 0,
    f$1 = [],
    c$1 = [],
    e = l$2.__b,
    a$1 = l$2.__r,
    v$1 = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d$1(t, u) {
    l$2.__h && l$2.__h(r$2, t, o$1 || u), o$1 = 0;
    var i = r$2.__H || (r$2.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c$1
    }), i.__[t];
  }
  function h$1(n) {
    return o$1 = 1, s$1(B$1, n);
  }
  function s$1(n, u, i) {
    var o = d$1(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$2, !r$2.u)) {
      var f = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !c || c.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
      };
      r$2.u = !0;
      var c = r$2.shouldComponentUpdate,
        e = r$2.componentWillUpdate;
      r$2.componentWillUpdate = function (n, t, r) {
        if (this.__e) {
          var u = c;
          c = void 0, f(n, t, r), c = u;
        }
        e && e.call(this, n, t, r);
      }, r$2.shouldComponentUpdate = f;
    }
    return o.__N || o.__;
  }
  function p$1(u, i) {
    var o = d$1(t++, 3);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__H.__h.push(o));
  }
  function y$1(u, i) {
    var o = d$1(t++, 4);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__h.push(o));
  }
  function _(n) {
    return o$1 = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o$1 = 6, y$1(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d$1(t++, 7);
    return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o$1 = 8, F$1(function () {
      return n;
    }, t);
  }
  function q$1(n) {
    var u = r$2.context[n.__c],
      i = d$1(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$2)), u.props.value) : n.__;
  }
  function b() {
    for (var t; t = f$1.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$2 = null, e && e(n);
  }, l$2.__r = function (n) {
    a$1 && a$1(n), t = 0;
    var i = (r$2 = n.__c).__H;
    i && (u$1 === r$2 ? (i.__h = [], r$2.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c$1, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u$1 = r$2;
  }, l$2.diffed = function (t) {
    v$1 && v$1(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f$1.push(o) && i$1 === l$2.requestAnimationFrame || ((i$1 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c$1 && (n.__ = n.__V), n.i = void 0, n.__V = c$1;
    })), u$1 = r$2 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$2,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$2 = t;
  }
  function w$1(n) {
    var t = r$2;
    n.__c = n.__(), r$2 = t;
  }
  function z(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  let cached$1 = null;
  function getBuildModeUnmemoized$1() {
    try {
      if (process.env.NODE_ENV === "development") return "development";
      return "production";
    } catch (_e) {
      // As long as we're returning "production" due to it being unspecified, 
      // try to make sure anyone else who tries does too for consistency.
      // TODO: Good/bad idea?
      try {
        var _process, _globalThis$_process, _globalThis$process, _env, _globalThis$process$_, _globalThis$process$e, _NODE_ENV, _globalThis$process$e2;
        (_globalThis$_process = globalThis[_process = "process"]) !== null && _globalThis$_process !== void 0 ? _globalThis$_process : globalThis[_process] = {};
        (_globalThis$process$_ = (_globalThis$process = globalThis["process"])[_env = "env"]) !== null && _globalThis$process$_ !== void 0 ? _globalThis$process$_ : _globalThis$process[_env] = {};
        (_globalThis$process$e2 = (_globalThis$process$e = globalThis["process"]["env"])[_NODE_ENV = "NODE_ENV"]) !== null && _globalThis$process$e2 !== void 0 ? _globalThis$process$e2 : _globalThis$process$e[_NODE_ENV] = "production";
      } finally {
        return "production";
      }
    }
  }
  function getBuildMode$1() {
    var _cached$;
    return (_cached$ = cached$1) !== null && _cached$ !== void 0 ? _cached$ : cached$1 = getBuildModeUnmemoized$1();
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop$1() {
    // No operation performed.
  }

  // TODO: This shouldn't be in every build, I don't think it's in core-js? I think?
  // And it's extremely small anyway and basically does nothing.
  (_window$requestIdleCa = (_window = window).requestIdleCallback) !== null && _window$requestIdleCa !== void 0 ? _window$requestIdleCa : _window.requestIdleCallback = callback => {
    return setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => {
          return 0;
        }
      });
    }, 5);
  };
  function callCountU$1(hook) {
    return;
  }
  new Set();
  getBuildMode$1() == "development" ? callCountU$1 : noop$1;

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability$1(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    if (getBuildMode$1() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering$1(f) {
    var _l$2$debounceRenderin;
    ((_l$2$debounceRenderin = l$2.debounceRendering) !== null && _l$2$debounceRenderin !== void 0 ? _l$2$debounceRenderin : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState$1(onChange, getInitialValue, customDebounceRendering) {
    //let [id, ,getId] = useState(() => generateRandomId());
    const valueRef = _(Unset$3);
    const reasonRef = _(Unset$3);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$3);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability$1("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$3 && getInitialValue != undefined) {
        try {
          var _onChange;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$3) tryEnsureValue();
      return valueRef.current === Unset$3 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$3 ? undefined : valueRef.current) : arg;
      //let id = getId();
      //console.log((nextValue !== valueRef.current? "" : "NOT ") + "Scheduling effect ", id, " with value ", nextValue);
      if ( /*dependencyToCompareAgainst.current === Unset &&*/nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering$1)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          //let id = getId();
          //console.log(((dependencyToCompareAgainst.current != valueRef.current)? "" : "NOT ") + "Running effect ", id, " with value ", nextDep);
          if (dependencyToCompareAgainst.current != valueRef.current) {
            // TODO: This needs to happen here in order to make recursive onChanges work
            // but it feels better to have it happen after onChange...
            valueRef.current = dependencyToCompareAgainst.current = Unset$3;
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              valueRef.current = nextDep; // Needs to happen before onChange in case onChange is recursive (e.g. focusing causing a focus causing a focus)
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$3 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$3;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      //valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$3 = Symbol();
  function returnNull$1() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately$1(f) {
    f();
  }
  function useMergedChildren$1(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }
  function r$1(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx$1() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses$1(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx$1(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx$1(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  const toRun$1 = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  //
  // Also, in theory this could be replaced with `useInsertionEffect`,
  // but that probably won't be available in Preact for awhile.
  const commitName$1 = "diffed";
  const newCommit$1 = function (vnode) {
    for (const [id, effectInfo] of toRun$1) {
      const oldInputs = effectInfo.prevInputs;
      if (argsChanged$1(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        effectInfo.prevInputs = effectInfo.inputs;
      }
    }
    toRun$1.clear();
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    originalCommit$1 === null || originalCommit$1 === void 0 ? void 0 : originalCommit$1(vnode, ...args);
  };
  const originalCommit$1 = l$2[commitName$1];
  l$2[commitName$1] = newCommit$1;
  let incrementingId$1 = 0;
  function nextId$1() {
    let next = ++incrementingId$1;
    // TODO: This seems reasonable, but is is necessary or are we orders of magnitude from having to worry about overflow?
    if (incrementingId$1 >= Number.MAX_SAFE_INTEGER) incrementingId$1 = -Number.MAX_SAFE_INTEGER;
    return next;
  }
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect$1(effect, inputs) {
    var _ref$current;
    // Note to self: This is by far the most called hook by sheer volume of dependencies.
    // So it should ideally be as quick as possible.
    const ref = _(null);
    (_ref$current = ref.current) !== null && _ref$current !== void 0 ? _ref$current : ref.current = nextId$1();
    const id = ref.current;
    if (effect) toRun$1.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun$1.delete(id);
    // Not needed, because the insertion cleanup would run before useEffect anyway, I think?
    /*useEffect(() => {
        return () => {
            toRun.delete(id);
        }
    }, [id])*/
  }

  function argsChanged$1(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset$2 = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter$1(value) {
    const ref = _(Unset$2);
    useBeforeLayoutEffect$1(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset$2) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject$1(t) {
    const e = Object.entries(t);
    useEnsureStability$1("useStableObject", e.length, ...e.map(_ref => {
      let [_k, v] = _ref;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map$1 = new WeakMap();
  function isStableGetter$1(obj) {
    var _map$1$get;
    return (_map$1$get = map$1.get(obj)) !== null && _map$1$get !== void 0 ? _map$1$get : false;
  }
  function setIsStableGetter$1(obj) {
    map$1.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback$1(fn, noDeps) {
    useEnsureStability$1("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter$1(fn));
    if (isStableGetter$1(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter$1(fn);
      return setIsStableGetter$1(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter$1(T$1(fn, []));
    }
  }
  function processRef$1(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs$1(rhs, lhs) {
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback$1(function combined(current) {
      processRef$1(current, lhs);
      processRef$1(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject$1(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles$1(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles$1(styleStringToObject$1(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles$1(lhs, styleStringToObject$1(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log$1 = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps$1() {
    for (var _len3 = arguments.length, allProps = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      allProps[_key3] = arguments[_key3];
    }
    useEnsureStability$1("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2$1(ret, nextProps);
    }
    return ret;
  }
  const knowns$1 = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown$1(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions$1(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log$1 === null || log$1 === void 0 ? void 0 : log$1("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2$1(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs$1(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles$1(lhsAll.style, rhsAll.style),
      className: useMergedClasses$1(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren$1(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns$1.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns$1.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown$1(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions$1(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren$1(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildrenCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability$1("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildrenCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildrenCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) {
          if (f(child) == 'break') return;
        }
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) if (f(child) == 'break') return;
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering$1(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildrenCountChange || onChildrenMountChange) {
          debounceRendering$1(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildrenCountChange === null || onChildrenCountChange === void 0 ? void 0 : onChildrenCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject$1({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject$1({
        managedChildContext: useStableObject$1({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild$1(_ref2) {
    let {
      context,
      info
    } = _ref2;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = context !== null && context !== void 0 ? context : {
      managedChildContext: {}
    };
    const index = info.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...info
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...info
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState$1(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * `"mode"` controls if there's one handler that calls all your functions (default), or one handler added per function (`"single"`).
   *
   * The default, `"grouped"`, is faster when you have, say, a button component, used hundreds of times on a page, that each installs a global event handler.
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options, mode) {
    mode || (mode = "grouped");
    useEnsureStability$1("useGlobalHandler", mode);
    if (mode === "grouped") {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      useGlobalHandlerGrouped(target, type, handler, options);
    } else {
      useGlobalHandlerSingle(target, type, handler, options);
    }
  }
  let mapThing = new Map();
  function doMapThing(op, target, type, handler, options) {
    if (handler) {
      const optionsKey = JSON.stringify(options);
      const byType = mapThing.get(target) || new Map();
      const byOptions = byType.get(type) || new Map();
      const info = byOptions.get(optionsKey) || {
        listener: null,
        listeners: new Set()
      };
      op(info, handler);
      byOptions.set(optionsKey, info);
      byType.set(type, byOptions);
      mapThing.set(target, byType);
    }
  }
  function addToMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.add(h);
      if (info.listener == null) target.addEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  function removeFromMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.delete(h);
      if (info.listener == null) target.removeEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  /**
   * This is way faster for large numbers of event handlers.
   *
   * For example, if every button listens for a global click, or something,
   * it would be nice if it was efficient at least.
   */
  function useGlobalHandlerGrouped(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        addToMapThing(target, type, stableHandler, options);
        return () => removeFromMapThing(target, type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }
  function useGlobalHandlerSingle(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: ElementProps<E>[]): ElementProps<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement$1(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability$1("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState$1(handler, returnNull$1, runImmediately$1);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      propsStable: propsStable.current,
      refElementReturn: {
        getElement
      }
    };
  }
  new Map();
  new Map();
  new Map();
  new Map();

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck$1(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass$1(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck$1(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass$1(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck$1(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass$1(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();
  function g(n, t) {
    for (var e in t) n[e] = t[e];
    return n;
  }
  function C(n, t) {
    for (var e in n) if ("__source" !== e && !(e in t)) return !0;
    for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function x(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, y$2(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new k$2()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var R = l$2.__b;
  l$2.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$2.__e;
  l$2.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    T(n, t, e, r);
  };
  var I = l$2.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$2.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new k$2()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && y$2(_$2, null, n.fallback);
    return i && (i.__h = null), [y$2(_$2, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) e.pop()();
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  (V.prototype = new k$2()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = P(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var B = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    H = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
    Y = /[A-Z0-9]/g,
    $ = "undefined" != typeof document,
    q = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
    };
  k$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(k$2.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var K = l$2.event;
  function Q() {}
  function X() {
    return this.cancelBubble;
  }
  function nn() {
    return this.defaultPrevented;
  }
  l$2.event = function (n) {
    return K && (n = K(n)), n.persist = Q, n.isPropagationStopped = X, n.isDefaultPrevented = nn, n.nativeEvent = n;
  };
  var en = {
      enumerable: !1,
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    rn = l$2.vnode;
  l$2.vnode = function (n) {
    "string" == typeof n.type && function (n) {
      var t = n.props,
        e = n.type,
        u = {};
      for (var o in t) {
        var i = t[o];
        if (!("value" === o && "defaultValue" in t && null == i || $ && "children" === o && "noscript" === e || "class" === o || "className" === o)) {
          var l = o.toLowerCase();
          "defaultValue" === o && "value" in t && null == t.value ? o = "value" : "download" === o && !0 === i ? i = "" : "ondoubleclick" === l ? o = "ondblclick" : "onchange" !== l || "input" !== e && "textarea" !== e || q(t.type) ? "onfocus" === l ? o = "onfocusin" : "onblur" === l ? o = "onfocusout" : Z.test(o) ? o = l : -1 === e.indexOf("-") && H.test(o) ? o = o.replace(Y, "-$&").toLowerCase() : null === i && (i = void 0) : l = o = "oninput", "oninput" === l && u[o = l] && (o = "oninputCapture"), u[o] = i;
        }
      }
      "select" == e && u.multiple && Array.isArray(u.value) && (u.value = P(t.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == e && null != u.defaultValue && (u.value = P(t.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), t.class && !t.className ? (u.class = t.class, Object.defineProperty(u, "className", en)) : (t.className && !t.class || t.class && t.className) && (u.class = u.className = t.className), n.props = u;
    }(n), n.$$typeof = B, rn && rn(n);
  };
  var un = l$2.__r;
  l$2.__r = function (n) {
    un && un(n), n.__c;
  };
  var on = l$2.diffed;
  l$2.diffed = function (n) {
    on && on(n);
    var t = n.props,
      e = n.__e;
    null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value);
  };
  let templateElement$1 = null;
  function htmlToElement$1(parent, html) {
    var _templateElement$;
    const document = parent.ownerDocument;
    (_templateElement$ = templateElement$1) !== null && _templateElement$ !== void 0 ? _templateElement$ : templateElement$1 = document.createElement("template");
    templateElement$1.innerHTML = html.trim(); // TODO: Trim ensures whitespace doesn't add anything, but with a better explanation of why
    return templateElement$1.content.firstChild;
  }
  /**
   * Easy access to an HTMLElement that can be controlled imperatively.
   *
   * The HTMLElement rendered is controlled by the `tag` prop (e.g. "span", "div").
   *
   * The `handle` prop should be e.g. `useRef<ImperativeHandle<HTMLDivElement>>(null)`
   */
  x(k(ImperativeElementU$1));
  function useImperativeProps$1(_ref3) {
    let {
      refElementReturn: {
        getElement
      }
    } = _ref3;
    const currentImperativeProps = _({
      className: new Set(),
      style: {},
      children: null,
      html: null,
      others: {}
    });
    const hasClass = T$1(cls => {
      return currentImperativeProps.current.className.has(cls);
    }, []);
    const setClass = T$1((cls, enabled) => {
      if (hasClass(cls) == !enabled) {
        var _getElement;
        (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.classList[enabled ? "add" : "remove"](cls);
        currentImperativeProps.current.className[enabled ? "add" : "delete"](cls);
      }
    }, []);
    const setStyle = T$1((prop, value) => {
      const element = getElement();
      if (element) {
        if (currentImperativeProps.current.style[prop] != value) {
          currentImperativeProps.current.style[prop] = value;
          if (prop.startsWith("--")) {
            if (value != null) element.style.setProperty(prop, "".concat(value));else element.style.removeProperty(prop);
          } else {
            element.style[prop] = value !== null && value !== void 0 ? value : "";
          }
        }
      }
    }, []);
    const setChildren = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.children != children) {
        currentImperativeProps.current.children = children;
        currentImperativeProps.current.html = null;
        e.textContent = children;
      }
    }, []);
    const dangerouslySetInnerHTML = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.html != children) {
        currentImperativeProps.current.html = children;
        currentImperativeProps.current.children = null;
        e.innerHTML = children;
      }
    }, []);
    const dangerouslyAppendHTML = T$1(children => {
      let e = getElement();
      if (e && children) {
        const newChild = htmlToElement$1(e, children);
        console.assert(newChild && newChild instanceof Node);
        if (newChild && newChild instanceof Node) {
          e.appendChild(newChild);
          return newChild;
        }
      }
      return null;
    }, []);
    const getAttribute = T$1(prop => {
      return currentImperativeProps.current.others[prop];
    }, []);
    const setAttribute = T$1((prop, value) => {
      if (value != null) {
        if (getAttribute(prop) != value) {
          var _getElement2;
          currentImperativeProps.current.others[prop] = value;
          (_getElement2 = getElement()) === null || _getElement2 === void 0 ? void 0 : _getElement2.setAttribute(prop, value);
        }
      } else {
        if (getAttribute(prop) != undefined) {
          var _getElement3;
          delete currentImperativeProps.current.others[prop];
          (_getElement3 = getElement()) === null || _getElement3 === void 0 ? void 0 : _getElement3.removeAttribute(prop);
        }
      }
    }, []);
    const setEventHandler = T$1((type, handler, options) => {
      const element = getElement();
      const mappedKey = EventMapping$1[type];
      if (element) {
        if (handler) {
          element.addEventListener(type, handler, options);
          currentImperativeProps.current.others[mappedKey] = handler;
        } else if (currentImperativeProps.current.others[mappedKey]) {
          element.removeEventListener(type, currentImperativeProps.current.others[mappedKey], options);
          currentImperativeProps.current.others[mappedKey] = undefined;
        }
      }
    }, []);
    return {
      imperativeHandle: _({
        hasClass,
        setClass,
        setStyle,
        getAttribute,
        setAttribute,
        setEventHandler,
        setChildren,
        dangerouslySetInnerHTML,
        dangerouslyAppendHTML
      }).current,
      props: useMergedProps$1({
        className: [...currentImperativeProps.current.className].join(" "),
        style: currentImperativeProps.current.style
      }, currentImperativeProps.current.others)
    };
  }
  function ImperativeElementU$1(_ref4, ref) {
    let {
      tag: Tag,
      handle,
      ...props
    } = _ref4;
    const {
      propsStable,
      refElementReturn
    } = useRefElement$1({
      refElementParameters: {}
    });
    const {
      props: iprops,
      imperativeHandle
    } = useImperativeProps$1({
      refElementReturn
    });
    A(handle, () => imperativeHandle);
    return y$2(Tag, useMergedProps$1(propsStable, iprops, props, {
      ref
    }));
  }
  const EventMapping$1 = {
    abort: "onAbort",
    animationend: "onAnimationEnd",
    animationstart: "onAnimationStart",
    animationiteration: "onAnimationIteration",
    beforeinput: "onBeforeInput",
    blur: "onBlur",
    canplay: "onCanPlay",
    canplaythrough: "onCanPlayThrough",
    change: "onChange",
    click: "onClick",
    compositionend: "onCompositionEnd",
    compositionstart: "onCompositionStart",
    compositionupdate: "onCompositionUpdate",
    contextmenu: "onContextMenu",
    cut: "onCut",
    dblclick: "onDblClick",
    drag: "onDrag",
    dragend: "onDragEnd",
    dragenter: "onDragEnter",
    dragleave: "onDragLeave",
    dragover: "onDragOver",
    dragstart: "onDragStart",
    drop: "onDrop",
    durationchange: "onDurationChange",
    emptied: "onEmptied",
    ended: "onEnded",
    error: "onError",
    focus: "onFocus",
    focusin: "onfocusin",
    focusout: "onfocusout",
    formdata: "onFormData",
    gotpointercapture: "onGotPointerCapture",
    input: "onInput",
    invalid: "onInvalid",
    keydown: "onKeyDown",
    keypress: "onKeyPress",
    keyup: "onKeyUp",
    load: "onLoad",
    loadeddata: "onLoadedData",
    loadedmetadata: "onLoadedMetadata",
    loadstart: "onLoadStart",
    lostpointercapture: "onLostPointerCapture",
    mousedown: "onMouseDown",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseover: "onMouseOver",
    mouseup: "onMouseUp",
    paste: "onPaste",
    pause: "onPause",
    play: "onPlay",
    playing: "onPlaying",
    pointercancel: "onPointerCancel",
    pointerdown: "onPointerDown",
    pointerenter: "onPointerEnter",
    pointerleave: "onPointerLeave",
    pointermove: "onPointerMove",
    pointerout: "onPointerOut",
    pointerover: "onPointerOver",
    pointerup: "onPointerUp",
    progress: "onProgress",
    reset: "onReset",
    scroll: "onScroll",
    seeked: "onSeeked",
    seeking: "onSeeking",
    select: "onSelect",
    stalled: "onStalled",
    submit: "onSubmit",
    suspend: "onSuspend",
    timeupdate: "onTimeUpdate",
    toggle: "onToggle",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart",
    transitionend: "onTransitionEnd",
    volumechange: "onVolumeChange",
    waiting: "onWaiting",
    wheel: "onWheel"
  };
  F$2(null);
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  let cached = null;
  function getBuildModeUnmemoized() {
    try {
      if (process.env.NODE_ENV === "development") return "development";
      return "production";
    } catch (_e) {
      // As long as we're returning "production" due to it being unspecified, 
      // try to make sure anyone else who tries does too for consistency.
      // TODO: Good/bad idea?
      try {
        var _process2, _globalThis$_process2, _globalThis$process2, _env2, _globalThis$process2$, _globalThis$process$e3, _NODE_ENV2, _globalThis$process$e4;
        (_globalThis$_process2 = globalThis[_process2 = "process"]) !== null && _globalThis$_process2 !== void 0 ? _globalThis$_process2 : globalThis[_process2] = {};
        (_globalThis$process2$ = (_globalThis$process2 = globalThis["process"])[_env2 = "env"]) !== null && _globalThis$process2$ !== void 0 ? _globalThis$process2$ : _globalThis$process2[_env2] = {};
        (_globalThis$process$e4 = (_globalThis$process$e3 = globalThis["process"]["env"])[_NODE_ENV2 = "NODE_ENV"]) !== null && _globalThis$process$e4 !== void 0 ? _globalThis$process$e4 : _globalThis$process$e3[_NODE_ENV2] = "production";
      } finally {
        return "production";
      }
    }
  }
  function getBuildMode() {
    var _cached;
    return (_cached = cached) !== null && _cached !== void 0 ? _cached : cached = getBuildModeUnmemoized();
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();
  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];
  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');
  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  // TODO: This shouldn't be in every build, I don't think it's in core-js? I think?
  // And it's extremely small anyway and basically does nothing.
  (_window2$requestIdleC = (_window2 = window).requestIdleCallback) !== null && _window2$requestIdleC !== void 0 ? _window2$requestIdleC : _window2.requestIdleCallback = callback => {
    return setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => {
          return 0;
        }
      });
    }, 5);
  };
  function callCountU(hook) {
    return;
  }
  new Set();
  getBuildMode() == "development" ? callCountU : noop;

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      values[_key4 - 1] = arguments[_key4];
    }
    if (getBuildMode() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$2$debounceRenderin2;
    ((_l$2$debounceRenderin2 = l$2.debounceRendering) !== null && _l$2$debounceRenderin2 !== void 0 ? _l$2$debounceRenderin2 : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    //let [id, ,getId] = useState(() => generateRandomId());
    const valueRef = _(Unset$1);
    const reasonRef = _(Unset$1);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$1);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange3;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange3 = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange3 !== void 0 ? _onChange3 : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      //let id = getId();
      //console.log((nextValue !== valueRef.current? "" : "NOT ") + "Scheduling effect ", id, " with value ", nextValue);
      if ( /*dependencyToCompareAgainst.current === Unset &&*/nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          //let id = getId();
          //console.log(((dependencyToCompareAgainst.current != valueRef.current)? "" : "NOT ") + "Running effect ", id, " with value ", nextDep);
          if (dependencyToCompareAgainst.current != valueRef.current) {
            // TODO: This needs to happen here in order to make recursive onChanges work
            // but it feels better to have it happen after onChange...
            valueRef.current = dependencyToCompareAgainst.current = Unset$1;
            warningRef.current = true;
            try {
              var _onChange4;
              // Call any registered cleanup function
              onShouldCleanUp();
              valueRef.current = nextDep; // Needs to happen before onChange in case onChange is recursive (e.g. focusing causing a focus causing a focus)
              cleanupCallbackRef.current = (_onChange4 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange4 !== void 0 ? _onChange4 : undefined;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      //valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$1 = Symbol();
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  const toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  //
  // Also, in theory this could be replaced with `useInsertionEffect`,
  // but that probably won't be available in Preact for awhile.
  const commitName = "diffed";
  const newCommit = function (vnode) {
    for (const [id, effectInfo] of toRun) {
      const oldInputs = effectInfo.prevInputs;
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup2;
        (_effectInfo$cleanup2 = effectInfo.cleanup) === null || _effectInfo$cleanup2 === void 0 ? void 0 : _effectInfo$cleanup2.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        effectInfo.prevInputs = effectInfo.inputs;
      }
    }
    toRun.clear();
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(vnode, ...args);
  };
  const originalCommit = l$2[commitName];
  l$2[commitName] = newCommit;
  let incrementingId = 0;
  function nextId() {
    let next = ++incrementingId;
    // TODO: This seems reasonable, but is is necessary or are we orders of magnitude from having to worry about overflow?
    if (incrementingId >= Number.MAX_SAFE_INTEGER) incrementingId = -Number.MAX_SAFE_INTEGER;
    return next;
  }
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    var _ref$current2;
    // Note to self: This is by far the most called hook by sheer volume of dependencies.
    // So it should ideally be as quick as possible.
    const ref = _(null);
    (_ref$current2 = ref.current) !== null && _ref$current2 !== void 0 ? _ref$current2 : ref.current = nextId();
    const id = ref.current;
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    // Not needed, because the insertion cleanup would run before useEffect anyway, I think?
    /*useEffect(() => {
        return () => {
            toRun.delete(id);
        }
    }, [id])*/
  }

  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    const ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    const e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref5 => {
      let [_k, v] = _ref5;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback(function combined(current) {
      processRef(current, lhs);
      processRef(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len6 = arguments.length, allProps = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      allProps[_key6] = arguments[_key6];
    }
    useEnsureStability("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  const knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildrenCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildrenCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildrenCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) {
          if (f(child) == 'break') return;
        }
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) if (f(child) == 'break') return;
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildrenCountChange || onChildrenMountChange) {
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildrenCountChange === null || onChildrenCountChange === void 0 ? void 0 : onChildrenCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(_ref6) {
    let {
      context,
      info
    } = _ref6;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = context !== null && context !== void 0 ? context : {
      managedChildContext: {}
    };
    const index = info.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...info
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...info
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref7) {
    let {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref7;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    const [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    // Shared between onChildrenMountChange and changeIndex, not public
    // Only called when `closestFit` is false, naturally.
    const getClosestFit = T$1(requestedIndex => {
      const children = getChildren();
      let closestDistance = Infinity;
      let closestIndex = null;
      children.forEach(child => {
        if (child != null && isValid(child)) {
          console.assert(typeof child.index == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    const reevaluateClosestFit = useStableCallback(() => {
      const children = getChildren();
      const requestedIndex = getRequestedIndex();
      const currentIndex = getCurrentIndex();
      const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
        const closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (currentChild) setAt(currentChild, false, closestFitIndex, currentIndex);
        if (closestFitIndex != null) {
          const closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true, closestFitIndex, currentIndex);
        }
      }
    });
    const changeIndex = T$1((arg, reason) => {
      const children = getChildren();
      const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      setRequestedIndex(requestedIndex, reason);
      const currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
        return null;
      } else {
        const childIsValid = newMatchingChild && isValid(newMatchingChild);
        if (childIsValid || !closestFit) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
          if (newMatchingChild) setAt(newMatchingChild, true, requestedIndex, currentIndex);
          return requestedIndex;
        } else {
          console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            setAt(newMatchingChild, true, closestFitIndex, currentIndex);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    y$1(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }
  new Map();

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: ElementProps<E>[]): ElementProps<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      propsStable: propsStable.current,
      refElementReturn: {
        getElement
      }
    };
  }
  new Map();
  new Map();
  new Map();
  new Map();

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();
  let templateElement = null;
  function htmlToElement(parent, html) {
    var _templateElement;
    const document = parent.ownerDocument;
    (_templateElement = templateElement) !== null && _templateElement !== void 0 ? _templateElement : templateElement = document.createElement("template");
    templateElement.innerHTML = html.trim(); // TODO: Trim ensures whitespace doesn't add anything, but with a better explanation of why
    return templateElement.content.firstChild;
  }
  /**
   * Easy access to an HTMLElement that can be controlled imperatively.
   *
   * The HTMLElement rendered is controlled by the `tag` prop (e.g. "span", "div").
   *
   * The `handle` prop should be e.g. `useRef<ImperativeHandle<HTMLDivElement>>(null)`
   */
  x(k(ImperativeElementU));
  function useImperativeProps(_ref8) {
    let {
      refElementReturn: {
        getElement
      }
    } = _ref8;
    const currentImperativeProps = _({
      className: new Set(),
      style: {},
      children: null,
      html: null,
      others: {}
    });
    const hasClass = T$1(cls => {
      return currentImperativeProps.current.className.has(cls);
    }, []);
    const setClass = T$1((cls, enabled) => {
      if (hasClass(cls) == !enabled) {
        var _getElement4;
        (_getElement4 = getElement()) === null || _getElement4 === void 0 ? void 0 : _getElement4.classList[enabled ? "add" : "remove"](cls);
        currentImperativeProps.current.className[enabled ? "add" : "delete"](cls);
      }
    }, []);
    const setStyle = T$1((prop, value) => {
      const element = getElement();
      if (element) {
        if (currentImperativeProps.current.style[prop] != value) {
          currentImperativeProps.current.style[prop] = value;
          if (prop.startsWith("--")) {
            if (value != null) element.style.setProperty(prop, "".concat(value));else element.style.removeProperty(prop);
          } else {
            element.style[prop] = value !== null && value !== void 0 ? value : "";
          }
        }
      }
    }, []);
    const setChildren = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.children != children) {
        currentImperativeProps.current.children = children;
        currentImperativeProps.current.html = null;
        e.textContent = children;
      }
    }, []);
    const dangerouslySetInnerHTML = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.html != children) {
        currentImperativeProps.current.html = children;
        currentImperativeProps.current.children = null;
        e.innerHTML = children;
      }
    }, []);
    const dangerouslyAppendHTML = T$1(children => {
      let e = getElement();
      if (e && children) {
        const newChild = htmlToElement(e, children);
        console.assert(newChild && newChild instanceof Node);
        if (newChild && newChild instanceof Node) {
          e.appendChild(newChild);
          return newChild;
        }
      }
      return null;
    }, []);
    const getAttribute = T$1(prop => {
      return currentImperativeProps.current.others[prop];
    }, []);
    const setAttribute = T$1((prop, value) => {
      if (value != null) {
        if (getAttribute(prop) != value) {
          var _getElement5;
          currentImperativeProps.current.others[prop] = value;
          (_getElement5 = getElement()) === null || _getElement5 === void 0 ? void 0 : _getElement5.setAttribute(prop, value);
        }
      } else {
        if (getAttribute(prop) != undefined) {
          var _getElement6;
          delete currentImperativeProps.current.others[prop];
          (_getElement6 = getElement()) === null || _getElement6 === void 0 ? void 0 : _getElement6.removeAttribute(prop);
        }
      }
    }, []);
    const setEventHandler = T$1((type, handler, options) => {
      const element = getElement();
      const mappedKey = EventMapping[type];
      if (element) {
        if (handler) {
          element.addEventListener(type, handler, options);
          currentImperativeProps.current.others[mappedKey] = handler;
        } else if (currentImperativeProps.current.others[mappedKey]) {
          element.removeEventListener(type, currentImperativeProps.current.others[mappedKey], options);
          currentImperativeProps.current.others[mappedKey] = undefined;
        }
      }
    }, []);
    return {
      imperativeHandle: _({
        hasClass,
        setClass,
        setStyle,
        getAttribute,
        setAttribute,
        setEventHandler,
        setChildren,
        dangerouslySetInnerHTML,
        dangerouslyAppendHTML
      }).current,
      props: useMergedProps({
        className: [...currentImperativeProps.current.className].join(" "),
        style: currentImperativeProps.current.style
      }, currentImperativeProps.current.others)
    };
  }
  function ImperativeElementU(_ref9, ref) {
    let {
      tag: Tag,
      handle,
      ...props
    } = _ref9;
    const {
      propsStable,
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    const {
      props: iprops,
      imperativeHandle
    } = useImperativeProps({
      refElementReturn
    });
    A(handle, () => imperativeHandle);
    return y$2(Tag, useMergedProps(propsStable, iprops, props, {
      ref
    }));
  }
  const EventMapping = {
    abort: "onAbort",
    animationend: "onAnimationEnd",
    animationstart: "onAnimationStart",
    animationiteration: "onAnimationIteration",
    beforeinput: "onBeforeInput",
    blur: "onBlur",
    canplay: "onCanPlay",
    canplaythrough: "onCanPlayThrough",
    change: "onChange",
    click: "onClick",
    compositionend: "onCompositionEnd",
    compositionstart: "onCompositionStart",
    compositionupdate: "onCompositionUpdate",
    contextmenu: "onContextMenu",
    cut: "onCut",
    dblclick: "onDblClick",
    drag: "onDrag",
    dragend: "onDragEnd",
    dragenter: "onDragEnter",
    dragleave: "onDragLeave",
    dragover: "onDragOver",
    dragstart: "onDragStart",
    drop: "onDrop",
    durationchange: "onDurationChange",
    emptied: "onEmptied",
    ended: "onEnded",
    error: "onError",
    focus: "onFocus",
    focusin: "onfocusin",
    focusout: "onfocusout",
    formdata: "onFormData",
    gotpointercapture: "onGotPointerCapture",
    input: "onInput",
    invalid: "onInvalid",
    keydown: "onKeyDown",
    keypress: "onKeyPress",
    keyup: "onKeyUp",
    load: "onLoad",
    loadeddata: "onLoadedData",
    loadedmetadata: "onLoadedMetadata",
    loadstart: "onLoadStart",
    lostpointercapture: "onLostPointerCapture",
    mousedown: "onMouseDown",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseover: "onMouseOver",
    mouseup: "onMouseUp",
    paste: "onPaste",
    pause: "onPause",
    play: "onPlay",
    playing: "onPlaying",
    pointercancel: "onPointerCancel",
    pointerdown: "onPointerDown",
    pointerenter: "onPointerEnter",
    pointerleave: "onPointerLeave",
    pointermove: "onPointerMove",
    pointerout: "onPointerOut",
    pointerover: "onPointerOver",
    pointerup: "onPointerUp",
    progress: "onProgress",
    reset: "onReset",
    scroll: "onScroll",
    seeked: "onSeeked",
    seeking: "onSeeking",
    select: "onSelect",
    stalled: "onStalled",
    submit: "onSubmit",
    suspend: "onSuspend",
    timeupdate: "onTimeUpdate",
    toggle: "onToggle",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart",
    transitionend: "onTransitionEnd",
    volumechange: "onVolumeChange",
    waiting: "onWaiting",
    wheel: "onWheel"
  };
  F$2(null);
  function getExclusiveTransitionContextPrememoization(exclusivityKey) {
    if (exclusivityKey == null) return null;
    return F$2(null);
  }
  const SwappableContext = F$2({
    getAnimateOnMount: () => false
  });
  /**
   * Returns the context for a given `exclusivityKey`, creating one if it doesn't already exist.
   *
   * If
   */
  const GetExclusiveTransitionContext = memoize(getExclusiveTransitionContextPrememoization);
  const CssClassContext = F$2({
    GetBaseClass: () => "ptl",
    GetEnterClass: () => "n",
    GetExitClass: () => "x",
    GetMeasureClass: () => "m",
    GetInitClass: () => "i",
    GetTransitionClass: () => "t",
    GetFinalizeClass: () => "f"
  });
  function useCssClasses() {
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass
    } = q$1(CssClassContext);
    const GetDirectionClass = T$1(direction => {
      switch (direction) {
        case "enter":
          return GetEnterClass();
        case "exit":
          return GetExitClass();
      }
    }, []);
    const GetPhaseClass = T$1(phase => {
      switch (phase) {
        case "measure":
          return GetMeasureClass();
        case "init":
          return GetInitClass();
        case "transition":
          return GetTransitionClass();
        case "finalize":
          return GetFinalizeClass();
      }
    }, []);
    return {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    };
  }
  let globalCount = -1;
  function ExclusiveTransitionProvider(_ref10) {
    let {
      exclusivityKey,
      children
    } = _ref10;
    useEnsureStability("ExclusiveTransitionProvider", exclusivityKey);
    const [getNextIndexInLine, setNextIndexInLine] = usePassiveState(null);
    const {
      context,
      managedChildrenReturn,
      managedChildrenReturn: {
        getChildren
      }
    } = useManagedChildren({
      managedChildrenParameters: {}
    });
    const {
      changeIndex,
      getCurrentIndex
    } = useChildrenFlag({
      getChildren,
      closestFit: false,
      initialIndex: null,
      onIndexChange: null,
      setAt: T$1((m, v) => {
        m.setExclusivelyOpen(v);
      }, []),
      getAt: T$1(m => m.getExclusivelyOpen(), []),
      isValid: T$1(m => {
        return true;
      }, [])
    });
    const onVisibilityChange = T$1((index, visible) => {
      const nextInLine = getNextIndexInLine();
      const currentInLine = getCurrentIndex();
      if (visible == "show" && index != currentInLine) {
        /**
         * When a child transition shows itself initially
         * (i.e. requests itself to be the exclusive transition)
         * we either let it open immediately if there's no one finishing their exit,
         * or wait until that aforementioned exit has finished.
         */
        if (currentInLine == null) {
          changeIndex(index);
        } else {
          var _getChildren$getAt, _getChildren$getAt$fo;
          (_getChildren$getAt = getChildren().getAt(currentInLine)) === null || _getChildren$getAt === void 0 ? void 0 : (_getChildren$getAt$fo = _getChildren$getAt.forceClose) === null || _getChildren$getAt$fo === void 0 ? void 0 : _getChildren$getAt$fo.call(_getChildren$getAt);
          setNextIndexInLine(index);
        }
      } else if (visible == "hidden") {
        /**
         * When a child transition has finished its exit transition,
         * make sure that if someone requested to be shown in the meantime
         * that we do so.
         */
        if (nextInLine != null) {
          changeIndex(nextInLine);
          setNextIndexInLine(null);
        } else {
          changeIndex(null);
        }
      }
    }, []);
    const context2 = useStableObject({
      ...context,
      exclusiveTransitionContext: useStableObject({
        exclusivityKey,
        onVisibilityChange
      })
    });
    const ExclusiveTransitionContext = GetExclusiveTransitionContext(exclusivityKey);
    return ExclusiveTransitionContext == null ? children !== null && children !== void 0 ? children : null : o$2(ExclusiveTransitionContext.Provider, {
      value: context2,
      children: children
    });
  }
  function useExclusiveTransition(_ref11) {
    let {
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        forceClose,
        exclusivityKey
      }
    } = _ref11;
    const c = GetExclusiveTransitionContext(exclusivityKey);
    useEnsureStability("useExclusiveTransition", c == null);
    const context = c ? q$1(c) : null;
    const index = F$1(() => {
      globalCount += 1;
      return globalCount.toString();
    }, []);
    const [exclusivelyOpen, setExclusivelyOpen, getExclusivelyOpen] = useState(!!show);
    useManagedChild({
      context,
      info: {
        index,
        getExclusivelyOpen,
        setExclusivelyOpen,
        forceClose
      }
    });
    const parentOnVisChange = context === null || context === void 0 ? void 0 : context.exclusiveTransitionContext.onVisibilityChange;
    const onVisibilityChange = T$1(visible => {
      parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, visible == false ? "hidden" : "show");
    }, [parentOnVisChange, index]);
    y$1(() => {
      if (show) parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, "show");
    }, [show, parentOnVisChange, index]);
    return {
      exclusiveTransitionReturn: {
        isExclusive: context != null,
        exclusivelyOpen,
        setExclusivelyOpen,
        getExclusivelyOpen,
        onVisibilityChange
      }
    };
  }

  /**
   * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
   * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
   *
   * TODO: Still needed?
   */
  function forwardElementRef(Component) {
    const ForwardedComponent = k(Component);
    return ForwardedComponent;
  }
  /**
   * Useful in particular for Slides with a Tab Panel --
   * if we do Math.sign(currentIndex - slideIndex), it
   * transitions nicely in the expected direction,
   * but we need to "remember" which direction to use
   * when it's the current panel (and the difference is 0)
   */
  function useLastNonNullValue(value) {
    const lastNonNullValue = _(null);
    p$1(() => {
      if (value != null) lastNonNullValue.current = value;
    }, [value]);
    return value !== null && value !== void 0 ? value : lastNonNullValue.current;
  }

  /**
   * Creates a set of props that implement a swap container.
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useCreateSwappableProps(_ref12, otherProps) {
    let {
      inline
    } = _ref12;
    const {
      GetBaseClass
    } = useCssClasses();
    return useMergedProps({
      className: clsx("".concat(GetBaseClass(), "-swap-container"), inline && "".concat(GetBaseClass(), "-swap-container-inline"))
    }, otherProps);
  }
  /**
   * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
   *
   * You must manage each child `<Transitionable>` component's `show` prop -- this component *does not* manage any sort of state in that regard.
   *
   * If you pass a regular element (like a div) or other single component, then thee props and ref will be forwarded onto that element. Otherwise, all the children will be wrapped in a div or span depending on the `inline` prop.
   * @param param0
   * @returns
   */
  const Swappable = x(forwardElementRef(function Swappable(_ref13, ref) {
    var _inline;
    let {
      children: c,
      inline,
      childrenAnimateOnMount,
      exclusivityKey,
      ...p
    } = _ref13;
    let children = c;
    if (!children.type) children = !inline ? o$2("div", {
      children: children
    }) : o$2("span", {
      children: children
    });
    (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
    const transitionProps = useCreateSwappableProps({
      inline
    }, {
      ...p,
      ref
    });
    const mergedWithChildren = useMergedProps(transitionProps, children.props);
    const animateOnMount = _(childrenAnimateOnMount !== null && childrenAnimateOnMount !== void 0 ? childrenAnimateOnMount : false);
    p$1(() => {
      animateOnMount.current = true;
    }, []);
    const contextValue = _({
      getAnimateOnMount: () => {
        return animateOnMount.current;
      }
    });
    let ret = E(children, mergedWithChildren);
    ret = o$2(SwappableContext.Provider, {
      value: contextValue.current,
      children: ret
    });
    if (exclusivityKey) {
      ret = o$2(ExclusiveTransitionProvider, {
        exclusivityKey: exclusivityKey,
        children: ret
      }, exclusivityKey);
    }
    return ret;
  }));
  // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
  // Not perfect, but it's not supposed to be. `inline` is for perfect.
  const inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
  function getTimeoutDuration(element) {
    return Math.max(...window.getComputedStyle(element || document.body).getPropertyValue("transition-duration").split(",").map(str => {
      if (str.endsWith("ms")) return +str.substring(0, str.length - 2);
      if (str.endsWith("s")) return +str.substring(0, str.length - 1) * 1000;
      return 1000;
    }));
  }
  function parseState(nextState) {
    return nextState.split("-");
  }
  /**
   * Provide props that can be used to animate a transition.
   *
   * @param param0
   * @returns
   */
  function useTransition(_ref14) {
    var _animateOnMount, _measure, _easingIn, _easingOut;
    let {
      transitionParameters: {
        propsIncoming: {
          children,
          ...p
        },
        show,
        animateOnMount,
        measure,
        exitVisibility,
        duration,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    } = _ref14;
    useEnsureStability("useTransition", onVisibilityChange);
    const {
      getAnimateOnMount
    } = q$1(SwappableContext);
    exitVisibility || (exitVisibility = "hidden");
    (_animateOnMount = animateOnMount) !== null && _animateOnMount !== void 0 ? _animateOnMount : animateOnMount = getAnimateOnMount();
    (_measure = measure) !== null && _measure !== void 0 ? _measure : measure = false;
    const getExitVisibility = useStableGetter(exitVisibility);
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    } = useCssClasses();
    const getMeasure = useStableGetter(measure);
    const {
      exclusiveTransitionReturn: {
        exclusivelyOpen,
        isExclusive,
        onVisibilityChange: exclusiveTransitionVisibilityChange
      }
    } = useExclusiveTransition({
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        exclusivityKey,
        forceClose: useStableCallback(() => {
          internalOnShowChanged(false, getMeasure());
        })
      }
    });
    if (isExclusive) {
      show = show && exclusivelyOpen;
    }
    const {
      refElementReturn: {
        getElement
      },
      propsStable
    } = useRefElement({});
    const cssProperties = _({});
    const classNames = _(new Set([// This is removed during useLayoutEffect on the first render
    // (at least once `show` is non-null)
    "".concat(GetBaseClass(), "-pending")]));
    const handleTransitionFinished = T$1(() => {
      const state = getState();
      console.assert(!!state);
      if (state) {
        const [direction, phase] = parseState(state);
        if (phase == "transition") {
          setState("".concat(direction, "-finalize"));
          if (timeoutHandle.current > 0) {
            var _timeoutClearFunction;
            (_timeoutClearFunction = timeoutClearFunction.current) === null || _timeoutClearFunction === void 0 ? void 0 : _timeoutClearFunction.call(timeoutClearFunction, timeoutHandle.current);
            timeoutHandle.current = -1;
          }
        }
      }
    }, []);
    const otherProps = _({
      onTransitionEnd: e => {
        if (e.target == getElement() && e.elapsedTime) {
          handleTransitionFinished();
        }
      }
    });
    const hasMounted = _(false);
    /**
     * Sets the element's CSS class to match the given direction and phase.
     */
    const updateClasses = T$1((element, direction, phase) => {
      if (element == null) return;
      const exitVisibility = getExitVisibility();
      const allClassesToRemove = ["".concat(GetBaseClass(), "-").concat(GetEnterClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-ev-", "inert"), "".concat(GetBaseClass(), "-ev-", "removed"), "".concat(GetBaseClass(), "-ev-", "hidden"), "".concat(GetBaseClass(), "-ev-", "visible"), "".concat(GetBaseClass(), "-pending")];
      const allClassesToAdd = ["".concat(GetBaseClass()), "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction)), phase ? "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction), "-").concat(GetPhaseClass(phase)) : "", "".concat(GetBaseClass(), "-ev-").concat(exitVisibility)];
      element.classList.remove(...allClassesToRemove);
      allClassesToRemove.map(v => classNames.current.delete(v));
      element.classList.add(...allClassesToAdd);
      allClassesToAdd.map(v => classNames.current.add(v));
    }, []);
    /**
     * Updates a single "measure" variable (or removes it)
     */
    const updateSizeProperty = T$1((element, varName, value) => {
      if (value != null) {
        value = "".concat(value, "px");
        element.style.setProperty(varName, value);
        cssProperties.current[varName] = value;
      } else {
        element.style.removeProperty(varName);
        delete cssProperties.current[varName];
      }
    }, []);
    /**
     * Adds the "measure" variupdateClassesables to the element if requested.
     */
    const measureElementAndUpdateProperties = T$1((element, measure) => {
      if (element) {
        var _size, _size2, _size3, _size4;
        let size = null;
        if (measure) {
          size = element.getBoundingClientRect();
        }
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-top"), (_size = size) === null || _size === void 0 ? void 0 : _size.top);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-left"), (_size2 = size) === null || _size2 === void 0 ? void 0 : _size2.left);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-width"), (_size3 = size) === null || _size3 === void 0 ? void 0 : _size3.width);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-height"), (_size4 = size) === null || _size4 === void 0 ? void 0 : _size4.height);
      }
    }, []);
    // We use both useTimeout and requestAnimationFrame for timing certain things --
    // raf is used for changing from init to transition (would use queueMicrotask but it can't be cancelled)
    // setTimeout is used for changing from transition to finalize (as a backup in case transitionend doesn't fire)
    //
    // In order to avoid stale callbacks running (i.e. when we rapidly switch between visible and not)
    // we need to make sure we accurately cancel anything that can change our state on a delay.
    //
    // Also of note, we store "(f) => window.clearTimeout(f)" instead of just "window.clearTimeout" because
    // of the implicit window object -- problems with a missing `this` object and all that nonsense.
    const timeoutHandle = _(-1);
    const timeoutClearFunction = _(null);
    /**
     * Any time the state changes, there's some logic we need to run:
     *
     * * If we're changing to an `init` phase, update the classes, then wait a moment and then change to the `transition` phase.
     * * If we're changing to a `transition` phase, update the classes, then wait until the transition completes, then change to the `finalize` phase.
     *
     * Any change in state or classes/styles does not implicitly cause a re-render.
     */
    const onStateChange = T$1((nextState, prevState, reason) => {
      if (nextState == null) return;
      const [nextDirection, nextPhase] = parseState(nextState);
      const element = getElement();
      // Make sure no stale change code ever runs
      if (timeoutHandle.current >= 0 && timeoutClearFunction.current) timeoutClearFunction.current(timeoutHandle.current);
      // Handle inert props/property
      const exitVisibility = getExitVisibility();
      if (exitVisibility) {
        const inert = exitVisibility == "inert" && nextDirection == "exit" && nextPhase == "finalize" ? true : undefined;
        if (inert) otherProps.current.inert = true;else delete otherProps.current["inert"];
        if (element) element.inert = inert || false;
      }
      const isBeingPainted = nextDirection == "enter" || nextDirection == "exit" && nextPhase != "finalize";
      onVisibilityChange === null || onVisibilityChange === void 0 ? void 0 : onVisibilityChange(isBeingPainted);
      exclusiveTransitionVisibilityChange === null || exclusiveTransitionVisibilityChange === void 0 ? void 0 : exclusiveTransitionVisibilityChange(isBeingPainted);
      updateClasses(element, nextDirection, nextPhase);
      if (element && (nextPhase == "init" || nextPhase == "transition")) forceReflow(element);
      switch (nextPhase) {
        case "measure":
          {
            if (element) measureElementAndUpdateProperties(element, true);
            //setState(`${nextDirection}-init`);
            updateClasses(element, nextDirection, "init");
            if (element) forceReflow(element);
            // !!Intentional fall-through!!
          }

        case "init":
          {
            timeoutHandle.current = requestAnimationFrame(() => {
              setState("".concat(nextDirection, "-transition"));
            });
            timeoutClearFunction.current = f => cancelAnimationFrame(f);
            break;
          }
        case "transition":
          {
            timeoutHandle.current = setTimeout(() => {
              handleTransitionFinished();
            }, getTimeoutDuration(element) * 1.5);
            timeoutClearFunction.current = f => clearTimeout(f);
            break;
          }
        case "finalize":
          {
            // Nothing to do or schedule or anything -- we just update our classes and we're done.
            timeoutClearFunction.current = null; // Does this make it more or less clear?
            break;
          }
        default:
          {
            debugger; // Intentional
            console.log("Invalid state used in transition: ".concat(nextState, ". Previous state was ").concat(prevState !== null && prevState !== void 0 ? prevState : "null"));
            break;
          }
      }
    }, []);
    const [getState, setState] = usePassiveState(onStateChange, returnNull, runImmediately);
    // When we mount, and every time thereafter that `show` changes,
    // change our current state according to that `show` value.
    y$1(() => internalOnShowChanged(show, measure), [measure, show]);
    // This has no dependences and is relied on in two different areas
    function internalOnShowChanged(show, measure) {
      // If `show` is null, then we don't change anything.
      if (show == null) return;
      // (If `show` is true/false, we'll remove the CSS classes during `onChange`)
      const currentState = getState();
      let nextPhase = measure ? "measure" : "init";
      if (currentState) {
        const [currentDirection, currentPhase] = parseState(currentState);
        if (currentPhase != "finalize") nextPhase = "transition";
      }
      // Note: the setState change handler runs immediately with no debounce.
      if (show) {
        if (hasMounted.current || animateOnMount) setState("enter-".concat(nextPhase));else setState("enter-finalize");
      } else {
        if (hasMounted.current || animateOnMount) setState("exit-".concat(nextPhase));else setState("exit-finalize");
      }
      hasMounted.current = true;
    }
    if (duration != null) cssProperties.current["--".concat(GetBaseClass(), "-duration")] = duration + "ms";else delete cssProperties.current["--".concat(GetBaseClass(), "-duration")];
    (_easingIn = easingIn) !== null && _easingIn !== void 0 ? _easingIn : easingIn = easing;
    (_easingOut = easingOut) !== null && _easingOut !== void 0 ? _easingOut : easingOut = easing;
    if (easingOut != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")] = easingOut;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")];
    if (easingIn != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")] = easingIn;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")];
    // No matter what delayMountUntilShown is,
    // once we've rendered our children once, 
    // ensure that we don't unmount them again and waste all that work.
    // (If you really need this you can just unmount the entire transition itself)
    const definitelyShouldMountChildren = show || !delayMountUntilShown;
    const hasRenderedChildren = _(false);
    const renderChildren = definitelyShouldMountChildren || hasRenderedChildren.current;
    p$1(() => {
      if (definitelyShouldMountChildren) hasRenderedChildren.current || (hasRenderedChildren.current = true);
    }, [hasRenderedChildren.current ? false : definitelyShouldMountChildren]);
    const childrenIsVnode = children && children.type && children.props;
    const finalProps = useMergedProps(p, propsStable, otherProps.current, {
      className: [...classNames.current, "".concat(GetBaseClass()), "".concat(GetBaseClass(), "-ev-").concat(exitVisibility), "".concat(GetBaseClass(), "-inline-direction-", "ltr"), "".concat(GetBaseClass(), "-block-direction-", "ttb")].join(" "),
      style: cssProperties.current
    }, childrenIsVnode ? {
      ref: children.ref,
      ...children.props
    } : {});
    const resetContext = _({
      getAnimateOnMount: returnFalse
    }).current;
    let modifiedChildren;
    if (childrenIsVnode) {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: E(children, finalProps)
      });
    } else {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: o$2("span", {
          ...finalProps,
          children: children
        })
      });
    }
    return renderChildren ? modifiedChildren : null;
  }
  function forceReflow(e) {
    // Try really hard to make sure this isn't optimized out by anything.
    // We need it for its document reflow side effect.
    const p = globalThis._dummy;
    globalThis._dummy = e.getBoundingClientRect();
    globalThis._dummy = e.style.opacity;
    globalThis._dummy = e.style.transform;
    globalThis._dummy = p;
    return e;
  }

  /**
   * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useBasePropsFade(_ref15) {
    let {
      fadeParameters: {
        fadeMin,
        fadeMax
      }
    } = _ref15;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-fade"),
      style: {
        ["--".concat(GetBaseClass(), "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
        ["--".concat(GetBaseClass(), "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
   *
   * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
   * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
   * It's generally recommended to either use the components that include a combined fade effect,
   * or just directly a `<Transitionable>` on your own.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Fade(_ref16, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref16;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  function useBasePropsClip(_ref17) {
    var _ref18, _ref19, _ref20, _ref21;
    let {
      clipParameters: {
        clipMin,
        clipMinBlock,
        clipMinInline,
        clipOrigin,
        clipOriginBlock,
        clipOriginInline
      }
    } = _ref17;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: clsx("".concat(GetBaseClass(), "-clip")),
      style: {
        ["--".concat(GetBaseClass(), "-clip-origin-inline")]: (_ref18 = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref18 !== void 0 ? _ref18 : 0.5,
        ["--".concat(GetBaseClass(), "-clip-origin-block")]: (_ref19 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref19 !== void 0 ? _ref19 : 0,
        ["--".concat(GetBaseClass(), "-clip-min-inline")]: (_ref20 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref20 !== void 0 ? _ref20 : 1,
        ["--".concat(GetBaseClass(), "-clip-min-block")]: (_ref21 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref21 !== void 0 ? _ref21 : 0
      }
    };
  }
  x(forwardElementRef(function Clip(_ref22, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref22;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ClipFade(_ref23, ref) {
    let {
      delayMountUntilShown,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      clipMin,
      clipMinBlock,
      clipMinInline,
      clipOrigin,
      clipOriginBlock,
      clipOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref23;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   *
   * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
   *
   * @example <Transitionable measure {...useCreateCollapseProps(...)} />
   */
  function useBasePropsCollapse(_ref24) {
    let {
      collapseParameters: {
        minBlockSize
      }
    } = _ref24;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-collapse"),
      style: {
        ["--".concat(GetBaseClass(), "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
   *
   * *Important*: This component is *not* efficient for the browser to animate!
   * Make sure you do testing on lower power devices, or prefer a lighter
   * alternative, like `<Clip>`.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Collapse(_ref25, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      delayMountUntilShown,
      minBlockSize,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref25;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function CollapseFade(_ref26, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      animateOnMount,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      exitVisibility,
      minBlockSize,
      onVisibilityChange,
      ...rest
    } = _ref26;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsFlip(_ref27) {
    var _useLastNonNullValue, _useLastNonNullValue2;
    let {
      flipParameters: {
        flipAngleBlock,
        flipAngleInline,
        flipPerspective
      }
    } = _ref27;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-flip"),
      style: {
        ["--".concat(GetBaseClass(), "-flip-angle-inline")]: "".concat((_useLastNonNullValue = useLastNonNullValue(flipAngleInline)) !== null && _useLastNonNullValue !== void 0 ? _useLastNonNullValue : 0, "deg"),
        ["--".concat(GetBaseClass(), "-flip-angle-block")]: "".concat((_useLastNonNullValue2 = useLastNonNullValue(flipAngleBlock)) !== null && _useLastNonNullValue2 !== void 0 ? _useLastNonNullValue2 : 0, "deg"),
        ["--".concat(GetBaseClass(), "-perspective")]: "".concat(flipPerspective !== null && flipPerspective !== void 0 ? flipPerspective : 800, "px")
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
   *
   * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * exclusivityKey allows for convenient setups inside of a `SwapContainer`
   * (`flipInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Flip(_ref28, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      flipAngleInline,
      flipAngleBlock,
      flipPerspective,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref28;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFlip({
          flipParameters: {
            flipAngleBlock,
            flipAngleInline,
            flipPerspective
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsSlide(_ref29) {
    var _slideTargetInline, _slideTargetBlock;
    let {
      slideParameters: {
        slideTargetInline,
        slideTargetBlock
      }
    } = _ref29;
    slideTargetInline = useLastNonNullValue(slideTargetInline);
    slideTargetBlock = useLastNonNullValue(slideTargetBlock);
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-slide"),
      style: {
        ["--".concat(GetBaseClass(), "-slide-target-inline")]: "".concat((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 0),
        ["--".concat(GetBaseClass(), "-slide-target-block")]: "".concat((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
   *
   * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * which allows for convenient setups inside of a `SwapContainer`
   * (`slideInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Slide(_ref30, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      onVisibilityChange,
      slideTargetInline,
      slideTargetBlock,
      show,
      animateOnMount,
      exitVisibility,
      delayMountUntilShown,
      ...rest
    } = _ref30;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange,
        propsIncoming: useMergedProps(useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideFade(_ref31, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref31;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsZoom(_ref32) {
    var _ref33, _ref34, _ref35, _ref36;
    let {
      zoomParameters: {
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }
    } = _ref32;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-zoom"),
      style: {
        ["--".concat(GetBaseClass(), "-zoom-origin-inline")]: "".concat((_ref33 = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref33 !== void 0 ? _ref33 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-origin-block")]: "".concat((_ref34 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref34 !== void 0 ? _ref34 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-min-inline")]: "".concat((_ref35 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref35 !== void 0 ? _ref35 : 0),
        ["--".concat(GetBaseClass(), "-zoom-min-block")]: "".concat((_ref36 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref36 !== void 0 ? _ref36 : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
   * @see `Transitionable` `ZoomFade`
   */
  x(forwardElementRef(function Zoom(_ref37, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref37;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoom(_ref38, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref38;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoomFade(_ref39, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      fadeMax,
      fadeMin,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref39;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ZoomFade(_ref40, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref40;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.13.2", l$2, {
    Fragment: _$2,
    Component: k$2
  });
  var o = {};
  function a(e) {
    return e.type === _$2 ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
  }
  var i = [],
    c = [];
  function s() {
    return i.length > 0 ? i[i.length - 1] : null;
  }
  var u = !1;
  function l(e) {
    return "function" == typeof e.type && e.type != _$2;
  }
  function f(n) {
    for (var e = [n], t = n; null != t.__o;) e.push(t.__o), t = t.__o;
    return e.reduce(function (n, e) {
      n += "  in " + a(e);
      var t = e.__source;
      return t ? n += " (at " + t.fileName + ":" + t.lineNumber + ")" : u || (u = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
    }, "");
  }
  var p = "function" == typeof WeakMap;
  function d(n) {
    return n ? "function" == typeof n.type ? d(n.__) : n : {};
  }
  var h = k$2.prototype.setState;
  k$2.prototype.setState = function (n, e) {
    return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(s())), h.call(this, n, e);
  };
  var y = k$2.prototype.forceUpdate;
  function v(n) {
    var e = n.props,
      t = a(n),
      o = "";
    for (var r in e) if (e.hasOwnProperty(r) && "children" !== r) {
      var i = e[r];
      "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), o += " " + r + "=" + JSON.stringify(i);
    }
    var c = e.children;
    return "<" + t + o + (c && c.length ? ">..</" + t + ">" : " />");
  }
  k$2.prototype.forceUpdate = function (n) {
    return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(s())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + f(this.__v)), y.call(this, n);
  }, function () {
    !function () {
      var n = l$2.__b,
        t = l$2.diffed,
        o = l$2.__,
        r = l$2.vnode,
        a = l$2.__r;
      l$2.diffed = function (n) {
        l(n) && c.pop(), i.pop(), t && t(n);
      }, l$2.__b = function (e) {
        l(e) && i.push(e), n && n(e);
      }, l$2.__ = function (n, e) {
        c = [], o && o(n, e);
      }, l$2.vnode = function (n) {
        n.__o = c.length > 0 ? c[c.length - 1] : null, r && r(n);
      }, l$2.__r = function (n) {
        l(n) && c.push(n), a && a(n);
      };
    }();
    var n = !1,
      t = l$2.__b,
      r = l$2.diffed,
      s = l$2.vnode,
      u = l$2.__e,
      h = l$2.__,
      y = l$2.__h,
      m = p ? {
        useEffect: new WeakMap(),
        useLayoutEffect: new WeakMap(),
        lazyPropTypes: new WeakMap()
      } : null,
      b = [];
    l$2.__e = function (n, e, t, o) {
      if (e && e.__c && "function" == typeof n.then) {
        var r = n;
        n = new Error("Missing Suspense. The throwing component was: " + a(e));
        for (var i = e; i; i = i.__) if (i.__c && i.__c.__c) {
          n = r;
          break;
        }
        if (n instanceof Error) throw n;
      }
      try {
        (o = o || {}).componentStack = f(e), u(n, e, t, o), "function" != typeof n.then && setTimeout(function () {
          throw n;
        });
      } catch (n) {
        throw n;
      }
    }, l$2.__ = function (n, e) {
      if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
      var t;
      switch (e.nodeType) {
        case 1:
        case 11:
        case 9:
          t = !0;
          break;
        default:
          t = !1;
      }
      if (!t) {
        var o = a(n);
        throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + o + " />, " + e + ");");
      }
      h && h(n, e);
    }, l$2.__b = function (e) {
      var r = e.type,
        i = d(e.__);
      if (n = !0, void 0 === r) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + v(e) + "\n\n" + f(e));
      if (null != r && "object" == typeof r) {
        if (void 0 !== r.__k && void 0 !== r.__e) throw new Error("Invalid type passed to createElement(): " + r + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + v(r) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
        throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r) ? "array" : r));
      }
      if ("thead" !== r && "tfoot" !== r && "tbody" !== r || "table" === i.type ? "tr" === r && "thead" !== i.type && "tfoot" !== i.type && "tbody" !== i.type && "table" !== i.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + v(e) + "\n\n" + f(e)) : "td" === r && "tr" !== i.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + v(e) + "\n\n" + f(e)) : "th" === r && "tr" !== i.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + v(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + v(e) + "\n\n" + f(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("string" == typeof e.type) for (var c in e.props) if ("o" === c[0] && "n" === c[1] && "function" != typeof e.props[c] && null != e.props[c]) throw new Error("Component's \"" + c + '" property should be a function, but got [' + typeof e.props[c] + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && m && !m.lazyPropTypes.has(e.type)) {
          var s = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
          try {
            var u = e.type();
            m.lazyPropTypes.set(e.type, !0), console.warn(s + "Component wrapped in lazy() is " + a(u));
          } catch (n) {
            console.warn(s + "We will log the wrapped component's name once it is loaded.");
          }
        }
        var l = e.props;
        e.type.__f && delete (l = function (n, e) {
          for (var t in e) n[t] = e[t];
          return n;
        }({}, l)).ref, function (n, e, t, r, a) {
          Object.keys(n).forEach(function (t) {
            var i;
            try {
              i = n[t](e, t, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (n) {
              i = n;
            }
            i && !(i.message in o) && (o[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
          });
        }(e.type.propTypes, l, 0, a(e), function () {
          return f(e);
        });
      }
      t && t(e);
    }, l$2.__h = function (e, t, o) {
      if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
      y && y(e, t, o);
    };
    var w = function (n, e) {
        return {
          get: function () {
            var t = "get" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
          },
          set: function () {
            var t = "set" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
          }
        };
      },
      g = {
        nodeName: w("nodeName", "use vnode.type"),
        attributes: w("attributes", "use vnode.props"),
        children: w("children", "use vnode.props.children")
      },
      E = Object.create({}, g);
    l$2.vnode = function (n) {
      var e = n.props;
      if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
        var t = n.props = {};
        for (var o in e) {
          var r = e[o];
          "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
        }
      }
      n.__proto__ = E, s && s(n);
    }, l$2.diffed = function (e) {
      if (e.__k && e.__k.forEach(function (n) {
        if ("object" == typeof n && n && void 0 === n.type) {
          var t = Object.keys(n).join(",");
          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + f(e));
        }
      }), n = !1, r && r(e), null != e.__k) for (var t = [], o = 0; o < e.__k.length; o++) {
        var a = e.__k[o];
        if (a && null != a.key) {
          var i = a.key;
          if (-1 !== t.indexOf(i)) {
            console.error('Following component has two or more children with the same key attribute: "' + i + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + v(e) + "\n\n" + f(e));
            break;
          }
          t.push(i);
        }
      }
    };
  }();

  /**
   * Relatively low-level hook that allows you to inspect
   * when the entire URL changes, either because the hash changed,
   * or because the Back/Forward browser buttons were pressed.
   *
   * (Changing query parameters reloads the page and so isn't
   * tracked, unless of course it's because of the browser
   * navigating back/forwards).
   *
   * In general, you'll want to inspect a specific directory of
   * a path, or a specific query parameter value, not the
   * entire URL.
   */
  function useUrl(onUrlChange) {
    const [getUrl, setUrl] = usePassiveState$1(useStableCallback$1(onUrlChange), T$1(() => window.location.toString(), []));
    useGlobalHandler(window, "hashchange", e => {
      setUrl(window.location.toString());
    });
    useGlobalHandler(window, "popstate", e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#the_history_stack
      // TODO: If this assert never fires, it's *probably* fine??
      console.assert(window.location.toString() === document.location.toString());
      setUrl(window.location.toString());
    });
    return [getUrl, setUrl];
  }

  //export const RouterLevelContext = createContext(0);
  /**
   * Internal helper to trim the crusts off of a hash path.
   * @param hash
   * @returns
   */
  function trimHash(hash) {
    if (hash.startsWith("#")) hash = hash.substr(1);
    if (hash.startsWith("/")) hash = hash.substr(1);
    if (hash.endsWith("/")) hash = hash.substr(0, hash.length - 1);
    return hash;
  }
  function normalizeHashToPath(hash) {
    hash = trimHash(hash);
    return hash.split("/");
  }
  // Not public -- just contains shared code for history modification.
  // This is what actually changes History and updates the window's URL.
  function setEntireHash(hash, action) {
    var _action;
    (_action = action) !== null && _action !== void 0 ? _action : action = "push";
    hash = trimHash(hash);
    let oldURL = window.location.toString();
    let nextUrl = new URL(window.location.toString());
    nextUrl.hash = "#".concat(hash);
    history["".concat(action, "State")]({}, document.title, nextUrl);
    // Modifying history doesn't actually cause a hashchange event.
    window.dispatchEvent(new HashChangeEvent('hashchange', {
      oldURL,
      newURL: nextUrl.toString()
    }));
  }
  /**
   * Modifies the given Search Params object to have its key be set to the given value.
   *
   * Specifically for boolean types this ensures that the param is simply existant/non-existant,
   * but for other types this is pretty straightforward.
   * @param params
   * @param key
   * @param value
   * @param type
   */
  function unparseParam(params, key, value, type) {
    if (type === "boolean") {
      if (value === true) {
        params.set(key, "");
      } else {
        params.delete(key);
      }
    } else {
      params.set(key, "".concat(value));
    }
  }
  /**
   * Parses the requested Search Param from the given URL.
   *
   * The type will be automatically parsed with special handling for booleans
   */
  function parseParam(url, key, type) {
    let value = url.searchParams.get(key);
    switch (type) {
      case "string":
        return value !== null && value !== void 0 ? value : null;
      case "boolean":
        return value != null;
      case "number":
        if (value == null) return null;
        let parsed = +value;
        if (isFinite(parsed)) return parsed;
        return null;
      case "bigint":
        if (value == null) return null;
        try {
          return BigInt(value);
        } catch (ex) {
          return null;
        }
    }
    return value !== null && value !== void 0 ? value : null;
  }
  //export interface RouterChildInfo extends ManagedChildInfo<string> {
  //    notifyOfSiblingsHaveNoMatches(noMatches: boolean): void;
  //path: RouterPathType | null;
  //    matches: boolean | null;
  //}

  function useConsumeRouter(_ref41) {
    let {
      context,
      info: {
        index
      },
      consumeRouterParameters: {
        onLocalPathChange,
        localPath: wantedLocalPath
      }
    } = _ref41;
    const {
      routerContext: {
        level,
        notifyParentThatNonDefaultMatchHasChanged
      }
    } = context;
    const [anyMatchesAmongNonDefaultSiblings, setAnyMatchesAmongNonDefaultSiblings] = useState$1(null);
    const [pathWhenMatching, setPathWhenMatching] = useState$1(null);
    const {
      managedChildReturn
    } = useManagedChild$1({
      context,
      info: {
        index,
        setAnyMatchesAmongNonDefaultSiblings: useStableCallback$1(anyMatches => {
          setAnyMatchesAmongNonDefaultSiblings(anyMatches);
          onLocalPathChange2(wantedLocalPath, anyMatches, getLocalPath());
        })
      }
    });
    y$1(() => {
      onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, getLocalPath());
    }, [wantedLocalPath, anyMatchesAmongNonDefaultSiblings]);
    const onLocalPathChange2 = useStableCallback$1(function (wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path) {
      const matches = pathCompare(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
      setMatches(matches);
      console.log("".concat(index, ": onLocalPathChange2(wlp: ").concat((wantedLocalPath !== null && wantedLocalPath !== void 0 ? wantedLocalPath : "null").toString(), ", amands: ").concat((anyMatchesAmongNonDefaultSiblings !== null && anyMatchesAmongNonDefaultSiblings !== void 0 ? anyMatchesAmongNonDefaultSiblings : "null").toString(), ", p: ").concat(path, "): ").concat((matches !== null && matches !== void 0 ? matches : "null").toString()));
      if (matches) setPathWhenMatching(path);
      if (wantedLocalPath != null) {
        notifyParentThatNonDefaultMatchHasChanged(index, matches);
      } else {
        notifyParentThatNonDefaultMatchHasChanged(index, null);
      }
    });
    const [matches, setMatches] = useState$1(null);
    const [getLocalPath, setLocalPath] = useLocalPath({
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange: useStableCallback$1((path, prev, reason) => {
          onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
          onLocalPathChange === null || onLocalPathChange === void 0 ? void 0 : onLocalPathChange(path, prev, reason);
        })
      }
    });
    return {
      managedChildReturn,
      consumeRouterReturn: {
        level,
        matches,
        getLocalPath,
        setLocalPath,
        pathWhenMatching
      }
    };
  }
  function useLocalPath(_ref42) {
    let {
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange
      }
    } = _ref42;
    useEnsureStability$1("useLocalPath", level);
    const urlToPath = T$1(url => {
      const oldHashPath = normalizeHashToPath(trimHash(new URL(url).hash));
      return oldHashPath[level];
    }, []);
    const [getLocalPath, setLocalPath] = usePassiveState$1(useStableCallback$1(onLocalPathChange), T$1(() => {
      return urlToPath(window.location.href);
    }, [urlToPath]));
    // Any time the URL changes, inspect the hash
    // at our current level, and change our local copy of our path
    // in our passive state. This will trigger our callback if they're different.
    useUrl(url => {
      setLocalPath(urlToPath(url));
    });
    return [getLocalPath, setLocalPath];
  }
  function pathCompare(requestedLocalHash, anyMatchesAmongNonDefaultSiblings, localPath) {
    var _localPath;
    let matches;
    (_localPath = localPath) !== null && _localPath !== void 0 ? _localPath : localPath = "";
    if (requestedLocalHash instanceof RegExp) matches = requestedLocalHash.test(localPath);else if (requestedLocalHash instanceof Function) matches = requestedLocalHash(localPath);else if (requestedLocalHash == null) matches = anyMatchesAmongNonDefaultSiblings == null ? null : !anyMatchesAmongNonDefaultSiblings;else matches = requestedLocalHash === localPath;
    return matches;
  }

  /**
   * Error class used when attemps to modify the root directory occur.
   */
  class RootRouterError extends Error {
    constructor() {
      super("The root Router's path can only be pushed to and cannot be set or popped from.");
    }
  }

  /**
   * Removes the directory at the current level, effectively returning
   * to the previous level.  You can also switch to a different
   * previous level if you would like.
   */
  function usePopLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      setEntireHash(popLocalPath(level, dir), action);
    }, [level]);
  }
  function popLocalPath(level, dir) {
    if (level < 0) throw new RootRouterError();
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, level).map(s => s !== null && s !== void 0 ? s : "");
    if (dir) {
      dir = trimHash(dir);
      newHashPath[newHashPath.length - 1] = dir;
    }
    return newHashPath.join("/");
  }

  /**
   * Adds a directory at one level deeper.
   */
  function usePushLocalPath(level) {
    return T$1(function pushLocalHash(dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      dir = trimHash(dir);
      const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
      let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
      newHashPath.splice(level + 1, 1, dir);
      setEntireHash(newHashPath.join("/"), action);
    }, [level]);
  }

  /**
   * Replaces the directory at the current level with a new one. You can
   * choose whether or not any trailing paths are kept -- by default this is false.
   * @returns
   */
  function useSetLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      setEntireHash(setLocalPath(level, dir, keepTrailing || false), action);
    }, [level]);
  }
  function setLocalPath(level, dir, keepTrailing) {
    if (level < 0) throw new RootRouterError();
    dir = trimHash(dir);
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
    newHashPath.splice(level, 1, dir);
    return newHashPath.join("/");
  }

  /**
   * Allows easy access to the controls at the current level.
   *
   * You can also get this information from a child <Router />
   * by passing in a ref (e.g. <Router ref={setControls} />).
   */
  function useRouterControls(level) {
    // This is the hash at this level specifically, 
    // so it contains no directory separators.
    const popLocalPath = usePopLocalPath(level);
    const pushLocalPath = usePushLocalPath(level);
    const setLocalPath = useSetLocalPath(level);
    return F$1(() => ({
      popLocalPath,
      pushLocalPath,
      setLocalPath
    }), [popLocalPath, pushLocalPath, setLocalPath]);
  }
  const RouterContext = F$2(null);
  //const RouterContext = createContext<RouterContextType | null>(null);
  /**
   * The "parent" part of a router.
   *
   * This is responsible for coordinating, among all children, which route to show.
   * This coordination is really only needed for the "default" pathway, which
   * needs to know as painlessly as possible whether any of its siblings are currently valid.
   *
   * It also increases the depth by one, starting at depth=-1 for the root router is *just* a parent.
   */
  function useProvideRouter(_ref43) {
    var _q$;
    let {
      managedChildrenParameters
    } = _ref43;
    const {
      context,
      managedChildrenReturn
    } = useManagedChildren$1({
      managedChildrenParameters
    });
    const {
      routerContext: {
        level
      }
    } = (_q$ = q$1(RouterContext)) !== null && _q$ !== void 0 ? _q$ : {
      routerContext: {
        level: -1
      }
    };
    const matchingIndices = _(new Set());
    const [getShowingDefault, setShowingDefault] = usePassiveState$1(useStableCallback$1(showingDefault => {
      managedChildrenReturn.getChildren().forEach(child => {
        child.setAnyMatchesAmongNonDefaultSiblings(!showingDefault);
      });
    }), returnNull$1);
    const onNonDefaultChildMatchChanged = useStableCallback$1((index, matches) => {
      matchingIndices.current[matches ? "add" : "delete"](index);
      setShowingDefault(matchingIndices.current.size == 0);
    });
    return {
      context: useStableObject$1({
        ...context,
        routerContext: useStableObject$1({
          level: level + 1,
          notifyParentThatNonDefaultMatchHasChanged: onNonDefaultChildMatchChanged
        })
      }),
      managedChildrenReturn
    };
  }

  /**
   * Allows you to conditionally hide/show content based on a path in the hash component of the URL.
   *
   * @param param0
   * @param ref
   * @returns
   */
  function Router(_ref44, ref) {
    var _consumeRouterReturn;
    let {
      localPath,
      onLocalPathChange,
      children
    } = _ref44;
    const context = q$1(RouterContext);
    const {
      context: contextFromParent,
      managedChildrenReturn
    } = useProvideRouter({
      managedChildrenParameters: {}
    });
    const index = F$1(() => (localPath !== null && localPath !== void 0 ? localPath : "<default>") + "-".concat(Math.random()), [localPath]);
    let consumeRouterReturn = null;
    useEnsureStability$1("Router", !!context);
    if (context) {
      consumeRouterReturn = useConsumeRouter({
        consumeRouterParameters: {
          localPath,
          onLocalPathChange
        },
        context,
        info: {
          index
        }
      });
    }
    const {
      consumeRouterReturn: {
        level,
        matches,
        pathWhenMatching
      }
    } = (_consumeRouterReturn = consumeRouterReturn) !== null && _consumeRouterReturn !== void 0 ? _consumeRouterReturn : {
      consumeRouterReturn: {
        level: -1,
        matches: null,
        pathWhenMatching: null
      }
    };
    const controls = useRouterControls(level);
    A(ref, () => ({
      level,
      matches,
      pathWhenMatching,
      ...controls
    }));
    return o$2(RouterContext.Provider, {
      value: contextFromParent,
      children: children(level == -1 ? "/" : matches ? pathWhenMatching : null, useRouterControls(level))
    });
  }

  /**
   * Provides access to the requested Search Param's value
   *
   * Note that while this function is like usePassiveState (itself like useState and useEffect combined),
   * the `setState` return function is, due to browser limitations, not syncronous, but that's
   * like most calls to `setState` anyway I guess?
   *
   * @param paramKey The name of the URL search parameter to reference
   * @param type The type of data encode/decode (`"string"` | `"boolean"` | `"number"` | `"bigint"`)
   * @param onParamValueChanged Will be called any time the requested Search Parameter's value changes.
   */
  function useSearchParams(paramKey, type, onParamValueChanged) {
    // We keep a local copy of our current Search Param value
    // because changing it is actually an asyncronous operation
    // and we can't know when it ends aside from just "did the URL change or not"
    // so we might as well keep this state around locally to compensate.
    const [getSavedParamValue, setSavedParamValue] = usePassiveState$1(onParamValueChanged, T$1(() => {
      return parseParam(new URL(window.location.toString()), paramKey, type);
    }, []));
    const setParamWithHistory = useStableCallback$1((newValueOrUpdater, reason) => {
      let prevValue = parseParam(new URL(window.location.toString()), paramKey, type);
      let nextValue = typeof newValueOrUpdater == "function" ? newValueOrUpdater(prevValue) : newValueOrUpdater;
      let newParams = new URLSearchParams(new URL(window.location.toString()).searchParams);
      unparseParam(newParams, paramKey, nextValue, type);
      let nextUrl = new URL(window.location.toString());
      nextUrl.search = prettyPrintParams(newParams);
      history["".concat(reason !== null && reason !== void 0 ? reason : "replace", "State")]({}, document.title, nextUrl);
      setSavedParamValue(nextValue);
    });
    // Any time the URL changes, it means the Search Param we care about might have changed.
    // Parse it out and save it.
    useUrl(useStableCallback$1(url => {
      const newParam = parseParam(new URL(url), paramKey, type);
      setSavedParamValue(newParam);
    }));
    return [getSavedParamValue, setParamWithHistory];
  }
  function prettyPrintParams(params) {
    const paramArray = [...params.entries()].filter((key, value) => value != null);
    if (paramArray.length == 0) return "";
    let queryString = paramArray.map(_ref45 => {
      let [key, value] = _ref45;
      if (value === "" || value === true) return "".concat(encodeURIComponent(key));else return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
    }).join("&");
    return "?".concat(queryString);
  }
  const Component = () => {
    const [url, setUrl] = useState$1("");
    useUrl(setUrl);
    const [example, setExampleLocal] = useState$1(null);
    const [getExample, setExample] = useSearchParams("example", "number");
    return o$2(Router, {
      localPath: null,
      children: (path, _ref46) => {
        let {
          pushLocalPath,
          popLocalPath,
          setLocalPath
        } = _ref46;
        return path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is the current URL: ", o$2("code", {
              children: url
            }), "."]
          }), o$2("p", {
            children: "This is content in the root router. It is always displayed, no matter what."
          }), o$2("p", {
            children: ["The ", o$2("code", {
              children: "Router"
            }), " that's rendering this content cannot have path-related functions performed on it, since the path is always just implicitly ", o$2("code", {
              children: "/"
            }), "."]
          }), o$2("p", {
            children: "Just beneath me is a child component that reads the first path after the root."
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => {
                debugger;
                pushLocalPath("test1");
              },
              children: "Push \"test1\""
            })
          }), o$2("p", {
            children: o$2("button", {
              disabled: true,
              onClick: () => popLocalPath(),
              children: "Pop"
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => setLocalPath("test1"),
              children: "Set \"test1\""
            })
          }), o$2("p", {
            children: o$2("label", {
              children: ["Search param example: ", o$2("input", {
                value: example !== null && example !== void 0 ? example : undefined,
                type: "number",
                onInput: e => setExample(e.currentTarget.valueAsNumber)
              })]
            })
          }), o$2("hr", {}), o$2(Swappable, {
            children: o$2("div", {
              children: o$2(Level1, {})
            })
          })]
        });
      }
    });
  };
  function Level1() {
    //const [{ popLocalPath, pushLocalPath, setLocalPath }, setRouteControls] = useState<Partial<RouterControls>>({});
    return o$2(_$2, {
      children: [o$2(Router, {
        localPath: null,
        children: (path, _ref47) => {
          let {
            popLocalPath,
            pushLocalPath,
            setLocalPath
          } = _ref47;
          return path != null && o$2("div", {
            children: [o$2("p", {
              children: ["This is within the first-level child ", o$2("code", {
                children: "Router"
              }), " that displays ", o$2("em", {
                children: "default content"
              }), ". That is, if no other ", o$2("code", {
                children: "Router"
              }), " at this level matches (which is presumably true if you're reading this), then ", o$2("em", {
                children: "this"
              }), " ", o$2("code", {
                children: "Router"
              }), " will display."]
            }), o$2("p", {
              children: ["The current path is: ", o$2("code", {
                children: path
              })]
            }), o$2("p", {
              children: ["These buttons are hooked up to this ", o$2("code", {
                children: "Router"
              }), "'s ", o$2("code", {
                children: "ref"
              }), ", so they control this level in the path."]
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("");
              },
              children: "(empty string)"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test1");
              },
              children: "test1"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test2");
              },
              children: "test2"
            })]
          });
        }
      }), o$2(Router, {
        localPath: "",
        children: path => path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is within the first-level child ", o$2("code", {
              children: "Router"
            }), " that displays when the path is empty (this is different from the default path, taken when there is no match from anyone at this level)."]
          }), o$2("p", {
            children: ["The current path is: ", o$2("code", {
              children: path
            })]
          })]
        })
      })]
    });
  }
  /*
  function Test1() {
        const [{ popLocalPath: popHash1, pushLocalPath: pushHash1, setLocalPath: setHash1 }, setRouteControls] = useState<Partial<RouterControls>>({});
       return (
          <>
              <p>This is within the first-level child <code>Router</code> that displays when the path is <code>test1</code>.<Test1 /></p>
              <p>Level 1, Test1
                  <button onClick={() => { debugger; pushHash1?.("testa") }}>testA</button>
                  <Router ref={setRouteControls} localPath="testa">
                      <div>A</div>
                  </Router>
              </p>
          </>
       )
  }
   function Test2() {
      const [route0Controls, setRoute0Controls] = useState<RouterRefType | null>(null);
      const [route1Controls, setRoute1Controls] = useState<RouterRefType | null>(null);
       const [param, setParam] = useSearchParams("param", "boolean");
      console.log(param == null ? "<null>" : param);
      return (<>
          Test2: "{param == null ? "<null>" : param}".
          <Swappable>
              <span>
                  <Router ref={setRoute1Controls} localPath="">
                      <div>
                          Test2
                          <button onClick={() => route1Controls?.setLocalPath?.("testa")}>testA</button>
                      </div>
                  </Router>
                  <Router ref={setRoute1Controls} localPath="testa">
                      <div>
                          <div>A</div>
                          <label><input checked={param ?? false} type="checkbox" onInput={e => { e.preventDefault(); setParam(e.currentTarget.checked) }} />Checkbox</label>
                      </div>
                  </Router>
              </span>
          </Swappable>
      </>
      )
  }*/
  requestAnimationFrame(() => {
    B$2(o$2(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jYXRjaC1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXRpbC91c2UtY2FsbC1jb3VudC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDEuMi4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXByb3BzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvb2JzZXJ2ZXJzL3VzZS1hY3RpdmUtZWxlbWVudC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tpbmctZWxlbWVudHNAMC4xLjEvbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS93aWNnLWluZXJ0QDMuMS4yL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuZXNtLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9QdXJlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9tZW1vLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvc3VzcGVuc2UtbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcG9ydGFscy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLWltcGVyYXRpdmUtcHJvcHMudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdGltaW5nL3VzZS1hbmltYXRpb24tZnJhbWUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2Nsc3hAMS4yLjEvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanMiLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91dGlsL21vZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbm9vcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvdXNlLWNhbGwtY291bnQudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtc3R5bGVzLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLW1hbmFnZWQtY2hpbGRyZW4udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAYzY2YjQyZGVkMWE3OTNiMmYxMGIwMzk4YTYzNDBiY2U4MTJlMzhlY19wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQGM2NmI0MmRlZDFhNzkzYjJmMTBiMDM5OGE2MzQwYmNlODEyZTM4ZWNfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9vYnNlcnZlcnMvdXNlLWFjdGl2ZS1lbGVtZW50LnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9ibG9ja2luZy1lbGVtZW50c0AwLjEuMS9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvc3JjL2Jsb2NraW5nLWVsZW1lbnRzLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3dpY2ctaW5lcnRAMy4xLjIvbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5lc20uanMiLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtaW1wZXJhdGl2ZS1wcm9wcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0BjNjZiNDJkZWQxYTc5M2IyZjEwYjAzOThhNjM0MGJjZTgxMmUzOGVjX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvY29udGV4dC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2V4Y2x1c2l2ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvdXRpbC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3N3YXBwYWJsZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb25hYmxlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBlNWEwYzYyNzJjOTkxZjRlZDJiZWMwMzBkNjg5ZjhmMzU1ZjJlNGUxX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvZmFkZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NsaXAudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jbGlwLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jb2xsYXBzZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NvbGxhcHNlLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9mbGlwLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBlNWEwYzYyNzJjOTkxZjRlZDJiZWMwMzBkNjg5ZjhmMzU1ZjJlNGUxX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvc2xpZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS1mYWRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBlNWEwYzYyNzJjOTkxZjRlZDJiZWMwMzBkNjg5ZjhmMzU1ZjJlNGUxX3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvem9vbS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZTVhMGM2MjcyYzk5MWY0ZWQyYmVjMDMwZDY4OWY4ZjM1NWYyZTRlMV9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3NsaWRlLXpvb20udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS16b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGU1YTBjNjI3MmM5OTFmNGVkMmJlYzAzMGQ2ODlmOGYzNTVmMmU0ZTFfcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy96b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvZGV2dG9vbHMvc3JjL2RldnRvb2xzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NoZWNrLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4yL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NvbXBvbmVudC1zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjIvbm9kZV9tb2R1bGVzL3ByZWFjdC9kZWJ1Zy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMi9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9pbmRleC5qcyIsIi4uL3NyYy91c2UtdXJsLnRzeCIsIi4uL3NyYy91dGlsLnRzeCIsIi4uL3NyYy91c2Utcm91dGVyLWNvbnN1bWVyLnRzeCIsIi4uL3NyYy9yb290LXJvdXRlci1lcnJvci50cyIsIi4uL3NyYy91c2UtcG9wLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1wdXNoLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1zZXQtbG9jYWwtcGF0aC50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1jb250cm9scy50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1wcm92aWRlci50c3giLCIuLi9zcmMvcm91dGVyLnRzeCIsIi4uL3NyYy91c2Utc2VhcmNoLXBhcmFtcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdC8vIEB0cy1pZ25vcmUgV2UgY2hhbmdlIHRoZSB0eXBlIG9mIGBvYmpgIHRvIGJlIGBPICYgUGBcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjaGlsZCBub2RlIGZyb20gaXRzIHBhcmVudCBpZiBhdHRhY2hlZC4gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yXG4gKiBJRTExIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlKClgLiBVc2luZyB0aGlzIGZ1bmN0aW9uXG4gKiBpcyBzbWFsbGVyIHRoYW4gaW5jbHVkaW5nIGEgZGVkaWNhdGVkIHBvbHlmaWxsLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNsaWNlID0gRU1QVFlfQVJSLnNsaWNlO1xuIiwiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBDcmVhdGUgYW4gdmlydHVhbCBub2RlICh1c2VkIGZvciBKU1gpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogY29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4nKS5Db21wb25lbnRDaGlsZHJlbj59IFtjaGlsZHJlbl0gVGhlIGNoaWxkcmVuIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHNcblx0Ly8gTm90ZTogdHlwZSBtYXkgYmUgdW5kZWZpbmVkIGluIGRldmVsb3BtZW50LCBtdXN0IG5ldmVyIGVycm9yIGhlcmUuXG5cdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmIHR5cGUuZGVmYXVsdFByb3BzICE9IG51bGwpIHtcblx0XHRmb3IgKGkgaW4gdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB0eXBlLmRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbm9ybWFsaXplZFByb3BzLCBrZXksIHJlZiwgbnVsbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgVk5vZGUgKHVzZWQgaW50ZXJuYWxseSBieSBQcmVhY3QpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogQ29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IG51bWJlciB8IG51bGx9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdmlydHVhbCBub2RlLlxuICogSWYgdGhpcyB2aXJ0dWFsIG5vZGUgcmVwcmVzZW50cyBhIHRleHQgbm9kZSwgdGhpcyBpcyB0aGUgdGV4dCBvZiB0aGUgbm9kZSAoc3RyaW5nIG9yIG51bWJlcikuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG51bGx9IGtleSBUaGUga2V5IGZvciB0aGlzIHZpcnR1YWwgbm9kZSwgdXNlZCB3aGVuXG4gKiBkaWZmaW5nIGl0IGFnYWluc3QgaXRzIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1wicmVmXCJdfSByZWYgVGhlIHJlZiBwcm9wZXJ0eSB0aGF0IHdpbGxcbiAqIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gaXRzIGNyZWF0ZWQgY2hpbGRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIHJlZiwgb3JpZ2luYWwpIHtcblx0Ly8gVjggc2VlbXMgdG8gYmUgYmV0dGVyIGF0IGRldGVjdGluZyB0eXBlIHNoYXBlcyBpZiB0aGUgb2JqZWN0IGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBzYW1lIGNhbGwgc2l0ZVxuXHQvLyBEbyBub3QgaW5saW5lIGludG8gY3JlYXRlRWxlbWVudCBhbmQgY29lcmNlVG9WTm9kZSFcblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdC8vIF9uZXh0RG9tIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIGIvYyBpdCB3aWxsIGV2ZW50dWFsbHlcblx0XHQvLyBiZSBzZXQgdG8gZG9tLm5leHRTaWJsaW5nIHdoaWNoIGNhbiByZXR1cm4gYG51bGxgIGFuZCBpdCBpcyBpbXBvcnRhbnRcblx0XHQvLyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gdW5pbml0aWFsaXplZCBfbmV4dERvbSBhbmRcblx0XHQvLyBhIF9uZXh0RG9tIHRoYXQgaGFzIGJlZW4gc2V0IHRvIGBudWxsYFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbCA9PSBudWxsID8gKyt2bm9kZUlkIDogb3JpZ2luYWxcblx0fTtcblxuXHQvLyBPbmx5IGludm9rZSB0aGUgdm5vZGUgaG9vayBpZiB0aGlzIHdhcyAqbm90KiBhIGRpcmVjdCBjb3B5OlxuXHRpZiAob3JpZ2luYWwgPT0gbnVsbCAmJiBvcHRpb25zLnZub2RlICE9IG51bGwpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgKChzOiBvYmplY3QsIHA6IG9iamVjdCkgPT4gb2JqZWN0KX0gdXBkYXRlIEEgaGFzaCBvZiBzdGF0ZVxuICogcHJvcGVydGllcyB0byB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzIG9yIGEgZnVuY3Rpb24gdGhhdCBnaXZlbiB0aGUgY3VycmVudFxuICogc3RhdGUgYW5kIHByb3BzIHJldHVybnMgYSBuZXcgcGFydGlhbCBzdGF0ZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzXG4gKiB1cGRhdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAodXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuX3N0YXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdH1cblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBhXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYlxuICovXG5jb25zdCBkZXB0aFNvcnQgPSAoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoO1xuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdHdoaWxlICgoYyA9IHJlcmVuZGVyUXVldWUuc2hpZnQoKSkpIHtcblx0XHRpZiAoYy5fZGlydHkpIHtcblx0XHRcdGxldCByZW5kZXJRdWV1ZUxlbmd0aCA9IHJlcmVuZGVyUXVldWUubGVuZ3RoO1xuXHRcdFx0cmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdFx0aWYgKHJlcmVuZGVyUXVldWUubGVuZ3RoID4gcmVuZGVyUXVldWVMZW5ndGgpIHtcblx0XHRcdFx0Ly8gV2hlbiBpLmUuIHJlcmVuZGVyaW5nIGEgcHJvdmlkZXIgYWRkaXRpb25hbCBuZXcgaXRlbXMgY2FuIGJlIGluamVjdGVkLCB3ZSB3YW50IHRvXG5cdFx0XHRcdC8vIGtlZXAgdGhlIG9yZGVyIGZyb20gdG9wIHRvIGJvdHRvbSB3aXRoIHRob3NlIG5ldyBpdGVtcyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW0gaW4gYVxuXHRcdFx0XHQvLyBzaW5nbGUgcGFzc1xuXHRcdFx0XHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRbXX0gKi9cblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAoX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0XHRjLl9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5zdWIgPSBjID0+IHtcblx0XHRcdFx0XHRzdWJzLnB1c2goYyk7XG5cdFx0XHRcdFx0bGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRcdFx0XHRcdHN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjKSwgMSk7XG5cdFx0XHRcdFx0XHRpZiAob2xkKSBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cblx0cmV0dXJuIChjb250ZXh0LlByb3ZpZGVyLl9jb250ZXh0UmVmID0gY29udGV4dC5Db25zdW1lci5jb250ZXh0VHlwZSA9XG5cdFx0Y29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID1cblx0L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChcblx0XHRcdGNoaWxkVk5vZGUgPT0gbnVsbCB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tICE9IG51bGwgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSA9PSBuZXdQYXJlbnRWTm9kZS5fbmV4dERvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXdQYXJlbnRWTm9kZS5fX25leHREb20gcG9pbnRzIHRvIGEgZG9tIG5vZGUgdGhhdCBpcyBhYm91dCB0b1xuXHRcdFx0XHQvLyBiZSB1bm1vdW50ZWQsIHRoZW4gZ2V0IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhhdCB2bm9kZSBhbmQgc2V0XG5cdFx0XHRcdC8vIF9uZXh0RG9tIHRvIGl0XG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gZ2V0TGFzdERvbShvbGRQYXJlbnRWTm9kZSkubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBnZXRMYXN0RG9tKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09IG51bGwgfHwgdHlwZW9mIHZub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLl9kb207XG5cdH1cblxuXHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0Zm9yIChsZXQgaSA9IHZub2RlLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdGxldCBsYXN0RG9tID0gZ2V0TGFzdERvbShjaGlsZCk7XG5cdFx0XHRcdGlmIChsYXN0RG9tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhc3REb207XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ3dpZHRoJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hlaWdodCcgJiZcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIGFyaWEtIGFuZCBkYXRhLSBhdHRyaWJ1dGVzIGhhdmUgbm8gYm9vbGVhbiByZXByZXNlbnRhdGlvbi5cblx0XHQvLyBBIGBmYWxzZWAgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGF0dHJpYnV0ZSBub3QgYmVpbmdcblx0XHQvLyBwcmVzZW50LCBzbyB3ZSBjYW4ndCByZW1vdmUgaXQuIEZvciBub24tYm9vbGVhbiBhcmlhXG5cdFx0Ly8gYXR0cmlidXRlcyB3ZSBjb3VsZCB0cmVhdCBmYWxzZSBhcyBhIHJlbW92YWwsIGJ1dCB0aGVcblx0XHQvLyBhbW91bnQgb2YgZXhjZXB0aW9ucyB3b3VsZCBjb3N0IHRvbyBtYW55IGJ5dGVzLiBPbiB0b3Agb2Zcblx0XHQvLyB0aGF0IG90aGVyIGZyYW1ld29ya3MgZ2VuZXJhbGx5IHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZVs0XSA9PT0gJy0nKSkge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgZmFsc2VdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50UHJveHlDYXB0dXJlKGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyB0cnVlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbXBvbmVudCwgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGRpZmZDaGlsZHJlbiB9IGZyb20gJy4vY2hpbGRyZW4nO1xuaW1wb3J0IHsgZGlmZlByb3BzLCBzZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHsgYXNzaWduLCByZW1vdmVOb2RlLCBzbGljZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyBhbmQgYXBwbHkgcHJvcGVyIGNoYW5nZXMgdG8gdGhlIERPTVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBwYXJlbnQgb2YgdGhlIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QuIE1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIGVsZW1lbnQgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQ+fSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gb2xkRG9tIFRoZSBjdXJyZW50IGF0dGFjaGVkIERPTVxuICogZWxlbWVudCBhbnkgbmV3IGRvbSBlbGVtZW50cyBzaG91bGQgYmUgcGxhY2VkIGFyb3VuZC4gTGlrZWx5IGBudWxsYCBvbiBmaXJzdFxuICogcmVuZGVyIChleGNlcHQgd2hlbiBoeWRyYXRpbmcpLiBDYW4gYmUgYSBzaWJsaW5nIERPTSBlbGVtZW50IHdoZW4gZGlmZmluZ1xuICogRnJhZ21lbnRzIHRoYXQgaGF2ZSBzaWJsaW5ncy4gSW4gbW9zdCBjYXNlcywgaXQgc3RhcnRzIG91dCBhcyBgb2xkQ2hpbGRyZW5bMF0uX2RvbWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0h5ZHJhdGluZ10gV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZihcblx0cGFyZW50RG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgdG1wLFxuXHRcdG5ld1R5cGUgPSBuZXdWTm9kZS50eXBlO1xuXG5cdC8vIFdoZW4gcGFzc2luZyB0aHJvdWdoIGNyZWF0ZUVsZW1lbnQgaXQgYXNzaWducyB0aGUgb2JqZWN0XG5cdC8vIGNvbnN0cnVjdG9yIGFzIHVuZGVmaW5lZC4gVGhpcyB0byBwcmV2ZW50IEpTT04taW5qZWN0aW9uLlxuXHRpZiAobmV3Vk5vZGUuY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cblx0Ly8gSWYgdGhlIHByZXZpb3VzIGRpZmYgYmFpbGVkIG91dCwgcmVzdW1lIGNyZWF0aW5nL2h5ZHJhdGluZy5cblx0aWYgKG9sZFZOb2RlLl9oeWRyYXRpbmcgIT0gbnVsbCkge1xuXHRcdGlzSHlkcmF0aW5nID0gb2xkVk5vZGUuX2h5ZHJhdGluZztcblx0XHRvbGREb20gPSBuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHQvLyBpZiB3ZSByZXN1bWUsIHdlIHdhbnQgdGhlIHRyZWUgdG8gYmUgXCJ1bmxvY2tlZFwiXG5cdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBbb2xkRG9tXTtcblx0fVxuXG5cdGlmICgodG1wID0gb3B0aW9ucy5fZGlmZikpIHRtcChuZXdWTm9kZSk7XG5cblx0dHJ5IHtcblx0XHRvdXRlcjogaWYgKHR5cGVvZiBuZXdUeXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxldCBjLCBpc05ldywgb2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCwgY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uO1xuXHRcdFx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgY3JlYXRlQ29udGV4dCBhcGkuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHBhc3Ncblx0XHRcdC8vIHRoZSBjb250ZXh0IHZhbHVlIGFzIGB0aGlzLmNvbnRleHRgIGp1c3QgZm9yIHRoaXMgY29tcG9uZW50LlxuXHRcdFx0dG1wID0gbmV3VHlwZS5jb250ZXh0VHlwZTtcblx0XHRcdGxldCBwcm92aWRlciA9IHRtcCAmJiBnbG9iYWxDb250ZXh0W3RtcC5faWRdO1xuXHRcdFx0bGV0IGNvbXBvbmVudENvbnRleHQgPSB0bXBcblx0XHRcdFx0PyBwcm92aWRlclxuXHRcdFx0XHRcdD8gcHJvdmlkZXIucHJvcHMudmFsdWVcblx0XHRcdFx0XHQ6IHRtcC5fZGVmYXVsdFZhbHVlXG5cdFx0XHRcdDogZ2xvYmFsQ29udGV4dDtcblxuXHRcdFx0Ly8gR2V0IGNvbXBvbmVudCBhbmQgc2V0IGl0IHRvIGBjYFxuXHRcdFx0aWYgKG9sZFZOb2RlLl9jb21wb25lbnQpIHtcblx0XHRcdFx0YyA9IG5ld1ZOb2RlLl9jb21wb25lbnQgPSBvbGRWTm9kZS5fY29tcG9uZW50O1xuXHRcdFx0XHRjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcGVuZGluZ0Vycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIG5ldyBjb21wb25lbnRcblx0XHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUaGUgY2hlY2sgYWJvdmUgdmVyaWZpZXMgdGhhdCBuZXdUeXBlIGlzIHN1cHBvc2UgdG8gYmUgY29uc3RydWN0ZWRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBuZXdUeXBlKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUcnVzdCBtZSwgQ29tcG9uZW50IGltcGxlbWVudHMgdGhlIGludGVyZmFjZSB3ZSB3YW50XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgQ29tcG9uZW50KG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0XHRjLmNvbnN0cnVjdG9yID0gbmV3VHlwZTtcblx0XHRcdFx0XHRjLnJlbmRlciA9IGRvUmVuZGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcm92aWRlcikgcHJvdmlkZXIuc3ViKGMpO1xuXG5cdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0aWYgKCFjLnN0YXRlKSBjLnN0YXRlID0ge307XG5cdFx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRcdGMuX2dsb2JhbENvbnRleHQgPSBnbG9iYWxDb250ZXh0O1xuXHRcdFx0XHRpc05ldyA9IGMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludm9rZSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcblx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gbnVsbCkge1xuXHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IGMuc3RhdGUpIHtcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIGMuX25leHRTdGF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ24oXG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdG9sZFByb3BzID0gYy5wcm9wcztcblx0XHRcdG9sZFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cblx0XHRcdC8vIEludm9rZSBwcmUtcmVuZGVyIGxpZmVjeWNsZSBtZXRob2RzXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRNb3VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5jb21wb25lbnREaWRNb3VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0bmV3UHJvcHMgIT09IG9sZFByb3BzICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIWMuX2ZvcmNlICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZShcblx0XHRcdFx0XHRcdFx0bmV3UHJvcHMsXG5cdFx0XHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50Q29udGV4dFxuXHRcdFx0XHRcdFx0KSA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSB7XG5cdFx0XHRcdFx0XHQvLyBXaGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBiYWlsIGJlY2F1c2Ugb2Ygc0NVIHdlIGhhdmUgdG8gdXBkYXRlXG5cdFx0XHRcdFx0XHQvLyB0aGUgcHJvcHMsIHN0YXRlIGFuZCBkaXJ0eS1zdGF0ZS5cblx0XHRcdFx0XHRcdC8vIHdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBzdHJpY3QtZXF1YWxpdHkgd2UgZG9uJ3QgYXMgdGhlIGNoaWxkIGNvdWxkIHN0aWxsXG5cdFx0XHRcdFx0XHQvLyBiZSBkaXJ0aWVkIHNlZSAjMzg4M1xuXHRcdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSW4gY2FzZXMgb2YgYmFpbGluZyBkdWUgdG8gc3RyaWN0LWVxdWFsaXR5IHdlIGhhdmUgdG8gcmVzZXQgZm9yY2UgYXMgd2VsbFxuXHRcdFx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdH0gd2hpbGUgKGMuX2RpcnR5ICYmICsrY291bnQgPCAyNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cblx0XHRcdGlmIChjLmdldENoaWxkQ29udGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGdsb2JhbENvbnRleHQgPSBhc3NpZ24oYXNzaWduKHt9LCBnbG9iYWxDb250ZXh0KSwgYy5nZXRDaGlsZENvbnRleHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNOZXcgJiYgYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNuYXBzaG90ID0gYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXNUb3BMZXZlbEZyYWdtZW50ID1cblx0XHRcdFx0dG1wICE9IG51bGwgJiYgdG1wLnR5cGUgPT09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdGxldCByZW5kZXJSZXN1bHQgPSBpc1RvcExldmVsRnJhZ21lbnQgPyB0bXAucHJvcHMuY2hpbGRyZW4gOiB0bXA7XG5cblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KHJlbmRlclJlc3VsdCkgPyByZW5kZXJSZXN1bHQgOiBbcmVuZGVyUmVzdWx0XSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHRjLmJhc2UgPSBuZXdWTm9kZS5fZG9tO1xuXG5cdFx0XHQvLyBXZSBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgdGhpcyBWTm9kZSwgdW5zZXQgYW55IHN0b3JlZCBoeWRyYXRpb24vYmFpbG91dCBzdGF0ZTpcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHRcdGMuX3BlbmRpbmdFcnJvciA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbiA9PSBudWxsICYmXG5cdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBkaWZmRWxlbWVudE5vZGVzKFxuXHRcdFx0XHRvbGRWTm9kZS5fZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICgodG1wID0gb3B0aW9ucy5kaWZmZWQpKSB0bXAobmV3Vk5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0bmV3Vk5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHQvLyBpZiBoeWRyYXRpbmcgb3IgY3JlYXRpbmcgaW5pdGlhbCB0cmVlLCBiYWlsb3V0IHByZXNlcnZlcyBET006XG5cdFx0aWYgKGlzSHlkcmF0aW5nIHx8IGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGREb207XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gISFpc0h5ZHJhdGluZztcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2V4Y2Vzc0RvbUNoaWxkcmVuLmluZGV4T2Yob2xkRG9tKV0gPSBudWxsO1xuXHRcdFx0Ly8gXiBjb3VsZCBwb3NzaWJseSBiZSBzaW1wbGlmaWVkIHRvOlxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFJldXNlIHRoZSBjb21taXRRdWV1ZSB2YXJpYWJsZSBoZXJlIHNvIHRoZSB0eXBlIGNoYW5nZXNcblx0XHRcdGNvbW1pdFF1ZXVlID0gYy5fcmVuZGVyQ2FsbGJhY2tzO1xuXHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGNiID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBTZWUgYWJvdmUgdHMtaWdub3JlIG9uIGNvbW1pdFF1ZXVlXG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzO1xuXHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblx0bGV0IG5vZGVUeXBlID0gbmV3Vk5vZGUudHlwZTtcblx0bGV0IGkgPSAwO1xuXG5cdC8vIFRyYWNrcyBlbnRlcmluZyBhbmQgZXhpdGluZyBTVkcgbmFtZXNwYWNlIHdoZW4gZGVzY2VuZGluZyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRpZiAobm9kZVR5cGUgPT09ICdzdmcnKSBpc1N2ZyA9IHRydWU7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKDsgaSA8IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGV4Y2Vzc0RvbUNoaWxkcmVuW2ldO1xuXG5cdFx0XHQvLyBpZiBuZXdWTm9kZSBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4gb3IgdGhlIGBkb21gXG5cdFx0XHQvLyBhcmd1bWVudCBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4sIHJlbW92ZSBpdCBmcm9tXG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbiBzbyBpdCBpc24ndCBsYXRlciByZW1vdmVkIGluIGRpZmZDaGlsZHJlblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGlsZCAmJlxuXHRcdFx0XHQnc2V0QXR0cmlidXRlJyBpbiBjaGlsZCA9PT0gISFub2RlVHlwZSAmJlxuXHRcdFx0XHQobm9kZVR5cGUgPyBjaGlsZC5sb2NhbE5hbWUgPT09IG5vZGVUeXBlIDogY2hpbGQubm9kZVR5cGUgPT09IDMpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZG9tID0gY2hpbGQ7XG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2ldID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSA9PSBudWxsKSB7XG5cdFx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIGNyZWF0ZVRleHROb2RlIHJldHVybnMgVGV4dCwgd2UgZXhwZWN0IFByZWFjdEVsZW1lbnRcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdQcm9wcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG5cdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGUsXG5cdFx0XHRcdG5ld1Byb3BzLmlzICYmIG5ld1Byb3BzXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdlIGNyZWF0ZWQgYSBuZXcgcGFyZW50LCBzbyBub25lIG9mIHRoZSBwcmV2aW91c2x5IGF0dGFjaGVkIGNoaWxkcmVuIGNhbiBiZSByZXVzZWQ6XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBudWxsO1xuXHRcdC8vIHdlIGFyZSBjcmVhdGluZyBhIG5ldyBub2RlLCBzbyB3ZSBjYW4gYXNzdW1lIHRoaXMgaXMgYSBuZXcgc3VidHJlZSAoaW4gY2FzZSB3ZSBhcmUgaHlkcmF0aW5nKSwgdGhpcyBkZW9wdHMgdGhlIGh5ZHJhdGVcblx0XHRpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgd2Ugc3RpbGwgaGF2ZSB0byBzcGxpdCBtZXJnZWQgdGV4dCBmcm9tIFNTUidkIEhUTUwuXG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiAoIWlzSHlkcmF0aW5nIHx8IGRvbS5kYXRhICE9PSBuZXdQcm9wcykpIHtcblx0XHRcdGRvbS5kYXRhID0gbmV3UHJvcHM7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIGV4Y2Vzc0RvbUNoaWxkcmVuIHdhcyBub3QgbnVsbCwgcmVwb3B1bGF0ZSBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQncyBjaGlsZHJlbjpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IGV4Y2Vzc0RvbUNoaWxkcmVuICYmIHNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXG5cdFx0b2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG5cblx0XHRsZXQgb2xkSHRtbCA9IG9sZFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXHRcdGxldCBuZXdIdG1sID0gbmV3UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCBwcm9wcyBhcmUgbm90IGRpZmZlZCBhdCBhbGwgKGluY2x1ZGluZyBkYW5nZXJvdXNseVNldElubmVySFRNTClcblx0XHQvLyBAVE9ETyB3ZSBzaG91bGQgd2FybiBpbiBkZWJ1ZyBtb2RlIHdoZW4gcHJvcHMgZG9uJ3QgbWF0Y2ggaGVyZS5cblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHQvLyBCdXQsIGlmIHdlIGFyZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhcmUgdXNpbmcgZXhpc3RpbmcgRE9NIChlLmcuIHJlcGxhY2VOb2RlKVxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHJlYWQgdGhlIGV4aXN0aW5nIERPTSBhdHRyaWJ1dGVzIHRvIGRpZmYgdGhlbVxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2xkUHJvcHNbZG9tLmF0dHJpYnV0ZXNbaV0ubmFtZV0gPSBkb20uYXR0cmlidXRlc1tpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3SHRtbCB8fCBvbGRIdG1sKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHJlLWFwcGx5aW5nIHRoZSBzYW1lICdfX2h0bWwnIGlmIGl0IGRpZCBub3QgY2hhbmdlZCBiZXR3ZWVuIHJlLXJlbmRlclxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IW5ld0h0bWwgfHxcblx0XHRcdFx0XHQoKCFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSAmJlxuXHRcdFx0XHRcdFx0bmV3SHRtbC5fX2h0bWwgIT09IGRvbS5pbm5lckhUTUwpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRvbS5pbm5lckhUTUwgPSAobmV3SHRtbCAmJiBuZXdIdG1sLl9faHRtbCkgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBpc0h5ZHJhdGluZyk7XG5cblx0XHQvLyBJZiB0aGUgbmV3IHZub2RlIGRpZG4ndCBoYXZlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCBkaWZmIGl0cyBjaGlsZHJlblxuXHRcdGlmIChuZXdIdG1sKSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSA9IG5ld1ZOb2RlLnByb3BzLmNoaWxkcmVuO1xuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRkb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoaSkgPyBpIDogW2ldLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnICYmIG5vZGVUeXBlICE9PSAnZm9yZWlnbk9iamVjdCcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5cblx0XHRcdFx0XHQ/IGV4Y2Vzc0RvbUNoaWxkcmVuWzBdXG5cdFx0XHRcdFx0OiBvbGRWTm9kZS5fY2hpbGRyZW4gJiYgZ2V0RG9tU2libGluZyhvbGRWTm9kZSwgMCksXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHBhcnQgb2YgYW55IHZub2RlLlxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIChhcyBhYm92ZSwgZG9uJ3QgZGlmZiBwcm9wcyBkdXJpbmcgaHlkcmF0aW9uKVxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0J3ZhbHVlJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLnZhbHVlKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vICMyNzU2IEZvciB0aGUgPHByb2dyZXNzPi1lbGVtZW50IHRoZSBpbml0aWFsIHZhbHVlIGlzIDAsXG5cdFx0XHRcdC8vIGRlc3BpdGUgdGhlIGF0dHJpYnV0ZSBub3QgYmVpbmcgcHJlc2VudC4gV2hlbiB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIGlzIG1pc3NpbmcgdGhlIHByb2dyZXNzIGJhciBpcyB0cmVhdGVkIGFzIGluZGV0ZXJtaW5hdGUuXG5cdFx0XHRcdC8vIFRvIGZpeCB0aGF0IHdlJ2xsIGFsd2F5cyB1cGRhdGUgaXQgd2hlbiBpdCBpcyAwIGZvciBwcm9ncmVzcyBlbGVtZW50c1xuXHRcdFx0XHQoaSAhPT0gZG9tLnZhbHVlIHx8XG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAncHJvZ3Jlc3MnICYmICFpKSB8fFxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgb25seSBmb3IgSUUgMTEgdG8gZml4IDxzZWxlY3Q+IHZhbHVlIG5vdCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0XHRcdC8vIFRvIGF2b2lkIGEgc3RhbGUgc2VsZWN0IHZhbHVlIHdlIG5lZWQgdG8gc2V0IHRoZSBvcHRpb24udmFsdWVcblx0XHRcdFx0XHQvLyBhZ2Fpbiwgd2hpY2ggdHJpZ2dlcnMgSUUxMSB0byByZS1ldmFsdWF0ZSB0aGUgc2VsZWN0IHZhbHVlXG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAnb3B0aW9uJyAmJiBpICE9PSBvbGRQcm9wcy52YWx1ZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAndmFsdWUnLCBpLCBvbGRQcm9wcy52YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQnY2hlY2tlZCcgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy5jaGVja2VkKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdGkgIT09IGRvbS5jaGVja2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAnY2hlY2tlZCcsIGksIG9sZFByb3BzLmNoZWNrZWQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZG9tO1xufVxuXG4vKipcbiAqIEludm9rZSBvciB1cGRhdGUgYSByZWYsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHJlZi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSByZWZcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlLCB2bm9kZSkge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHJlZih2YWx1ZSk7XG5cdFx0ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCB2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGEgdmlydHVhbCBub2RlIGZyb20gdGhlIHRyZWUgYW5kIGFwcGx5IERPTSBjaGFuZ2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byB1bm1vdW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcGFyZW50Vk5vZGUgVGhlIHBhcmVudCBvZiB0aGUgVk5vZGUgdGhhdFxuICogaW5pdGlhdGVkIHRoZSB1bm1vdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgYSBwYXJlbnQgbm9kZSBvZiB0aGVcbiAqIGN1cnJlbnQgZWxlbWVudCBpcyBhbHJlYWR5IGRldGFjaGVkIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQodm5vZGUsIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlKSB7XG5cdGxldCByO1xuXHRpZiAob3B0aW9ucy51bm1vdW50KSBvcHRpb25zLnVubW91bnQodm5vZGUpO1xuXG5cdGlmICgociA9IHZub2RlLnJlZikpIHtcblx0XHRpZiAoIXIuY3VycmVudCB8fCByLmN1cnJlbnQgPT09IHZub2RlLl9kb20pIHtcblx0XHRcdGFwcGx5UmVmKHIsIG51bGwsIHBhcmVudFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY29tcG9uZW50KSAhPSBudWxsKSB7XG5cdFx0aWYgKHIuY29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBwYXJlbnRWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ci5iYXNlID0gci5fcGFyZW50RG9tID0gbnVsbDtcblx0XHR2bm9kZS5fY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NoaWxkcmVuKSkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJbaV0pIHtcblx0XHRcdFx0dW5tb3VudChcblx0XHRcdFx0XHRyW2ldLFxuXHRcdFx0XHRcdHBhcmVudFZOb2RlLFxuXHRcdFx0XHRcdHNraXBSZW1vdmUgfHwgdHlwZW9mIHZub2RlLnR5cGUgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSB7XG5cdFx0cmVtb3ZlTm9kZSh2bm9kZS5fZG9tKTtcblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9wYXJlbnQgPSB2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBvYmplY3R9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2UgYXJlIGluXG5cdC8vIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIHRoZSBgaHlkcmF0ZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBhIERPTVxuXHQvLyBlbGVtZW50Li5cblx0bGV0IGlzSHlkcmF0aW5nID0gdHlwZW9mIHJlcGxhY2VOb2RlID09PSAnZnVuY3Rpb24nO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXG5cdHZub2RlID0gKCghaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGUpIHx8IHBhcmVudERvbSkuX2NoaWxkcmVuID1cblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsImltcG9ydCB7IGFzc2lnbiwgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKFxuXHRcdHZub2RlLnR5cGUsXG5cdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSB8fCB2bm9kZS5rZXksXG5cdFx0cmVmIHx8IHZub2RlLnJlZixcblx0XHRudWxsXG5cdCk7XG59XG4iLCIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgncHJlYWN0JykuVk5vZGV9IFZOb2RlICovXG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGZpbGUgZXhwb3J0cyB2YXJpb3VzIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQmFiZWwncyBcImF1dG9tYXRpY1wiIEpTWCBydW50aW1lIEFQSTpcbiAqIC0ganN4KHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeHModHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIF9fc291cmNlLCBfX3NlbGYpXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGNyZWF0ZVZOb2RlIGhlcmUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cbiAqIEJlbmNobWFya3M6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWY2YjU0YTBiNDYzMjEwMGE3ZGNkMmIzXG4gKi9cblxuLyoqXG4gKiBKU1guRWxlbWVudCBmYWN0b3J5IHVzZWQgYnkgQmFiZWwncyB7cnVudGltZTpcImF1dG9tYXRpY1wifSBKU1ggdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1ZOb2RlWyd0eXBlJ119IHR5cGVcbiAqIEBwYXJhbSB7Vk5vZGVbJ3Byb3BzJ119IHByb3BzXG4gKiBAcGFyYW0ge1ZOb2RlWydrZXknXX0gW2tleV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW2lzU3RhdGljQ2hpbGRyZW5dXG4gKiBAcGFyYW0ge3Vua25vd259IFtfX3NvdXJjZV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW19fc2VsZl1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgX19zb3VyY2UsIF9fc2VsZikge1xuXHQvLyBXZSdsbCB3YW50IHRvIHByZXNlcnZlIGByZWZgIGluIHByb3BzIHRvIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yXG5cdC8vIGZvcndhcmRSZWYgY29tcG9uZW50cyBpbiB0aGUgZnV0dXJlLCBidXQgdGhhdCBzaG91bGQgaGFwcGVuIHZpYVxuXHQvLyBhIHNlcGFyYXRlIFBSLlxuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdyZWYnKSB7XG5cdFx0XHRyZWYgPSBwcm9wc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wczogbm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IC0tdm5vZGVJZCxcblx0XHRfX3NvdXJjZSxcblx0XHRfX3NlbGZcblx0fTtcblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHMuXG5cdC8vIE5vdGU6IGB0eXBlYCBpcyBvZnRlbiBhIFN0cmluZywgYW5kIGNhbiBiZSBgdW5kZWZpbmVkYCBpbiBkZXZlbG9wbWVudC5cblx0aWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIChyZWYgPSB0eXBlLmRlZmF1bHRQcm9wcykpIHtcblx0XHRmb3IgKGkgaW4gcmVmKVxuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkUHJvcHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHJlZltpXTtcblx0XHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQge1xuXHRjcmVhdGVWTm9kZSBhcyBqc3gsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeHMsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeERFVixcblx0RnJhZ21lbnRcbn07XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRsZXQgcHJldlNjdSA9IGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuXHRcdFx0Y29uc3QgcHJldkNXVSA9IGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgZm9yY2VkIHVwZGF0ZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCB3aWxsXG5cdFx0XHQvLyBub3QgYmUgY2FsbGVkLiBCdXQgd2UgdXNlIHRoYXQgdG8gdXBkYXRlIHRoZSBob29rIHZhbHVlcywgc28gd2Vcblx0XHRcdC8vIG5lZWQgdG8gY2FsbCBpdC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIChwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9mb3JjZSkge1xuXHRcdFx0XHRcdGxldCB0bXAgPSBwcmV2U2N1O1xuXHRcdFx0XHRcdC8vIENsZWFyIHRvIGF2b2lkIG90aGVyIHNDVSBob29rcyBmcm9tIGJlaW5nIGNhbGxlZFxuXHRcdFx0XHRcdHByZXZTY3UgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0dXBkYXRlSG9va1N0YXRlKHAsIHMsIGMpO1xuXHRcdFx0XHRcdHByZXZTY3UgPSB0bXA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocHJldkNXVSkgcHJldkNXVS5jYWxsKHRoaXMsIHAsIHMsIGMpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0LyoqXG5cdFx0XHQgKlxuXHRcdFx0ICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudFtcInNob3VsZENvbXBvbmVudFVwZGF0ZVwiXX1cblx0XHRcdCAqL1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSAtIFdlIGRvbid0IHVzZSBUUyB0byBkb3dudHJhbnNwaWxlXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVIb29rU3RhdGUocCwgcywgYykge1xuXHRcdFx0XHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXRlSG9va3MgPSBob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZpbHRlcihcblx0XHRcdFx0XHR4ID0+IHguX2NvbXBvbmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCBhbGxIb29rc0VtcHR5ID0gc3RhdGVIb29rcy5ldmVyeSh4ID0+ICF4Ll9uZXh0VmFsdWUpO1xuXHRcdFx0XHQvLyBXaGVuIHdlIGhhdmUgbm8gdXBkYXRlZCBob29rcyBpbiB0aGUgY29tcG9uZW50IHdlIGludm9rZSB0aGUgcHJldmlvdXMgU0NVIG9yXG5cdFx0XHRcdC8vIHRyYXZlcnNlIHRoZSBWRE9NIHRyZWUgZnVydGhlci5cblx0XHRcdFx0aWYgKGFsbEhvb2tzRW1wdHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJldlNjdSA/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKSA6IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSBjaGVjayB3aGV0aGVyIHdlIGhhdmUgY29tcG9uZW50cyB3aXRoIGEgbmV4dFZhbHVlIHNldCB0aGF0XG5cdFx0XHRcdC8vIGhhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGVxdWFsIHRvIG9uZSBhbm90aGVyIHRoaXMgcHVzaGVzXG5cdFx0XHRcdC8vIHVzIHRvIHVwZGF0ZSBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcblx0XHRcdFx0bGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGF0ZUhvb2tzLmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rSXRlbS5fdmFsdWVbMF07XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IGhvb2tJdGVtLl92YWx1ZVswXSkgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiBzaG91bGRVcGRhdGUgfHwgaG9va1N0YXRlLl9jb21wb25lbnQucHJvcHMgIT09IHBcblx0XHRcdFx0XHQ/IHByZXZTY3Vcblx0XHRcdFx0XHRcdD8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpXG5cdFx0XHRcdFx0XHQ6IHRydWVcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHVwZGF0ZUhvb2tTdGF0ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl9uZXh0VmFsdWUgfHwgaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55LCBlcnJvckluZm86IGltcG9ydCgncHJlYWN0JykuRXJyb3JJbmZvKSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSAoZXJyLCBlcnJvckluZm8pID0+IHtcblx0XHRcdGlmIChzdGF0ZS5fdmFsdWUpIHN0YXRlLl92YWx1ZShlcnIsIGVycm9ySW5mbyk7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkKCkge1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTEpO1xuXHRpZiAoIXN0YXRlLl92YWx1ZSkge1xuXHRcdC8vIEdyYWIgZWl0aGVyIHRoZSByb290IG5vZGUgb3IgdGhlIG5lYXJlc3QgYXN5bmMgYm91bmRhcnkgbm9kZS5cblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbC5kJykuVk5vZGV9ICovXG5cdFx0bGV0IHJvb3QgPSBjdXJyZW50Q29tcG9uZW50Ll92bm9kZTtcblx0XHR3aGlsZSAocm9vdCAhPT0gbnVsbCAmJiAhcm9vdC5fbWFzayAmJiByb290Ll9wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJvb3QgPSByb290Ll9wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0bGV0IG1hc2sgPSByb290Ll9tYXNrIHx8IChyb290Ll9tYXNrID0gWzAsIDBdKTtcblx0XHRzdGF0ZS5fdmFsdWUgPSAnUCcgKyBtYXNrWzBdICsgJy0nICsgbWFza1sxXSsrO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cbi8qKlxuICogQWZ0ZXIgcGFpbnQgZWZmZWN0cyBjb25zdW1lci5cbiAqL1xuZnVuY3Rpb24gZmx1c2hBZnRlclBhaW50RWZmZWN0cygpIHtcblx0bGV0IGNvbXBvbmVudDtcblx0d2hpbGUgKChjb21wb25lbnQgPSBhZnRlclBhaW50RWZmZWN0cy5zaGlmdCgpKSkge1xuXHRcdGlmICghY29tcG9uZW50Ll9wYXJlbnREb20gfHwgIWNvbXBvbmVudC5fX2hvb2tzKSBjb250aW51ZTtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGEgY2hhbmNlIHRvIHBhaW50IGEgbmV3IGZyYW1lLlxuICogRG8gdGhpcyBieSBjb21iaW5pbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpICsgc2V0VGltZW91dCB0byBpbnZva2UgYSBjYWxsYmFjayBhZnRlclxuICogdGhlIG5leHQgYnJvd3NlciBmcmFtZS5cbiAqXG4gKiBBbHNvLCBzY2hlZHVsZSBhIHRpbWVvdXQgaW4gcGFyYWxsZWwgdG8gdGhlIHRoZSByQUYgdG8gZW5zdXJlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkXG4gKiBldmVuIGlmIFJBRiBkb2Vzbid0IGZpcmUgKGZvciBleGFtcGxlIGlmIHRoZSBicm93c2VyIHRhYiBpcyBub3QgdmlzaWJsZSlcbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFmdGVyTmV4dEZyYW1lKGNhbGxiYWNrKSB7XG5cdGNvbnN0IGRvbmUgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdGlmIChIQVNfUkFGKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuXHRcdHNldFRpbWVvdXQoY2FsbGJhY2spO1xuXHR9O1xuXHRjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChkb25lLCBSQUZfVElNRU9VVCk7XG5cblx0bGV0IHJhZjtcblx0aWYgKEhBU19SQUYpIHtcblx0XHRyYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9uZSk7XG5cdH1cbn1cblxuLy8gTm90ZTogaWYgc29tZW9uZSB1c2VkIG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4vLyB0aGVuIGVmZmVjdHMgd2lsbCBBTFdBWVMgcnVuIG9uIHRoZSBORVhUIGZyYW1lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLCBpbmN1cnJpbmcgYSB+MTZtcyBkZWxheS5cbi8vIFBlcmhhcHMgdGhpcyBpcyBub3Qgc3VjaCBhIGJpZyBkZWFsLlxuLyoqXG4gKiBTY2hlZHVsZSBhZnRlclBhaW50RWZmZWN0cyBmbHVzaCBhZnRlciB0aGUgYnJvd3NlciBwYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdRdWV1ZUxlbmd0aFxuICovXG5mdW5jdGlvbiBhZnRlclBhaW50KG5ld1F1ZXVlTGVuZ3RoKSB7XG5cdGlmIChuZXdRdWV1ZUxlbmd0aCA9PT0gMSB8fCBwcmV2UmFmICE9PSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdHByZXZSYWYgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQocHJldlJhZiB8fCBhZnRlck5leHRGcmFtZSkoZmx1c2hBZnRlclBhaW50RWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VDbGVhbnVwKGhvb2spIHtcblx0Ly8gQSBob29rIGNsZWFudXAgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0bGV0IGNsZWFudXAgPSBob29rLl9jbGVhbnVwO1xuXHRpZiAodHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhvb2suX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Ly8gQSBob29rIGNhbGwgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0aG9vay5fY2xlYW51cCA9IGhvb2suX3ZhbHVlKCk7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IG9sZEFyZ3NcbiAqIEBwYXJhbSB7YW55W119IG5ld0FyZ3NcbiAqL1xuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncywgbmV3QXJncykge1xuXHRyZXR1cm4gKFxuXHRcdCFvbGRBcmdzIHx8XG5cdFx0b2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3MubGVuZ3RoIHx8XG5cdFx0bmV3QXJncy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuXHQpO1xufVxuXG5mdW5jdGlvbiBpbnZva2VPclJldHVybihhcmcsIGYpIHtcblx0cmV0dXJuIHR5cGVvZiBmID09ICdmdW5jdGlvbicgPyBmKGFyZykgOiBmO1xufVxuIiwiXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgY29uc3QgcHJvY2VzczogeyBlbnY6IHsgTk9ERV9FTlY/OiBzdHJpbmcgfCB1bmRlZmluZWQgfSB8IHVuZGVmaW5lZCB9O1xufVxuXG5sZXQgY2FjaGVkOiBcInByb2R1Y3Rpb25cIiB8IFwiZGV2ZWxvcG1lbnRcIiB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkKCk6IFwicHJvZHVjdGlvblwiIHwgXCJkZXZlbG9wbWVudFwiIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYhLk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gXCJkZXZlbG9wbWVudFwiO1xuXG4gICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgIC8vIEFzIGxvbmcgYXMgd2UncmUgcmV0dXJuaW5nIFwicHJvZHVjdGlvblwiIGR1ZSB0byBpdCBiZWluZyB1bnNwZWNpZmllZCwgXG4gICAgICAgIC8vIHRyeSB0byBtYWtlIHN1cmUgYW55b25lIGVsc2Ugd2hvIHRyaWVzIGRvZXMgdG9vIGZvciBjb25zaXN0ZW5jeS5cbiAgICAgICAgLy8gVE9ETzogR29vZC9iYWQgaWRlYT9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIChnbG9iYWxUaGlzIGFzIGFueSlbXCJwcm9jZXNzXCJdID8/PSB7fTtcbiAgICAgICAgICAgIChnbG9iYWxUaGlzIGFzIGFueSlbXCJwcm9jZXNzXCJdW1wiZW52XCJdID8/PSB7fTtcbiAgICAgICAgICAgIChnbG9iYWxUaGlzIGFzIGFueSlbXCJwcm9jZXNzXCJdW1wiZW52XCJdW1wiTk9ERV9FTlZcIl0gPz89IFwicHJvZHVjdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVpbGRNb2RlKCkge1xuICAgIHJldHVybiBjYWNoZWQgPz89IChnZXRCdWlsZE1vZGVVbm1lbW9pemVkKCkpO1xufVxuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi9tb2RlLmpzXCI7XG5cbi8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIGluIGV2ZXJ5IGJ1aWxkLCBJIGRvbid0IHRoaW5rIGl0J3MgaW4gY29yZS1qcz8gSSB0aGluaz9cbi8vIEFuZCBpdCdzIGV4dHJlbWVseSBzbWFsbCBhbnl3YXkgYW5kIGJhc2ljYWxseSBkb2VzIG5vdGhpbmcuXG53aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA/Pz0gKGNhbGxiYWNrKSA9PiB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4geyBjYWxsYmFjayh7IGRpZFRpbWVvdXQ6IGZhbHNlLCB0aW1lUmVtYWluaW5nOiAoKSA9PiB7IHJldHVybiAwOyB9LCB9KTsgfSwgNSk7XG59O1xuXG5sZXQgdGltZW91dEhhbmRsZSA9IG51bGwgYXMgbnVtYmVyIHwgbnVsbDtcblxuaW50ZXJmYWNlIEhvb2tDYWxsQ291bnQge1xuICAgIGNhbGxDb3VudHM6IHsgW0s6IHN0cmluZ106IHsgdG90YWw6IG51bWJlciwgbW9tZW50OiBudW1iZXIgfSB8IHVuZGVmaW5lZCB9O1xufVxuXG50eXBlIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50ID0gKFdpbmRvdyAmIHR5cGVvZiBnbG9iYWxUaGlzKSAmIHtcbiAgICBfaG9va0NhbGxDb3VudDogSG9va0NhbGxDb3VudDtcbn1cblxuZnVuY3Rpb24gY2FsbENvdW50VShob29rOiBGdW5jdGlvbikge1xuICAgIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBuYW1lID0gaG9vay5uYW1lO1xuICAgIGlmIChmaWx0ZXJBbGwgfHwgZmlsdGVycy5oYXMobmFtZSkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGNvbnNvbGUuYXNzZXJ0KG5hbWUubGVuZ3RoID4gMCk7XG5cbiAgICAod2luZG93IGFzIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50KS5faG9va0NhbGxDb3VudCA/Pz0geyBjYWxsQ291bnRzOiB7fSB9O1xuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHNbbmFtZV0gPz89IHsgbW9tZW50OiAwLCB0b3RhbDogMCB9O1xuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHNbbmFtZV0hLm1vbWVudCArPSAxO1xuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHNbbmFtZV0hLnRvdGFsICs9IDE7XG5cbiAgICBpZiAodGltZW91dEhhbmRsZSA9PSBudWxsKSB7XG4gICAgICAgIHRpbWVvdXRIYW5kbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudCk7XG4gICAgICAgICAgICAvLyh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHNNb21lbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG86IEFycmF5PHsgcmVhZG9ubHkgSG9vazogc3RyaW5nOyByZWFkb25seSBOb3c6IG51bWJlcjsgcmVhZG9ubHkgVG90YWw6IG51bWJlcjsgfT4gPVxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKCh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtob29rLCBjb3VudHNdKSA9PiB7IHJldHVybiB7IEhvb2s6IGhvb2sgfHwgXCI/XCIsIE5vdzogY291bnRzPy5tb21lbnQgfHwgMCwgVG90YWw6IGNvdW50cz8udG90YWwgfHwgMCB9IGFzIGNvbnN0IH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgTm93IH0pID0+IHsgcmV0dXJuICEhTm93IH0pXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KCh7IE5vdzogbGhzTSB9LCB7IE5vdzogcmhzTSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxoc00gJiYgIXJoc00pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaHNNIHx8PSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoc00gfHw9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxoc00gLSByaHNNO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUudGFibGUobywgWydIb29rJywgJ05vdycsICdUb3RhbCddKTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKCh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50LmNhbGxDb3VudHMpLmZvckVhY2goKFssIGNvdW50c10pID0+IHsgY291bnRzIS5tb21lbnQgPSAwOyB9KTtcbiAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmxldCBmaWx0ZXJBbGwgPSBmYWxzZTtcbmNvbnN0IGZpbHRlcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVDYWxsQ291bnQoaG9vazogRnVuY3Rpb24gfCBcImFsbFwiKSB7XG4gICAgZmlsdGVyQWxsID0gKGhvb2sgPT09IFwiYWxsXCIpO1xuXG4gICAgaWYgKGhvb2sgIT0gXCJhbGxcIilcbiAgICAgICAgZmlsdGVycy5hZGQoaG9vay5uYW1lKTtcbn1cblxuZXhwb3J0IGNvbnN0IG1vbml0b3JDYWxsQ291bnQ6IHR5cGVvZiBjYWxsQ291bnRVID0gKGdldEJ1aWxkTW9kZSgpID09IFwiZGV2ZWxvcG1lbnRcIikgPyBjYWxsQ291bnRVIDogbm9vcDtcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi4vdXRpbC9tb2RlLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi4vdXRpbC9yYW5kb20taWQuanNcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlLmpzXCI7XG5cbi8qKiBUYWtlcyBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBhIHZhbHVlLCB1bmxpa2UgYE9uUGFzc2l2ZVN0YXRlQ2hhbmdlYCB3aGljaCByZWFjdHMgdG8gdGhvc2UgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTLCBSPiA9ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCkgOiAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb246IFIpID0+IHZvaWQpO1xuLyoqIFJlc3BvbmRzIHRvIGEgY2hhbmdlIGluIGEgdmFsdWUsIHVubGlrZSBgUGFzc2l2ZVN0YXRlVXBkYXRlcmAgd2hpY2ggY2F1c2VzIHRoZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxTLCBSPiA9ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKSA6ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uOiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG5cblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgaWYgKGdldEJ1aWxkTW9kZSgpID09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmPEFycmF5PFQ+PihbXSk7XG4gICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZjxBcnJheTxib29sZWFuPj4oW10pO1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoIGFzIGFueSwgLTEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VSBleHRlbmRzIFQ+KHZhbHVlOiBVLCBpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgMTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2l9LWluZGV4ZWQgYXJndW1lbnQgKCR7aSA+PSAwPyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbaV0pIDogXCJ0aGUgbnVtYmVyIG9mIHN1cHBvc2VkbHkgc3RhYmxlIGVsZW1lbnRzXCJ9KS5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBxdWV1ZU1pY3JvdGFzaykoZik7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgdXNlU3RhdGVgLCBidXQgZm9yIHZhbHVlcyB0aGF0IGFyZW4ndCBcInJlbmRlci1pbXBvcnRhbnRcIiAmbmRhc2g7IHVwZGF0ZXMgZG9uJ3QgY2F1c2UgYSByZS1yZW5kZXIgYW5kIHNvIHRoZSB2YWx1ZSBzaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgcmVuZGVyICh0aG91Z2ggaXQgY2VydGFpbmx5IGNhbiwgYXQgbGVhc3QgYnkgcmUtcmVuZGVyaW5nIGFnYWluKS5cbiAqIFxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXG4gKiBcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XG4gKiBcbiAqIDEuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgdGhpcyB2ZXJzaW9uIG9mIGBzZXRTdGF0ZWAgZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIGNvbXBvbmVudFxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXG4gKiA0LiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB0aGUgc2luZ2xlIFwiZGVwZW5kZW5jeVwiIGlzIGJhc2VkIG9uIHlvdXIgY2FsbHMgdG8gYHNldFN0YXRlYFxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cbiAqIFxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgQnkgZGVmYXVsdCwgY2hhbmdlcyB0byBwYXNzaXZlIHN0YXRlIGFyZSBkZWxheWVkIGJ5IG9uZSB0aWNrIHNvIHRoYXQgd2Ugb25seSBjaGVjayBmb3IgY2hhbmdlcyBpbiBhIHNpbWlsYXIgd2F5IHRvIFByZWFjdC4gWW91IGNhbiBvdmVycmlkZSB0aGlzIHRvLCBmb3IgZXhhbXBsZSwgYWx3YXlzIHJ1biBpbW1lZGlhdGVseSBpbnN0ZWFkLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VCwgUj4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxULCBSPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmc/OiB0eXBlb2YgZGVib3VuY2VSZW5kZXJpbmcpOiByZWFkb25seSBbZ2V0U3RhdGVTdGFibGU6ICgpID0+IFQsIHNldFN0YXRlU3RhYmxlOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+XSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VQYXNzaXZlU3RhdGUpO1xuICAgIC8vbGV0IFtpZCwgLGdldElkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3QgcmVhc29uUmVmID0gdXNlUmVmPFIgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCA9IHVzZVJlZjxUIHwgKHR5cGVvZiBVbnNldCk+KFVuc2V0KTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVBhc3NpdmVTdGF0ZVwiLCBvbkNoYW5nZSwgZ2V0SW5pdGlhbFZhbHVlLCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCEpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzFdKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuICAgICAgICAvL2xldCBpZCA9IGdldElkKCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coKG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudD8gXCJcIiA6IFwiTk9UIFwiKSArIFwiU2NoZWR1bGluZyBlZmZlY3QgXCIsIGlkLCBcIiB3aXRoIHZhbHVlIFwiLCBuZXh0VmFsdWUpO1xuXG4gICAgICAgIGlmICgvKmRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPT09IFVuc2V0ICYmKi8gbmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZXF1ZXN0IHRvIGNoYW5nZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHksIHRoZW4gcXVldWUgdXAgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgdmFsdWUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGl0IGxhdGVyXG4gICAgICAgICAgICAvLyAoaWYgd2UgZmxpcCBiYWNrIHRvIHRoaXMgc3RhdGUsIHRoZW4gd2Ugd29uJ3Qgc2VuZCB0aGUgb25DaGFuZ2UgZnVuY3Rpb24pXG4gICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gdmFsdWVSZWYuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoaXMgaGVyZSAoYXMgd2VsbCBhcyBiZWxvdykgaW4gY2FzZSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBpbnZva2VzIHRoaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICByZWFzb25SZWYuY3VycmVudCA9IHJlYXNvbiBhcyBSO1xuXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgYWN0dWFsIGNoZWNrIGFuZCBpbnZvY2F0aW9uIG9mIG9uQ2hhbmdlIGxhdGVyIHRvIGxldCBlZmZlY3RzIHNldHRsZVxuICAgICAgICAgICAgKGN1c3RvbURlYm91bmNlUmVuZGVyaW5nID8/IGRlYm91bmNlUmVuZGVyaW5nKSgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVhc29uID0gcmVhc29uUmVmLmN1cnJlbnQhIGFzIFI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICAvL2xldCBpZCA9IGdldElkKCk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygoKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCk/IFwiXCIgOiBcIk5PVCBcIikgKyBcIlJ1bm5pbmcgZWZmZWN0IFwiLCBpZCwgXCIgd2l0aCB2YWx1ZSBcIiwgbmV4dERlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBoZXJlIGluIG9yZGVyIHRvIG1ha2UgcmVjdXJzaXZlIG9uQ2hhbmdlcyB3b3JrXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBmZWVscyBiZXR0ZXIgdG8gaGF2ZSBpdCBoYXBwZW4gYWZ0ZXIgb25DaGFuZ2UuLi5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHREZXA7IC8vIE5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgb25DaGFuZ2UgaW4gY2FzZSBvbkNoYW5nZSBpcyByZWN1cnNpdmUgKGUuZy4gZm9jdXNpbmcgY2F1c2luZyBhIGZvY3VzIGNhdXNpbmcgYSBmb2N1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiBwcmV2RGVwLCBuZXh0UmVhc29uKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIC8vdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH1cblxuLyoqIFxuICogQW4gYWx0ZXJuYXRpdmUgdG8gdXNlIGZvciBgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmdgIHRoYXQgY2F1c2VzIGB1c2VQYXNzaXZlU3RhdGVgIHRvIHJ1biBjaGFuZ2VzIHdpdGhvdXQgd2FpdGluZyBhIHRpY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7IGYoKTsgfSIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWxlbWVudFByb3BzIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4obGhzOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0sIHJoczogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdKTogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZENoaWxkcmVuKTtcbiAgICBcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCB7IGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgRWxlbWVudFByb3BzIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xudHlwZSBDID0gRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcImNsYXNzTmFtZVwiXTtcbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxuICogRHVwbGljYXRlIGNsYXNzZXMgYXJlIHJlbW92ZWQgKG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFueXdheSkuXG4gKiBcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XG4gKiBAcGFyYW0gcmhzIENsYXNzZXMgb2YgdGhlIHNlY29uZCBjb21wb25lbnRcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2xhc3NlcyhsaHNDbGFzczogQywgbGhzQ2xhc3NOYW1lOiBDLCByaHNDbGFzczogQywgcmhzQ2xhc3NOYW1lOiBDKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZENsYXNzZXMpO1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiXG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxudW1iZXIsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgcHJldklucHV0cz86IElucHV0cyB8IHVuZGVmaW5lZCwgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbi8vXG4vLyBBbHNvLCBpbiB0aGVvcnkgdGhpcyBjb3VsZCBiZSByZXBsYWNlZCB3aXRoIGB1c2VJbnNlcnRpb25FZmZlY3RgLFxuLy8gYnV0IHRoYXQgcHJvYmFibHkgd29uJ3QgYmUgYXZhaWxhYmxlIGluIFByZWFjdCBmb3IgYXdoaWxlLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKHZub2RlLCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IGVmZmVjdEluZm8ucHJldklucHV0cztcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8ucHJldklucHV0cyA9IGVmZmVjdEluZm8uaW5wdXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/Lih2bm9kZSwgLi4uYXJncyk7XG59XG5cblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdO1xub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG5sZXQgaW5jcmVtZW50aW5nSWQgPSAwO1xuXG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gICAgbGV0IG5leHQgPSArK2luY3JlbWVudGluZ0lkO1xuICAgIC8vIFRPRE86IFRoaXMgc2VlbXMgcmVhc29uYWJsZSwgYnV0IGlzIGlzIG5lY2Vzc2FyeSBvciBhcmUgd2Ugb3JkZXJzIG9mIG1hZ25pdHVkZSBmcm9tIGhhdmluZyB0byB3b3JyeSBhYm91dCBvdmVyZmxvdz9cbiAgICBpZiAoaW5jcmVtZW50aW5nSWQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIGluY3JlbWVudGluZ0lkID0gLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIHJldHVybiBuZXh0O1xufVxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrIHwgbnVsbCwgaW5wdXRzPzogSW5wdXRzKSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VCZWZvcmVMYXlvdXRFZmZlY3QpO1xuXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGlzIGlzIGJ5IGZhciB0aGUgbW9zdCBjYWxsZWQgaG9vayBieSBzaGVlciB2b2x1bWUgb2YgZGVwZW5kZW5jaWVzLlxuICAgIC8vIFNvIGl0IHNob3VsZCBpZGVhbGx5IGJlIGFzIHF1aWNrIGFzIHBvc3NpYmxlLlxuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPG51bWJlcj4obnVsbCEpO1xuICAgIHJlZi5jdXJyZW50ID8/PSBuZXh0SWQoKTtcbiAgICBjb25zdCBpZCA9IHJlZi5jdXJyZW50O1xuXG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIC8vIE5vdCBuZWVkZWQsIGJlY2F1c2UgdGhlIGluc2VydGlvbiBjbGVhbnVwIHdvdWxkIHJ1biBiZWZvcmUgdXNlRWZmZWN0IGFueXdheSwgSSB0aGluaz9cbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSkqL1xufVxuXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzPzogSW5wdXRzLCBuZXdBcmdzPzogSW5wdXRzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhb2xkQXJncyB8fFxuICAgICAgICBvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncz8ubGVuZ3RoIHx8XG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG4gICAgKTtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlU3RhYmxlR2V0dGVyKTtcblxuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKCkgPT4geyByZWYuY3VycmVudCA9IHZhbHVlOyB9KSwgW3ZhbHVlXSk7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgYXMgdW5rbm93biA9PT0gVW5zZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgcmV0cmlldmVkIGZyb20gdXNlU3RhYmxlR2V0dGVyKCkgY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyLicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbn1cblxuXG4vKipcbiAqIExpa2UgYHVzZVN0YWJsZUdldHRlcmAsIGJ1dCAqKipyZXF1aXJlcyoqKiB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlIG9iamVjdCBpcyBhbHNvIHN0YWJsZSxcbiAqIGFuZCBpbiB0dXJuIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaXRzZWxmIGlzIHN0YWJsZS5cbiAqIEBwYXJhbSB0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVPYmplY3Q8VCBleHRlbmRzIHt9Pih0OiBUKTogVCB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5lbnRyaWVzKHQpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZU9iamVjdFwiLCBlLmxlbmd0aCwgLi4uZS5tYXAoKFtfaywgdl0pID0+IHYpKTtcbiAgICByZXR1cm4gdXNlUmVmKHQpLmN1cnJlbnQ7XG59XG5cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrTmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlU3RhYmxlQ2FsbGJhY2spO1xuICAgIFxuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMsIFJlZiwgUmVmT2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWY8VD4oaW5zdGFuY2U6IFQgfCBudWxsLCByZWY6IFJlZjxUPiB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cbiAqIEBwYXJhbSBsaHMgXG4gKiBAcGFyYW0gcmhzIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ocmhzOiBFbGVtZW50UHJvcHM8RT5bXCJyZWZcIl0sIGxoczogRWxlbWVudFByb3BzPEU+W1wicmVmXCJdKSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRSZWZzKTtcbiAgICBcbiAgICAvLyBUaGlzICptdXN0KiBiZSBzdGFibGUgaW4gb3JkZXIgdG8gcHJldmVudCByZXBlYXRlZCByZXNldCBgbnVsbGAgY2FsbHMgYWZ0ZXIgZXZlcnkgcmVuZGVyLlxuICAgIGNvbnN0IGNvbWJpbmVkID0gdXNlU3RhYmxlQ2FsbGJhY2soZnVuY3Rpb24gY29tYmluZWQoY3VycmVudDogRSB8IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XG4gICAgfSk7XG5cbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHMhO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzITtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDU1NQcm9wZXJ0aWVzLCBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IENTU1Byb3BlcnRpZXMge1xuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHN0eWxlLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSBhcyB1bmtub3duIGFzIENTU1Byb3BlcnRpZXM7XG59XG5cbi8qKlxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAqIFxuICogQHBhcmFtIHN0eWxlIFRoZSB1c2VyLWdpdmVuIHN0eWxlIHByb3AgZm9yIHRoaXMgY29tcG9uZW50XG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdLCByaHM6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRTdHlsZXMpO1xuXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXG4gICAgaWYgKCFsaHMgJiYgIXJocylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgbGhzICE9IHR5cGVvZiByaHMpIHtcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxuICAgICAgICBpZiAobGhzICYmICFyaHMpXG4gICAgICAgICAgICByZXR1cm4gbGhzO1xuICAgICAgICBpZiAoIWxocyAmJiByaHMpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBub24tbnVsbCBidXQgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cbiAgICAgICAgaWYgKGxocyAmJiByaHMpIHtcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhzdHlsZVN0cmluZ1RvT2JqZWN0KGxocyBhcyBzdHJpbmcpLCByaHMpIGFzIENTU1Byb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMobGhzLCBzdHlsZVN0cmluZ1RvT2JqZWN0KHJocyBhcyBzdHJpbmcpKSBhcyBDU1NQcm9wZXJ0aWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9naWM/Pz9cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxuICAgIGlmICh0eXBlb2YgbGhzID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke2xoc307JHtyaHMgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xuICAgIH1cblxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGxocyA/PyB7fSkgYXMgQ1NTUHJvcGVydGllcyxcbiAgICAgICAgLi4uKHJocyA/PyB7fSkgYXMgQ1NTUHJvcGVydGllc1xuICAgIH0gYXMgdW5rbm93biBhcyBDU1NQcm9wZXJ0aWVzXG59XG5cbiIsImltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgRWxlbWVudFByb3BzIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDbGFzc2VzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jbGFzc2VzLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlcy5qc1wiO1xuXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1Byb3BDb25mbGljdHMobG9nMjogdHlwZW9mIGNvbnNvbGVbXCJsb2dcIl0pIHtcbiAgICBsb2cgPSBsb2cyXG59XG5cblxuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZW0gYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAqIFxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cbiAqIEBwYXJhbSBsaHMyIFxuICogQHBhcmFtIHJoczIgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oLi4uYWxsUHJvcHM6IEVsZW1lbnRQcm9wczxFPltdKSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRQcm9wcyk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVyZ2VkUHJvcHNcIiwgYWxsUHJvcHMubGVuZ3RoKTtcbiAgICBsZXQgcmV0OiBFbGVtZW50UHJvcHM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogRWxlbWVudFByb3BzPEU+LCByaHNBbGw6IEVsZW1lbnRQcm9wczxFPik6IEVsZW1lbnRQcm9wczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IEVsZW1lbnRQcm9wczxFPiA9IHtcbiAgICAgICAgcmVmOiB1c2VNZXJnZWRSZWZzPEU+KGxoc0FsbC5yZWYsIHJoc0FsbC5yZWYpLFxuICAgICAgICBzdHlsZTogdXNlTWVyZ2VkU3R5bGVzKGxoc0FsbC5zdHlsZSwgcmhzQWxsLnN0eWxlKSxcbiAgICAgICAgY2xhc3NOYW1lOiB1c2VNZXJnZWRDbGFzc2VzKGxoc0FsbFtcImNsYXNzXCJdLCBsaHNBbGwuY2xhc3NOYW1lLCByaHNBbGxbXCJjbGFzc1wiXSwgcmhzQWxsLmNsYXNzTmFtZSksXG4gICAgICAgIGNoaWxkcmVuOiB1c2VNZXJnZWRDaGlsZHJlbihsaHNBbGwuY2hpbGRyZW4sIHJoc0FsbC5jaGlsZHJlbiksXG4gICAgfSBhcyBhbnk7XG5cbiAgICBpZiAocmV0LnJlZiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnJlZjtcbiAgICBpZiAocmV0LnN0eWxlID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuc3R5bGU7XG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XG4gICAgaWYgKHJldFtcImNsYXNzXCJdID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXRbXCJjbGFzc1wiXTtcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XG5cbiAgICBmb3IgKGNvbnN0IGxoc0tleVUgaW4gbGhzQWxsKSB7XG4gICAgICAgIGNvbnN0IGxoc0tleSA9IGxoc0tleVUgYXMga2V5b2YgdHlwZW9mIGxoc0FsbDtcbiAgICAgICAgaWYgKGtub3ducy5oYXMobGhzS2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXRbbGhzS2V5XSA9IGxoc0FsbFtsaHNLZXldO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcmhzS2V5VSBpbiByaHNBbGwpIHtcbiAgICAgICAgY29uc3QgcmhzS2V5ID0gcmhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgcmhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhyaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtyaHNLZXldID0gbWVyZ2VVbmtub3duKHJoc0tleSwgcmV0W3Joc0tleV0sIHJoc0FsbFtyaHNLZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiAodm9pZCB8IFByb21pc2U8dm9pZD4pLCBVIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiAodm9pZCB8IFByb21pc2U8dm9pZD4pPihsaHM6IFQgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IFUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG5cbiAgICBpZiAoIWxocylcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICBpZiAoIXJocylcbiAgICAgICAgcmV0dXJuIGxocztcblxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xuICAgICAgICBjb25zdCBsdiA9IGxocyguLi5hcmdzKTtcbiAgICAgICAgY29uc3QgcnYgPSByaHMoLi4uYXJncyk7XG5cbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2x2LCBydl0pO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCB9IGZyb20gXCIuLi91dGlsL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgUGFzc2l2ZVN0YXRlVXBkYXRlciwgZGVib3VuY2VSZW5kZXJpbmcsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IEludGVybmFsQ2hpbGRJbmZvPE0+O1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ6IChpbmRleDogTVtcImluZGV4XCJdLCBtb3VudGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWQ6IChpbmRleDogTVtcImluZGV4XCJdKSA9PiAoKCkgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXG4gKiBcbiAqIE90aGVyIGhvb2tzIHdpbGwgaW5oZXJpdCBmcm9tIHRoaXMgdG8gcHJvdmlkZSBtb3JlIGNvbXBsaWNhdGVkIGJlaGF2aW9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4ge1xuICAgIGluZGV4OiBUO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgICAgICogXG4gICAgICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRPRE86IFRoaXMgZW5kZWQgdXAgbm90IGJlaW5nIG5lZWRlZCBieSBhbnl0aGluZy4gSXMgaXQgbmVjZXNzYXJ5PyBEb2VzIGl0IGNvc3QgYW55dGhpbmc/XG4gICAgICAgICAqL1xuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PE1bXCJpbmRleFwiXT47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxNW1wiaW5kZXhcIl0+O1xuXG4gICAgICAgIG9uQ2hpbGRyZW5Db3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNvdW50OiBudW1iZXIpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkbid0IGJlIG51bGwsIGJ1dCBmb3IgY29udmVuaWVuY2UncyBzYWtlIHlvdSBhcmUgYWxsb3dlZCB0bywgd2hpY2ggZGlzYWJsZXMgYWxsIGJlaGF2aW9yLCBhbmQgYWxzbyBtZWFucyBgZ2V0Q2hpbGRyZW5gIHdpbGwgYmUgYHVuZGVmaW5lZGAhXG4gICAgICovXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXhhY3QgZGF0YSB0aGF0J3MgYXZhaWxhYmxlIGZyb20gdGhlIHBhcmVudC9lYWNoIHNpYmxpbmcgZWxlbWVudCB2aWEgYGdldEF0YCBvciB0aGUgb3RoZXIgbWV0aG9kcyBvbiBgTWFuYWdlZENoaWxkcmVuYC5cbiAgICAgKi9cbiAgICBpbmZvOiBNO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiAqKipTVEFCTEUqKipcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0ICoqYm90aCoqIGBnZXRDaGlsZHJlbmAgYW5kIHRoZSBgTWFuYWdlZENoaWxkcmVuYCBvYmplY3QgaXQgcmV0dXJucyBhcmUgc3RhYmxlIVxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBpcyBhIGdldHRlciBpbnN0ZWFkIG9mIGFuIG9iamVjdCBiZWNhdXNlIHdoZW4gZnVuY3Rpb24gY2FsbHMgaGFwcGVuIG91dCBvZiBvcmRlciBpdCdzIGVhc2llciB0byBqdXN0IGhhdmUgYWx3YXlzIGJlZW4gcGFzc2luZyBhbmQgcmV0dXJuIGdldHRlcnMgZXZlcnl3aGVyZSBcbiAgICAgICAgICovXG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuICAgIH07XG5cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgfVxufVxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEF0KGluZGV4OiBNW1wiaW5kZXhcIl0pOiBNIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNKSA9PiB2b2lkKSA9PiB2b2lkIHwgXCJicmVha1wiO1xuXG4gICAgLyoqXG4gICAgICogKipVTlNUQUJMRSoqLCBcbiAgICAgKiBhbHNvIGludGVybmFsLXVzZSBvbmx5LCBcbiAgICAgKiBhbHNvIFRPRE8gbmVlZCBhIHdvcmthcm91bmQgZm9yIHRoaXMgZm9yIHNvcnRhYmxlIGNoaWxkcmVuLFxuICAgICAqIG9yIGF0IGxlYXN0IHByb3Blcmx5IG5hbWUgaXQuXG4gICAgICogXG4gICAgICogV0hBVCBUSElTIERPRVM6XG4gICAgICogXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgY2hpbGRyZW4sIHNsaWNlcyB0aGUgYXJyYXkgY29udGFpbmluZyB0aGVtLCBcbiAgICAgKiBhbmQsICpjcnV0aWFsbHkqLCBmaWxscyBpbiBhbnkgaG9sZXMgaW4gdGhlIGFycmF5IHdpdGggYSBwc2V1ZG8tY2hpbGQgdGhhdCBqdXN0IGNvbnRhaW5zIGFuIGluZGV4LlxuICAgICAqIFxuICAgICAqIFRoaXMgYmVoYXZpb3IsIHRvIGJlIGNsZWFyLCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3Igc29ydGluZyBhbmQgcmVhcnJhbmdpbmcgYmVjYXVzZVxuICAgICAqIHNvcnRpbmcgYW5kIHJlYXJyYW5naW5nIHJlcXVpcmUga25vd2luZyBwZXJmZWN0bHkgd2hpY2ggaW5kZXggbWFwcyB0byB3aGljaC5cbiAgICAgKiBXZSBkb24ndCBuZWVkIGFueSBvdGhlciBtaXNzaW5nIGluZm9ybWF0aW9uIGluIHRoZSBhcnJheSBiZXNpZGVzIHRoZSBtaXNzaW5nIGluZGV4LlxuICAgICAqICovXG4gICAgYXJyYXlTbGljZTogKCkgPT4gTVtdO1xufVxuXG5pbnRlcmZhY2UgSW50ZXJuYWxDaGlsZEluZm88TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nIHwgbnVtYmVyPj4ge1xuICAgIGFycjogQXJyYXk8TT47XG4gICAgcmVjOiBQYXJ0aWFsPFJlY29yZDxNW1wiaW5kZXhcIl0sIE0+PjtcbiAgICBoaWdoZXN0SW5kZXg6IG51bWJlcjtcbiAgICBsb3dlc3RJbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBkZXNpZ25lZCB0byBiZSBsaWdodHdlaWdodCwgaW4gdGhhdCB0aGUgcGFyZW50IGtlZXBzIG5vIHN0YXRlXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cbiAqIFxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nIHwgbnVtYmVyPj4ocGFyZW50UGFyYW1ldGVyczogVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT4ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWFuYWdlZENoaWxkcmVuKTtcblxuICAgIHR5cGUgSW5kZXhUeXBlID0gTVtcImluZGV4XCJdO1xuICAgIHR5cGUgSW5mbyA9IE07XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRyZW5Db3VudENoYW5nZSB9LCAuLi5yZXN0IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHJlc3QpO1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWFuYWdlZENoaWxkcmVuXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBvbkNoaWxkcmVuQ291bnRDaGFuZ2UpO1xuXG4gICAgLy9jb25zdCBbZ2V0TW91bnRDb3VudCwgc2V0TW91bnRDb3VudF0gPSB1c2VQYXNzaXZlU3RhdGUob25DaGlsZHJlbkNvdW50Q2hhbmdlLCByZXR1cm5aZXJvLCBydW5JbW1lZGlhdGVseSk7XG5cbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4O1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFsbCB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBhYm91dCBvdXIgY2hpbGRyZW4gaXMgc3RvcmVkIGluIHRoaXMgKipzdGFibGUqKiBhcnJheS5cbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbkFycmF5ID0gdXNlUmVmPEludGVybmFsQ2hpbGRJbmZvPE0+Pih7IGFycjogW10sIHJlYzoge30sIGhpZ2hlc3RJbmRleDogMCwgbG93ZXN0SW5kZXg6IDAgfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWRzIHRvIHNlYXJjaCBhbGwgY2hpbGRyZW4gZm9yIHRoYXQgY2xvc2VzdCBmaXQuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiAodm9pZCB8IFwiYnJlYWtcIikpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYoY2hpbGQpID09ICdicmVhaycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxJbmRleFR5cGUsIEluZm8+XTtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBpZiAoZihjaGlsZCkgPT0gJ2JyZWFrJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZHJlbkNvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbkNvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEhpZ2hlc3RJbmRleCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2ldID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IHsgaW5kZXg6IGkgfSBhcyBNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KHsgY29udGV4dCwgaW5mbyB9OiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNPiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNYW5hZ2VkQ2hpbGQpO1xuXG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZENvbnRleHQ6IHsgZ2V0Q2hpbGRyZW4sIG1hbmFnZWRDaGlsZHJlbkFycmF5LCByZW1vdGVVTEVDaGlsZE1vdW50ZWQsIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCB9IH0gPSAoY29udGV4dCA/PyB7IG1hbmFnZWRDaGlsZENvbnRleHQ6IHt9IH0pO1xuICAgIGNvbnN0IGluZGV4ID0gaW5mby5pbmRleDtcbiAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9PSBudWxsIHx8IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgLi4uaW5mbyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkucmVjW2luZGV4IGFzIEluZGV4VHlwZV0gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZGV4IGFzIEluZGV4VHlwZSk7XG4gICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXG5cbiAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cbiAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgZmFsc2UpO1xuICAgIH0sIFtpbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbiEgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55PiwgUj4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcblxuICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+O1xuXG4gICAgc2V0QXQoaW5kZXg6IE0sIHZhbHVlOiBib29sZWFuLCBuZXdTZWxlY3RlZEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsLCBwcmV2U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCk6IHZvaWQ7XG4gICAgZ2V0QXQoaW5kZXg6IE0pOiBib29sZWFuO1xuICAgIGlzVmFsaWQoaW5kZXg6IE0pOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55PiwgUj4ge1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogTWFudWFsbHkgY2hhbmdlcyB0aGUgY3VycmVudCBpbmRleCB0aGF0IGlzIChmb2N1c2VkL3NlbGVjdGVkL3RhYmJhYmxlL3doYXRldmVyKS5cbiAgICAgKiBcbiAgICAgKiBUaGUgcGFyZW50IGNhbiB1c2UgdGhpcyB0byBub3RpZnkgZWFjaCByZWxldmFudCBjaGlsZCBvZiB3aGF0IGl0IG11c3QgZG8gaW4gb3JkZXIgdG8gbWFrZSB0aGlzIGNoYW5nZSBoYXBwZW4uXG4gICAgICogXG4gICAgICogVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIG5ldyBpbmRleCB0aGF0IHdpbGwgYmUgdXNlZC4gSWYgYGNsb3Nlc3RGaXRgIGlzIGZhbHNlLCBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB3aGF0IHlvdSBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgY2hhbmdlSW5kZXg6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj47XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIG9yIHdoZW5ldmVyIGNhbGxpbmcgYSBjaGlsZCdzIGlzVmFsaWQoKSB3b3VsZCBjaGFuZ2VcbiAgICAgKiAgKi9cbiAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdDogKCkgPT4gdm9pZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldEN1cnJlbnRJbmRleDogKCkgPT4gTVtcImluZGV4XCJdIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gdG8gdXNlTWFuYWdlZENoaWxkcmVuIHRoYXQgaGFuZGxlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiBjYXNlOlxuICogMS4gWW91IGhhdmUgYSBidW5jaCBvZiBjaGlsZHJlblxuICogMi4gQXQgYW55IGdpdmVuIHRpbWUsIG9ubHkgMSBvZiB0aGVtIGlzIFwic2VsZWN0ZWRcIiwgXCJhY3RpdmF0ZWRcIiwgXCJmb2N1c2FibGVcIiwgd2hhdGV2ZXIgKG9yIDAgb2YgdGhlbSwgdGhhdCdzIGNvb2wgdG9vLCBqdXN0IDAgb3IgMSB0aG91Z2gpLlxuICogMy4gVGhlIHBhcmVudCBoYXMgY29udHJvbCBvdmVyIHdobyBpcyBcInNlbGVjdGVkXCIgdmlhIGEgbnVtZXJpY2FsIGluZGV4LlxuICogXG4gKiBUaGlzIGhvb2sgYWxsb3dzIGZvciBtdWNoIGVhc2llciBjb250cm9sIG92ZXIgc2VsZWN0aW9uIG1hbmFnZW1lbnQuXG4gKiBcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHlvdSBtYXkgd2FudCB0byB1c2UgbXVsdGlwbGUgZmxhZ3Mgd2l0aCB0aGUgc2FtZSBjaGlsZHJlbiwgdGhpcyBob29rICpkb2VzIG5vdCogdXNlIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIVxuICogWW91IG5lZWQgdG8gcGFzcyBpdCB0aGUgZXhpc3RpbmcgY2hpbGRyZW4sIGFuZCB5b3UgbXVzdCBwYXNzIHlvdXIgaW52b2NhdGlvbiBvZiBgdXNlTWFuYWdlZENoaWxkcmVuYCB0aGUgcmV0dXJuZWQgYG9uQ2hpbGRyZW5Nb3VudENoYW5nZWAgaGFuZGxlciFcbiAqIFxuICogQWxzbyBiZWNhdXNlIG9mIHRoYXQsIHRoZSB0eXBlcyBvZiB0aGlzIGZ1bmN0aW9uIGFyZSByYXRoZXIgb2RkLiAgSXQncyBiZXR0ZXIgdG8gc3RhcnQgb2ZmIHVzaW5nIGEgaG9vayB0aGF0IGFscmVhZHkgdXNlcyBhIGZsYWcsIHN1Y2ggYXMgYHVzZVJvdmluZ1RhYkluZGV4YCwgYXMgYW4gZXhhbXBsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkZsYWc8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPiwgUj4oeyBnZXRDaGlsZHJlbiwgaW5pdGlhbEluZGV4LCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQsIH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TSwgUj4pOiBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPE0sIFI+IHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwgZ2V0QXQsIHNldEF0LCBpc1ZhbGlkKTtcblxuICAgIC8vIFRPRE8gKG1heWJlPyk6IEV2ZW4gaWYgdGhlcmUgaXMgYW4gaW5pdGlhbCBpbmRleCwgaXQncyBub3Qgc2V0IHVudGlsIG1vdW50LiBJcyB0aGF0IGZpbmU/XG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgTVtcImluZGV4XCJdLCBSPihvbkluZGV4Q2hhbmdlKTtcblxuICAgIGNvbnN0IFtnZXRSZXF1ZXN0ZWRJbmRleCwgc2V0UmVxdWVzdGVkSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG51bGwpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpY1xuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYGNsb3Nlc3RGaXRgIGlzIGZhbHNlLCBuYXR1cmFsbHkuXG4gICAgY29uc3QgZ2V0Q2xvc2VzdEZpdCA9IHVzZUNhbGxiYWNrKChyZXF1ZXN0ZWRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmIGlzVmFsaWQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIGNoaWxkLmluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicygoY2hpbGQuaW5kZXggYXMgbnVtYmVyKSAtIHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgfHwgKG5ld0Rpc3RhbmNlID09IGNsb3Nlc3REaXN0YW5jZSAmJiAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKSA8IHJlcXVlc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gKGNoaWxkLmluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlISAqL10pO1xuXG4gICAgLy8gQW55IHRpbWUgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHRvIHNlZSBpZiB0aGF0IGFmZmVjdHMgXG4gICAgLy8gdGhlIFwiY3VycmVudGx5IHNlbGVjdGVkXCIgKG9yIHdoYXRldmVyKSBpbmRleC4gIFRoZSB0d28gY2FzZXMgd2UncmUgbG9va2luZyBmb3I6XG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcbiAgICAvLyAyLiBBIGNoaWxkIG1vdW50ZWQsIGFuZCBpdCBtb3VudHMgd2l0aCB0aGUgaW5kZXggd2UncmUgbG9va2luZyBmb3JcbiAgICBjb25zdCByZWV2YWx1YXRlQ2xvc2VzdEZpdCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGdldFJlcXVlc3RlZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhaXNWYWxpZChjdXJyZW50Q2hpbGQpKSkge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgsIHVuZGVmaW5lZCEpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChjdXJyZW50Q2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjbG9zZXN0Rml0Q2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICBzZXRBdChjbG9zZXN0Rml0Q2hpbGQsIHRydWUsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBjb25zdCBjaGFuZ2VJbmRleCA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+KChhcmc6IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj5bMF0sIHJlYXNvbjogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlsxXSkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnKSBhcyBNW1wiaW5kZXhcIl07XG5cbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZElzVmFsaWQgPSAobmV3TWF0Y2hpbmdDaGlsZCAmJiBpc1ZhbGlkKG5ld01hdGNoaW5nQ2hpbGQpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZElzVmFsaWQgfHwgIWNsb3Nlc3RGaXQpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCByZXF1ZXN0ZWRJbmRleCwgY3VycmVudEluZGV4KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiByZXF1ZXN0ZWRJbmRleCA9PSBcIm51bWJlclwiLCBcImNsb3Nlc3RGaXQgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGVhY2ggY2hpbGQgaGFzIGEgbnVtZXJpYyBpbmRleCwgYW5kIGNhbm5vdCBiZSB1c2VkIHdoZW4gY2hpbGRyZW4gdXNlIHN0cmluZyBpbmRpY2VzIGluc3RlYWQuXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQobmV3TWF0Y2hpbmdDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEZpdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBSdW4gb25jZSwgb24gbW91bnRcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VJbmRleChpbml0aWFsSW5kZXggPz8gbnVsbCwgdW5kZWZpbmVkKTtcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgZ2V0Q3VycmVudEluZGV4IH07XG59XG5cbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlU3RhdGUpO1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH0sIFtdKTtcblxuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHR5cGUgeyBKU1gsIFByZWFjdERPTUF0dHJpYnV0ZXMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHMuanNcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0ICpqdXN0KiB0aGUgdHlwZWQgYWRkRXZlbnRMaXN0ZW5lciBcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cbiAqIFxuICogVE9ETzogVGhpcyBcIlwiXCJ3b3Jrc1wiXCJcIiBidXQgaXQncyBub3QgZ3JlYXQgYW5kIGltcGxpY2l0bHkgcmVsaWVzIG9uXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxuICogdHlwZWQgb25lIGZpcnN0LiAqVGhhdCogcHJvYmFibHkgd29uJ3QgY2hhbmdlLCBidXQgaWYgbW9yZSBvdmVybG9hZHNcbiAqIGFyZSBldmVyIGFkZGVkIHRoaXMgd2lsbCBuZWVkIGFkanVzdG1lbnQuXG4gKiBcbiAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI3NjExNTYgZm9yIGhvdyBzZWxlY3RpbmcgdGhlIGNvcnJlY3Qgb3ZlcmxvYWQgd29ya3MuXG4gKi9cbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogaW5mZXIgUiB9ID8gUiA6XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFIpID0+IGFueSA/IFIgOiBbXTtcblxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXG50eXBlIFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKC4uLmFyZ3M6IEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPChUW1wiYWRkRXZlbnRMaXN0ZW5lclwiXSk+KSA9PiB2b2lkO1xuXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXG50eXBlIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4gZXh0ZW5kcyAoKHR5cGU6IGluZmVyIEsyLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEsyIDogc3RyaW5nO1xuXG5cbi8vIFRPRE86IFRoaXMgaXNuJ3QgcXVpdGUgYWJsZSB0byBuYXJyb3cgZG93biB0aGUgZXhhY3QgZXZlbnQgdHlwZSBmb3IgdW5rbm93biByZWFzb25zLlxuLy8gSW5zdGVhZCBpdCByZXR1cm5zIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSBldmVudCB0eXBlcywgd2hpY2ggaXMuLi5maW5lLCBJIGd1ZXNzLlxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXG4vLyBOb3RlIHRoYXQgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIHN0aWxsIHVzZWQsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3QgbmFycm93IGRvd24gdGhlIHR5cGUsXG4vLyBiZWNhdXNlIG90aGVyd2lzZSwgaW5zdGVhZCBvZiBiZWluZyBhIHVuaW9uIG9mIGFsbCB0eXBlcywgaXQncyBqdXN0IGBhbnlgXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xuLy8oKFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiAmICgodHlwZTogVCwgaGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSkgZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBpbmZlciBIKSA9PiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSCA6IEZ1bmN0aW9uKSAvKiYgKFQgZXh0ZW5kcyBrZXlvZiBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXA/IEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcFtUXSA6IChlOiBFdmVudCkgPT4gdm9pZCkqLztcblxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cbiAgICBUIGV4dGVuZHMgRXZlbnRMaXN0ZW5lck9iamVjdCA/IFBhcmFtZXRlcnM8VFtcImhhbmRsZUV2ZW50XCJdPiA6XG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXI7XG5cblxudHlwZSBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFBhcmFtZXRlcnMyPFR5cGVkRXZlbnRIYW5kbGVyPEUsIFQ+PlswXTtcblxuXG4vKipcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqIFxuICogYFwibW9kZVwiYCBjb250cm9scyBpZiB0aGVyZSdzIG9uZSBoYW5kbGVyIHRoYXQgY2FsbHMgYWxsIHlvdXIgZnVuY3Rpb25zIChkZWZhdWx0KSwgb3Igb25lIGhhbmRsZXIgYWRkZWQgcGVyIGZ1bmN0aW9uIChgXCJzaW5nbGVcImApLiBcbiAqIFxuICogVGhlIGRlZmF1bHQsIGBcImdyb3VwZWRcImAsIGlzIGZhc3RlciB3aGVuIHlvdSBoYXZlLCBzYXksIGEgYnV0dG9uIGNvbXBvbmVudCwgdXNlZCBodW5kcmVkcyBvZiB0aW1lcyBvbiBhIHBhZ2UsIHRoYXQgZWFjaCBpbnN0YWxscyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLlxuICogXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cbiAqIEByZXR1cm5zXG4gKiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSwgbW9kZT86IFwiZ3JvdXBlZFwiIHwgXCJzaW5nbGVcIik6IHZvaWQge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlR2xvYmFsSGFuZGxlcik7XG4gICAgbW9kZSB8fD0gXCJncm91cGVkXCI7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlR2xvYmFsSGFuZGxlclwiLCBtb2RlKTtcblxuICAgIGlmIChtb2RlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgICAvLyBOb3RlIHRvIHNlbGY6IFRoZSB0eXBpbmcgZG9lc24ndCBpbXByb3ZlIGV2ZW4gaWYgdGhpcyBpcyBzcGxpdCB1cCBpbnRvIGEgc3ViLWZ1bmN0aW9uLlxuICAgICAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxuICAgICAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxuICAgICAgICAvLyBBZ2Fpbiwgbm8gbWF0dGVyIHdoYXQgY29tYmluYXRpb24gb2Ygc3ViLSBvciBzdWItc3ViLWZ1bmN0aW9ucyB1c2VkLlxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZDxULCBFdmVudFR5cGUsIEg+KHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyU2luZ2xlPFQsIEV2ZW50VHlwZSwgSD4odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbnR5cGUgR2xvYmFsSGFuZGxlckluZm8gPSB7IGxpc3RlbmVyOiBFdmVudExpc3RlbmVyOyBsaXN0ZW5lcnM6IFNldDxFdmVudExpc3RlbmVyPjsgfTtcbnR5cGUgTWFwT2ZPcHRpb25zVG9JbmZvID0gTWFwPHN0cmluZywgR2xvYmFsSGFuZGxlckluZm8+XG50eXBlIE1hcE9mVHlwZVRvTWFwT2ZPcHRpb25zVG9JbmZvID0gTWFwPFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEV2ZW50VGFyZ2V0PiwgTWFwT2ZPcHRpb25zVG9JbmZvPjtcbmxldCBtYXBUaGluZyA9IG5ldyBNYXA8RXZlbnRUYXJnZXQsIE1hcE9mVHlwZVRvTWFwT2ZPcHRpb25zVG9JbmZvPigpO1xuXG5mdW5jdGlvbiBkb01hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KG9wOiAoaTogR2xvYmFsSGFuZGxlckluZm8sIGg6IEV2ZW50TGlzdGVuZXIpID0+IHZvaWQsIHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9uczogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XG4gICAgaWYgKGhhbmRsZXIpIHtcblxuICAgICAgICBjb25zdCBvcHRpb25zS2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGJ5VHlwZSA9IG1hcFRoaW5nLmdldCh0YXJnZXQpIHx8IChuZXcgTWFwKCkgYXMgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8pO1xuICAgICAgICBjb25zdCBieU9wdGlvbnMgPSAoYnlUeXBlLmdldCh0eXBlKSB8fCAobmV3IE1hcCgpIGFzIE1hcE9mT3B0aW9uc1RvSW5mbykpO1xuICAgICAgICBjb25zdCBpbmZvID0gYnlPcHRpb25zLmdldChvcHRpb25zS2V5KSB8fCB7IGxpc3RlbmVyOiBudWxsISwgbGlzdGVuZXJzOiBuZXcgU2V0KCkgfTtcblxuICAgICAgICBvcChpbmZvLCBoYW5kbGVyKTtcblxuICAgICAgICBieU9wdGlvbnMuc2V0KG9wdGlvbnNLZXksIGluZm8pO1xuICAgICAgICBieVR5cGUuc2V0KHR5cGUsIGJ5T3B0aW9ucyk7XG4gICAgICAgIG1hcFRoaW5nLnNldCh0YXJnZXQsIGJ5VHlwZSk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGFkZFRvTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zOiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBkb01hcFRoaW5nKChpbmZvLCBoKSA9PiB7XG4gICAgICAgIGluZm8ubGlzdGVuZXJzLmFkZChoKTtcbiAgICAgICAgaWYgKGluZm8ubGlzdGVuZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGluZm8ubGlzdGVuZXIgPSBlID0+IGluZm8ubGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oZSkpLCBvcHRpb25zKTtcbiAgICB9LCB0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZyb21NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBkb01hcFRoaW5nKChpbmZvLCBoKSA9PiB7XG4gICAgICAgIGluZm8ubGlzdGVuZXJzLmRlbGV0ZShoKTtcbiAgICAgICAgaWYgKGluZm8ubGlzdGVuZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGluZm8ubGlzdGVuZXIgPSBlID0+IGluZm8ubGlzdGVuZXJzLmZvckVhY2goZm4gPT4gZm4oZSkpLCBvcHRpb25zKTtcbiAgICB9LCB0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgd2F5IGZhc3RlciBmb3IgbGFyZ2UgbnVtYmVycyBvZiBldmVudCBoYW5kbGVycy5cbiAqIFxuICogRm9yIGV4YW1wbGUsIGlmIGV2ZXJ5IGJ1dHRvbiBsaXN0ZW5zIGZvciBhIGdsb2JhbCBjbGljaywgb3Igc29tZXRoaW5nLFxuICogaXQgd291bGQgYmUgbmljZSBpZiBpdCB3YXMgZWZmaWNpZW50IGF0IGxlYXN0LiBcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlckdyb3VwZWQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XG4gICAgbGV0IHN0YWJsZUhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gdXNlU3RhYmxlQ2FsbGJhY2s8RXZlbnRMaXN0ZW5lcj4oKGhhbmRsZXIgYXMgYW55KSA/PyAoKCkgPT4geyB9KSkgYXMgKEV2ZW50TGlzdGVuZXIgfCBudWxsKTtcbiAgICBpZiAoaGFuZGxlciA9PSBudWxsKVxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XG4gICAgICAgICAgICBhZGRUb01hcFRoaW5nKHRhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3ZlRnJvbU1hcFRoaW5nKHRhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXJTaW5nbGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XG4gICAgbGV0IHN0YWJsZUhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gdXNlU3RhYmxlQ2FsbGJhY2s8RXZlbnRMaXN0ZW5lcj4oKGhhbmRsZXIgYXMgYW55KSA/PyAoKCkgPT4geyB9KSkgYXMgKEV2ZW50TGlzdGVuZXIgfCBudWxsKTtcbiAgICBpZiAoaGFuZGxlciA9PSBudWxsKVxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW3RhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlcl0pO1xufVxuXG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXG4gKiBcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cbiAqIFxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICogXG4gKiBgYGBcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyPEVsZW1lbnRUeXBlIGV4dGVuZHMgKEhUTUxFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBdIHwgU1ZHRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXBdKT4oKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKDxFdmVudFR5cGUgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIEpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8SlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xuXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IEVsZW1lbnRQcm9wczxFbGVtZW50VHlwZT4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFbGVtZW50VHlwZT4oeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyBFbGVtZW50UHJvcHM8RWxlbWVudFR5cGU+LCBwcm9wcykgYXMgRWxlbWVudFByb3BzPEVsZW1lbnRUeXBlPjtcbiAgICAgICAgfSwgW3R5cGVdKTtcblxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XG5cbiAgICB9LCBbXSk7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5LCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgRWxlbWVudFByb3BzIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHByb3BzU3RhYmxlOiBFbGVtZW50UHJvcHM8VD47XG5cbiAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHNha2Ugb2YgY29udmVuaWVuY2UsXG4gICAgICogdGhpcyBvbmUgaXMgb3B0aW9uYWwsIHNpbmNlIHVzaW5nIHRoaXMgaG9vayBpcyBzbyBjb21tb24sXG4gICAgICogYnV0IHVzaW5nIGl0cyBwYXJhbWV0ZXIgb3B0aW9ucyBpcyBzbyB1bmNvbW1vbiwgYW5kIGl0J3NcbiAgICAgKiBhYnNlbnNlIGlzbid0IHVzdWFsbHkgYmVjYXVzZSBpdCB3YXMgZm9yZ290dGVuLCBpdCdzIGJlY2F1c2VcbiAgICAgKiBpdCBkb2Vzbid0IG1hdHRlci5cbiAgICAgKi9cbiAgICByZWZFbGVtZW50UGFyYW1ldGVycz86IHtcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPjtcbiAgICAgICAgb25Nb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgICAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICB9XG59XG5cblxuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50UHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCAuLi5vdGhlclByb3BzOiBFbGVtZW50UHJvcHM8RT5bXSk6IEVsZW1lbnRQcm9wczxFPltdIHtcbiAgICByZXR1cm4gW3IucmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSwgLi4ub3RoZXJQcm9wc107XG59Ki9cblxuLyoqXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cbiAqIFxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXG4gKiBcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJnczogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VSZWZFbGVtZW50KTtcblxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzLnJlZkVsZW1lbnRQYXJhbWV0ZXJzIHx8IHt9KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+PigoZSwgcHJldlZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xuICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XG5cbiAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XG5cbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbCwgbmV2ZXI+KGhhbmRsZXIsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZjxFbGVtZW50UHJvcHM8VD4+KHsgcmVmOiBzZXRFbGVtZW50IH0pO1xuXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzU3RhYmxlOiBwcm9wc1N0YWJsZS5jdXJyZW50LFxuICAgICAgICBcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjoge1xuICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCBydW5JbW1lZGlhdGVseSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5cbi8qKlxuICogXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKiBcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogXG4gKiBcbiAqIEluIHN1bW1hcnk6XG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuaW50ZXJmYWNlIEZvbzxUPiB7XG4gICAgbGFzdFNlbnQ6IFQgfCB1bmRlZmluZWQ7XG4gICAgc2VuZDogKGU6IFQsIHI6IEZvY3VzRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxOb2RlIHwgbnVsbD4+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxOb2RlPj4+KCk7XG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Ym9vbGVhbj4+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTtcblxuXG4vLyBUaGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIG9mdGVuIGZpcmUgc3luY3Jvbm91c2x5IGluIHRoZSBtaWRkbGUgb2YgcnVubmluZyBjb2RlLlxuLy8gRS5HLiBjYWxsaW5nIGVsZW1lbnQuZm9jdXMoKSBjYW4gY2F1c2UgYSBmb2N1c2luIGV2ZW50IGhhbmRsZXIgdG8gaW1tZWRpYXRlbHkgaW50ZXJydXB0IHRoYXQgY29kZS5cbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cbmZ1bmN0aW9uIGZvckVhY2hVcGRhdGVyPFQ+KHdpbmRvdzogV2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgbWFwOiBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxUPj4+LCB2YWx1ZTogVCwgcmVhc29uOiBhbnkpIHtcbiAgICBjb25zdCB1cGRhdGVycyA9IG1hcC5nZXQod2luZG93KTtcbiAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhc3RTZW50LCBzZW5kIH0gPSB1cGRhdGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZCh2YWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlci5sYXN0U2VudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c291dChlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIG51bGwsIGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZm9jdXNpbihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCwgZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCwgZSk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIHRydWUpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCB0cnVlLCBlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Qmx1cihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBmYWxzZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIGZhbHNlLCBlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB7XG5cbiAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50IHwgbnVsbCwgRm9jdXNFdmVudD4gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgICAgICogTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCwgRm9jdXNFdmVudD4gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuLCBGb2N1c0V2ZW50PiB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHdoYXRldmVyIGVsZW1lbnRzIHdlJ3JlIGxpc3RlbmluZyB0by5cbiAgICAgICAgICogXG4gICAgICAgICAqIEUuRy4gc29tZURpdkVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAgICAgKiBcbiAgICAgICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXREb2N1bWVudCgpOiBEb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgZXZlbnQgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCdzIGRlZmF1bHRWaWV3IFdpbmRvdy5cbiAgICAgICAgICogSWYgeW91IG5lZWQgc29tZXRoaW5nIGRpZmZlcmVudCwgb3ZlcnJpZGUgaXQgaGVyZS5cbiAgICAgICAgICogXG4gICAgICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2luZG93PzogKChkb2N1bWVudDogRG9jdW1lbnQpID0+IFdpbmRvdykgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XG4gICAgYWN0aXZlRWxlbWVudFJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICovXG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICovXG4gICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXG4gKiBcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcbiAqIFxuICogVGhpcyBpcyBhIHBhc3NpdmUgaG9vaywgc28gYnkgZGVmYXVsdCBpdCByZXR1cm5zIGdldHRlciBmdW5jdGlvbnMgdGhhdCByZXBvcnQgdGhpcyBpbmZvcm1hdGlvbiBidXQgdGhlIGNvbXBvbmVudCB3aWxsIG5vdCByZS1yZW5kZXIgYnkgZGVmYXVsdCB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLlxuICogXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQoeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9IH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzKTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlQWN0aXZlRWxlbWVudCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VBY3RpdmVFbGVtZW50XCIsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gKGdldFdpbmRvdz8uKGRvY3VtZW50KSA/PyBkb2N1bWVudD8uZGVmYXVsdFZpZXcpO1xuXG4gICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZW0gZXZlbiBpZiB0aGV5J3JlIHVuZGVmaW5lZCB0byBtb3JlIGVhc2lseVxuICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXG4gICAgICAgIGNvbnN0IGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcblxuICAgICAgICBjb25zdCBsYWV1ID0geyBzZW5kOiBzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4sIGxhc3RTZW50OiB1bmRlZmluZWQgfVxuICAgICAgICBjb25zdCBsbGFldSA9IHsgc2VuZDogc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+LCBsYXN0U2VudDogdW5kZWZpbmVkIH07XG4gICAgICAgIGNvbnN0IGx3ZnUgPSB7IHNlbmQ6IHNldFdpbmRvd0ZvY3VzZWQsIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcblxuICAgICAgICBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQobGFldSk7XG4gICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQobGxhZXUpO1xuICAgICAgICBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycy5hZGQobHdmdSk7XG5cbiAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsYWV1KTtcbiAgICAgICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsYWV1KTtcbiAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGx3ZnUpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IFtnZXRBY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50IHwgbnVsbCwgRm9jdXNFdmVudD4ob25BY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgW2dldExhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCwgRm9jdXNFdmVudD4ob25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCBhcyAoKSA9PiBuZXZlciwgcnVuSW1tZWRpYXRlbHkpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuLCBGb2N1c0V2ZW50PihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUsIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIHJldHVybiB7IGFjdGl2ZUVsZW1lbnRSZXR1cm46IHsgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQgfSB9O1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQmxvY2tpbmdFbGVtZW50c2AgbWFuYWdlcyBhIHN0YWNrIG9mIGVsZW1lbnRzIHRoYXQgaW5lcnQgdGhlIGludGVyYWN0aW9uXG4gKiBvdXRzaWRlIHRoZW0uIFRoZSB0b3AgZWxlbWVudCBpcyB0aGUgaW50ZXJhY3RpdmUgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgc3RhY2sgY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbWV0aG9kcyBgcHVzaCwgcmVtb3ZlLCBwb3BgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NraW5nRWxlbWVudHMge1xuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gVGhpcyBlbXB0aWVzXG4gICAqIHRoZSBibG9ja2luZyBlbGVtZW50c1xuICAgKi9cbiAgZGVzdHJ1Y3RvcigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9wIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICB0b3A6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmcgZWxlbWVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICogZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgdG9wIGJsb2NraW5nIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBhIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgZXh0ZW5kcyBEb2N1bWVudCB7XG4gICRibG9ja2luZ0VsZW1lbnRzOiBCbG9ja2luZ0VsZW1lbnRzO1xufVxuXG4oKCkgPT4ge1xuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuXG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuXG4gIGludGVyZmFjZSBJbmVydGFibGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgaW5lcnQ/OiBib29sZWFuO1xuICB9XG5cbiAgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICAgIFtfc2libGluZ3NUb1Jlc3RvcmVdOiBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPjtcbiAgICBbX3BhcmVudE1PXTogTXV0YXRpb25PYnNlcnZlcjtcbiAgfVxuICBpbnRlcmZhY2UgSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgSW50ZXJuYWxTdGF0ZSB7fVxuICBpbnRlcmZhY2UgTWF5YmVIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBQYXJ0aWFsPEludGVybmFsU3RhdGU+IHt9XG5cbiAgLyoqXG4gICAqIFNoYWR5RE9NIHNoYWR5IHJvb3RzIGxvb2sgYSBsb3QgbGlrZSByZWFsIFNoYWRvd1Jvb3RzLiBUaGUgX19zaGFkeSBwcm9wZXJ0eVxuICAgKiBnaXZlcyB0aGVtIGF3YXksIHRob3VnaC5cbiAgICovXG4gIGludGVyZmFjZSBNYXliZVNoYWR5Um9vdCBleHRlbmRzIEVsZW1lbnQge1xuICAgIF9fc2hhZHk6IHVua25vd247XG4gICAgaG9zdDogRWxlbWVudDtcbiAgfVxuXG4gIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tpbmdFbGVtZW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2Jsb2NraW5nRWxlbWVudHNdOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BFbFBhcmVudHNdOiBIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICogcHVzaGVkLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG5ldyBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPigpO1xuXG4gICAgZGVzdHJ1Y3RvcigpOiB2b2lkIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAvLyBleGNlcHRpb24uXG4gICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgIFtfYmxvY2tpbmdFbGVtZW50c106IG51bGw7XG4gICAgICAgIFtfdG9wRWxQYXJlbnRzXTogbnVsbDtcbiAgICAgICAgW19hbHJlYWR5SW5lcnRFbGVtZW50c106IG51bGw7XG4gICAgICB9O1xuICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BDaGFuZ2VkXShuZXdUb3A6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZXxudWxsKTogdm9pZCB7XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHMgYXMgQXJyYXk8SGFzSW50ZXJuYWxTdGF0ZT47XG5cbiAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG5cbiAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19zd2FwSW5lcnRlZFNpYmxpbmddKFxuICAgICAgICBvbGRJbmVydDogSGFzSW50ZXJuYWxTdGF0ZSwgbmV3SW5lcnQ6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgIH1cbiAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHM6IEhhc0ludGVybmFsU3RhdGVbXSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX2luZXJ0U2libGluZ3NdKFxuICAgICAgICBlbGVtZW50czogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10sIHRvU2tpcDogU2V0PEhUTUxFbGVtZW50PnxudWxsLFxuICAgICAgICB0b0tlZXBJbmVydDogU2V0PEhUTUxFbGVtZW50PnxudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSE7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlIGFzIE1heWJlU2hhZHlSb290O1xuICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pOiB2b2lkIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG11dGF0aW9uLnRhcmdldCBhcyBTaGFkb3dSb290KS5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQgYXMgSGFzSW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuXG4gICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaXNJbmVydGFibGVdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXRQYXJlbnRzXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgY3VycmVudDogSFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWQgPSBlbGVtZW50O1xuICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjdXJyZW50IGFzIE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTpcbiAgICAgICAgU2V0PEhUTUxFbGVtZW50PnxudWxsIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgbGV0IGk7XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAoZG9jdW1lbnQgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuIiwidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICovXG4gIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gIC8qKlxuICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICogYXR0cmlidXRlLlxuICAgKlxuICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgKlxuICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgKlxuICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAqL1xuXG4gIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBIVE1MRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICovXG4gICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAqXG4gICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAqXG4gICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICovXG5cblxuICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ25vZGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE5vZGU7XG4gIH0oKTtcblxuICAvKipcbiAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgKlxuICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAqL1xuXG5cbiAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFIVE1MRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKCFIVE1MRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgIH0sXG4gICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pKCk7XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlXG4gKiBAcGFyYW0geyp9IHhcbiAqIEBwYXJhbSB7Kn0geVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdHJldHVybiAoeCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNsYXNzIHdpdGggYSBwcmVkZWZpbmVkIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHApIHtcblx0dGhpcy5wcm9wcyA9IHA7XG59XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcbi8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbiAodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGNvbnN0IGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Ll9vblJlc29sdmUpIHtcblx0XHRjb21wb25lbnQuX29uUmVzb2x2ZSgpO1xuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBoeWRyYXRpbmdcblx0Ly8gbW9zdCBsaWtlbHkgaXQgaXMgYmVjYXVzZSB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZFxuXHQvLyB3ZSBzZXQgdGhlIHZub2RlLnR5cGUgYXMgYG51bGxgIHNvIHRoYXQgaXQgaXMgbm90IGEgdHlwZW9mIGZ1bmN0aW9uXG5cdC8vIHNvIHRoZSB1bm1vdW50IHdpbGwgcmVtb3ZlIHRoZSB2bm9kZS5fZG9tXG5cdGlmIChjb21wb25lbnQgJiYgdm5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZSkge1xuXHRcdHZub2RlLnR5cGUgPSBudWxsO1xuXHR9XG5cblx0aWYgKG9sZFVubW91bnQpIG9sZFVubW91bnQodm5vZGUpO1xufTtcblxuZnVuY3Rpb24gZGV0YWNoZWRDbG9uZSh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSkge1xuXHRpZiAodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAmJiB2bm9kZS5fY29tcG9uZW50Ll9faG9va3MpIHtcblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5mb3JFYWNoKGVmZmVjdCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZWZmZWN0Ll9jbGVhbnVwID09ICdmdW5jdGlvbicpIGVmZmVjdC5fY2xlYW51cCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBwYXJlbnREb20pIHtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gZGV0YWNoZWRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdGRldGFjaGVkQ2xvbmUoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pXG5cdFx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPcmlnaW5hbCh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdHZub2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRyZW1vdmVPcmlnaW5hbChjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KVxuXHRcdFx0KTtcblxuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBkZXRhY2hlZFBhcmVudCkge1xuXHRcdFx0XHRpZiAodm5vZGUuX2RvbSkge1xuXHRcdFx0XHRcdG9yaWdpbmFsUGFyZW50Lmluc2VydEJlZm9yZSh2bm9kZS5fZG9tLCB2bm9kZS5fbmV4dERvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBvcmlnaW5hbFBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbi8vIGhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXNcbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZSgpIHtcblx0Ly8gd2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZSB0byBnb2xmIHNvbWUgYnl0ZXMuLi5cblx0dGhpcy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCA9IDA7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBudWxsO1xuXHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xufVxuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSB0aHJvd24gcHJvbWlzZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZTxhbnksIGFueT59IHN1c3BlbmRpbmdWTm9kZSBUaGUgc3VzcGVuZGluZyBjb21wb25lbnRcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLl9jaGlsZERpZFN1c3BlbmQgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcywgc3RhdGUpIHtcblx0aWYgKHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcikge1xuXHRcdC8vIFdoZW4gdGhlIFN1c3BlbnNlJ3MgX3Zub2RlIHdhcyBjcmVhdGVkIGJ5IGEgY2FsbCB0byBjcmVhdGVWTm9kZVxuXHRcdC8vIChpLmUuIGR1ZSB0byBhIHNldFN0YXRlIGZ1cnRoZXIgdXAgaW4gdGhlIHRyZWUpXG5cdFx0Ly8gaXQncyBfY2hpbGRyZW4gcHJvcCBpcyBudWxsLCBpbiB0aGlzIGNhc2Ugd2UgXCJmb3JnZXRcIiBhYm91dCB0aGUgcGFya2VkIHZub2RlcyB0byBkZXRhY2hcblx0XHRpZiAodGhpcy5fdm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBkZXRhY2hlZFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRDb21wb25lbnQgPSB0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0uX2NvbXBvbmVudDtcblx0XHRcdHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXSA9IGRldGFjaGVkQ2xvbmUoXG5cdFx0XHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcixcblx0XHRcdFx0ZGV0YWNoZWRQYXJlbnQsXG5cdFx0XHRcdChkZXRhY2hlZENvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb20gPSBkZXRhY2hlZENvbXBvbmVudC5fcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xuXHR9XG5cblx0Ly8gV3JhcCBmYWxsYmFjayB0cmVlIGluIGEgVk5vZGUgdGhhdCBwcmV2ZW50cyBpdHNlbGYgZnJvbSBiZWluZyBtYXJrZWQgYXMgYWJvcnRpbmcgbWlkLWh5ZHJhdGlvbjpcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gKi9cblx0Y29uc3QgZmFsbGJhY2sgPVxuXHRcdHN0YXRlLl9zdXNwZW5kZWQgJiYgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuZmFsbGJhY2spO1xuXHRpZiAoZmFsbGJhY2spIGZhbGxiYWNrLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdHJldHVybiBbXG5cdFx0Y3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgc3RhdGUuX3N1c3BlbmRlZCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbiksXG5cdFx0ZmFsbGJhY2tcblx0XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGFuZCBjYWxscyB0aGUgcGFyZW50IGNvbXBvbmVudCdzIF9zdXNwZW5kZWQgbWV0aG9kLCBwYXNzaW5nIGluIHRoZVxuICogc3VzcGVuZGVkIHZub2RlLiBUaGlzIGlzIGEgd2F5IGZvciBhIHBhcmVudCAoZS5nLiBTdXNwZW5zZUxpc3QpIHRvIGdldCBub3RpZmllZFxuICogdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIHN1c3BlbmRlZC5cbiAqXG4gKiBUaGUgcGFyZW50IE1BWSByZXR1cm4gYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogc3VzcGVuc2lvbiByZXNvbHZlcywgbm90aWZ5aW5nIHRoZSBwYXJlbnQgb2YgdGhlIGZhY3QuXG4gKiBNb3Jlb3ZlciwgdGhlIGNhbGxiYWNrIGdldHMgZnVuY3Rpb24gYHVuc3VzcGVuZGAgYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXNvbHZlZFxuICogY2hpbGQgZGVzY2VuZGFudCB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdW5zdXNwZW5kZWQgdW50aWwgYHVuc3VzcGVuZGAgZ2V0cyBjYWxsZWQuXG4gKiBUaGlzIGlzIGEgd2F5IGZvciB0aGUgcGFyZW50IHRvIGRlbGF5IHVuc3VzcGVuZGluZy5cbiAqXG4gKiBJZiB0aGUgcGFyZW50IGRvZXMgbm90IHJldHVybiBhIGNhbGxiYWNrIHRoZW4gdGhlIHJlc29sdmVkIHZub2RlXG4gKiBnZXRzIHVuc3VzcGVuZGVkIGltbWVkaWF0ZWx5IHdoZW4gaXQgcmVzb2x2ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHsoKHVuc3VzcGVuZDogKCkgPT4gdm9pZCkgPT4gdm9pZCk/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZGVkKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50ID0gdm5vZGUuX3BhcmVudC5fY29tcG9uZW50O1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkKHZub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenkobG9hZGVyKSB7XG5cdGxldCBwcm9tO1xuXHRsZXQgY29tcG9uZW50O1xuXHRsZXQgZXJyb3I7XG5cblx0ZnVuY3Rpb24gTGF6eShwcm9wcykge1xuXHRcdGlmICghcHJvbSkge1xuXHRcdFx0cHJvbSA9IGxvYWRlcigpO1xuXHRcdFx0cHJvbS50aGVuKFxuXHRcdFx0XHRleHBvcnRzID0+IHtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cztcblx0XHRcdFx0fSxcblx0XHRcdFx0ZSA9PiB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wb25lbnQpIHtcblx0XHRcdHRocm93IHByb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG5cdH1cblxuXHRMYXp5LmRpc3BsYXlOYW1lID0gJ0xhenknO1xuXHRMYXp5Ll9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTGF6eTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRjb25zdCBkZWxlZ2F0ZWQgPSBzdXNwZW5kZWQobGlzdC5fdm5vZGUpO1xuXG5cdGxldCBub2RlID0gbGlzdC5fbWFwLmdldChjaGlsZCk7XG5cdG5vZGVbU1VTUEVOREVEX0NPVU5UXSsrO1xuXG5cdHJldHVybiB1bnN1c3BlbmQgPT4ge1xuXHRcdGNvbnN0IHdyYXBwZWRVbnN1c3BlbmQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIWxpc3QucHJvcHMucmV2ZWFsT3JkZXIpIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRoZSB1bmRlZmluZWQgKGZhbHN5KSByZXZlYWxPcmRlciwgYXMgdGhlcmVcblx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBjb29yZGluYXRlIGEgc3BlY2lmaWMgb3JkZXIgb3IgdW5zdXNwZW5kcy5cblx0XHRcdFx0dW5zdXNwZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnB1c2godW5zdXNwZW5kKTtcblx0XHRcdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRkZWxlZ2F0ZWQod3JhcHBlZFVuc3VzcGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdyYXBwZWRVbnN1c3BlbmQoKTtcblx0XHR9XG5cdH07XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPVxuXHRTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHRcdC8vIDEuIEFzIGVhY2ggbm9kZVtTVVNQRU5ERURfQ09VTlRdIHN0YXJ0cyBmcm9tIDEsIHRoaXMgaXRlcmF0aW9uIGluY3JlYXNlc1xuXHRcdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdFx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0XHQvLyAyLiBIYW5kbGUgbm9kZXMgdGhhdCBtaWdodCBoYXZlIGdvdHRlbiByZXNvbHZlZCBiZXR3ZWVuIHJlbmRlciBhbmRcblx0XHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0XHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRcdHJlc29sdmUodGhpcywgY2hpbGQsIG5vZGUpO1xuXHRcdH0pO1xuXHR9O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc3JjL2luZGV4JykuUmVuZGVyYWJsZVByb3BzPHsgY29udGV4dDogYW55IH0+fSBwcm9wc1xuICovXG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcblx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBwcm9wcy5jb250ZXh0O1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogUG9ydGFsIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcHNcbiAqXG4gKiBUT0RPOiB1c2UgY3JlYXRlUm9vdCgpIGluc3RlYWQgb2YgZmFrZSByb290XG4gKi9cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuXHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdGxldCBjb250YWluZXIgPSBwcm9wcy5fY29udGFpbmVyO1xuXG5cdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsImltcG9ydCB7XG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGh5ZHJhdGUgYXMgcHJlYWN0SHlkcmF0ZSxcblx0b3B0aW9ucyxcblx0dG9DaGlsZEFycmF5LFxuXHRDb21wb25lbnRcbn0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQweGVhYzc7XG5cbmNvbnN0IENBTUVMX1BST1BTID1cblx0L14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxkb21pbmFudHxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxpbWFnZXxsZXR0ZXJ8bGlnaHRpbmd8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHBvaW50ZXJ8c2hhcGV8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dHJhbnNmb3JtfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5jb25zdCBPTl9BTkkgPSAvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvO1xuY29uc3QgQ0FNRUxfUkVQTEFDRSA9IC9bQS1aMC05XS9nO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9cblx0XHQ6IC9maWx8Y2hlfHJhL1xuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmNvbnN0IGNsYXNzTmFtZURlc2NyaXB0b3JOb25FbnVtYmVyYWJsZSA9IHtcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVEb21WTm9kZSh2bm9kZSkge1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcyxcblx0XHR0eXBlID0gdm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRpZiAoXG5cdFx0XHQoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB8fFxuXHRcdFx0Ly8gRW11bGF0ZSBSZWFjdCdzIGJlaGF2aW9yIG9mIG5vdCByZW5kZXJpbmcgdGhlIGNvbnRlbnRzIG9mIG5vc2NyaXB0IHRhZ3Mgb24gdGhlIGNsaWVudC5cblx0XHRcdChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB8fFxuXHRcdFx0aSA9PT0gJ2NsYXNzJyB8fFxuXHRcdFx0aSA9PT0gJ2NsYXNzTmFtZSdcblx0XHQpIHtcblx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHQvLyBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGxldCBsb3dlckNhc2VkID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmIChpID09PSAnZGVmYXVsdFZhbHVlJyAmJiAndmFsdWUnIGluIHByb3BzICYmIHByb3BzLnZhbHVlID09IG51bGwpIHtcblx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgZm9yIEVsZW1lbnRzIHdpdGggbm8gdmFsdWUgcHJvcCBpcyB0aGUgc2FtZSBhcyB0aGUgRE9NIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eS5cblx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0Ly8gQ2FsbGluZyBgc2V0QXR0cmlidXRlYCB3aXRoIGEgdHJ1dGh5IHZhbHVlIHdpbGwgbGVhZCB0byBpdCBiZWluZ1xuXHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0Ly8gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBmaWxlIG5hbWUgYW5kIHRoZSBmaWxlIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWQgPT09ICdvbmRvdWJsZWNsaWNrJykge1xuXHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bG93ZXJDYXNlZCA9PT0gJ29uY2hhbmdlJyAmJlxuXHRcdFx0KHR5cGUgPT09ICdpbnB1dCcgfHwgdHlwZSA9PT0gJ3RleHRhcmVhJykgJiZcblx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdCkge1xuXHRcdFx0bG93ZXJDYXNlZCA9IGkgPSAnb25pbnB1dCc7XG5cdFx0fSBlbHNlIGlmIChsb3dlckNhc2VkID09PSAnb25mb2N1cycpIHtcblx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWQgPT09ICdvbmJsdXInKSB7XG5cdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdH0gZWxzZSBpZiAoT05fQU5JLnRlc3QoaSkpIHtcblx0XHRcdGkgPSBsb3dlckNhc2VkO1xuXHRcdH0gZWxzZSBpZiAodHlwZS5pbmRleE9mKCctJykgPT09IC0xICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdGkgPSBpLnJlcGxhY2UoQ0FNRUxfUkVQTEFDRSwgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHQvLyBpZiB3ZSBoYXZlIGFuIG9uaW5wdXQgcHJvcCBhbHJlYWR5IGNoYW5nZSBpdCB0byBvbmlucHV0Q2FwdHVyZVxuXHRcdGlmIChsb3dlckNhc2VkID09PSAnb25pbnB1dCcpIHtcblx0XHRcdGkgPSBsb3dlckNhc2VkO1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0aWYgKFxuXHRcdHR5cGUgPT0gJ3NlbGVjdCcgJiZcblx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0KSB7XG5cdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSA9PSBjaGlsZC5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGlmIChwcm9wcy5jbGFzcyAmJiAhcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3M7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFxuXHRcdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdFx0J2NsYXNzTmFtZScsXG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yTm9uRW51bWJlcmFibGVcblx0XHQpO1xuXHR9IGVsc2UgaWYgKHByb3BzLmNsYXNzTmFtZSAmJiAhcHJvcHMuY2xhc3MpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBub3JtYWxpemVkUHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuXHR9IGVsc2UgaWYgKHByb3BzLmNsYXNzICYmIHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZWRQcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG5cdH1cblxuXHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcbn1cblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRoYW5kbGVEb21WTm9kZSh2bm9kZSk7XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uICh2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbmNvbnN0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuLyoqIEB0eXBlIHsodm5vZGU6IGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlKX0gKi9cbm9wdGlvbnMuZGlmZmVkID0gZnVuY3Rpb24gKHZub2RlKSB7XG5cdGlmIChvbGREaWZmZWQpIHtcblx0XHRvbGREaWZmZWQodm5vZGUpO1xuXHR9XG5cblx0Y29uc3QgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0Y29uc3QgZG9tID0gdm5vZGUuX2RvbTtcblx0aWYgKFxuXHRcdGRvbSAhPSBudWxsICYmXG5cdFx0dm5vZGUudHlwZSA9PT0gJ3RleHRhcmVhJyAmJlxuXHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRwcm9wcy52YWx1ZSAhPT0gZG9tLnZhbHVlXG5cdCkge1xuXHRcdGRvbS52YWx1ZSA9IHByb3BzLnZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLnZhbHVlO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG4vLyBUaGlzIGlzIGEgdmVyeSB2ZXJ5IHByaXZhdGUgaW50ZXJuYWwgZnVuY3Rpb24gZm9yIFJlYWN0IGl0XG4vLyBpcyB1c2VkIHRvIHNvcnQtb2YgZG8gcnVudGltZSBkZXBlbmRlbmN5IGluamVjdGlvbi4gU28gZmFyXG4vLyBvbmx5IGByZWFjdC1yZWxheWAgbWFrZXMgdXNlIG9mIGl0LiBJdCB1c2VzIGl0IHRvIHJlYWQgdGhlXG4vLyBjb250ZXh0IHZhbHVlLlxuZXhwb3J0IGNvbnN0IF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0ge1xuXHRSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiB7XG5cdFx0Y3VycmVudDoge1xuXHRcdFx0cmVhZENvbnRleHQoY29udGV4dCkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudENvbXBvbmVudC5fZ2xvYmFsQ29udGV4dFtjb250ZXh0Ll9pZF0ucHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgdHlwZSBKU1gsIHR5cGUgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgQ1NTUHJvcGVydGllcywgRWxlbWVudFByb3BzLCBSZWYgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHMuanNcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50LmpzXCI7XG5cbmV4cG9ydCB0eXBlIFNldENoaWxkcmVuID0gKChjaGlsZHJlbjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBHZXRDbGFzcyA9IChjbHM6IHN0cmluZykgPT4gYm9vbGVhbjtcbmV4cG9ydCB0eXBlIFNldENsYXNzID0gKGNsczogc3RyaW5nLCBlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgU2V0U3R5bGUgPSA8VCBleHRlbmRzIChrZXlvZiBDU1NTdHlsZURlY2xhcmF0aW9uKSAmIHN0cmluZz4ocHJvcDogVCwgdmFsdWU6IENTU1Byb3BlcnRpZXNbVF0gfCBudWxsKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgR2V0QXR0cmlidXRlPFQgZXh0ZW5kcyBFbGVtZW50PiA9IDxLIGV4dGVuZHMga2V5b2YgRWxlbWVudFByb3BzPFQ+Pihwcm9wOiBLKSA9PiBFbGVtZW50UHJvcHM8VD5bS107XG5leHBvcnQgdHlwZSBTZXRBdHRyaWJ1dGU8VCBleHRlbmRzIEVsZW1lbnQ+ID0gPEsgZXh0ZW5kcyBrZXlvZiBFbGVtZW50UHJvcHM8VD4+KHByb3A6IEssIHZhbHVlOiBFbGVtZW50UHJvcHM8VD5bS10gfCBudWxsKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgU2V0RXZlbnRIYW5kbGVyID0gPEsgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBLLCBsaXN0ZW5lcjogbnVsbCB8ICgodGhpczogSFRNTEVsZW1lbnQsIGV2OiBIVE1MRWxlbWVudEV2ZW50TWFwW0tdKSA9PiB2b2lkKSwgb3B0aW9uczogQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBEYW5nZXJvdXNseVNldElubmVySFRNTCA9IChodG1sOiBzdHJpbmcpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBEYW5nZXJvdXNseUFwcGVuZEhUTUwgPSAoaHRtbDogc3RyaW5nKSA9PiBFbGVtZW50O1xuXG5leHBvcnQgaW50ZXJmYWNlIEltcGVyYXRpdmVIYW5kbGU8VCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBoYXNDbGFzczogR2V0Q2xhc3M7XG4gICAgc2V0Q2xhc3M6IFNldENsYXNzO1xuICAgIHNldFN0eWxlOiBTZXRTdHlsZTtcbiAgICBnZXRBdHRyaWJ1dGU6IEdldEF0dHJpYnV0ZTxUPjtcbiAgICBzZXRBdHRyaWJ1dGU6IFNldEF0dHJpYnV0ZTxUPjtcbiAgICBzZXRDaGlsZHJlbjogU2V0Q2hpbGRyZW47XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IERhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGRhbmdlcm91c2x5QXBwZW5kSFRNTDogRGFuZ2Vyb3VzbHlBcHBlbmRIVE1MO1xuICAgIHNldEV2ZW50SGFuZGxlcjogU2V0RXZlbnRIYW5kbGVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUltcGVyYXRpdmVQcm9wc1BhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltcGVyYXRpdmVFbGVtZW50UHJvcHM8VCBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcD4gZXh0ZW5kcyBFbGVtZW50UHJvcHM8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPiB7XG4gICAgdGFnOiBUO1xuICAgIGhhbmRsZTogUmVmPEltcGVyYXRpdmVIYW5kbGU8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPj47XG59XG5cbmxldCB0ZW1wbGF0ZUVsZW1lbnQ6IEhUTUxUZW1wbGF0ZUVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gaHRtbFRvRWxlbWVudChwYXJlbnQ6IEVsZW1lbnQsIGh0bWw6IHN0cmluZykge1xuICAgIGNvbnN0IGRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdGVtcGxhdGVFbGVtZW50ID8/PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9IGh0bWwudHJpbSgpOyAgIC8vIFRPRE86IFRyaW0gZW5zdXJlcyB3aGl0ZXNwYWNlIGRvZXNuJ3QgYWRkIGFueXRoaW5nLCBidXQgd2l0aCBhIGJldHRlciBleHBsYW5hdGlvbiBvZiB3aHlcbiAgICByZXR1cm4gdGVtcGxhdGVFbGVtZW50LmNvbnRlbnQuZmlyc3RDaGlsZCEgYXMgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBFYXN5IGFjY2VzcyB0byBhbiBIVE1MRWxlbWVudCB0aGF0IGNhbiBiZSBjb250cm9sbGVkIGltcGVyYXRpdmVseS5cbiAqIFxuICogVGhlIEhUTUxFbGVtZW50IHJlbmRlcmVkIGlzIGNvbnRyb2xsZWQgYnkgdGhlIGB0YWdgIHByb3AgKGUuZy4gXCJzcGFuXCIsIFwiZGl2XCIpLlxuICogXG4gKiBUaGUgYGhhbmRsZWAgcHJvcCBzaG91bGQgYmUgZS5nLiBgdXNlUmVmPEltcGVyYXRpdmVIYW5kbGU8SFRNTERpdkVsZW1lbnQ+PihudWxsKWBcbiAqL1xuZXhwb3J0IGNvbnN0IEltcGVyYXRpdmVFbGVtZW50ID0gbWVtbyhmb3J3YXJkUmVmKEltcGVyYXRpdmVFbGVtZW50VSkpIGFzIHR5cGVvZiBJbXBlcmF0aXZlRWxlbWVudFU7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50IH0gfTogVXNlSW1wZXJhdGl2ZVByb3BzUGFyYW1ldGVyczxFPikge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlSW1wZXJhdGl2ZVByb3BzKTtcblxuICAgIGNvbnN0IGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMgPSB1c2VSZWY8eyBjbGFzc05hbWU6IFNldDxzdHJpbmc+LCBzdHlsZTogQ1NTUHJvcGVydGllcywgY2hpbGRyZW46IHN0cmluZyB8IG51bGwsIGh0bWw6IHN0cmluZyB8IG51bGwsIG90aGVyczogRWxlbWVudFByb3BzPEU+IH0+KHsgY2xhc3NOYW1lOiBuZXcgU2V0KCksIHN0eWxlOiB7fSwgY2hpbGRyZW46IG51bGwsIGh0bWw6IG51bGwsIG90aGVyczoge30gfSk7XG5cblxuICAgIGNvbnN0IGhhc0NsYXNzID0gdXNlQ2FsbGJhY2s8R2V0Q2xhc3M+KChjbHM6IHN0cmluZykgPT4geyByZXR1cm4gY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LmNsYXNzTmFtZS5oYXMoY2xzKTsgfSwgW10pXG4gICAgY29uc3Qgc2V0Q2xhc3MgPSB1c2VDYWxsYmFjazxTZXRDbGFzcz4oKGNscywgZW5hYmxlZCkgPT4ge1xuICAgICAgICBpZiAoaGFzQ2xhc3MoY2xzKSA9PSAhZW5hYmxlZCkge1xuICAgICAgICAgICAgZ2V0RWxlbWVudCgpPy5jbGFzc0xpc3RbZW5hYmxlZCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShjbHMpO1xuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LmNsYXNzTmFtZVtlbmFibGVkID8gXCJhZGRcIiA6IFwiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRTdHlsZSA9IHVzZUNhbGxiYWNrPFNldFN0eWxlPigocHJvcCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChnZXRFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LnN0eWxlW3Byb3BdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wIGFzIHN0cmluZykuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBgJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZSA/PyAoXCJcIiBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldENoaWxkcmVuID0gdXNlQ2FsbGJhY2s8U2V0Q2hpbGRyZW4+KChjaGlsZHJlbjogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICBsZXQgZSA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGUgJiYgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LmNoaWxkcmVuICE9IGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5odG1sID0gbnVsbDtcbiAgICAgICAgICAgIGUudGV4dENvbnRlbnQgPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0gdXNlQ2FsbGJhY2s8RGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw+KChjaGlsZHJlbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBlID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZSAmJiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuaHRtbCAhPSBjaGlsZHJlbikge1xuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lmh0bWwgPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICBlLmlubmVySFRNTCA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZGFuZ2Vyb3VzbHlBcHBlbmRIVE1MID0gdXNlQ2FsbGJhY2s8RGFuZ2Vyb3VzbHlBcHBlbmRIVE1MPigoY2hpbGRyZW46IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgZSA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGUgJiYgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gaHRtbFRvRWxlbWVudChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCgobmV3Q2hpbGQgJiYgbmV3Q2hpbGQgaW5zdGFuY2VvZiBOb2RlKSk7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgJiYgbmV3Q2hpbGQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICAgICAgZS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsITtcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGdldEF0dHJpYnV0ZSA9IHVzZUNhbGxiYWNrPEdldEF0dHJpYnV0ZTxFPj4oKHByb3ApID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbcHJvcF07XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0QXR0cmlidXRlID0gdXNlQ2FsbGJhY2s8U2V0QXR0cmlidXRlPEU+PigocHJvcCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGUocHJvcCkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudCgpPy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGdldEF0dHJpYnV0ZShwcm9wKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXTtcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50KCk/LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldEV2ZW50SGFuZGxlciA9IHVzZUNhbGxiYWNrPFNldEV2ZW50SGFuZGxlcj4oKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChnZXRFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG1hcHBlZEtleSA9IEV2ZW50TWFwcGluZ1t0eXBlXSBhcyBrZXlvZiBFbGVtZW50UHJvcHM8RT47XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW21hcHBlZEtleV0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbbWFwcGVkS2V5XSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlOiB1c2VSZWY8SW1wZXJhdGl2ZUhhbmRsZTxFPj4oe1xuICAgICAgICAgICAgaGFzQ2xhc3MsXG4gICAgICAgICAgICBzZXRDbGFzcyxcbiAgICAgICAgICAgIHNldFN0eWxlLFxuICAgICAgICAgICAgZ2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgc2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgc2V0RXZlbnRIYW5kbGVyLFxuICAgICAgICAgICAgc2V0Q2hpbGRyZW4sXG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTCxcbiAgICAgICAgICAgIGRhbmdlcm91c2x5QXBwZW5kSFRNTFxuICAgICAgICB9KS5jdXJyZW50LFxuICAgICAgICBwcm9wczogdXNlTWVyZ2VkUHJvcHM8RT4oXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogWy4uLmN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jbGFzc05hbWVdLmpvaW4oXCIgXCIpLCBzdHlsZTogY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LnN0eWxlIH0sXG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzXG4gICAgICAgIClcblxuICAgIH1cbn1cblxuZnVuY3Rpb24gSW1wZXJhdGl2ZUVsZW1lbnRVPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXA+KHsgdGFnOiBUYWcsIGhhbmRsZSwgLi4ucHJvcHMgfTogUmVuZGVyYWJsZVByb3BzPEltcGVyYXRpdmVFbGVtZW50UHJvcHM8VD4+LCByZWY6IFJlZjxIVE1MRWxlbWVudFRhZ05hbWVNYXBbVF0+KSB7XG4gICAgY29uc3QgeyBwcm9wc1N0YWJsZSwgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxIVE1MRWxlbWVudFRhZ05hbWVNYXBbVF0+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pXG4gICAgY29uc3QgeyBwcm9wczogaXByb3BzLCBpbXBlcmF0aXZlSGFuZGxlIH0gPSB1c2VJbXBlcmF0aXZlUHJvcHM8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPih7IHJlZkVsZW1lbnRSZXR1cm4gfSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShoYW5kbGUsICgpID0+IGltcGVyYXRpdmVIYW5kbGUpO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWcsIHVzZU1lcmdlZFByb3BzKHByb3BzU3RhYmxlLCBpcHJvcHMsIHByb3BzLCB7IHJlZiB9KSkpO1xufVxuXG5cbmNvbnN0IEV2ZW50TWFwcGluZzogUGFydGlhbDx7IFtLIGluIGtleW9mIEhUTUxFbGVtZW50RXZlbnRNYXBdOiAoa2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzW1wiZGl2XCJdICYgYG9uJHtzdHJpbmd9YCkgfT4gPSB7XG4gICAgYWJvcnQ6IFwib25BYm9ydFwiLFxuICAgIGFuaW1hdGlvbmVuZDogXCJvbkFuaW1hdGlvbkVuZFwiLFxuICAgIGFuaW1hdGlvbnN0YXJ0OiBcIm9uQW5pbWF0aW9uU3RhcnRcIixcbiAgICBhbmltYXRpb25pdGVyYXRpb246IFwib25BbmltYXRpb25JdGVyYXRpb25cIixcbiAgICBiZWZvcmVpbnB1dDogXCJvbkJlZm9yZUlucHV0XCIsXG4gICAgYmx1cjogXCJvbkJsdXJcIixcbiAgICBjYW5wbGF5OiBcIm9uQ2FuUGxheVwiLFxuICAgIGNhbnBsYXl0aHJvdWdoOiBcIm9uQ2FuUGxheVRocm91Z2hcIixcbiAgICBjaGFuZ2U6IFwib25DaGFuZ2VcIixcbiAgICBjbGljazogXCJvbkNsaWNrXCIsXG4gICAgY29tcG9zaXRpb25lbmQ6IFwib25Db21wb3NpdGlvbkVuZFwiLFxuICAgIGNvbXBvc2l0aW9uc3RhcnQ6IFwib25Db21wb3NpdGlvblN0YXJ0XCIsXG4gICAgY29tcG9zaXRpb251cGRhdGU6IFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFxuICAgIGNvbnRleHRtZW51OiBcIm9uQ29udGV4dE1lbnVcIixcbiAgICBjdXQ6IFwib25DdXRcIixcbiAgICBkYmxjbGljazogXCJvbkRibENsaWNrXCIsXG4gICAgZHJhZzogXCJvbkRyYWdcIixcbiAgICBkcmFnZW5kOiBcIm9uRHJhZ0VuZFwiLFxuICAgIGRyYWdlbnRlcjogXCJvbkRyYWdFbnRlclwiLFxuICAgIGRyYWdsZWF2ZTogXCJvbkRyYWdMZWF2ZVwiLFxuICAgIGRyYWdvdmVyOiBcIm9uRHJhZ092ZXJcIixcbiAgICBkcmFnc3RhcnQ6IFwib25EcmFnU3RhcnRcIixcbiAgICBkcm9wOiBcIm9uRHJvcFwiLFxuICAgIGR1cmF0aW9uY2hhbmdlOiBcIm9uRHVyYXRpb25DaGFuZ2VcIixcbiAgICBlbXB0aWVkOiBcIm9uRW1wdGllZFwiLFxuICAgIGVuZGVkOiBcIm9uRW5kZWRcIixcbiAgICBlcnJvcjogXCJvbkVycm9yXCIsXG4gICAgZm9jdXM6IFwib25Gb2N1c1wiLFxuICAgIGZvY3VzaW46IFwib25mb2N1c2luXCIsXG4gICAgZm9jdXNvdXQ6IFwib25mb2N1c291dFwiLFxuICAgIGZvcm1kYXRhOiBcIm9uRm9ybURhdGFcIixcbiAgICBnb3Rwb2ludGVyY2FwdHVyZTogXCJvbkdvdFBvaW50ZXJDYXB0dXJlXCIsXG4gICAgaW5wdXQ6IFwib25JbnB1dFwiLFxuICAgIGludmFsaWQ6IFwib25JbnZhbGlkXCIsXG4gICAga2V5ZG93bjogXCJvbktleURvd25cIixcbiAgICBrZXlwcmVzczogXCJvbktleVByZXNzXCIsXG4gICAga2V5dXA6IFwib25LZXlVcFwiLFxuICAgIGxvYWQ6IFwib25Mb2FkXCIsXG4gICAgbG9hZGVkZGF0YTogXCJvbkxvYWRlZERhdGFcIixcbiAgICBsb2FkZWRtZXRhZGF0YTogXCJvbkxvYWRlZE1ldGFkYXRhXCIsXG4gICAgbG9hZHN0YXJ0OiBcIm9uTG9hZFN0YXJ0XCIsXG4gICAgbG9zdHBvaW50ZXJjYXB0dXJlOiBcIm9uTG9zdFBvaW50ZXJDYXB0dXJlXCIsXG4gICAgbW91c2Vkb3duOiBcIm9uTW91c2VEb3duXCIsXG4gICAgbW91c2VlbnRlcjogXCJvbk1vdXNlRW50ZXJcIixcbiAgICBtb3VzZWxlYXZlOiBcIm9uTW91c2VMZWF2ZVwiLFxuICAgIG1vdXNlbW92ZTogXCJvbk1vdXNlTW92ZVwiLFxuICAgIG1vdXNlb3V0OiBcIm9uTW91c2VPdXRcIixcbiAgICBtb3VzZW92ZXI6IFwib25Nb3VzZU92ZXJcIixcbiAgICBtb3VzZXVwOiBcIm9uTW91c2VVcFwiLFxuICAgIHBhc3RlOiBcIm9uUGFzdGVcIixcbiAgICBwYXVzZTogXCJvblBhdXNlXCIsXG4gICAgcGxheTogXCJvblBsYXlcIixcbiAgICBwbGF5aW5nOiBcIm9uUGxheWluZ1wiLFxuICAgIHBvaW50ZXJjYW5jZWw6IFwib25Qb2ludGVyQ2FuY2VsXCIsXG4gICAgcG9pbnRlcmRvd246IFwib25Qb2ludGVyRG93blwiLFxuICAgIHBvaW50ZXJlbnRlcjogXCJvblBvaW50ZXJFbnRlclwiLFxuICAgIHBvaW50ZXJsZWF2ZTogXCJvblBvaW50ZXJMZWF2ZVwiLFxuICAgIHBvaW50ZXJtb3ZlOiBcIm9uUG9pbnRlck1vdmVcIixcbiAgICBwb2ludGVyb3V0OiBcIm9uUG9pbnRlck91dFwiLFxuICAgIHBvaW50ZXJvdmVyOiBcIm9uUG9pbnRlck92ZXJcIixcbiAgICBwb2ludGVydXA6IFwib25Qb2ludGVyVXBcIixcbiAgICBwcm9ncmVzczogXCJvblByb2dyZXNzXCIsXG4gICAgcmVzZXQ6IFwib25SZXNldFwiLFxuICAgIHNjcm9sbDogXCJvblNjcm9sbFwiLFxuICAgIHNlZWtlZDogXCJvblNlZWtlZFwiLFxuICAgIHNlZWtpbmc6IFwib25TZWVraW5nXCIsXG4gICAgc2VsZWN0OiBcIm9uU2VsZWN0XCIsXG4gICAgc3RhbGxlZDogXCJvblN0YWxsZWRcIixcbiAgICBzdWJtaXQ6IFwib25TdWJtaXRcIixcbiAgICBzdXNwZW5kOiBcIm9uU3VzcGVuZFwiLFxuICAgIHRpbWV1cGRhdGU6IFwib25UaW1lVXBkYXRlXCIsXG4gICAgdG9nZ2xlOiBcIm9uVG9nZ2xlXCIsXG4gICAgdG91Y2hjYW5jZWw6IFwib25Ub3VjaENhbmNlbFwiLFxuICAgIHRvdWNoZW5kOiBcIm9uVG91Y2hFbmRcIixcbiAgICB0b3VjaG1vdmU6IFwib25Ub3VjaE1vdmVcIixcbiAgICB0b3VjaHN0YXJ0OiBcIm9uVG91Y2hTdGFydFwiLFxuICAgIHRyYW5zaXRpb25lbmQ6IFwib25UcmFuc2l0aW9uRW5kXCIsXG4gICAgdm9sdW1lY2hhbmdlOiBcIm9uVm9sdW1lQ2hhbmdlXCIsXG4gICAgd2FpdGluZzogXCJvbldhaXRpbmdcIixcbiAgICB3aGVlbDogXCJvbldoZWVsXCJcbn1cbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbi8qKlxuICogV2hlbiBhIGJ1bmNoIG9mIHVucmVsYXRlZCBjb21wb25lbnRzIGFsbCB1c2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsXG4gKiB5ZXMsIHRoaXMgYWN0dWFsbHkgaXMgZmFzdGVyLiBJIHdpc2ggaXQgd2Fzbid0LiBJdCdzIGxhbWUuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlQW5pbWF0aW9uRnJhbWUpO1xuICAgIFxuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH07XG59XG5cbmxldCBjYWNoZWQ6IFwicHJvZHVjdGlvblwiIHwgXCJkZXZlbG9wbWVudFwiIHwgbnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKTogXCJwcm9kdWN0aW9uXCIgfCBcImRldmVsb3BtZW50XCIge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudiEuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBcImRldmVsb3BtZW50XCI7XG5cbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB3ZSdyZSByZXR1cm5pbmcgXCJwcm9kdWN0aW9uXCIgZHVlIHRvIGl0IGJlaW5nIHVuc3BlY2lmaWVkLCBcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2Ugc3VyZSBhbnlvbmUgZWxzZSB3aG8gdHJpZXMgZG9lcyB0b28gZm9yIGNvbnNpc3RlbmN5LlxuICAgICAgICAvLyBUT0RPOiBHb29kL2JhZCBpZGVhP1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKGdsb2JhbFRoaXMgYXMgYW55KVtcInByb2Nlc3NcIl0gPz89IHt9O1xuICAgICAgICAgICAgKGdsb2JhbFRoaXMgYXMgYW55KVtcInByb2Nlc3NcIl1bXCJlbnZcIl0gPz89IHt9O1xuICAgICAgICAgICAgKGdsb2JhbFRoaXMgYXMgYW55KVtcInByb2Nlc3NcIl1bXCJlbnZcIl1bXCJOT0RFX0VOVlwiXSA/Pz0gXCJwcm9kdWN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWlsZE1vZGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlZCA/Pz0gKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKSk7XG59XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vb3A7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IGdldEJ1aWxkTW9kZSB9IGZyb20gXCIuL21vZGUuanNcIjtcblxuLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgaW4gZXZlcnkgYnVpbGQsIEkgZG9uJ3QgdGhpbmsgaXQncyBpbiBjb3JlLWpzPyBJIHRoaW5rP1xuLy8gQW5kIGl0J3MgZXh0cmVtZWx5IHNtYWxsIGFueXdheSBhbmQgYmFzaWNhbGx5IGRvZXMgbm90aGluZy5cbndpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID8/PSAoY2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7IGNhbGxiYWNrKHsgZGlkVGltZW91dDogZmFsc2UsIHRpbWVSZW1haW5pbmc6ICgpID0+IHsgcmV0dXJuIDA7IH0sIH0pOyB9LCA1KTtcbn07XG5cbmxldCB0aW1lb3V0SGFuZGxlID0gbnVsbCBhcyBudW1iZXIgfCBudWxsO1xuXG5pbnRlcmZhY2UgSG9va0NhbGxDb3VudCB7XG4gICAgY2FsbENvdW50czogeyBbSzogc3RyaW5nXTogeyB0b3RhbDogbnVtYmVyLCBtb21lbnQ6IG51bWJlciB9IHwgdW5kZWZpbmVkIH07XG59XG5cbnR5cGUgV2luZG93V2l0aEhvb2tDYWxsQ291bnQgPSAoV2luZG93ICYgdHlwZW9mIGdsb2JhbFRoaXMpICYge1xuICAgIF9ob29rQ2FsbENvdW50OiBIb29rQ2FsbENvdW50O1xufVxuXG5mdW5jdGlvbiBjYWxsQ291bnRVKGhvb2s6IEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG5hbWUgPSBob29rLm5hbWU7XG4gICAgaWYgKGZpbHRlckFsbCB8fCBmaWx0ZXJzLmhhcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgY29uc29sZS5hc3NlcnQobmFtZS5sZW5ndGggPiAwKTtcblxuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50ID8/PSB7IGNhbGxDb3VudHM6IHt9IH07XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSA/Pz0geyBtb21lbnQ6IDAsIHRvdGFsOiAwIH07XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSEubW9tZW50ICs9IDE7XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSEudG90YWwgKz0gMTtcblxuICAgIGlmICh0aW1lb3V0SGFuZGxlID09IG51bGwpIHtcbiAgICAgICAgdGltZW91dEhhbmRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygod2luZG93IGFzIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50KS5faG9va0NhbGxDb3VudC5jYWxsQ291bnRzTW9tZW50KTtcbiAgICAgICAgICAgIC8vKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbzogQXJyYXk8eyByZWFkb25seSBIb29rOiBzdHJpbmc7IHJlYWRvbmx5IE5vdzogbnVtYmVyOyByZWFkb25seSBUb3RhbDogbnVtYmVyOyB9PiA9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2hvb2ssIGNvdW50c10pID0+IHsgcmV0dXJuIHsgSG9vazogaG9vayB8fCBcIj9cIiwgTm93OiBjb3VudHM/Lm1vbWVudCB8fCAwLCBUb3RhbDogY291bnRzPy50b3RhbCB8fCAwIH0gYXMgY29uc3QgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoeyBOb3cgfSkgPT4geyByZXR1cm4gISFOb3cgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKHsgTm93OiBsaHNNIH0sIHsgTm93OiByaHNNIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGhzTSAmJiAhcmhzTSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxoc00gfHw9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmhzTSB8fD0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGhzTSAtIHJoc007XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShvLCBbJ0hvb2snLCAnTm93JywgJ1RvdGFsJ10pO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50cykuZm9yRWFjaCgoWywgY291bnRzXSkgPT4geyBjb3VudHMhLm1vbWVudCA9IDA7IH0pO1xuICAgICAgICAgICAgdGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubGV0IGZpbHRlckFsbCA9IGZhbHNlO1xuY29uc3QgZmlsdGVycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUNhbGxDb3VudChob29rOiBGdW5jdGlvbiB8IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJBbGwgPSAoaG9vayA9PT0gXCJhbGxcIik7XG5cbiAgICBpZiAoaG9vayAhPSBcImFsbFwiKVxuICAgICAgICBmaWx0ZXJzLmFkZChob29rLm5hbWUpO1xufVxuXG5leHBvcnQgY29uc3QgbW9uaXRvckNhbGxDb3VudDogdHlwZW9mIGNhbGxDb3VudFUgPSAoZ2V0QnVpbGRNb2RlKCkgPT0gXCJkZXZlbG9wbWVudFwiKSA/IGNhbGxDb3VudFUgOiBub29wO1xuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldEJ1aWxkTW9kZSB9IGZyb20gXCIuLi91dGlsL21vZGUuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuLi91dGlsL3JhbmRvbS1pZC5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGUuanNcIjtcblxuLyoqIFRha2VzIGEgbmV3IHZhbHVlIG9yIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIGEgdmFsdWUsIHVubGlrZSBgT25QYXNzaXZlU3RhdGVDaGFuZ2VgIHdoaWNoIHJlYWN0cyB0byB0aG9zZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBQYXNzaXZlU3RhdGVVcGRhdGVyPFMsIFI+ID0gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKSA6ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbjogUikgPT4gdm9pZCk7XG4vKiogUmVzcG9uZHMgdG8gYSBjaGFuZ2UgaW4gYSB2YWx1ZSwgdW5saWtlIGBQYXNzaXZlU3RhdGVVcGRhdGVyYCB3aGljaCBjYXVzZXMgdGhlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFMsIFI+ID0gKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb24/OiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb24/OiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpIDogKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb246IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XG5cblxuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICBpZiAoZ2V0QnVpbGRNb2RlKCkgPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICByZXR1cm47XG4gICAgXG4gICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWY8QXJyYXk8VD4+KFtdKTtcbiAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmPEFycmF5PGJvb2xlYW4+PihbXSk7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGggYXMgYW55LCAtMSk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVIGV4dGVuZHMgVD4odmFsdWU6IFUsIGk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGkgKyAxO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aX0taW5kZXhlZCBhcmd1bWVudCAoJHtpID49IDA/IEpTT04uc3RyaW5naWZ5KHZhbHVlc1tpXSkgOiBcInRoZSBudW1iZXIgb2Ygc3VwcG9zZWRseSBzdGFibGUgZWxlbWVudHNcIn0pLmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VSZW5kZXJpbmcoZjogKCkgPT4gdm9pZCkge1xuICAgIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID8/IHF1ZXVlTWljcm90YXNrKShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxULCBSPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQsIFI+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj5dIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZVBhc3NpdmVTdGF0ZSk7XG4gICAgLy9sZXQgW2lkLCAsZ2V0SWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMV0pID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG4gICAgICAgIC8vbGV0IGlkID0gZ2V0SWQoKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygobmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50PyBcIlwiIDogXCJOT1QgXCIpICsgXCJTY2hlZHVsaW5nIGVmZmVjdCBcIiwgaWQsIFwiIHdpdGggdmFsdWUgXCIsIG5leHRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKC8qZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9PT0gVW5zZXQgJiYqLyBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJlYXNvblJlZi5jdXJyZW50ID0gcmVhc29uIGFzIFI7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWFzb24gPSByZWFzb25SZWYuY3VycmVudCEgYXMgUjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudDtcblxuICAgICAgICAgICAgICAgIC8vbGV0IGlkID0gZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCgoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KT8gXCJcIiA6IFwiTk9UIFwiKSArIFwiUnVubmluZyBlZmZlY3QgXCIsIGlkLCBcIiB3aXRoIHZhbHVlIFwiLCBuZXh0RGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gaGFwcGVuIGhlcmUgaW4gb3JkZXIgdG8gbWFrZSByZWN1cnNpdmUgb25DaGFuZ2VzIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IGZlZWxzIGJldHRlciB0byBoYXZlIGl0IGhhcHBlbiBhZnRlciBvbkNoYW5nZS4uLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IFVuc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDsgLy8gTmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBvbkNoYW5nZSBpbiBjYXNlIG9uQ2hhbmdlIGlzIHJlY3Vyc2l2ZSAoZS5nLiBmb2N1c2luZyBjYXVzaW5nIGEgZm9jdXMgY2F1c2luZyBhIGZvY3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHByZXZEZXAsIG5leHRSZWFzb24pID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLCBzbyBtYXJrIHVzIGFzIGJlaW5nIG9uIGEgY2xlYW4gc2xhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IFVuc2V0O1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgcHJldkRlcCB0byBzZWUgaWYgd2Ugc2hvdWxkIGFjdHVhbGx5IGNhbGwgb25DaGFuZ2VcbiAgICAgICAgLy92YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfVxuXG4vKiogXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byB1c2UgZm9yIGBjdXN0b21EZWJvdW5jZVJlbmRlcmluZ2AgdGhhdCBjYXVzZXMgYHVzZVBhc3NpdmVTdGF0ZWAgdG8gcnVuIGNoYW5nZXMgd2l0aG91dCB3YWl0aW5nIGEgdGljay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHsgZigpOyB9IiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbihsaHM6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSwgcmhzOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0pOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkQ2hpbGRyZW4pO1xuICAgIFxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG50eXBlIEMgPSBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqIFxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxoc0NsYXNzOiBDLCBsaHNDbGFzc05hbWU6IEMsIHJoc0NsYXNzOiBDLCByaHNDbGFzc05hbWU6IEMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkQ2xhc3Nlcyk7XG5cbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXG5cbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IHJoc0NsYXNzZXMgPSBjbHN4KHJoc0NsYXNzLCByaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFsbENsYXNzZXMpLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCJcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuY29uc3QgdG9SdW4gPSBuZXcgTWFwPG51bWJlciwgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBwcmV2SW5wdXRzPzogSW5wdXRzIHwgdW5kZWZpbmVkLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuLy9cbi8vIEFsc28sIGluIHRoZW9yeSB0aGlzIGNvdWxkIGJlIHJlcGxhY2VkIHdpdGggYHVzZUluc2VydGlvbkVmZmVjdGAsXG4vLyBidXQgdGhhdCBwcm9iYWJseSB3b24ndCBiZSBhdmFpbGFibGUgaW4gUHJlYWN0IGZvciBhd2hpbGUuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAodm5vZGUsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gZWZmZWN0SW5mby5wcmV2SW5wdXRzO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5wcmV2SW5wdXRzID0gZWZmZWN0SW5mby5pbnB1dHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKHZub2RlLCAuLi5hcmdzKTtcbn1cblxuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV07XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbmxldCBpbmNyZW1lbnRpbmdJZCA9IDA7XG5cbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgICBsZXQgbmV4dCA9ICsraW5jcmVtZW50aW5nSWQ7XG4gICAgLy8gVE9ETzogVGhpcyBzZWVtcyByZWFzb25hYmxlLCBidXQgaXMgaXMgbmVjZXNzYXJ5IG9yIGFyZSB3ZSBvcmRlcnMgb2YgbWFnbml0dWRlIGZyb20gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IG92ZXJmbG93P1xuICAgIGlmIChpbmNyZW1lbnRpbmdJZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgaW5jcmVtZW50aW5nSWQgPSAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2sgfCBudWxsLCBpbnB1dHM/OiBJbnB1dHMpIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUJlZm9yZUxheW91dEVmZmVjdCk7XG5cbiAgICAvLyBOb3RlIHRvIHNlbGY6IFRoaXMgaXMgYnkgZmFyIHRoZSBtb3N0IGNhbGxlZCBob29rIGJ5IHNoZWVyIHZvbHVtZSBvZiBkZXBlbmRlbmNpZXMuXG4gICAgLy8gU28gaXQgc2hvdWxkIGlkZWFsbHkgYmUgYXMgcXVpY2sgYXMgcG9zc2libGUuXG5cbiAgICBjb25zdCByZWYgPSB1c2VSZWY8bnVtYmVyPihudWxsISk7XG4gICAgcmVmLmN1cnJlbnQgPz89IG5leHRJZCgpO1xuICAgIGNvbnN0IGlkID0gcmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWZmZWN0KVxuICAgICAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG4gICAgZWxzZVxuICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuXG4gICAgLy8gTm90IG5lZWRlZCwgYmVjYXVzZSB0aGUgaW5zZXJ0aW9uIGNsZWFudXAgd291bGQgcnVuIGJlZm9yZSB1c2VFZmZlY3QgYW55d2F5LCBJIHRoaW5rP1xuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbaWRdKSovXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC5qc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VTdGFibGVHZXR0ZXIpO1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0pLCBbdmFsdWVdKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xufVxuXG5cbi8qKlxuICogTGlrZSBgdXNlU3RhYmxlR2V0dGVyYCwgYnV0ICoqKnJlcXVpcmVzKioqIHRoYXQgZXZlcnl0aGluZyBpbiB0aGUgb2JqZWN0IGlzIGFsc28gc3RhYmxlLFxuICogYW5kIGluIHR1cm4gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaXMgc3RhYmxlLlxuICogQHBhcmFtIHQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZU9iamVjdDxUIGV4dGVuZHMge30+KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModCk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlT2JqZWN0XCIsIGUubGVuZ3RoLCAuLi5lLm1hcCgoW19rLCB2XSkgPT4gdikpO1xuICAgIHJldHVybiB1c2VSZWYodCkuY3VycmVudDtcbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2tOYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG5cbi8vY29uc3QgX0lTX1NUQUJMRV9HRVRURVIgPSBTeW1ib2woXCJTVEFCTEVcIik7XG5leHBvcnQgdHlwZSBTdGFibGU8VD4gPSBUOy8vICYgeyBbX1NUQUJMRV06IHRydWUgfTtcblxuLyoqXG4gKiBXZSBrZWVwIHRyYWNrIG9mIHdoaWNoIGNhbGxiYWNrcyBhcmUgc3RhYmxlIHdpdGggYSBXZWFrTWFwIGluc3RlYWQgb2YsIHNheSwgYSBzeW1ib2wgYmVjYXVzZVxuICogYHVzZUNhbGxiYWNrYCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQncyBzdGFibGUgYWNyb3NzICphbGwqIHJlbmRlcnMsIG1lYW5pbmdcbiAqIHdlIGNhbid0IHVzZSBvdXIgZnVubnkgXCJgaWZgIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYnJlYWsgdGhlIHJ1bGVzIG9mIGhvb2tzXCIgdHJpY2sgdGhlbi5cbiAqL1xuY29uc3QgbWFwID0gbmV3IFdlYWtNYXA8RnVuY3Rpb24sIGJvb2xlYW4+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgRnVuY3Rpb24+KG9iajogVCk6IG9iaiBpcyBTdGFibGU8VD4ge1xuICAgIHJldHVybiAobWFwLmdldChvYmopID8/IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNldElzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KG9iajogVCk6IFN0YWJsZTxUPiB7XG4gICAgbWFwLnNldChvYmosIHRydWUpO1xuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogSW4gZ2VuZXJhbCwganVzdCBwYXNzIHRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBiZSBzdGFibGUgKGJ1dCB5b3UgY2FuJ3QgdXNlIGl0IGR1cmluZyByZW5kZXIsXG4gKiBzbyBiZSBjYXJlZnVsISkuICBBbHRlcm5hdGl2ZWx5LCBpZiB5b3UgbmVlZCBhIHN0YWJsZSBjYWxsYmFjayB0aGF0ICoqY2FuKiogYmUgdXNlZFxuICogZHVyaW5nIHJlbmRlciwgcGFzcyBhbiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5IGFuZCBpdCdsbCBhY3QgbGlrZSBgdXNlQ2FsbGJhY2tgIHdpdGggYW5cbiAqIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXksIGJ1dCB3aXRoIHRoZSBhc3NvY2lhdGVkIHN0YWJsZSB0eXBpbmcuIEluIHRoaXMgY2FzZSwgeW91ICoqKm11c3QqKiogZW5zdXJlIHRoYXQgaXRcbiAqIHRydWx5IGhhcyBubyBkZXBlbmRlbmNpZXMvb25seSBzdGFibGUgZGVwZW5kZW5jaWVzISFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyBGdW5jdGlvbiB8IG51bGwgfCB1bmRlZmluZWQ+KGZuOiBOb25OdWxsYWJsZTxUPiwgbm9EZXBzPzogW10gfCBudWxsIHwgdW5kZWZpbmVkKTogU3RhYmxlPE5vbk51bGxhYmxlPFQ+PiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VTdGFibGVDYWxsYmFjayk7XG4gICAgXG4gICAgdHlwZSBVID0gKE5vbk51bGxhYmxlPFQ+ICYgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZUNhbGxiYWNrXCIsIG5vRGVwcyA9PSBudWxsLCBub0RlcHM/Lmxlbmd0aCwgaXNTdGFibGVHZXR0ZXI8VT4oZm4gYXMgVSkpO1xuICAgIGlmIChpc1N0YWJsZUdldHRlcihmbikpXG4gICAgICAgIHJldHVybiBmbjtcblxuICAgIGlmIChub0RlcHMgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VT4oZm4pO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgICAgIH0pIGFzIFUsIFtdKSk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5vRGVwcy5sZW5ndGggPT09IDApO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oZm4sIFtdKSk7XG4gICAgfVxufVxuXG4iLCJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcywgUmVmLCBSZWZPYmplY3QgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxuICogQHBhcmFtIGxocyBcbiAqIEBwYXJhbSByaHMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihyaHM6IEVsZW1lbnRQcm9wczxFPltcInJlZlwiXSwgbGhzOiBFbGVtZW50UHJvcHM8RT5bXCJyZWZcIl0pIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZFJlZnMpO1xuICAgIFxuICAgIC8vIFRoaXMgKm11c3QqIGJlIHN0YWJsZSBpbiBvcmRlciB0byBwcmV2ZW50IHJlcGVhdGVkIHJlc2V0IGBudWxsYCBjYWxscyBhZnRlciBldmVyeSByZW5kZXIuXG4gICAgY29uc3QgY29tYmluZWQgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBjb21iaW5lZChjdXJyZW50OiBFIHwgbnVsbCkge1xuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcbiAgICB9KTtcblxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocyE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHMhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENTU1Byb3BlcnRpZXMsIEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0sIHJoczogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdKTogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZFN0eWxlcyk7XG5cbiAgICAvLyBFYXN5IGNhc2UsIHdoZW4gdGhlcmUgYXJlIG5vIHN0eWxlcyB0byBtZXJnZSByZXR1cm4gbm90aGluZy5cbiAgICBpZiAoIWxocyAmJiAhcmhzKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXG4gICAgICAgIGlmIChsaHMgJiYgIXJocylcbiAgICAgICAgICAgIHJldHVybiBsaHM7XG4gICAgICAgIGlmICghbGhzICYmIHJocylcbiAgICAgICAgICAgIHJldHVybiByaHM7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0eXBlIHRvIGFuIG9iamVjdCBiYWcgdHlwZSBhbmQgcnVuIGl0IGFnYWluLlxuICAgICAgICBpZiAobGhzICYmIHJocykge1xuICAgICAgICAgICAgLy8gKHVzZU1lcmdlZFN0eWxlcyBpc24ndCBhIHRydWUgaG9vayAtLSB0aGlzIGlzbid0IGEgdmlvbGF0aW9uKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHN0eWxlU3RyaW5nVG9PYmplY3QobGhzIGFzIHN0cmluZyksIHJocykgYXMgQ1NTUHJvcGVydGllcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHN0eWxlU3RyaW5nVG9PYmplY3QocmhzIGFzIHN0cmluZykpIGFzIENTU1Byb3BlcnRpZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2dpYz8/P1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFRoZXkncmUgYm90aCBzdHJpbmdzLCBqdXN0IGNvbmNhdGVuYXRlIHRoZW0uXG4gICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gYCR7bGhzfTske3JocyA/PyBcIlwifWAgYXMgdW5rbm93biBhcyBzdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4obGhzID8/IHt9KSBhcyBDU1NQcm9wZXJ0aWVzLFxuICAgICAgICAuLi4ocmhzID8/IHt9KSBhcyBDU1NQcm9wZXJ0aWVzXG4gICAgfSBhcyB1bmtub3duIGFzIENTU1Byb3BlcnRpZXNcbn1cblxuIiwiaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW4uanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzLmpzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogRWxlbWVudFByb3BzPEU+W10pIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1lcmdlZFByb3BzKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNZXJnZWRQcm9wc1wiLCBhbGxQcm9wcy5sZW5ndGgpO1xuICAgIGxldCByZXQ6IEVsZW1lbnRQcm9wczxFPiA9IHt9O1xuICAgIGZvciAobGV0IG5leHRQcm9wcyBvZiBhbGxQcm9wcykge1xuICAgICAgICByZXQgPSB1c2VNZXJnZWRQcm9wczI8RT4ocmV0LCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGtub3ducyA9IG5ldyBTZXQ8c3RyaW5nPihbXCJjaGlsZHJlblwiLCBcInJlZlwiLCBcImNsYXNzTmFtZVwiLCBcImNsYXNzXCIsIFwic3R5bGVcIl0pXG5cbmZ1bmN0aW9uIG1lcmdlVW5rbm93bihrZXk6IHN0cmluZywgbGhzVmFsdWU6IHVua25vd24sIHJoc1ZhbHVlOiB1bmtub3duKSB7XG5cbiAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXG4gICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZCBhcyBuZXZlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKChyaHNWYWx1ZSBhcyBhbnkpID09IGxoc1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJIG1lYW4sIHRoZXkncmUgdGhlIHNhbWUgdmFsdWUgYXQgbGVhc3RcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cbiAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVnaC5cbiAgICAgICAgICAgIC8vIE5vIGdvb2Qgc3RyYXRlZ2llcyBoZXJlLCBqdXN0IGxvZyBpdCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGxvZz8uKGBUaGUgcHJvcCBcIiR7a2V5fVwiIGNhbm5vdCBzaW11bHRhbmVvdXNseSBiZSB0aGUgdmFsdWVzICR7bGhzVmFsdWV9IGFuZCAke3Joc1ZhbHVlfS4gT25lIG11c3QgYmUgY2hvc2VuIG91dHNpZGUgb2YgdXNlTWVyZ2VkUHJvcHMuYCk7XG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uXG4gKiBcbiAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbmx5IGNhbGxlZCBmdW5jdGlvbnMgaW4gdGhpcyBhbmQgY29uc3VtZXIgbGlicmFyaWVzLFxuICogc28gaXQgdHJhZGVzIGEgYml0IG9mIHJlYWRhYmlsaXR5IGZvciBzcGVlZCAoaS5lLiB3ZSBkb24ndCBkZWNvbXBvc2Ugb2JqZWN0cyBhbmQganVzdCBkbyByZWd1bGFyIHByb3BlcnR5IGFjY2VzcywgaXRlcmF0ZSB3aXRoIGBmb3IuLi5pbmAsIGluc3RlYWQgb2YgYE9iamVjdC5lbnRyaWVzYCwgZXRjLilcbiAqL1xuZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHMyPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBFbGVtZW50UHJvcHM8RT4sIHJoc0FsbDogRWxlbWVudFByb3BzPEU+KTogRWxlbWVudFByb3BzPEU+IHtcblxuICAgIFxuICAgIGNvbnN0IHJldDogRWxlbWVudFByb3BzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPiksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPik+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCBkZWJvdW5jZVJlbmRlcmluZywgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogSW50ZXJuYWxDaGlsZEluZm88TT47XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0sIG1vdW50ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0pID0+ICgoKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogT3RoZXIgaG9va3Mgd2lsbCBpbmhlcml0IGZyb20gdGhpcyB0byBwcm92aWRlIG1vcmUgY29tcGxpY2F0ZWQgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiB7XG4gICAgaW5kZXg6IFQ7XG59XG5cblxuXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAgICAgKiBcbiAgICAgICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxuICAgICAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVE9ETzogVGhpcyBlbmRlZCB1cCBub3QgYmVpbmcgbmVlZGVkIGJ5IGFueXRoaW5nLiBJcyBpdCBuZWNlc3Nhcnk/IERvZXMgaXQgY29zdCBhbnl0aGluZz9cbiAgICAgICAgICovXG4gICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8TVtcImluZGV4XCJdPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPE1bXCJpbmRleFwiXT47XG5cbiAgICAgICAgb25DaGlsZHJlbkNvdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8ICgoY291bnQ6IG51bWJlcikgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBleGFjdCBkYXRhIHRoYXQncyBhdmFpbGFibGUgZnJvbSB0aGUgcGFyZW50L2VhY2ggc2libGluZyBlbGVtZW50IHZpYSBgZ2V0QXRgIG9yIHRoZSBvdGhlciBtZXRob2RzIG9uIGBNYW5hZ2VkQ2hpbGRyZW5gLlxuICAgICAqL1xuICAgIGluZm86IE07XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqICoqKlNUQUJMRSoqKlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgKipib3RoKiogYGdldENoaWxkcmVuYCBhbmQgdGhlIGBNYW5hZ2VkQ2hpbGRyZW5gIG9iamVjdCBpdCByZXR1cm5zIGFyZSBzdGFibGUhXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJlY2F1c2Ugd2hlbiBmdW5jdGlvbiBjYWxscyBoYXBwZW4gb3V0IG9mIG9yZGVyIGl0J3MgZWFzaWVyIHRvIGp1c3QgaGF2ZSBhbHdheXMgYmVlbiBwYXNzaW5nIGFuZCByZXR1cm4gZ2V0dGVycyBldmVyeXdoZXJlIFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG4gICAgfTtcblxuICAgIGNvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IE1bXCJpbmRleFwiXSk6IE0gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE0pID0+IHZvaWQpID0+IHZvaWQgfCBcImJyZWFrXCI7XG5cbiAgICAvKipcbiAgICAgKiAqKlVOU1RBQkxFKiosIFxuICAgICAqIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIFxuICAgICAqIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4sXG4gICAgICogb3IgYXQgbGVhc3QgcHJvcGVybHkgbmFtZSBpdC5cbiAgICAgKiBcbiAgICAgKiBXSEFUIFRISVMgRE9FUzpcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBjaGlsZHJlbiwgc2xpY2VzIHRoZSBhcnJheSBjb250YWluaW5nIHRoZW0sIFxuICAgICAqIGFuZCwgKmNydXRpYWxseSosIGZpbGxzIGluIGFueSBob2xlcyBpbiB0aGUgYXJyYXkgd2l0aCBhIHBzZXVkby1jaGlsZCB0aGF0IGp1c3QgY29udGFpbnMgYW4gaW5kZXguXG4gICAgICogXG4gICAgICogVGhpcyBiZWhhdmlvciwgdG8gYmUgY2xlYXIsIGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyBiZWNhdXNlXG4gICAgICogc29ydGluZyBhbmQgcmVhcnJhbmdpbmcgcmVxdWlyZSBrbm93aW5nIHBlcmZlY3RseSB3aGljaCBpbmRleCBtYXBzIHRvIHdoaWNoLlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IG90aGVyIG1pc3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IGJlc2lkZXMgdGhlIG1pc3NpbmcgaW5kZXguXG4gICAgICogKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNYW5hZ2VkQ2hpbGRyZW4pO1xuXG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZHJlbkNvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRyZW5Db3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkcmVuQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+ICh2b2lkIHwgXCJicmVha1wiKSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZihjaGlsZCkgPT0gJ2JyZWFrJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGlmIChmKGNoaWxkKSA9PSAnYnJlYWsnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48TT5bXCJnZXRBdFwiXT4oKGluZGV4OiBJbmRleFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PEluZGV4VHlwZT4sIHVubW91bnRzOiBTZXQ8SW5kZXhUeXBlPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PEluZGV4VHlwZT4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvbkNoaWxkcmVuQ291bnRDaGFuZ2UgfHwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuQ291bnRDaGFuZ2U/LihnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlU3RhYmxlT2JqZWN0PE1hbmFnZWRDaGlsZHJlbjxNPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gZ2V0SGlnaGVzdEluZGV4KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbaV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0geyBpbmRleDogaSB9IGFzIE07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuLCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPj4oeyBjb250ZXh0LCBpbmZvIH06IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1hbmFnZWRDaGlsZCk7XG5cbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChjb250ZXh0ID8/IHsgbWFuYWdlZENoaWxkQ29udGV4dDoge30gfSk7XG4gICAgY29uc3QgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAvLyB0aGUgcGFyZW50IGlmIHRoZXkgbmVlZCBpdC5cbiAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbkFycmF5ID09IG51bGwgfHwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID09IG51bGwpIHJldHVybjtcblxuICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmFycltpbmRleCBhcyBudW1iZXJdID0geyAuLi5pbmZvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSA9IHsgLi4uaW5mbyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdGVVTEVDaGlsZENoYW5nZWQoaW5kZXggYXMgSW5kZXhUeXBlKTtcbiAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xuICAgIC8vIChldmVyeSBjaGlsZCBkb2VzIHRoaXMsIHNvIGV2ZXJ5dGhpbmcncyBjb29yZGluYXRlZCB0byBvbmx5IHF1ZXVlIGEgc2luZ2xlIG1pY3JvdGFzayBwZXIgdGljaylcbiAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcbiAgICAvLyBzbyB0aGF0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgaW5mbyBvbiBtb3VudC5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCBmYWxzZSk7XG4gICAgfSwgW2luZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHsgZ2V0Q2hpbGRyZW46IGdldENoaWxkcmVuISB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlOiBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8TVtcImluZGV4XCJdIHwgbnVsbCwgUj47XG5cbiAgICBzZXRBdChpbmRleDogTSwgdmFsdWU6IGJvb2xlYW4sIG5ld1NlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwsIHByZXZTZWxlY3RlZEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsKTogdm9pZDtcbiAgICBnZXRBdChpbmRleDogTSk6IGJvb2xlYW47XG4gICAgaXNWYWxpZChpbmRleDogTSk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VTdGF0ZSk7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCJpbXBvcnQgdHlwZSB7IEpTWCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wcy5qc1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxuICogXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cbiAqIFxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cbiAqL1xudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xuXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XG5cblxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xuXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcblxuXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xuXG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICogXG4gKiBgXCJtb2RlXCJgIGNvbnRyb2xzIGlmIHRoZXJlJ3Mgb25lIGhhbmRsZXIgdGhhdCBjYWxscyBhbGwgeW91ciBmdW5jdGlvbnMgKGRlZmF1bHQpLCBvciBvbmUgaGFuZGxlciBhZGRlZCBwZXIgZnVuY3Rpb24gKGBcInNpbmdsZVwiYCkuIFxuICogXG4gKiBUaGUgZGVmYXVsdCwgYFwiZ3JvdXBlZFwiYCwgaXMgZmFzdGVyIHdoZW4geW91IGhhdmUsIHNheSwgYSBidXR0b24gY29tcG9uZW50LCB1c2VkIGh1bmRyZWRzIG9mIHRpbWVzIG9uIGEgcGFnZSwgdGhhdCBlYWNoIGluc3RhbGxzIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuXG4gKiBcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxuICogQHJldHVybnNcbiAqICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdLCBtb2RlPzogXCJncm91cGVkXCIgfCBcInNpbmdsZVwiKTogdm9pZCB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VHbG9iYWxIYW5kbGVyKTtcbiAgICBtb2RlIHx8PSBcImdyb3VwZWRcIjtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VHbG9iYWxIYW5kbGVyXCIsIG1vZGUpO1xuXG4gICAgaWYgKG1vZGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXG4gICAgICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXG4gICAgICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXG4gICAgICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJHcm91cGVkPFQsIEV2ZW50VHlwZSwgSD4odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJTaW5nbGU8VCwgRXZlbnRUeXBlLCBIPih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxudHlwZSBHbG9iYWxIYW5kbGVySW5mbyA9IHsgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7IGxpc3RlbmVyczogU2V0PEV2ZW50TGlzdGVuZXI+OyB9O1xudHlwZSBNYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8c3RyaW5nLCBHbG9iYWxIYW5kbGVySW5mbz5cbnR5cGUgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8VHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RXZlbnRUYXJnZXQ+LCBNYXBPZk9wdGlvbnNUb0luZm8+O1xubGV0IG1hcFRoaW5nID0gbmV3IE1hcDxFdmVudFRhcmdldCwgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8+KCk7XG5cbmZ1bmN0aW9uIGRvTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4ob3A6IChpOiBHbG9iYWxIYW5kbGVySW5mbywgaDogRXZlbnRMaXN0ZW5lcikgPT4gdm9pZCwgdGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zOiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBpZiAoaGFuZGxlcikge1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnNLZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYnlUeXBlID0gbWFwVGhpbmcuZ2V0KHRhcmdldCkgfHwgKG5ldyBNYXAoKSBhcyBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbyk7XG4gICAgICAgIGNvbnN0IGJ5T3B0aW9ucyA9IChieVR5cGUuZ2V0KHR5cGUpIHx8IChuZXcgTWFwKCkgYXMgTWFwT2ZPcHRpb25zVG9JbmZvKSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBieU9wdGlvbnMuZ2V0KG9wdGlvbnNLZXkpIHx8IHsgbGlzdGVuZXI6IG51bGwhLCBsaXN0ZW5lcnM6IG5ldyBTZXQoKSB9O1xuXG4gICAgICAgIG9wKGluZm8sIGhhbmRsZXIpO1xuXG4gICAgICAgIGJ5T3B0aW9ucy5zZXQob3B0aW9uc0tleSwgaW5mbyk7XG4gICAgICAgIGJ5VHlwZS5zZXQodHlwZSwgYnlPcHRpb25zKTtcbiAgICAgICAgbWFwVGhpbmcuc2V0KHRhcmdldCwgYnlUeXBlKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWRkVG9NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM6IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuYWRkKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbU1hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuZGVsZXRlKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB3YXkgZmFzdGVyIGZvciBsYXJnZSBudW1iZXJzIG9mIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBGb3IgZXhhbXBsZSwgaWYgZXZlcnkgYnV0dG9uIGxpc3RlbnMgZm9yIGEgZ2xvYmFsIGNsaWNrLCBvciBzb21ldGhpbmcsXG4gKiBpdCB3b3VsZCBiZSBuaWNlIGlmIGl0IHdhcyBlZmZpY2llbnQgYXQgbGVhc3QuIFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGFkZFRvTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVGcm9tTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlclNpbmdsZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cbiAqIFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICogXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIGBgYFxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxKU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcblxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XG5cbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogRWxlbWVudFByb3BzPEVsZW1lbnRUeXBlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIEVsZW1lbnRQcm9wczxFbGVtZW50VHlwZT4sIHByb3BzKSBhcyBFbGVtZW50UHJvcHM8RWxlbWVudFR5cGU+O1xuICAgICAgICB9LCBbdHlwZV0pO1xuXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcblxuICAgIH0sIFtdKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHksIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgcHJvcHNTdGFibGU6IEVsZW1lbnRQcm9wczxUPjtcblxuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xuICAgIC8qKlxuICAgICAqIEZvciB0aGUgc2FrZSBvZiBjb252ZW5pZW5jZSxcbiAgICAgKiB0aGlzIG9uZSBpcyBvcHRpb25hbCwgc2luY2UgdXNpbmcgdGhpcyBob29rIGlzIHNvIGNvbW1vbixcbiAgICAgKiBidXQgdXNpbmcgaXRzIHBhcmFtZXRlciBvcHRpb25zIGlzIHNvIHVuY29tbW9uLCBhbmQgaXQnc1xuICAgICAqIGFic2Vuc2UgaXNuJ3QgdXN1YWxseSBiZWNhdXNlIGl0IHdhcyBmb3Jnb3R0ZW4sIGl0J3MgYmVjYXVzZVxuICAgICAqIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAgICAqL1xuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzPzoge1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+O1xuICAgICAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnRQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IEVsZW1lbnRQcm9wczxFPltdKTogRWxlbWVudFByb3BzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZVJlZkVsZW1lbnQpO1xuXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MucmVmRWxlbWVudFBhcmFtZXRlcnMgfHwge30pO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xuXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj4+KChlLCBwcmV2VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XG4gICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcblxuICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcblxuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsLCBuZXZlcj4oaGFuZGxlciwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPEVsZW1lbnRQcm9wczxUPj4oeyByZWY6IHNldEVsZW1lbnQgfSk7XG5cbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnQsXG4gICAgICAgIFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHJ1bkltbWVkaWF0ZWx5LCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXG4gKiB0aGUgZm9sbG93aW5nIHN0ZXBzIGhhcHBlbiBpbiBvcmRlcjpcbiAqIFxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuIFxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCByZW1haW5zIGFzIGBib2R5YC5cbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXG4gKiAgICAgIFByb2JhYmx5IGp1c3QgYmVzdCB0byBub3QgcmVseSBvbiBpdCwgb3IgbGlzdGVuIHRvIGB3aW5kb3dgIGZvY3VzIGV2ZW50cyBkaXJlY3RseS5cbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgZm9jdXNvdXRgIGFuZCBgYmx1cmAgYXJlICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqICoqVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIGBib2R5YCoqIGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIGBmb2N1c2luYCBpcyBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgb2xkIGVsZW1lbnQuXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiBcbiAqIFxuICogSW4gc3VtbWFyeTpcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cbiAqIFxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5pbnRlcmZhY2UgRm9vPFQ+IHtcbiAgICBsYXN0U2VudDogVCB8IHVuZGVmaW5lZDtcbiAgICBzZW5kOiAoZTogVCwgcjogRm9jdXNFdmVudCkgPT4gdm9pZDtcbn1cblxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGUgfCBudWxsPj4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGU+Pj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxib29sZWFuPj4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPFQ+Pj4sIHZhbHVlOiBULCByZWFzb246IGFueSkge1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gbWFwLmdldCh3aW5kb3cpO1xuICAgIGlmICh1cGRhdGVycykge1xuICAgICAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFzdFNlbnQsIHNlbmQgfSA9IHVwZGF0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kKHZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyLmxhc3RTZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCwgZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LCBlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LCBlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUsIGUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UsIGUpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIHtcblxuICAgIGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsLCBGb2N1c0V2ZW50PiB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcyBhbmQgaXMgbm90IG51bGwuIFxuICAgICAgICAgKiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50LCBGb2N1c0V2ZW50PiB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4sIEZvY3VzRXZlbnQ+IHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRS5HLiBzb21lRGl2RWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICAgICAqIFxuICAgICAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBldmVudCBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgZGVmYXVsdFZpZXcgV2luZG93LlxuICAgICAgICAgKiBJZiB5b3UgbmVlZCBzb21ldGhpbmcgZGlmZmVyZW50LCBvdmVycmlkZSBpdCBoZXJlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3c/OiAoKGRvY3VtZW50OiBEb2N1bWVudCkgPT4gV2luZG93KSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcbiAgICBhY3RpdmVFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciBgbnVsbGAgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudCB8IG51bGw7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGUgd2luZG93IGl0c2VsZiBoYXMgZm9jdXMgb3Igbm90XG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47XG4gICAgfVxufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudCh7IGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0gfTogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMpOiBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VBY3RpdmVFbGVtZW50KTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSAoZ2V0V2luZG93Py4oZG9jdW1lbnQpID8/IGRvY3VtZW50Py5kZWZhdWx0Vmlldyk7XG5cbiAgICAgICAgaWYgKChhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdyk/LnNpemUgPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgIGNvbnN0IGxhZXUgPSB7IHNlbmQ6IHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9XG4gICAgICAgIGNvbnN0IGxsYWV1ID0geyBzZW5kOiBzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4sIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcbiAgICAgICAgY29uc3QgbHdmdSA9IHsgc2VuZDogc2V0V2luZG93Rm9jdXNlZCwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsYWV1KTtcbiAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsbGFldSk7XG4gICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChsd2Z1KTtcblxuICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobHdmdSk7XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsLCBGb2N1c0V2ZW50PihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIHNldExhc3RBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50LCBGb2N1c0V2ZW50Pihvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsIGFzICgpID0+IG5ldmVyLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4sIEZvY3VzRXZlbnQ+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSwgcnVuSW1tZWRpYXRlbHkpO1xuXG4gICAgcmV0dXJuIHsgYWN0aXZlRWxlbWVudFJldHVybjogeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9IH07XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHR5cGUgSlNYLCB0eXBlIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENTU1Byb3BlcnRpZXMsIEVsZW1lbnRQcm9wcywgUmVmIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzLmpzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudC5qc1wiO1xuXG5leHBvcnQgdHlwZSBTZXRDaGlsZHJlbiA9ICgoY2hpbGRyZW46IHN0cmluZyB8IG51bGwpID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgR2V0Q2xhc3MgPSAoY2xzOiBzdHJpbmcpID0+IGJvb2xlYW47XG5leHBvcnQgdHlwZSBTZXRDbGFzcyA9IChjbHM6IHN0cmluZywgZW5hYmxlZDogYm9vbGVhbikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFNldFN0eWxlID0gPFQgZXh0ZW5kcyAoa2V5b2YgQ1NTU3R5bGVEZWNsYXJhdGlvbikgJiBzdHJpbmc+KHByb3A6IFQsIHZhbHVlOiBDU1NQcm9wZXJ0aWVzW1RdIHwgbnVsbCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEdldEF0dHJpYnV0ZTxUIGV4dGVuZHMgRWxlbWVudD4gPSA8SyBleHRlbmRzIGtleW9mIEVsZW1lbnRQcm9wczxUPj4ocHJvcDogSykgPT4gRWxlbWVudFByb3BzPFQ+W0tdO1xuZXhwb3J0IHR5cGUgU2V0QXR0cmlidXRlPFQgZXh0ZW5kcyBFbGVtZW50PiA9IDxLIGV4dGVuZHMga2V5b2YgRWxlbWVudFByb3BzPFQ+Pihwcm9wOiBLLCB2YWx1ZTogRWxlbWVudFByb3BzPFQ+W0tdIHwgbnVsbCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFNldEV2ZW50SGFuZGxlciA9IDxLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcD4odHlwZTogSywgbGlzdGVuZXI6IG51bGwgfCAoKHRoaXM6IEhUTUxFbGVtZW50LCBldjogSFRNTEVsZW1lbnRFdmVudE1hcFtLXSkgPT4gdm9pZCksIG9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgRGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSAoaHRtbDogc3RyaW5nKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgRGFuZ2Vyb3VzbHlBcHBlbmRIVE1MID0gKGh0bWw6IHN0cmluZykgPT4gRWxlbWVudDtcblxuZXhwb3J0IGludGVyZmFjZSBJbXBlcmF0aXZlSGFuZGxlPFQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgaGFzQ2xhc3M6IEdldENsYXNzO1xuICAgIHNldENsYXNzOiBTZXRDbGFzcztcbiAgICBzZXRTdHlsZTogU2V0U3R5bGU7XG4gICAgZ2V0QXR0cmlidXRlOiBHZXRBdHRyaWJ1dGU8VD47XG4gICAgc2V0QXR0cmlidXRlOiBTZXRBdHRyaWJ1dGU8VD47XG4gICAgc2V0Q2hpbGRyZW46IFNldENoaWxkcmVuO1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBEYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBkYW5nZXJvdXNseUFwcGVuZEhUTUw6IERhbmdlcm91c2x5QXBwZW5kSFRNTDtcbiAgICBzZXRFdmVudEhhbmRsZXI6IFNldEV2ZW50SGFuZGxlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VJbXBlcmF0aXZlUHJvcHNQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcmVmRWxlbWVudFJldHVybjogUGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBlcmF0aXZlRWxlbWVudFByb3BzPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXA+IGV4dGVuZHMgRWxlbWVudFByb3BzPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4ge1xuICAgIHRhZzogVDtcbiAgICBoYW5kbGU6IFJlZjxJbXBlcmF0aXZlSGFuZGxlPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4+O1xufVxuXG5sZXQgdGVtcGxhdGVFbGVtZW50OiBIVE1MVGVtcGxhdGVFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIGh0bWxUb0VsZW1lbnQocGFyZW50OiBFbGVtZW50LCBodG1sOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICAgIHRlbXBsYXRlRWxlbWVudCA/Pz0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSBodG1sLnRyaW0oKTsgICAvLyBUT0RPOiBUcmltIGVuc3VyZXMgd2hpdGVzcGFjZSBkb2Vzbid0IGFkZCBhbnl0aGluZywgYnV0IHdpdGggYSBiZXR0ZXIgZXhwbGFuYXRpb24gb2Ygd2h5XG4gICAgcmV0dXJuIHRlbXBsYXRlRWxlbWVudC5jb250ZW50LmZpcnN0Q2hpbGQhIGFzIEVsZW1lbnQ7XG59XG5cbi8qKlxuICogRWFzeSBhY2Nlc3MgdG8gYW4gSFRNTEVsZW1lbnQgdGhhdCBjYW4gYmUgY29udHJvbGxlZCBpbXBlcmF0aXZlbHkuXG4gKiBcbiAqIFRoZSBIVE1MRWxlbWVudCByZW5kZXJlZCBpcyBjb250cm9sbGVkIGJ5IHRoZSBgdGFnYCBwcm9wIChlLmcuIFwic3BhblwiLCBcImRpdlwiKS5cbiAqIFxuICogVGhlIGBoYW5kbGVgIHByb3Agc2hvdWxkIGJlIGUuZy4gYHVzZVJlZjxJbXBlcmF0aXZlSGFuZGxlPEhUTUxEaXZFbGVtZW50Pj4obnVsbClgXG4gKi9cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlRWxlbWVudCA9IG1lbW8oZm9yd2FyZFJlZihJbXBlcmF0aXZlRWxlbWVudFUpKSBhcyB0eXBlb2YgSW1wZXJhdGl2ZUVsZW1lbnRVO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCB9IH06IFVzZUltcGVyYXRpdmVQcm9wc1BhcmFtZXRlcnM8RT4pIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUltcGVyYXRpdmVQcm9wcyk7XG5cbiAgICBjb25zdCBjdXJyZW50SW1wZXJhdGl2ZVByb3BzID0gdXNlUmVmPHsgY2xhc3NOYW1lOiBTZXQ8c3RyaW5nPiwgc3R5bGU6IENTU1Byb3BlcnRpZXMsIGNoaWxkcmVuOiBzdHJpbmcgfCBudWxsLCBodG1sOiBzdHJpbmcgfCBudWxsLCBvdGhlcnM6IEVsZW1lbnRQcm9wczxFPiB9Pih7IGNsYXNzTmFtZTogbmV3IFNldCgpLCBzdHlsZToge30sIGNoaWxkcmVuOiBudWxsLCBodG1sOiBudWxsLCBvdGhlcnM6IHt9IH0pO1xuXG5cbiAgICBjb25zdCBoYXNDbGFzcyA9IHVzZUNhbGxiYWNrPEdldENsYXNzPigoY2xzOiBzdHJpbmcpID0+IHsgcmV0dXJuIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jbGFzc05hbWUuaGFzKGNscyk7IH0sIFtdKVxuICAgIGNvbnN0IHNldENsYXNzID0gdXNlQ2FsbGJhY2s8U2V0Q2xhc3M+KChjbHMsIGVuYWJsZWQpID0+IHtcbiAgICAgICAgaWYgKGhhc0NsYXNzKGNscykgPT0gIWVuYWJsZWQpIHtcbiAgICAgICAgICAgIGdldEVsZW1lbnQoKT8uY2xhc3NMaXN0W2VuYWJsZWQgPyBcImFkZFwiIDogXCJyZW1vdmVcIl0oY2xzKTtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jbGFzc05hbWVbZW5hYmxlZCA/IFwiYWRkXCIgOiBcImRlbGV0ZVwiXShjbHMpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0U3R5bGUgPSB1c2VDYWxsYmFjazxTZXRTdHlsZT4oKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAoZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5zdHlsZVtwcm9wXSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcCBhcyBzdHJpbmcpLnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgYCR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWUgPz8gKFwiXCIgYXMgYW55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrPFNldENoaWxkcmVuPigoY2hpbGRyZW46IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgbGV0IGUgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlICYmIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jaGlsZHJlbiAhPSBjaGlsZHJlbikge1xuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuaHRtbCA9IG51bGw7XG4gICAgICAgICAgICBlLnRleHRDb250ZW50ID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBkYW5nZXJvdXNseVNldElubmVySFRNTCA9IHVzZUNhbGxiYWNrPERhbmdlcm91c2x5U2V0SW5uZXJIVE1MPigoY2hpbGRyZW46IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgZSA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGUgJiYgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lmh0bWwgIT0gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5odG1sID0gY2hpbGRyZW47XG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgZS5pbm5lckhUTUwgPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGRhbmdlcm91c2x5QXBwZW5kSFRNTCA9IHVzZUNhbGxiYWNrPERhbmdlcm91c2x5QXBwZW5kSFRNTD4oKGNoaWxkcmVuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGUgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlICYmIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGh0bWxUb0VsZW1lbnQoZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoKG5ld0NoaWxkICYmIG5ld0NoaWxkIGluc3RhbmNlb2YgTm9kZSkpO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkICYmIG5ld0NoaWxkIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbCE7XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBnZXRBdHRyaWJ1dGUgPSB1c2VDYWxsYmFjazxHZXRBdHRyaWJ1dGU8RT4+KChwcm9wKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW3Byb3BdO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldEF0dHJpYnV0ZSA9IHVzZUNhbGxiYWNrPFNldEF0dHJpYnV0ZTxFPj4oKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QXR0cmlidXRlKHByb3ApICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGdldEVsZW1lbnQoKT8uc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGUocHJvcCkgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbcHJvcF07XG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudCgpPy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRFdmVudEhhbmRsZXIgPSB1c2VDYWxsYmFjazxTZXRFdmVudEhhbmRsZXI+KCh0eXBlLCBoYW5kbGVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAoZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBtYXBwZWRLZXkgPSBFdmVudE1hcHBpbmdbdHlwZV0gYXMga2V5b2YgRWxlbWVudFByb3BzPEU+O1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbbWFwcGVkS2V5XSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW21hcHBlZEtleV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbbWFwcGVkS2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZTogdXNlUmVmPEltcGVyYXRpdmVIYW5kbGU8RT4+KHtcbiAgICAgICAgICAgIGhhc0NsYXNzLFxuICAgICAgICAgICAgc2V0Q2xhc3MsXG4gICAgICAgICAgICBzZXRTdHlsZSxcbiAgICAgICAgICAgIGdldEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHNldEV2ZW50SGFuZGxlcixcbiAgICAgICAgICAgIHNldENoaWxkcmVuLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsXG4gICAgICAgICAgICBkYW5nZXJvdXNseUFwcGVuZEhUTUxcbiAgICAgICAgfSkuY3VycmVudCxcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzPEU+KFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IFsuLi5jdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lXS5qb2luKFwiIFwiKSwgc3R5bGU6IGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5zdHlsZSB9LFxuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1xuICAgICAgICApXG5cbiAgICB9XG59XG5cbmZ1bmN0aW9uIEltcGVyYXRpdmVFbGVtZW50VTxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPih7IHRhZzogVGFnLCBoYW5kbGUsIC4uLnByb3BzIH06IFJlbmRlcmFibGVQcm9wczxJbXBlcmF0aXZlRWxlbWVudFByb3BzPFQ+PiwgcmVmOiBSZWY8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPikge1xuICAgIGNvbnN0IHsgcHJvcHNTdGFibGUsIHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuICAgIGNvbnN0IHsgcHJvcHM6IGlwcm9wcywgaW1wZXJhdGl2ZUhhbmRsZSB9ID0gdXNlSW1wZXJhdGl2ZVByb3BzPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4oeyByZWZFbGVtZW50UmV0dXJuIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUoaGFuZGxlLCAoKSA9PiBpbXBlcmF0aXZlSGFuZGxlKTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFnLCB1c2VNZXJnZWRQcm9wcyhwcm9wc1N0YWJsZSwgaXByb3BzLCBwcm9wcywgeyByZWYgfSkpKTtcbn1cblxuXG5jb25zdCBFdmVudE1hcHBpbmc6IFBhcnRpYWw8eyBbSyBpbiBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwXTogKGtleW9mIEpTWC5JbnRyaW5zaWNFbGVtZW50c1tcImRpdlwiXSAmIGBvbiR7c3RyaW5nfWApIH0+ID0ge1xuICAgIGFib3J0OiBcIm9uQWJvcnRcIixcbiAgICBhbmltYXRpb25lbmQ6IFwib25BbmltYXRpb25FbmRcIixcbiAgICBhbmltYXRpb25zdGFydDogXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgYW5pbWF0aW9uaXRlcmF0aW9uOiBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIsXG4gICAgYmVmb3JlaW5wdXQ6IFwib25CZWZvcmVJbnB1dFwiLFxuICAgIGJsdXI6IFwib25CbHVyXCIsXG4gICAgY2FucGxheTogXCJvbkNhblBsYXlcIixcbiAgICBjYW5wbGF5dGhyb3VnaDogXCJvbkNhblBsYXlUaHJvdWdoXCIsXG4gICAgY2hhbmdlOiBcIm9uQ2hhbmdlXCIsXG4gICAgY2xpY2s6IFwib25DbGlja1wiLFxuICAgIGNvbXBvc2l0aW9uZW5kOiBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgICBjb21wb3NpdGlvbnN0YXJ0OiBcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuICAgIGNvbXBvc2l0aW9udXBkYXRlOiBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgICBjb250ZXh0bWVudTogXCJvbkNvbnRleHRNZW51XCIsXG4gICAgY3V0OiBcIm9uQ3V0XCIsXG4gICAgZGJsY2xpY2s6IFwib25EYmxDbGlja1wiLFxuICAgIGRyYWc6IFwib25EcmFnXCIsXG4gICAgZHJhZ2VuZDogXCJvbkRyYWdFbmRcIixcbiAgICBkcmFnZW50ZXI6IFwib25EcmFnRW50ZXJcIixcbiAgICBkcmFnbGVhdmU6IFwib25EcmFnTGVhdmVcIixcbiAgICBkcmFnb3ZlcjogXCJvbkRyYWdPdmVyXCIsXG4gICAgZHJhZ3N0YXJ0OiBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgZHJvcDogXCJvbkRyb3BcIixcbiAgICBkdXJhdGlvbmNoYW5nZTogXCJvbkR1cmF0aW9uQ2hhbmdlXCIsXG4gICAgZW1wdGllZDogXCJvbkVtcHRpZWRcIixcbiAgICBlbmRlZDogXCJvbkVuZGVkXCIsXG4gICAgZXJyb3I6IFwib25FcnJvclwiLFxuICAgIGZvY3VzOiBcIm9uRm9jdXNcIixcbiAgICBmb2N1c2luOiBcIm9uZm9jdXNpblwiLFxuICAgIGZvY3Vzb3V0OiBcIm9uZm9jdXNvdXRcIixcbiAgICBmb3JtZGF0YTogXCJvbkZvcm1EYXRhXCIsXG4gICAgZ290cG9pbnRlcmNhcHR1cmU6IFwib25Hb3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIGlucHV0OiBcIm9uSW5wdXRcIixcbiAgICBpbnZhbGlkOiBcIm9uSW52YWxpZFwiLFxuICAgIGtleWRvd246IFwib25LZXlEb3duXCIsXG4gICAga2V5cHJlc3M6IFwib25LZXlQcmVzc1wiLFxuICAgIGtleXVwOiBcIm9uS2V5VXBcIixcbiAgICBsb2FkOiBcIm9uTG9hZFwiLFxuICAgIGxvYWRlZGRhdGE6IFwib25Mb2FkZWREYXRhXCIsXG4gICAgbG9hZGVkbWV0YWRhdGE6IFwib25Mb2FkZWRNZXRhZGF0YVwiLFxuICAgIGxvYWRzdGFydDogXCJvbkxvYWRTdGFydFwiLFxuICAgIGxvc3Rwb2ludGVyY2FwdHVyZTogXCJvbkxvc3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIG1vdXNlZG93bjogXCJvbk1vdXNlRG93blwiLFxuICAgIG1vdXNlZW50ZXI6IFwib25Nb3VzZUVudGVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJvbk1vdXNlTGVhdmVcIixcbiAgICBtb3VzZW1vdmU6IFwib25Nb3VzZU1vdmVcIixcbiAgICBtb3VzZW91dDogXCJvbk1vdXNlT3V0XCIsXG4gICAgbW91c2VvdmVyOiBcIm9uTW91c2VPdmVyXCIsXG4gICAgbW91c2V1cDogXCJvbk1vdXNlVXBcIixcbiAgICBwYXN0ZTogXCJvblBhc3RlXCIsXG4gICAgcGF1c2U6IFwib25QYXVzZVwiLFxuICAgIHBsYXk6IFwib25QbGF5XCIsXG4gICAgcGxheWluZzogXCJvblBsYXlpbmdcIixcbiAgICBwb2ludGVyY2FuY2VsOiBcIm9uUG9pbnRlckNhbmNlbFwiLFxuICAgIHBvaW50ZXJkb3duOiBcIm9uUG9pbnRlckRvd25cIixcbiAgICBwb2ludGVyZW50ZXI6IFwib25Qb2ludGVyRW50ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwib25Qb2ludGVyTGVhdmVcIixcbiAgICBwb2ludGVybW92ZTogXCJvblBvaW50ZXJNb3ZlXCIsXG4gICAgcG9pbnRlcm91dDogXCJvblBvaW50ZXJPdXRcIixcbiAgICBwb2ludGVyb3ZlcjogXCJvblBvaW50ZXJPdmVyXCIsXG4gICAgcG9pbnRlcnVwOiBcIm9uUG9pbnRlclVwXCIsXG4gICAgcHJvZ3Jlc3M6IFwib25Qcm9ncmVzc1wiLFxuICAgIHJlc2V0OiBcIm9uUmVzZXRcIixcbiAgICBzY3JvbGw6IFwib25TY3JvbGxcIixcbiAgICBzZWVrZWQ6IFwib25TZWVrZWRcIixcbiAgICBzZWVraW5nOiBcIm9uU2Vla2luZ1wiLFxuICAgIHNlbGVjdDogXCJvblNlbGVjdFwiLFxuICAgIHN0YWxsZWQ6IFwib25TdGFsbGVkXCIsXG4gICAgc3VibWl0OiBcIm9uU3VibWl0XCIsXG4gICAgc3VzcGVuZDogXCJvblN1c3BlbmRcIixcbiAgICB0aW1ldXBkYXRlOiBcIm9uVGltZVVwZGF0ZVwiLFxuICAgIHRvZ2dsZTogXCJvblRvZ2dsZVwiLFxuICAgIHRvdWNoY2FuY2VsOiBcIm9uVG91Y2hDYW5jZWxcIixcbiAgICB0b3VjaGVuZDogXCJvblRvdWNoRW5kXCIsXG4gICAgdG91Y2htb3ZlOiBcIm9uVG91Y2hNb3ZlXCIsXG4gICAgdG91Y2hzdGFydDogXCJvblRvdWNoU3RhcnRcIixcbiAgICB0cmFuc2l0aW9uZW5kOiBcIm9uVHJhbnNpdGlvbkVuZFwiLFxuICAgIHZvbHVtZWNoYW5nZTogXCJvblZvbHVtZUNoYW5nZVwiLFxuICAgIHdhaXRpbmc6IFwib25XYWl0aW5nXCIsXG4gICAgd2hlZWw6IFwib25XaGVlbFwiXG59XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG4vKipcbiAqIFdoZW4gYSBidW5jaCBvZiB1bnJlbGF0ZWQgY29tcG9uZW50cyBhbGwgdXNlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLFxuICogeWVzLCB0aGlzIGFjdHVhbGx5IGlzIGZhc3Rlci4gSSB3aXNoIGl0IHdhc24ndC4gSXQncyBsYW1lLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUFuaW1hdGlvbkZyYW1lKTtcbiAgICBcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbnRleHQsIGNyZWF0ZUNvbnRleHQsIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRXhjbHVzaXZlQ29udGV4dFR5cGUsIFN3YXBwYWJsZUNvbnRleHRUeXBlLCBUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2UgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBzdHJpbmcpOiBDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD47XG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBudWxsIHwgdW5kZWZpbmVkKTogbnVsbDtcbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD4gfCBudWxsO1xuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbihleGNsdXNpdml0eUtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPiB8IG51bGwge1xuICAgIGlmIChleGNsdXNpdml0eUtleSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dDxFeGNsdXNpdmVDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xufVxuXG5leHBvcnQgY29uc3QgU3dhcHBhYmxlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8U3dhcHBhYmxlQ29udGV4dFR5cGU+KHsgZ2V0QW5pbWF0ZU9uTW91bnQ6ICgpID0+IGZhbHNlIH0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgZm9yIGEgZ2l2ZW4gYGV4Y2x1c2l2aXR5S2V5YCwgY3JlYXRpbmcgb25lIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqIFxuICogSWYgXG4gKi9cbmV4cG9ydCBjb25zdCBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dDogdHlwZW9mIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24gPSBtZW1vaXplKGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24pO1xuXG5pbnRlcmZhY2UgQ3NzQ2xhc3Nlc1Byb3ZpZGVyUHJvcHMge1xuICAgIGJhc2U6IHN0cmluZztcbiAgICBlbnRlcjogc3RyaW5nO1xuICAgIGV4aXQ6IHN0cmluZztcbiAgICBtZWFzdXJlOiBzdHJpbmc7XG4gICAgaW5pdDogc3RyaW5nO1xuICAgIHRyYW5zaXRpb246IHN0cmluZztcbiAgICBmaW5hbGl6ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ3NzQ2xhc3NDb250ZXh0VHlwZSB7XG4gICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RW50ZXJDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEV4aXRDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldE1lYXN1cmVDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEluaXRDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldFRyYW5zaXRpb25DbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEZpbmFsaXplQ2xhc3M6ICgpID0+IHN0cmluZztcbn1cblxuY29uc3QgQ3NzQ2xhc3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDc3NDbGFzc0NvbnRleHRUeXBlPih7XG4gICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBcInB0bFwiLFxuICAgIEdldEVudGVyQ2xhc3M6ICgpID0+IFwiblwiLFxuICAgIEdldEV4aXRDbGFzczogKCkgPT4gXCJ4XCIsXG4gICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBcIm1cIixcbiAgICBHZXRJbml0Q2xhc3M6ICgpID0+IFwiaVwiLFxuICAgIEdldFRyYW5zaXRpb25DbGFzczogKCkgPT4gXCJ0XCIsXG4gICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gXCJmXCIsXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gQ3NzQ2xhc3Nlc1Byb3ZpZGVyKHsgYmFzZSwgZW50ZXIsIGV4aXQsIG1lYXN1cmUsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplLCBjaGlsZHJlbiwgLi4ucmVzdCB9OiBSZW5kZXJhYmxlUHJvcHM8UGFydGlhbDxDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcz4+KSB7XG4gICAgY29uc3QgY29udGV4dE9iamVjdCA9IHVzZUNzc0NsYXNzQ29udGV4dFZhbHVlKHsgYmFzZSwgZW50ZXIsIGV4aXQsIG1lYXN1cmUsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplIH0pO1xuICAgIHJldHVybiAoPENzc0NsYXNzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dE9iamVjdH0gIHsuLi5yZXN0fSBjaGlsZHJlbj17Y2hpbGRyZW59IC8+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3NzQ2xhc3NlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIEdldEJhc2VDbGFzcyxcbiAgICAgICAgR2V0RW50ZXJDbGFzcyxcbiAgICAgICAgR2V0RXhpdENsYXNzLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3MsXG4gICAgICAgIEdldEluaXRDbGFzcyxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzXG4gICAgfSA9IHVzZUNvbnRleHQoQ3NzQ2xhc3NDb250ZXh0KTtcbiAgICBjb25zdCBHZXREaXJlY3Rpb25DbGFzcyA9IHVzZUNhbGxiYWNrKChkaXJlY3Rpb246IFRyYW5zaXRpb25EaXJlY3Rpb24pOiBzdHJpbmcgPT4geyBzd2l0Y2ggKGRpcmVjdGlvbikgeyBjYXNlIFwiZW50ZXJcIjogcmV0dXJuIEdldEVudGVyQ2xhc3MoKTsgY2FzZSBcImV4aXRcIjogcmV0dXJuIEdldEV4aXRDbGFzcygpOyB9IH0sIFtdKTtcbiAgICBjb25zdCBHZXRQaGFzZUNsYXNzID0gdXNlQ2FsbGJhY2soKHBoYXNlOiBUcmFuc2l0aW9uUGhhc2UpOiBzdHJpbmcgPT4geyBzd2l0Y2ggKHBoYXNlKSB7IGNhc2UgXCJtZWFzdXJlXCI6IHJldHVybiBHZXRNZWFzdXJlQ2xhc3MoKTsgY2FzZSBcImluaXRcIjogcmV0dXJuIEdldEluaXRDbGFzcygpOyBjYXNlIFwidHJhbnNpdGlvblwiOiByZXR1cm4gR2V0VHJhbnNpdGlvbkNsYXNzKCk7IGNhc2UgXCJmaW5hbGl6ZVwiOiByZXR1cm4gR2V0RmluYWxpemVDbGFzcygpOyB9IH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBHZXRCYXNlQ2xhc3MsXG4gICAgICAgIEdldEVudGVyQ2xhc3MsXG4gICAgICAgIEdldEV4aXRDbGFzcyxcbiAgICAgICAgR2V0TWVhc3VyZUNsYXNzLFxuICAgICAgICBHZXRJbml0Q2xhc3MsXG4gICAgICAgIEdldFRyYW5zaXRpb25DbGFzcyxcbiAgICAgICAgR2V0RmluYWxpemVDbGFzcyxcbiAgICAgICAgR2V0RGlyZWN0aW9uQ2xhc3MsXG4gICAgICAgIEdldFBoYXNlQ2xhc3NcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc0NsYXNzQ29udGV4dFZhbHVlKG5ld1ZhbHVlczogUGFydGlhbDxDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcz4pOiBDc3NDbGFzc0NvbnRleHRUeXBlIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB1c2VDb250ZXh0KENzc0NsYXNzQ29udGV4dCk7XG4gICAgY29uc3QgYmFzZSA9IChuZXdWYWx1ZXM/LmJhc2UgPz8gb2xkVmFsdWVzLkdldEJhc2VDbGFzcygpKTtcbiAgICBjb25zdCBlbnRlciA9IChuZXdWYWx1ZXM/LmVudGVyID8/IG9sZFZhbHVlcy5HZXRFbnRlckNsYXNzKCkpO1xuICAgIGNvbnN0IGV4aXQgPSAobmV3VmFsdWVzPy5leGl0ID8/IG9sZFZhbHVlcy5HZXRFeGl0Q2xhc3MoKSk7XG4gICAgY29uc3QgbWVhc3VyZSA9IChuZXdWYWx1ZXM/Lm1lYXN1cmUgPz8gb2xkVmFsdWVzLkdldE1lYXN1cmVDbGFzcygpKTtcbiAgICBjb25zdCBpbml0ID0gKG5ld1ZhbHVlcz8uaW5pdCA/PyBvbGRWYWx1ZXMuR2V0SW5pdENsYXNzKCkpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSAobmV3VmFsdWVzPy50cmFuc2l0aW9uID8/IG9sZFZhbHVlcy5HZXRUcmFuc2l0aW9uQ2xhc3MoKSk7XG4gICAgY29uc3QgZmluYWxpemUgPSAobmV3VmFsdWVzPy5maW5hbGl6ZSA/PyBvbGRWYWx1ZXMuR2V0RmluYWxpemVDbGFzcygpKTtcblxuICAgIHJldHVybiB1c2VNZW1vPENzc0NsYXNzQ29udGV4dFR5cGU+KCgpID0+ICh7XG4gICAgICAgIEdldEJhc2VDbGFzczogKCkgPT4gYmFzZSEsXG4gICAgICAgIEdldEVudGVyQ2xhc3M6ICgpID0+IGVudGVyISxcbiAgICAgICAgR2V0RXhpdENsYXNzOiAoKSA9PiBleGl0ISxcbiAgICAgICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBtZWFzdXJlISxcbiAgICAgICAgR2V0SW5pdENsYXNzOiAoKSA9PiBpbml0ISxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiB0cmFuc2l0aW9uISxcbiAgICAgICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gZmluYWxpemUhLFxuICAgIH0pLCBbYmFzZSwgZW50ZXIsIGV4aXQsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplXSlcbn1cblxuIiwiaW1wb3J0IHsgRnJhZ21lbnQsIGgsIFJlbmRlcmFibGVQcm9wcywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDaGlsZHJlbkZsYWcsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlT2JqZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IEV4Y2x1c2l2ZUNvbnRleHRUeXBlLCBFeGNsdXNpdmVJbmZvLCBPbWl0U3Ryb25nLCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5cblxuXG5sZXQgZ2xvYmFsQ291bnQgPSAtMTtcblxuZXhwb3J0IGZ1bmN0aW9uIEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcih7IGV4Y2x1c2l2aXR5S2V5LCBjaGlsZHJlbiB9OiBSZW5kZXJhYmxlUHJvcHM8eyBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgfT4pIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXJcIiwgZXhjbHVzaXZpdHlLZXkpO1xuXG4gICAgY29uc3QgW2dldE5leHRJbmRleEluTGluZSwgc2V0TmV4dEluZGV4SW5MaW5lXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcgfCBudWxsLCBuZXZlcj4obnVsbCk7XG5cbiAgICBjb25zdCB7IGNvbnRleHQsIG1hbmFnZWRDaGlsZHJlblJldHVybiwgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxFeGNsdXNpdmVJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIGdldEN1cnJlbnRJbmRleCB9ID0gdXNlQ2hpbGRyZW5GbGFnPEV4Y2x1c2l2ZUluZm8sIG5ldmVyPih7XG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbEluZGV4OiBudWxsLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiBudWxsLFxuICAgICAgICBzZXRBdDogdXNlQ2FsbGJhY2soKG0sIHYpID0+IHsgbS5zZXRFeGNsdXNpdmVseU9wZW4odik7IH0sIFtdKSxcbiAgICAgICAgZ2V0QXQ6IHVzZUNhbGxiYWNrKChtKSA9PiBtLmdldEV4Y2x1c2l2ZWx5T3BlbigpLCBbXSksXG4gICAgICAgIGlzVmFsaWQ6IHVzZUNhbGxiYWNrKChtKSA9PiB7IHJldHVybiB0cnVlIH0sIFtdKSxcbiAgICB9KVxuXG4gICAgY29uc3Qgb25WaXNpYmlsaXR5Q2hhbmdlID0gdXNlQ2FsbGJhY2soKGluZGV4OiBzdHJpbmcsIHZpc2libGU6IFwic2hvd1wiIHwgXCJoaWRkZW5cIikgPT4ge1xuICAgICAgICBjb25zdCBuZXh0SW5MaW5lID0gZ2V0TmV4dEluZGV4SW5MaW5lKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbkxpbmUgPSBnZXRDdXJyZW50SW5kZXgoKTtcblxuICAgICAgICBpZiAodmlzaWJsZSA9PSBcInNob3dcIiAmJiBpbmRleCAhPSBjdXJyZW50SW5MaW5lKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBjaGlsZCB0cmFuc2l0aW9uIHNob3dzIGl0c2VsZiBpbml0aWFsbHlcbiAgICAgICAgICAgICAqIChpLmUuIHJlcXVlc3RzIGl0c2VsZiB0byBiZSB0aGUgZXhjbHVzaXZlIHRyYW5zaXRpb24pXG4gICAgICAgICAgICAgKiB3ZSBlaXRoZXIgbGV0IGl0IG9wZW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUncyBubyBvbmUgZmluaXNoaW5nIHRoZWlyIGV4aXQsXG4gICAgICAgICAgICAgKiBvciB3YWl0IHVudGlsIHRoYXQgYWZvcmVtZW50aW9uZWQgZXhpdCBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5MaW5lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlbigpLmdldEF0KGN1cnJlbnRJbkxpbmUpPy5mb3JjZUNsb3NlPy4oKTtcbiAgICAgICAgICAgICAgICBzZXROZXh0SW5kZXhJbkxpbmUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpc2libGUgPT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIGEgY2hpbGQgdHJhbnNpdGlvbiBoYXMgZmluaXNoZWQgaXRzIGV4aXQgdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAqIG1ha2Ugc3VyZSB0aGF0IGlmIHNvbWVvbmUgcmVxdWVzdGVkIHRvIGJlIHNob3duIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICogdGhhdCB3ZSBkbyBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG5leHRJbkxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4KG5leHRJbkxpbmUpO1xuICAgICAgICAgICAgICAgIHNldE5leHRJbmRleEluTGluZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb250ZXh0MjogRXhjbHVzaXZlQ29udGV4dFR5cGUgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIGV4Y2x1c2l2aXR5S2V5LFxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgY29uc3QgRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgPSBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dChleGNsdXNpdml0eUtleSk7XG5cbiAgICByZXR1cm4gKEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0ID09IG51bGwpID8gKChjaGlsZHJlbiBhcyBWTm9kZSkgPz8gbnVsbCkgOiA8RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHQyfT57Y2hpbGRyZW59PC9FeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlcj47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgT21pdFN0cm9uZzxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEV4Y2x1c2l2ZUluZm8+LCBcImluZm9cIiB8IFwiY29udGV4dFwiPiB7XG4gICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IFBpY2s8VHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPGFueT4sIFwic2hvd1wiPjtcbiAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBmb3JjZUNsb3NlOiAoKSA9PiB2b2lkOyBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24oeyB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBzaG93IH0sIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGZvcmNlQ2xvc2UsIGV4Y2x1c2l2aXR5S2V5IH0gfTogVXNlRXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjID0gR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQoZXhjbHVzaXZpdHlLZXkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25cIiwgYyA9PSBudWxsKTtcbiAgICBjb25zdCBjb250ZXh0ID0gYz8gdXNlQ29udGV4dChjKSA6IG51bGw7XG5cbiAgICBjb25zdCBpbmRleCA9IHVzZU1lbW8oKCkgPT4geyBnbG9iYWxDb3VudCArPSAxOyByZXR1cm4gKGdsb2JhbENvdW50KS50b1N0cmluZygpIH0sIFtdKTtcbiAgICBjb25zdCBbZXhjbHVzaXZlbHlPcGVuLCBzZXRFeGNsdXNpdmVseU9wZW4sIGdldEV4Y2x1c2l2ZWx5T3Blbl0gPSB1c2VTdGF0ZTxib29sZWFuPighIXNob3cpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9ID0gdXNlTWFuYWdlZENoaWxkPEV4Y2x1c2l2ZUluZm8+KHsgY29udGV4dCwgaW5mbzogeyBpbmRleCwgZ2V0RXhjbHVzaXZlbHlPcGVuLCBzZXRFeGNsdXNpdmVseU9wZW4sIGZvcmNlQ2xvc2UgfSB9KTtcblxuICAgIGNvbnN0IHBhcmVudE9uVmlzQ2hhbmdlID0gY29udGV4dD8uZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQub25WaXNpYmlsaXR5Q2hhbmdlO1xuXG4gICAgY29uc3Qgb25WaXNpYmlsaXR5Q2hhbmdlID0gdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPGFueT5bXCJvblZpc2liaWxpdHlDaGFuZ2VcIl0+PigodmlzaWJsZSkgPT4ge1xuICAgICAgICBwYXJlbnRPblZpc0NoYW5nZT8uKGluZGV4LCB2aXNpYmxlID09IGZhbHNlID8gXCJoaWRkZW5cIiA6IFwic2hvd1wiKTtcbiAgICB9LCBbcGFyZW50T25WaXNDaGFuZ2UsIGluZGV4XSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdylcbiAgICAgICAgICAgIHBhcmVudE9uVmlzQ2hhbmdlPy4oaW5kZXgsIFwic2hvd1wiKTtcbiAgICB9LCBbc2hvdywgcGFyZW50T25WaXNDaGFuZ2UsIGluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBpc0V4Y2x1c2l2ZTogKGNvbnRleHQgIT0gbnVsbCksXG4gICAgICAgICAgICBleGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBzZXRFeGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBnZXRFeGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuIiwiXHJcbmltcG9ydCB7IEZ1bmN0aW9uYWxDb21wb25lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbnR5cGUgRm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+ID0gT21pdDxQLCBcInJlZlwiPiAmIHsgcmVmPzogUmVmPEU+IH1cclxudHlwZSBGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50PFAsIEU+ID0gKHA6IEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnRQcm9wczxQLCBFPikgPT4gVk5vZGU8Rm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+PlxyXG5cclxudHlwZSBFbGVtZW50RnJvbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxpbmZlciBFPiA/IEUgOiBFdmVudFRhcmdldDtcclxudHlwZSBQcm9wc0Zyb21Db21wb25lbnQ8QyBleHRlbmRzIEZ1bmN0aW9uYWxDb21wb25lbnQ8YW55Pj4gPSBDIGV4dGVuZHMgRnVuY3Rpb25hbENvbXBvbmVudDxpbmZlciBQPiA/IFAgOiB1bmtub3duO1xyXG5cclxuLyoqXHJcbiAqIFNob3J0Y3V0IGZvciBwcmVhY3QvY29tcGF0J3MgYGZvcndhcmRSZWZgIHRoYXQgYXV0by1hc3N1bWVzIHNvbWUgdGhpbmdzIHRoYXQgYXJlIHVzZWZ1bCBmb3IgZm9yd2FyZGluZyByZWZzIHRvIGBIVE1MRWxlbWVudHNgIHNwZWNpZmljYWxseS5cclxuICogTmFtZWx5IGl0IGludm9sdmVzIGRlLWd1bmtpbmcgdGhlIHR5cGUgc3lzdGVtIGJ5IGxldHRpbmcgdXMgcmV0dXJuICpnZW5lcmljKiBmdW5jdGlvbiBhbmQgcGxheWluZyBuaWNlIHdpdGggUmVhY3QuIEluIGFsbCBvdGhlciByZXNwZWN0cywgaXQgYWN0cyBsaWtlIGBmb3J3YXJkUmVmYC5cclxuICogXHJcbiAqIFRPRE86IFN0aWxsIG5lZWRlZD9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkRWxlbWVudFJlZjxDIGV4dGVuZHMgPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4ocDogYW55LCByZWY6IFJlZjxFPikgPT4gKFZOb2RlPGFueT4gfCBudWxsKT4oQ29tcG9uZW50OiBDKSB7XHJcbiAgICB0eXBlIFAgPSBQcm9wc0Zyb21Db21wb25lbnQ8Qz47XHJcblxyXG5cclxuICAgIGNvbnN0IEZvcndhcmRlZENvbXBvbmVudCA9IGZvcndhcmRSZWYoQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBGb3J3YXJkZWRDb21wb25lbnQgYXMgQztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWZ1bCBpbiBwYXJ0aWN1bGFyIGZvciBTbGlkZXMgd2l0aCBhIFRhYiBQYW5lbCAtLVxyXG4gKiBpZiB3ZSBkbyBNYXRoLnNpZ24oY3VycmVudEluZGV4IC0gc2xpZGVJbmRleCksIGl0XHJcbiAqIHRyYW5zaXRpb25zIG5pY2VseSBpbiB0aGUgZXhwZWN0ZWQgZGlyZWN0aW9uLFxyXG4gKiBidXQgd2UgbmVlZCB0byBcInJlbWVtYmVyXCIgd2hpY2ggZGlyZWN0aW9uIHRvIHVzZVxyXG4gKiB3aGVuIGl0J3MgdGhlIGN1cnJlbnQgcGFuZWwgKGFuZCB0aGUgZGlmZmVyZW5jZSBpcyAwKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhc3ROb25OdWxsVmFsdWU8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogVCB8IG51bGwge1xyXG4gICAgY29uc3QgbGFzdE5vbk51bGxWYWx1ZSA9IHVzZVJlZjxUIHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICBsYXN0Tm9uTnVsbFZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcclxuICAgIH0sIFt2YWx1ZV0pO1xyXG5cclxuICAgIHJldHVybiB2YWx1ZSA/PyBsYXN0Tm9uTnVsbFZhbHVlLmN1cnJlbnQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNsb25lRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIgfSBmcm9tIFwiLi9leGNsdXNpdmUuanNcIjtcclxuaW1wb3J0IHsgU3dhcHBhYmxlQ29udGV4dCwgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBOb25JbnRydXNpdmVFbGVtZW50QXR0cmlidXRlcyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3dhcFByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsPENyZWF0ZVN3YXBwYWJsZVByb3BzPiwgTm9uSW50cnVzaXZlRWxlbWVudEF0dHJpYnV0ZXM8RT4ge1xyXG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgZWFjaCBjaGlsZCB0cmFuc2l0aW9ucyBpbi9vdXQgYXQgdGhlIHNhbWUgdGltZSwgaW4gc3luYyB3aXRoIGVhY2ggb3RoZXIuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHlvdSB3YW50IHRvIGd1YXJhbnRlZSB0aGF0LCBubyBtYXR0ZXIgd2hhdCwgb25seSBvbmUgaXMgZXZlciB2aXNpYmxlIGF0IGFsbCxcclxuICAgICAqIHBhc3MgYSBzdHJpbmcgdG8gYGV4Y2x1c2l2aXR5S2V5YCwgYW5kIGFsbCB0cmFuc2l0aW9ucyB0aGF0IHVzZSB0aGF0IHNhbWVcclxuICAgICAqIGBleGNsdXNpdml0eUtleWAgd2lsbCBjb29yZGluYXRlIHRoaXMgYmVoYXZpb3IgYW1vbmcgdGhlbXNlbHZlcy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHNvIGF2YWlsYWJsZSBhcyBhIHNlcGFyYXRlIGNvbXBvbmVudCAoYEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcmApXHJcbiAgICAgKiBpZiB5b3UgbmVlZCB0aGlzIGJlaGF2aW9yIGluIHVucmVsYXRlZCBjaXJjdW1zdGFuY2VzLlxyXG4gICAgICovXHJcbiAgICBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU3dhcHBhYmxlUHJvcHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgY29tcG9uZW50IGlzIGlubGluZS1ncmlkIG9yIGdyaWQuIFxyXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgY2hpbGQgZWxlbWVudCBpcyBsb29rZWQgYXQuIElmIGl0J3MgYSBzcGFuIG9yIG90aGVyIGlubGluZSBlbGVtZW50LCBpbmxpbmUgaXMgYXNzdW1lZC4gXHJcbiAgICAgKiAoQSBzaW1wbHktZm9vbGVkIGhldXJpc3RpYy0tcHJvdmlkZSB0aGlzIHByb3AgaWYgbmVjZXNzYXJ5KVxyXG4gICAgICovXHJcbiAgICBpbmxpbmU6IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgZGVmYXVsdCB2YWx1ZXMgdG8gYHVzZVRyYW5zaXRpb25gJ3MgYGFuaW1hdGVPbk1vdW50YC4gSWYgbnVsbCwgdGhlIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSwgdGhlbiBgdHJ1ZWAgYWZ0ZXIgdGhlIGBTd2FwcGFibGVgIGl0c2VsZiBoYXMgbW91bnRlZC5cclxuICAgICAqL1xyXG4gICAgY2hpbGRyZW5BbmltYXRlT25Nb3VudD86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIHN3YXAgY29udGFpbmVyLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZVN3YXBwYWJsZVByb3BzPFAgZXh0ZW5kcyB7fT4oeyBpbmxpbmUgfTogQ3JlYXRlU3dhcHBhYmxlUHJvcHMsIG90aGVyUHJvcHM6IFApIHtcclxuICAgIHR5cGUgRSA9IFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxpbmZlciBFPiA/IEUgOiBIVE1MRWxlbWVudDtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtHZXRCYXNlQ2xhc3MoKX0tc3dhcC1jb250YWluZXJgLCBpbmxpbmUgJiYgYCR7R2V0QmFzZUNsYXNzKCl9LXN3YXAtY29udGFpbmVyLWlubGluZWApXHJcbiAgICB9LCBvdGhlclByb3BzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhIHNldCBvZiBjaGlsZCA8VHJhbnNpdGlvbmFibGU+IGNvbXBvbmVudHMgdG8gYW5pbWF0ZSBpbiAmIG91dCBpbi1wbGFjZS4gVmVyeSB1c2VmdWwgZm9yLCBlLmcuLCB0YWIgcGFuZWxzLlxyXG4gKiBcclxuICogWW91IG11c3QgbWFuYWdlIGVhY2ggY2hpbGQgYDxUcmFuc2l0aW9uYWJsZT5gIGNvbXBvbmVudCdzIGBzaG93YCBwcm9wIC0tIHRoaXMgY29tcG9uZW50ICpkb2VzIG5vdCogbWFuYWdlIGFueSBzb3J0IG9mIHN0YXRlIGluIHRoYXQgcmVnYXJkLlxyXG4gKiBcclxuICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGVsZW1lbnQgKGxpa2UgYSBkaXYpIG9yIG90aGVyIHNpbmdsZSBjb21wb25lbnQsIHRoZW4gdGhlZSBwcm9wcyBhbmQgcmVmIHdpbGwgYmUgZm9yd2FyZGVkIG9udG8gdGhhdCBlbGVtZW50LiBPdGhlcndpc2UsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBiZSB3cmFwcGVkIGluIGEgZGl2IG9yIHNwYW4gZGVwZW5kaW5nIG9uIHRoZSBgaW5saW5lYCBwcm9wLlxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTd2FwcGFibGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFN3YXBwYWJsZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hpbGRyZW46IGMsIGlubGluZSwgY2hpbGRyZW5BbmltYXRlT25Nb3VudCwgZXhjbHVzaXZpdHlLZXksIC4uLnAgfTogU3dhcFByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgbGV0IGNoaWxkcmVuID0gYyBhcyBWTm9kZTtcclxuICAgIGlmICghKGNoaWxkcmVuIGFzIFZOb2RlKS50eXBlKVxyXG4gICAgICAgIGNoaWxkcmVuID0gKCFpbmxpbmUgPyA8ZGl2PntjaGlsZHJlbn08L2Rpdj4gOiA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPilcclxuICAgIGlubGluZSA/Pz0gdHlwZW9mIGNoaWxkcmVuLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgaW5saW5lRWxlbWVudHMuaGFzKGNoaWxkcmVuLnR5cGUpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHVzZUNyZWF0ZVN3YXBwYWJsZVByb3BzKHsgaW5saW5lIH0sIHsgLi4ucCwgcmVmIH0pO1xyXG4gICAgY29uc3QgbWVyZ2VkV2l0aENoaWxkcmVuID0gdXNlTWVyZ2VkUHJvcHM8RT4odHJhbnNpdGlvblByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XHJcblxyXG4gICAgY29uc3QgYW5pbWF0ZU9uTW91bnQgPSB1c2VSZWYoY2hpbGRyZW5BbmltYXRlT25Nb3VudCA/PyBmYWxzZSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGFuaW1hdGVPbk1vdW50LmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgfSwgW10pXHJcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VSZWYoeyBnZXRBbmltYXRlT25Nb3VudDogKCkgPT4geyByZXR1cm4gYW5pbWF0ZU9uTW91bnQuY3VycmVudDsgfSB9KTtcclxuICAgIGxldCByZXQgPSBjbG9uZUVsZW1lbnQoY2hpbGRyZW4sIG1lcmdlZFdpdGhDaGlsZHJlbiBhcyB0eXBlb2YgdHJhbnNpdGlvblByb3BzKTtcclxuICAgIHJldCA9ICg8U3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlLmN1cnJlbnR9PntyZXR9PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPilcclxuICAgIGlmIChleGNsdXNpdml0eUtleSkge1xyXG4gICAgICAgIHJldCA9ICg8RXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyIGtleT17ZXhjbHVzaXZpdHlLZXl9IGV4Y2x1c2l2aXR5S2V5PXtleGNsdXNpdml0eUtleX0+e3JldH08L0V4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcj4pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59KSlcclxuXHJcbi8vIElmIFwiaW5saW5lXCIgaXNuJ3QgZXhwbGljaXRseSBwcm92aWRlZCwgd2UgdHJ5IHRvIGltcGxpY2l0bHkgZG8gaXQgYmFzZWQgb24gdGhlIGNoaWxkJ3MgdGFnLlxyXG4vLyBOb3QgcGVyZmVjdCwgYnV0IGl0J3Mgbm90IHN1cHBvc2VkIHRvIGJlLiBgaW5saW5lYCBpcyBmb3IgcGVyZmVjdC5cclxuY29uc3QgaW5saW5lRWxlbWVudHMgPSBuZXcgU2V0KFtcclxuICAgIFwiYVwiLFxyXG4gICAgXCJhYmJyXCIsXHJcbiAgICBcImFjcm9ueW1cIixcclxuICAgIFwiYXVkaW9cIixcclxuICAgIFwiYlwiLFxyXG4gICAgXCJiZGlcIixcclxuICAgIFwiYmRvXCIsXHJcbiAgICBcImJpZ1wiLFxyXG4gICAgXCJiclwiLFxyXG4gICAgXCJidXR0b25cIixcclxuICAgIFwiY2FudmFzXCIsXHJcbiAgICBcImNpdGVcIixcclxuICAgIFwiY29kZVwiLFxyXG4gICAgXCJkYXRhXCIsXHJcbiAgICBcImRhdGFsaXN0XCIsXHJcbiAgICBcImRlbFwiLFxyXG4gICAgXCJkZm5cIixcclxuICAgIFwiZW1cIixcclxuICAgIFwiZW1iZWRcIixcclxuICAgIFwiaVwiLFxyXG4gICAgXCJpZnJhbWVcIixcclxuICAgIFwiaW1nXCIsXHJcbiAgICBcImlucHV0XCIsXHJcbiAgICBcImluc1wiLFxyXG4gICAgXCJrYmRcIixcclxuICAgIFwibGFiZWxcIixcclxuICAgIFwibWFwXCIsXHJcbiAgICBcIm1hcmtcIixcclxuICAgIFwibWV0ZXJcIixcclxuICAgIFwibm9zY3JpcHRcIixcclxuICAgIFwib2JqZWN0XCIsXHJcbiAgICBcIm91dHB1dFwiLFxyXG4gICAgXCJwaWN0dXJlXCIsXHJcbiAgICBcInByb2dyZXNzXCIsXHJcbiAgICBcInFcIixcclxuICAgIFwicnVieVwiLFxyXG4gICAgXCJzXCIsXHJcbiAgICBcInNhbXBcIixcclxuICAgIFwic2NyaXB0XCIsXHJcbiAgICBcInNlbGVjdFwiLFxyXG4gICAgXCJzbG90XCIsXHJcbiAgICBcInNtYWxsXCIsXHJcbiAgICBcInNwYW5cIixcclxuICAgIFwic3Ryb25nXCIsXHJcbiAgICBcInN1YlwiLFxyXG4gICAgXCJzdXBcIixcclxuICAgIFwic3ZnXCIsXHJcbiAgICBcInRlbXBsYXRlXCIsXHJcbiAgICBcInRleHRhcmVhXCIsXHJcbiAgICBcInRpbWVcIixcclxuICAgIFwidVwiLFxyXG4gICAgXCJ0dFwiLFxyXG4gICAgXCJ2YXJcIixcclxuICAgIFwidmlkZW9cIixcclxuICAgIFwid2JyXCJcclxuXSk7XHJcbiIsImltcG9ydCB7IGNsb25lRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHJldHVybkZhbHNlLCBydW5JbW1lZGlhdGVseSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9leGNsdXNpdmUuanNcIjtcbmltcG9ydCB7IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0LCB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0VHlwZSwgVHJhbnNpdGlvbkRpcmVjdGlvbiwgVHJhbnNpdGlvblBoYXNlLCBUcmFuc2l0aW9uU3RhdGUsIFVzZVRyYW5zaXRpb25QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgU3dhcHBhYmxlQ29udGV4dCB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuXG5cbmZ1bmN0aW9uIGdldFRpbWVvdXREdXJhdGlvbjxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KGVsZW1lbnQ6IEUgfCBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoYHRyYW5zaXRpb24tZHVyYXRpb25gKSkuc3BsaXQoXCIsXCIpLm1hcChzdHIgPT4ge1xuICAgICAgICBpZiAoc3RyLmVuZHNXaXRoKFwibXNcIikpXG4gICAgICAgICAgICByZXR1cm4gK3N0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICBpZiAoc3RyLmVuZHNXaXRoKFwic1wiKSlcbiAgICAgICAgICAgIHJldHVybiAoK3N0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiAxMDAwO1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGF0ZShuZXh0U3RhdGU6IFRyYW5zaXRpb25TdGF0ZSkge1xuICAgIHJldHVybiBuZXh0U3RhdGUuc3BsaXQoXCItXCIpIGFzIFtUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2VdO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgcHJvcHMgdGhhdCBjYW4gYmUgdXNlZCB0byBhbmltYXRlIGEgdHJhbnNpdGlvbi5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhbnNpdGlvbjxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgcHJvcHNJbmNvbWluZzogeyBjaGlsZHJlbiwgLi4ucCB9LCBzaG93LCBhbmltYXRlT25Nb3VudCwgbWVhc3VyZSwgZXhpdFZpc2liaWxpdHksIGR1cmF0aW9uLCBkZWxheU1vdW50VW50aWxTaG93biwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBvblZpc2liaWxpdHlDaGFuZ2UgfSwgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfSB9OiBVc2VUcmFuc2l0aW9uUGFyYW1ldGVyczxFPik6IFZOb2RlPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+PiB8IG51bGwge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVRyYW5zaXRpb25cIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcblxuICAgIGNvbnN0IHsgZ2V0QW5pbWF0ZU9uTW91bnQgfSA9IHVzZUNvbnRleHQoU3dhcHBhYmxlQ29udGV4dCk7XG4gICAgZXhpdFZpc2liaWxpdHkgfHw9IFwiaGlkZGVuXCJcbiAgICBhbmltYXRlT25Nb3VudCA/Pz0gZ2V0QW5pbWF0ZU9uTW91bnQoKTtcbiAgICBtZWFzdXJlID8/PSBmYWxzZTtcblxuICAgIGNvbnN0IGdldEV4aXRWaXNpYmlsaXR5ID0gdXNlU3RhYmxlR2V0dGVyKGV4aXRWaXNpYmlsaXR5KTtcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcywgR2V0RW50ZXJDbGFzcywgR2V0RXhpdENsYXNzLCBHZXRNZWFzdXJlQ2xhc3MsIEdldEluaXRDbGFzcywgR2V0VHJhbnNpdGlvbkNsYXNzLCBHZXRGaW5hbGl6ZUNsYXNzLCBHZXREaXJlY3Rpb25DbGFzcywgR2V0UGhhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xuICAgIGNvbnN0IGdldE1lYXN1cmUgPSB1c2VTdGFibGVHZXR0ZXIobWVhc3VyZSk7XG4gICAgY29uc3QgeyBleGNsdXNpdmVUcmFuc2l0aW9uUmV0dXJuOiB7IGV4Y2x1c2l2ZWx5T3BlbiwgaXNFeGNsdXNpdmUsIG9uVmlzaWJpbGl0eUNoYW5nZTogZXhjbHVzaXZlVHJhbnNpdGlvblZpc2liaWxpdHlDaGFuZ2UgfSB9ID0gdXNlRXhjbHVzaXZlVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IHNob3cgfSxcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXksIGZvcmNlQ2xvc2U6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgaW50ZXJuYWxPblNob3dDaGFuZ2VkKGZhbHNlLCBnZXRNZWFzdXJlKCkpOyB9KSB9XG4gICAgfSk7XG5cbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcbiAgICAgICAgc2hvdyA9IChzaG93ICYmIGV4Y2x1c2l2ZWx5T3Blbik7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSwgcHJvcHNTdGFibGUgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pXG4gICAgY29uc3QgY3NzUHJvcGVydGllcyA9IHVzZVJlZjxoLkpTWC5DU1NQcm9wZXJ0aWVzPih7fSk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oW1xuICAgICAgICAvLyBUaGlzIGlzIHJlbW92ZWQgZHVyaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgZmlyc3QgcmVuZGVyXG4gICAgICAgIC8vIChhdCBsZWFzdCBvbmNlIGBzaG93YCBpcyBub24tbnVsbClcbiAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LXBlbmRpbmdgLFxuICAgIF0pKTtcbiAgICBjb25zdCBoYW5kbGVUcmFuc2l0aW9uRmluaXNoZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoISFzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgW2RpcmVjdGlvbiwgcGhhc2VdID0gcGFyc2VTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICBpZiAocGhhc2UgPT0gXCJ0cmFuc2l0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShgJHtkaXJlY3Rpb259LWZpbmFsaXplYCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRIYW5kbGUuY3VycmVudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudD8uKHRpbWVvdXRIYW5kbGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUuY3VycmVudCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuICAgIGNvbnN0IG90aGVyUHJvcHMgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHtcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kOiAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IGdldEVsZW1lbnQoKSAmJiBlLmVsYXBzZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgaGFzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50J3MgQ1NTIGNsYXNzIHRvIG1hdGNoIHRoZSBnaXZlbiBkaXJlY3Rpb24gYW5kIHBoYXNlLlxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZUNsYXNzZXMgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIGRpcmVjdGlvbjogVHJhbnNpdGlvbkRpcmVjdGlvbiwgcGhhc2U/OiBUcmFuc2l0aW9uUGhhc2UpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuXG4gICAgICAgIGNvbnN0IGV4aXRWaXNpYmlsaXR5ID0gZ2V0RXhpdFZpc2liaWxpdHkoKTtcblxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzVG9SZW1vdmUgPSBbXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRNZWFzdXJlQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0SW5pdENsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldFRyYW5zaXRpb25DbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRGaW5hbGl6ZUNsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldE1lYXN1cmVDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldEluaXRDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldFRyYW5zaXRpb25DbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldEZpbmFsaXplQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJpbmVydFwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcInJlbW92ZWRcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJoaWRkZW5cIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJ2aXNpYmxlXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1wZW5kaW5nYCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzVG9BZGQgPSBbXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RGlyZWN0aW9uQ2xhc3MoZGlyZWN0aW9uKX1gLFxuICAgICAgICAgICAgcGhhc2UgPyBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXREaXJlY3Rpb25DbGFzcyhkaXJlY3Rpb24pfS0ke0dldFBoYXNlQ2xhc3MocGhhc2UpfWAgOiBcIlwiLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7ZXhpdFZpc2liaWxpdHl9YFxuICAgICAgICBdO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5hbGxDbGFzc2VzVG9SZW1vdmUpO1xuICAgICAgICBhbGxDbGFzc2VzVG9SZW1vdmUubWFwKHYgPT4gY2xhc3NOYW1lcy5jdXJyZW50LmRlbGV0ZSh2KSk7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmFsbENsYXNzZXNUb0FkZCk7XG4gICAgICAgIGFsbENsYXNzZXNUb0FkZC5tYXAodiA9PiBjbGFzc05hbWVzLmN1cnJlbnQuYWRkKHYpKTtcblxuICAgIH0sIFtdKTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBzaW5nbGUgXCJtZWFzdXJlXCIgdmFyaWFibGUgKG9yIHJlbW92ZXMgaXQpXG4gICAgICovXG4gICAgY29uc3QgdXBkYXRlU2l6ZVByb3BlcnR5ID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUsIHZhck5hbWU6IChrZXlvZiBoLkpTWC5DU1NQcm9wZXJ0aWVzKSAmIHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9cHhgO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkodmFyTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W3Zhck5hbWVdO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgXCJtZWFzdXJlXCIgdmFyaXVwZGF0ZUNsYXNzZXNhYmxlcyB0byB0aGUgZWxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gICAgICovXG4gICAgY29uc3QgbWVhc3VyZUVsZW1lbnRBbmRVcGRhdGVQcm9wZXJ0aWVzID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsLCBtZWFzdXJlOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgc2l6ZTogRE9NUmVjdFJlYWRPbmx5IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobWVhc3VyZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS10b3BgLCBzaXplPy50b3ApO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtbGVmdGAsIHNpemU/LmxlZnQpO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtd2lkdGhgLCBzaXplPy53aWR0aCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS1oZWlnaHRgLCBzaXplPy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gV2UgdXNlIGJvdGggdXNlVGltZW91dCBhbmQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciB0aW1pbmcgY2VydGFpbiB0aGluZ3MgLS1cbiAgICAvLyByYWYgaXMgdXNlZCBmb3IgY2hhbmdpbmcgZnJvbSBpbml0IHRvIHRyYW5zaXRpb24gKHdvdWxkIHVzZSBxdWV1ZU1pY3JvdGFzayBidXQgaXQgY2FuJ3QgYmUgY2FuY2VsbGVkKVxuICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCBmb3IgY2hhbmdpbmcgZnJvbSB0cmFuc2l0aW9uIHRvIGZpbmFsaXplIChhcyBhIGJhY2t1cCBpbiBjYXNlIHRyYW5zaXRpb25lbmQgZG9lc24ndCBmaXJlKVxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgc3RhbGUgY2FsbGJhY2tzIHJ1bm5pbmcgKGkuZS4gd2hlbiB3ZSByYXBpZGx5IHN3aXRjaCBiZXR3ZWVuIHZpc2libGUgYW5kIG5vdClcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBhY2N1cmF0ZWx5IGNhbmNlbCBhbnl0aGluZyB0aGF0IGNhbiBjaGFuZ2Ugb3VyIHN0YXRlIG9uIGEgZGVsYXkuXG4gICAgLy9cbiAgICAvLyBBbHNvIG9mIG5vdGUsIHdlIHN0b3JlIFwiKGYpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQoZilcIiBpbnN0ZWFkIG9mIGp1c3QgXCJ3aW5kb3cuY2xlYXJUaW1lb3V0XCIgYmVjYXVzZVxuICAgIC8vIG9mIHRoZSBpbXBsaWNpdCB3aW5kb3cgb2JqZWN0IC0tIHByb2JsZW1zIHdpdGggYSBtaXNzaW5nIGB0aGlzYCBvYmplY3QgYW5kIGFsbCB0aGF0IG5vbnNlbnNlLlxuICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSB1c2VSZWY8bnVtYmVyPigtMSk7XG4gICAgY29uc3QgdGltZW91dENsZWFyRnVuY3Rpb24gPSB1c2VSZWY8KHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSkgfCAodHlwZW9mIGNsZWFyVGltZW91dCkgfCBudWxsPihudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEFueSB0aW1lIHRoZSBzdGF0ZSBjaGFuZ2VzLCB0aGVyZSdzIHNvbWUgbG9naWMgd2UgbmVlZCB0byBydW46XG4gICAgICogXG4gICAgICogKiBJZiB3ZSdyZSBjaGFuZ2luZyB0byBhbiBgaW5pdGAgcGhhc2UsIHVwZGF0ZSB0aGUgY2xhc3NlcywgdGhlbiB3YWl0IGEgbW9tZW50IGFuZCB0aGVuIGNoYW5nZSB0byB0aGUgYHRyYW5zaXRpb25gIHBoYXNlLlxuICAgICAqICogSWYgd2UncmUgY2hhbmdpbmcgdG8gYSBgdHJhbnNpdGlvbmAgcGhhc2UsIHVwZGF0ZSB0aGUgY2xhc3NlcywgdGhlbiB3YWl0IHVudGlsIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcywgdGhlbiBjaGFuZ2UgdG8gdGhlIGBmaW5hbGl6ZWAgcGhhc2UuXG4gICAgICogXG4gICAgICogQW55IGNoYW5nZSBpbiBzdGF0ZSBvciBjbGFzc2VzL3N0eWxlcyBkb2VzIG5vdCBpbXBsaWNpdGx5IGNhdXNlIGEgcmUtcmVuZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IG9uU3RhdGVDaGFuZ2UgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUcmFuc2l0aW9uU3RhdGUgfCBudWxsLCB1bmRlZmluZWQ+PigobmV4dFN0YXRlLCBwcmV2U3RhdGUsIHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY29uc3QgW25leHREaXJlY3Rpb24sIG5leHRQaGFzZV0gPSBwYXJzZVN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIG5vIHN0YWxlIGNoYW5nZSBjb2RlIGV2ZXIgcnVuc1xuICAgICAgICBpZiAodGltZW91dEhhbmRsZS5jdXJyZW50ID49IDAgJiYgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudClcbiAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQodGltZW91dEhhbmRsZS5jdXJyZW50KTtcblxuICAgICAgICAvLyBIYW5kbGUgaW5lcnQgcHJvcHMvcHJvcGVydHlcbiAgICAgICAgY29uc3QgZXhpdFZpc2liaWxpdHkgPSBnZXRFeGl0VmlzaWJpbGl0eSgpO1xuICAgICAgICBpZiAoZXhpdFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZXJ0ID0gKGV4aXRWaXNpYmlsaXR5ID09IFwiaW5lcnRcIiAmJiAobmV4dERpcmVjdGlvbiA9PSBcImV4aXRcIiAmJiBuZXh0UGhhc2UgPT0gXCJmaW5hbGl6ZVwiKSA/IHRydWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKGluZXJ0KVxuICAgICAgICAgICAgICAgIChvdGhlclByb3BzLmN1cnJlbnQgYXMgYW55KS5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG90aGVyUHJvcHMuY3VycmVudFtcImluZXJ0XCIgYXMgbmV2ZXJdO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZXJ0ID0gKGluZXJ0IHx8IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQmVpbmdQYWludGVkID0gKG5leHREaXJlY3Rpb24gPT0gXCJlbnRlclwiIHx8IChuZXh0RGlyZWN0aW9uID09IFwiZXhpdFwiICYmIG5leHRQaGFzZSAhPSBcImZpbmFsaXplXCIpKTtcbiAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlPy4oaXNCZWluZ1BhaW50ZWQpO1xuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZT8uKGlzQmVpbmdQYWludGVkKTtcblxuICAgICAgICB1cGRhdGVDbGFzc2VzKGVsZW1lbnQsIG5leHREaXJlY3Rpb24sIG5leHRQaGFzZSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIChuZXh0UGhhc2UgPT0gXCJpbml0XCIgfHwgbmV4dFBoYXNlID09IFwidHJhbnNpdGlvblwiKSlcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xuXG5cblxuICAgICAgICBzd2l0Y2ggKG5leHRQaGFzZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1lYXN1cmVcIjoge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy9zZXRTdGF0ZShgJHtuZXh0RGlyZWN0aW9ufS1pbml0YCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhlbGVtZW50LCBuZXh0RGlyZWN0aW9uLCBcImluaXRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gISFJbnRlbnRpb25hbCBmYWxsLXRocm91Z2ghIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImluaXRcIjoge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHNldFN0YXRlKGAke25leHREaXJlY3Rpb259LXRyYW5zaXRpb25gKTsgfSk7XG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IChmOiBudW1iZXIpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGdldFRpbWVvdXREdXJhdGlvbihlbGVtZW50KSAqIDEuNSk7XG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IChmOiBudW1iZXIpID0+IGNsZWFyVGltZW91dChmKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplXCI6IHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIG9yIHNjaGVkdWxlIG9yIGFueXRoaW5nIC0tIHdlIGp1c3QgdXBkYXRlIG91ciBjbGFzc2VzIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQgPSBudWxsOyAgICAvLyBEb2VzIHRoaXMgbWFrZSBpdCBtb3JlIG9yIGxlc3MgY2xlYXI/XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gSW50ZW50aW9uYWxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZCBzdGF0ZSB1c2VkIGluIHRyYW5zaXRpb246ICR7bmV4dFN0YXRlfS4gUHJldmlvdXMgc3RhdGUgd2FzICR7cHJldlN0YXRlID8/IFwibnVsbFwifWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG5cbiAgICBjb25zdCBbZ2V0U3RhdGUsIHNldFN0YXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxUcmFuc2l0aW9uU3RhdGUgfCBudWxsLCB1bmRlZmluZWQ+KG9uU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIC8vIFdoZW4gd2UgbW91bnQsIGFuZCBldmVyeSB0aW1lIHRoZXJlYWZ0ZXIgdGhhdCBgc2hvd2AgY2hhbmdlcyxcbiAgICAvLyBjaGFuZ2Ugb3VyIGN1cnJlbnQgc3RhdGUgYWNjb3JkaW5nIHRvIHRoYXQgYHNob3dgIHZhbHVlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiBpbnRlcm5hbE9uU2hvd0NoYW5nZWQoc2hvdywgbWVhc3VyZSksIFttZWFzdXJlLCBzaG93XSk7XG5cblxuICAgIC8vIFRoaXMgaGFzIG5vIGRlcGVuZGVuY2VzIGFuZCBpcyByZWxpZWQgb24gaW4gdHdvIGRpZmZlcmVudCBhcmVhc1xuICAgIGZ1bmN0aW9uIGludGVybmFsT25TaG93Q2hhbmdlZChzaG93OiBib29sZWFuIHwgbnVsbCwgbWVhc3VyZTogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIElmIGBzaG93YCBpcyBudWxsLCB0aGVuIHdlIGRvbid0IGNoYW5nZSBhbnl0aGluZy5cbiAgICAgICAgaWYgKHNob3cgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyAoSWYgYHNob3dgIGlzIHRydWUvZmFsc2UsIHdlJ2xsIHJlbW92ZSB0aGUgQ1NTIGNsYXNzZXMgZHVyaW5nIGBvbkNoYW5nZWApXG5cbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHRQaGFzZTogVHJhbnNpdGlvblBoYXNlID0gbWVhc3VyZSA/IFwibWVhc3VyZVwiIDogXCJpbml0XCI7XG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50RGlyZWN0aW9uLCBjdXJyZW50UGhhc2VdID0gcGFyc2VTdGF0ZShjdXJyZW50U3RhdGUpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQaGFzZSAhPSBcImZpbmFsaXplXCIpXG4gICAgICAgICAgICAgICAgbmV4dFBoYXNlID0gXCJ0cmFuc2l0aW9uXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiB0aGUgc2V0U3RhdGUgY2hhbmdlIGhhbmRsZXIgcnVucyBpbW1lZGlhdGVseSB3aXRoIG5vIGRlYm91bmNlLlxuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgaWYgKGhhc01vdW50ZWQuY3VycmVudCB8fCBhbmltYXRlT25Nb3VudClcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShgZW50ZXItJHtuZXh0UGhhc2V9YCk7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShcImVudGVyLWZpbmFsaXplXCIpO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzTW91bnRlZC5jdXJyZW50IHx8IGFuaW1hdGVPbk1vdW50KVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKGBleGl0LSR7bmV4dFBoYXNlfWApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKFwiZXhpdC1maW5hbGl6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGR1cmF0aW9uICE9IG51bGwpXG4gICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS1kdXJhdGlvbmBdID0gZHVyYXRpb24gKyBcIm1zXCI7XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LWR1cmF0aW9uYF07XG5cbiAgICBlYXNpbmdJbiA/Pz0gZWFzaW5nO1xuICAgIGVhc2luZ091dCA/Pz0gZWFzaW5nO1xuXG4gICAgaWYgKGVhc2luZ091dCAhPSBudWxsKVxuICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF0gPSBlYXNpbmdPdXQ7XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdO1xuXG5cbiAgICBpZiAoZWFzaW5nSW4gIT0gbnVsbClcbiAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXSA9IGVhc2luZ0luO1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF07XG5cblxuXG4gICAgLy8gVE9ET1xuICAgIGNvbnN0IGlubGluZURpcmVjdGlvbiA9IG51bGw7XG4gICAgY29uc3QgYmxvY2tEaXJlY3Rpb24gPSBudWxsO1xuXG5cblxuICAgIC8vIE5vIG1hdHRlciB3aGF0IGRlbGF5TW91bnRVbnRpbFNob3duIGlzLFxuICAgIC8vIG9uY2Ugd2UndmUgcmVuZGVyZWQgb3VyIGNoaWxkcmVuIG9uY2UsIFxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRvbid0IHVubW91bnQgdGhlbSBhZ2FpbiBhbmQgd2FzdGUgYWxsIHRoYXQgd29yay5cbiAgICAvLyAoSWYgeW91IHJlYWxseSBuZWVkIHRoaXMgeW91IGNhbiBqdXN0IHVubW91bnQgdGhlIGVudGlyZSB0cmFuc2l0aW9uIGl0c2VsZilcbiAgICBjb25zdCBkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiA9IChzaG93IHx8ICFkZWxheU1vdW50VW50aWxTaG93bik7XG4gICAgY29uc3QgaGFzUmVuZGVyZWRDaGlsZHJlbiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgcmVuZGVyQ2hpbGRyZW4gPSBkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiB8fCBoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQ7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuKVxuICAgICAgICAgICAgaGFzUmVuZGVyZWRDaGlsZHJlbi5jdXJyZW50IHx8PSB0cnVlO1xuICAgIH0sIFtoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQgPyBmYWxzZSA6IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuXSk7XG5cblxuICAgIGNvbnN0IGNoaWxkcmVuSXNWbm9kZSA9IChjaGlsZHJlbiAmJiAoY2hpbGRyZW4gYXMgVk5vZGUpLnR5cGUgJiYgKGNoaWxkcmVuIGFzIFZOb2RlKS5wcm9wcyk7XG4gICAgY29uc3QgZmluYWxQcm9wcyA9IHVzZU1lcmdlZFByb3BzPEU+KHAsIHByb3BzU3RhYmxlLCBvdGhlclByb3BzLmN1cnJlbnQsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAuLi5jbGFzc05hbWVzLmN1cnJlbnQsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7ZXhpdFZpc2liaWxpdHl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1pbmxpbmUtZGlyZWN0aW9uLSR7aW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ibG9jay1kaXJlY3Rpb24tJHtibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwifWBcbiAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgc3R5bGU6IGNzc1Byb3BlcnRpZXMuY3VycmVudFxuICAgIH0sIGNoaWxkcmVuSXNWbm9kZSA/IHsgcmVmOiAoY2hpbGRyZW4gYXMgVk5vZGUpLnJlZiwgLi4uKGNoaWxkcmVuIGFzIFZOb2RlKS5wcm9wcyB9IDoge30pO1xuXG5cblxuICAgIGNvbnN0IHJlc2V0Q29udGV4dCA9IHVzZVJlZjxTd2FwcGFibGVDb250ZXh0VHlwZT4oeyBnZXRBbmltYXRlT25Nb3VudDogcmV0dXJuRmFsc2UgfSkuY3VycmVudDtcblxuICAgIGxldCBtb2RpZmllZENoaWxkcmVuOiBWTm9kZTtcblxuICAgIGlmIChjaGlsZHJlbklzVm5vZGUpIHtcbiAgICAgICAgbW9kaWZpZWRDaGlsZHJlbiA9IDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyZXNldENvbnRleHR9PntjbG9uZUVsZW1lbnQoY2hpbGRyZW4gYXMgVk5vZGUsIGZpbmFsUHJvcHMpfTwvU3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlcj5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vZGlmaWVkQ2hpbGRyZW4gPSA8U3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cmVzZXRDb250ZXh0fT48c3BhbiB7Li4uZmluYWxQcm9wcyBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+fT57Y2hpbGRyZW59PC9zcGFuPjwvU3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlcj5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyQ2hpbGRyZW4gPyBtb2RpZmllZENoaWxkcmVuIDogbnVsbDtcbn1cblxuXG5cbmZ1bmN0aW9uIGZvcmNlUmVmbG93PEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oZTogRSkge1xuXG4gICAgLy8gVHJ5IHJlYWxseSBoYXJkIHRvIG1ha2Ugc3VyZSB0aGlzIGlzbid0IG9wdGltaXplZCBvdXQgYnkgYW55dGhpbmcuXG4gICAgLy8gV2UgbmVlZCBpdCBmb3IgaXRzIGRvY3VtZW50IHJlZmxvdyBzaWRlIGVmZmVjdC5cbiAgICBjb25zdCBwID0gKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gZS5zdHlsZS5vcGFjaXR5O1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBwO1xuICAgIHJldHVybiBlO1xufVxuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgbWluaW11bSBvciBtYXhpbXVtIG9wYWNpdHkgdmFsdWVzIHRvIHVzZSBmb3IgdGhlIGZhZGUgZWZmZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBmYWRlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIGZhZGVkIG91dC5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmFkZU1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wYWNpdHkgdG8gdXNlIHdoZW4gZmFkZWQgaW4uXHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZhZGVNYXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgRmFkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzRmFkZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWluLCBmYWRlTWF4IH0gfTogVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWZhZGVgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mYWRlLW1pbmBdOiAoZmFkZU1pbiA/PyAwKSxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZhZGUtbWF4YF06IChmYWRlTWF4ID8/IDEpLFxyXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGYWRlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmFkZSBlZmZlY3QuXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgd2hpbGUgaXQgaXMgYWJzb2x1dGVseSBwb3NzaWJsZSB0byB3cmFwIGFub3RoZXIgdHJhbnNpdGlvbiB3aXRoIGA8RmFkZT5gLFxyXG4gKiB0aGVyZSB3aWxsIGJlIHNvbWUgZHVwbGljYXRlIGNvZGUgcnVuIGFzIHR3byBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50cyBlbmQgdXAgb3BlcmF0aW5nIG9uIHRoZSBzYW1lIGVsZW1lbnQuXHJcbiAqIEl0J3MgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIGVpdGhlciB1c2UgdGhlIGNvbXBvbmVudHMgdGhhdCBpbmNsdWRlIGEgY29tYmluZWQgZmFkZSBlZmZlY3QsXHJcbiAqIG9yIGp1c3QgZGlyZWN0bHkgYSBgPFRyYW5zaXRpb25hYmxlPmAgb24geW91ciBvd24uXHJcbiAqIFxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGZhZGVNaW4sIGZhZGVNYXgsIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IEZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oeyByZWYsIC4uLnJlc3QgfSwgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgY2xpcFBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIGNsaXAgYXJvdW5kICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwT3JpZ2luSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIGNsaXAgYXJvdW5kIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBjbGlwIHRvL2Zyb20sIGZyb20gMCB0byAxICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBjbGlwIHRvL2Zyb20sIGZyb20gMCB0byAxIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwTWluSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBNaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0NsaXA8RSBleHRlbmRzIEVsZW1lbnQ+KHsgY2xpcFBhcmFtZXRlcnM6IHsgY2xpcE1pbiwgY2xpcE1pbkJsb2NrLCBjbGlwTWluSW5saW5lLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBPcmlnaW5JbmxpbmUgfSB9OiBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3goYCR7R2V0QmFzZUNsYXNzKCl9LWNsaXBgKSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW9yaWdpbi1pbmxpbmVgXTogKGNsaXBPcmlnaW5JbmxpbmUgPz8gY2xpcE9yaWdpbiA/PyAwLjUpLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtb3JpZ2luLWJsb2NrYF06IChjbGlwT3JpZ2luQmxvY2sgPz8gY2xpcE9yaWdpbiA/PyAwKSxcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW1pbi1pbmxpbmVgXTogKGNsaXBNaW5JbmxpbmUgPz8gY2xpcE1pbiA/PyAxKSxcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW1pbi1ibG9ja2BdOiAoY2xpcE1pbkJsb2NrID8/IGNsaXBNaW4gPz8gMCksXHJcbiAgICAgICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICB9XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcFByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+LCBcImNsaXBQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgQ2xpcCA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ2xpcFByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NsaXAoeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jayB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpXHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzQ2xpcCwgVXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jbGlwLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbGlwRmFkZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+LCBcImNsaXBQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDbGlwRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcEZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGRlbGF5TW91bnRVbnRpbFNob3duLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGNsaXBNaW4sIGNsaXBNaW5CbG9jaywgY2xpcE1pbklubGluZSwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwT3JpZ2luSW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENsaXBGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDbGlwKHsgY2xpcFBhcmFtZXRlcnM6IHsgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2sgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcblxyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNvbGxhcHNlIGVmZmVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuXHJcbiAgICBjb2xsYXBzZVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBzbWFsbGVzdCBzaXplIHRoZSBjb21wb25lbnQgY29sbGFwc2VzIHRvLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgbWluQmxvY2tTaXplOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKiBcclxuICogSU1QT1JUQU5UOiBJZiB1c2VkIG91dHNpZGUgb2YgYSBgPENvbGxhcHNlIC8+YCwgeW91IG11c3QgaW5jbHVkZSB0aGUgYG1lYXN1cmVgIHByb3Agb24gdGhlIGA8VHJhbnNpdGlvbmFibGU+YCB0aGF0IHlvdSB1c2UuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZSA8VHJhbnNpdGlvbmFibGUgbWVhc3VyZSB7Li4udXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyguLi4pfSAvPlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0NvbGxhcHNlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGNvbGxhcHNlUGFyYW1ldGVyczogeyBtaW5CbG9ja1NpemUgfSB9OiBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWNvbGxhcHNlYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY29sbGFwc2UtbWluLWJsb2NrYF06IG1pbkJsb2NrU2l6ZSA/PyAwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2xsYXBzZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPiwgXCJjb2xsYXBzZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgQ29sbGFwc2UgZWZmZWN0LlxyXG4gKiBcclxuICogKkltcG9ydGFudCo6IFRoaXMgY29tcG9uZW50IGlzICpub3QqIGVmZmljaWVudCBmb3IgdGhlIGJyb3dzZXIgdG8gYW5pbWF0ZSEgXHJcbiAqIE1ha2Ugc3VyZSB5b3UgZG8gdGVzdGluZyBvbiBsb3dlciBwb3dlciBkZXZpY2VzLCBvciBwcmVmZXIgYSBsaWdodGVyXHJcbiAqIGFsdGVybmF0aXZlLCBsaWtlIGA8Q2xpcD5gLlxyXG4gKiBcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ29sbGFwc2UgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzaG93LCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgZGVsYXlNb3VudFVudGlsU2hvd24sIG1pbkJsb2NrU2l6ZSwgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ29sbGFwc2VQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuXHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NvbGxhcHNlKHsgY29sbGFwc2VQYXJhbWV0ZXJzOiB7IG1pbkJsb2NrU2l6ZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNDb2xsYXBzZSwgVXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY29sbGFwc2UuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGFwc2VGYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPiwgXCJjb2xsYXBzZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgc2hvdywgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZHVyYXRpb24sIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgZmFkZU1pbiwgZmFkZU1heCwgZXhpdFZpc2liaWxpdHksIG1pbkJsb2NrU2l6ZSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENvbGxhcHNlRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ29sbGFwc2UoeyBjb2xsYXBzZVBhcmFtZXRlcnM6IHsgbWluQmxvY2tTaXplIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiwgdXNlTGFzdE5vbk51bGxWYWx1ZSB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBhbmQgZXh0ZW50IG9mIHRoZSBmbGlwIGVmZmVjdC4gXG4gKiBWYWx1ZXMgYXJlIHJlbGF0aXZlLCB3aXRoIDEgb3IgLTEgYmVpbmcgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGF0IGRpcmVjdGlvbi5cbiAqIGAwLjVgLCBmb3IgZXhhbXBsZSwgd291bGQgZmxpcCB0byB0aGUgcmlnaHQgYnkgNTAlIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xuICAgIGZsaXBQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGFuZ2xlIChpbiBkZWdyZWVzKSB0byByb3RhdGUgdG93YXJkcyBvbiB0aGUgaW5saW5lIGF4aXMgKFggYXhpcyBmb3IgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cbiAgICAgICAgICovXG4gICAgICAgIGZsaXBBbmdsZUlubGluZTogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhcmdldCBhbmdsZSAoaW4gZGVncmVlcykgdG8gcm90YXRlIHRvd2FyZHMgb24gdGhlIGJsb2NrIGF4aXMgKFggYXhpcyBmb3IgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cbiAgICAgICAgICovXG4gICAgICAgIGZsaXBBbmdsZUJsb2NrOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaW5jZSB0aGlzIGlzIGEgM0QgZWZmZWN0LCBhIHBlcnNwZWN0aXZlIHZhbHVlIGlzIG5lZWRlZC5cbiAgICAgICAgICogQGRlZmF1bHQgODAwcHhcbiAgICAgICAgICovXG4gICAgICAgIGZsaXBQZXJzcGVjdGl2ZTogc3RyaW5nIHwgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgRmxpcCB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNGbGlwPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZsaXBQYXJhbWV0ZXJzOiB7IGZsaXBBbmdsZUJsb2NrLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBQZXJzcGVjdGl2ZSB9IH06IFVzZUJhc2VQcm9wc0ZsaXBQYXJhbWV0ZXJzPEU+KSB7XG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1mbGlwYCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mbGlwLWFuZ2xlLWlubGluZWBdOiBgJHsodXNlTGFzdE5vbk51bGxWYWx1ZShmbGlwQW5nbGVJbmxpbmUpID8/IDApfWRlZ2AsXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmxpcC1hbmdsZS1ibG9ja2BdOiBgJHsodXNlTGFzdE5vbk51bGxWYWx1ZShmbGlwQW5nbGVCbG9jaykgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1wZXJzcGVjdGl2ZWBdOiBgJHsoZmxpcFBlcnNwZWN0aXZlID8/IDgwMCl9cHhgXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGbGlwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RT4sIFwiZmxpcFBhcmFtZXRlcnNcIj4+IHsgfTtcblxuLyoqXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmxpcCBlZmZlY3QuXG4gKiBcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBmbGlwSW5saW5lYCBhbmQgYGZsaXBCbG9ja2AsXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXG4gKiBcbiAqIEEgdmFsdWUgb2YgYDBgIGlzIGhhbmRsZWQgc3BlY2lhbGx5LCBlZmZlY3RpdmVseSBtZWFuaW5nIFwidXNlIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlXCIsXG4gKiBleGNsdXNpdml0eUtleSBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYCBcbiAqIChgZmxpcElubGluZT17aW5kZXggLSBzZWxlY3RlZEluZGV4fWAgb3Igc2ltaWxhci4pIFxuICogXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcbiAqL1xuZXhwb3J0IGNvbnN0IEZsaXAgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZsaXA8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgZmxpcEFuZ2xlSW5saW5lLCBmbGlwQW5nbGVCbG9jaywgZmxpcFBlcnNwZWN0aXZlLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBGbGlwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93LFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBlYXNpbmdJbixcbiAgICAgICAgICAgIGVhc2luZ091dCxcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZsaXAoeyBmbGlwUGFyYW1ldGVyczogeyBmbGlwQW5nbGVCbG9jaywgZmxpcEFuZ2xlSW5saW5lLCBmbGlwUGVyc3BlY3RpdmUgfSB9KSxcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxuICAgICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XG4gICAgfSk7XG59KSk7XG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYsIHVzZUxhc3ROb25OdWxsVmFsdWUgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBkaXJlY3Rpb24gYW5kIGV4dGVudCBvZiB0aGUgc2xpZGUgZWZmZWN0LiBcclxuICogVmFsdWVzIGFyZSByZWxhdGl2ZSwgd2l0aCAxIG9yIC0xIGJlaW5nIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQgaW4gdGhhdCBkaXJlY3Rpb24uXHJcbiAqIGAwLjVgLCBmb3IgZXhhbXBsZSwgd291bGQgc2xpZGUgdG8gdGhlIHJpZ2h0IGJ5IDUwJSBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgc2xpZGVQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBzbGlkZSB0by9mcm9tIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNsaWRlVGFyZ2V0SW5saW5lOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHNsaWRlIHRvL2Zyb20gKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2xpZGVUYXJnZXRCbG9jazogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBTbGlkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzU2xpZGU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrIH0gfTogVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBzbGlkZVRhcmdldElubGluZSA9IHVzZUxhc3ROb25OdWxsVmFsdWUoc2xpZGVUYXJnZXRJbmxpbmUpO1xyXG4gICAgc2xpZGVUYXJnZXRCbG9jayA9IHVzZUxhc3ROb25OdWxsVmFsdWUoc2xpZGVUYXJnZXRCbG9jayk7XHJcblxyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tc2xpZGVgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1zbGlkZS10YXJnZXQtaW5saW5lYF06IGAkeyhzbGlkZVRhcmdldElubGluZSA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tc2xpZGUtdGFyZ2V0LWJsb2NrYF06IGAkeyhzbGlkZVRhcmdldEJsb2NrID8/IDApfWBcclxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFNsaWRlIGVmZmVjdC5cclxuICogXHJcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBzbGlkZUlubGluZWAgYW5kIGBzbGlkZUJsb2NrYCxcclxuICogd2l0aCBgMWAgYmVpbmcgYDEwMCVgIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0LlxyXG4gKiBcclxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcclxuICogd2hpY2ggYWxsb3dzIGZvciBjb252ZW5pZW50IHNldHVwcyBpbnNpZGUgb2YgYSBgU3dhcENvbnRhaW5lcmAgXHJcbiAqIChgc2xpZGVJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKSBcclxuICogXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNsaWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIG9uVmlzaWJpbGl0eUNoYW5nZSwgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2ssIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgZGVsYXlNb3VudFVudGlsU2hvd24sIC4uLnJlc3QgfTogU2xpZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNsaWRlRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBTbGlkZUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBvcmlnaW4sIG1pbmltdW0gc2l6ZSwgYW5kIGRpcmVjdGlvbiBvZiB0aGUgem9vbSBlZmZlY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIHpvb21QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21PcmlnaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSBvdXQgb2YvaW50byAoWCBjb21wb25lbnQpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU9yaWdpbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvIChZIGNvbXBvbmVudClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tT3JpZ2luQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gc2hyaW5rIHRvL2Zyb20sIGZyb20gMCB0byAxICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21NaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gc2hyaW5rIHRvL2Zyb20sIGZyb20gMCB0byAxIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tTWluQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgWm9vbSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzWm9vbTxFIGV4dGVuZHMgRWxlbWVudD4oeyB6b29tUGFyYW1ldGVyczogeyB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jayB9IH06IFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuICh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tem9vbWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tb3JpZ2luLWlubGluZWBdOiBgJHsoem9vbU9yaWdpbklubGluZSA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tb3JpZ2luLWJsb2NrYF06IGAkeyh6b29tT3JpZ2luQmxvY2sgPz8gem9vbU9yaWdpbiA/PyAwLjUpfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW1pbi1pbmxpbmVgXTogYCR7KHpvb21NaW5JbmxpbmUgPz8gem9vbU1pbiA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1taW4tYmxvY2tgXTogYCR7KHpvb21NaW5CbG9jayA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9vbVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFpvb20gZWZmZWN0LlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFpvb21GYWRlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFpvb20gPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb208RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2ssIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFpvb21Qcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxufSkpO1xyXG5cclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVab29tUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPiwgXCJ6b29tUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZVpvb20gPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlWm9vbTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlWm9vbVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzU2xpZGUsIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL3NsaWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzWm9vbSwgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnMgfSBmcm9tIFwiLi96b29tLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlWm9vbUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVab29tRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBmYWRlTWF4LCBmYWRlTWluLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlWm9vbUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzWm9vbSwgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnMgfSBmcm9tIFwiLi96b29tLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFpvb21GYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgWm9vbUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb21GYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBab29tRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXREZXZUb29scygpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fUFJFQUNUX0RFVlRPT0xTX18pIHtcblx0XHR3aW5kb3cuX19QUkVBQ1RfREVWVE9PTFNfXy5hdHRhY2hQcmVhY3QoJzEwLjEzLjInLCBvcHRpb25zLCB7XG5cdFx0XHRGcmFnbWVudCxcblx0XHRcdENvbXBvbmVudFxuXHRcdH0pO1xuXHR9XG59XG4iLCJjb25zdCBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbmxldCBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBSZXNldCB0aGUgaGlzdG9yeSBvZiB3aGljaCBwcm9wIHR5cGUgd2FybmluZ3MgaGF2ZSBiZWVuIGxvZ2dlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UHJvcFdhcm5pbmdzKCkge1xuXHRsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3Byb3AtdHlwZXMvYmxvYi9tYXN0ZXIvY2hlY2tQcm9wVHlwZXMuanNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKFxuXHR0eXBlU3BlY3MsXG5cdHZhbHVlcyxcblx0bG9jYXRpb24sXG5cdGNvbXBvbmVudE5hbWUsXG5cdGdldFN0YWNrXG4pIHtcblx0T2JqZWN0LmtleXModHlwZVNwZWNzKS5mb3JFYWNoKHR5cGVTcGVjTmFtZSA9PiB7XG5cdFx0bGV0IGVycm9yO1xuXHRcdHRyeSB7XG5cdFx0XHRlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKFxuXHRcdFx0XHR2YWx1ZXMsXG5cdFx0XHRcdHR5cGVTcGVjTmFtZSxcblx0XHRcdFx0Y29tcG9uZW50TmFtZSxcblx0XHRcdFx0bG9jYXRpb24sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdFJlYWN0UHJvcFR5cGVzU2VjcmV0XG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGVycm9yID0gZTtcblx0XHR9XG5cdFx0aWYgKGVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG5cdFx0XHRsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0YEZhaWxlZCAke2xvY2F0aW9ufSB0eXBlOiAke2Vycm9yLm1lc3NhZ2V9JHtcblx0XHRcdFx0XHQoZ2V0U3RhY2sgJiYgYFxcbiR7Z2V0U3RhY2soKX1gKSB8fCAnJ1xuXHRcdFx0XHR9YFxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEdldCBodW1hbiByZWFkYWJsZSBuYW1lIG9mIHRoZSBjb21wb25lbnQvZG9tIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuXHRcdHJldHVybiAnRnJhZ21lbnQnO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gdm5vZGUudHlwZS5kaXNwbGF5TmFtZSB8fCB2bm9kZS50eXBlLm5hbWU7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUudHlwZTtcblx0fVxuXG5cdHJldHVybiAnI3RleHQnO1xufVxuXG4vKipcbiAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGB2bm9kZWAgYW5kIHByaW50IGl0XG4gKiBpbiBkZWJ1ZyBtZXNzYWdlcy5cbiAqL1xubGV0IHJlbmRlclN0YWNrID0gW107XG5cbi8qKlxuICogS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lcnMuIEFuIG93bmVyIGRlc2NyaWJlcyBhIGNvbXBvbmVudFxuICogd2hpY2ggd2FzIHJlc3BvbnNpYmxlIHRvIHJlbmRlciBhIHNwZWNpZmljIGB2bm9kZWAuIFRoaXMgZXhjbHVkZVxuICogY2hpbGRyZW4gdGhhdCBhcmUgcGFzc2VkIHZpYSBgcHJvcHMuY2hpbGRyZW5gLCBiZWNhdXNlIHRoZXkgYmVsb25nXG4gKiB0byB0aGUgcGFyZW50IG93bmVyLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgRm9vID0gcHJvcHMgPT4gPGRpdj57cHJvcHMuY2hpbGRyZW59PC9kaXY+IC8vIGRpdidzIG93bmVyIGlzIEZvb1xuICogY29uc3QgQmFyID0gcHJvcHMgPT4ge1xuICogICByZXR1cm4gKFxuICogICAgIDxGb28+PHNwYW4gLz48L0Zvbz4gLy8gRm9vJ3Mgb3duZXIgaXMgQmFyLCBzcGFuJ3Mgb3duZXIgaXMgQmFyXG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGU6IEEgYHZub2RlYCBtYXkgYmUgaG9pc3RlZCB0byB0aGUgcm9vdCBzY29wZSBkdWUgdG8gY29tcGlsZXJcbiAqIG9wdGltaXp0aW9ucy4gSW4gdGhlc2UgY2FzZXMgdGhlIGBfb3duZXJgIHdpbGwgYmUgZGlmZmVyZW50LlxuICovXG5sZXQgb3duZXJTdGFjayA9IFtdO1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGB2bm9kZWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50Vk5vZGUoKSB7XG5cdHJldHVybiByZW5kZXJTdGFjay5sZW5ndGggPiAwID8gcmVuZGVyU3RhY2tbcmVuZGVyU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG4vKipcbiAqIElmIHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSBgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcmVhY3QtanN4LXNvdXJjZWBcbiAqIHNvbWV3aGVyZSBpbiBoaXMgdG9vbCBjaGFpbiB3ZSBjYW4ndCBwcmludCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZVxuICogbG9jYXRpb24gb2YgYSBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBqdXN0IG9taXQgdGhhdCwgYnV0IHdlJ2xsXG4gKiBwcmludCBhIGhlbHBmdWwgbWVzc2FnZSB0byB0aGUgY29uc29sZSwgbm90aWZ5aW5nIHRoZSB1c2VyIG9mIGl0LlxuICovXG5sZXQgaGFzQmFiZWxQbHVnaW4gPSBmYWxzZTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGB2bm9kZWAgaXMgYSBwb3NzaWJsZSBvd25lci5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGlzUG9zc2libGVPd25lcih2bm9kZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB2bm9kZS50eXBlICE9IEZyYWdtZW50O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY29tcG9uZW50IHN0YWNrIHRoYXQgd2FzIGNhcHR1cmVkIHVwIHRvIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE93bmVyU3RhY2sodm5vZGUpIHtcblx0Y29uc3Qgc3RhY2sgPSBbdm5vZGVdO1xuXHRsZXQgbmV4dCA9IHZub2RlO1xuXHR3aGlsZSAobmV4dC5fb3duZXIgIT0gbnVsbCkge1xuXHRcdHN0YWNrLnB1c2gobmV4dC5fb3duZXIpO1xuXHRcdG5leHQgPSBuZXh0Ll9vd25lcjtcblx0fVxuXG5cdHJldHVybiBzdGFjay5yZWR1Y2UoKGFjYywgb3duZXIpID0+IHtcblx0XHRhY2MgKz0gYCAgaW4gJHtnZXREaXNwbGF5TmFtZShvd25lcil9YDtcblxuXHRcdGNvbnN0IHNvdXJjZSA9IG93bmVyLl9fc291cmNlO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdGFjYyArPSBgIChhdCAke3NvdXJjZS5maWxlTmFtZX06JHtzb3VyY2UubGluZU51bWJlcn0pYDtcblx0XHR9IGVsc2UgaWYgKCFoYXNCYWJlbFBsdWdpbikge1xuXHRcdFx0aGFzQmFiZWxQbHVnaW4gPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHQnQWRkIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXJlYWN0LWpzeC1zb3VyY2UgdG8gZ2V0IGEgbW9yZSBkZXRhaWxlZCBjb21wb25lbnQgc3RhY2suIE5vdGUgdGhhdCB5b3Ugc2hvdWxkIG5vdCBhZGQgaXQgdG8gcHJvZHVjdGlvbiBidWlsZHMgb2YgeW91ciBBcHAgZm9yIGJ1bmRsZSBzaXplIHJlYXNvbnMuJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGFjYyArPSAnXFxuJyk7XG5cdH0sICcnKTtcbn1cblxuLyoqXG4gKiBTZXR1cCBjb2RlIHRvIGNhcHR1cmUgdGhlIGNvbXBvbmVudCB0cmFjZSB3aGlsZSByZW5kZXJpbmcuIE5vdGUgdGhhdFxuICogd2UgY2Fubm90IHNpbXBseSB0cmF2ZXJzZSBgdm5vZGUuX3BhcmVudGAgdXB3YXJkcywgYmVjYXVzZSB3ZSBoYXZlIHNvbWVcbiAqIGRlYnVnIG1lc3NhZ2VzIGZvciBgdGhpcy5zZXRTdGF0ZWAgd2hlcmUgdGhlIGB2bm9kZWAgaXMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENvbXBvbmVudFN0YWNrKCkge1xuXHRsZXQgb2xkRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5cdGxldCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcblx0bGV0IG9sZFJvb3QgPSBvcHRpb25zLl9yb290O1xuXHRsZXQgb2xkVk5vZGUgPSBvcHRpb25zLnZub2RlO1xuXHRsZXQgb2xkUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xuXG5cdG9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRcdGlmIChpc1Bvc3NpYmxlT3duZXIodm5vZGUpKSB7XG5cdFx0XHRvd25lclN0YWNrLnBvcCgpO1xuXHRcdH1cblx0XHRyZW5kZXJTdGFjay5wb3AoKTtcblx0XHRpZiAob2xkRGlmZmVkKSBvbGREaWZmZWQodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdHJlbmRlclN0YWNrLnB1c2godm5vZGUpO1xuXHRcdH1cblx0XHRpZiAob2xkRGlmZikgb2xkRGlmZih2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fcm9vdCA9ICh2bm9kZSwgcGFyZW50KSA9PiB7XG5cdFx0b3duZXJTdGFjayA9IFtdO1xuXHRcdGlmIChvbGRSb290KSBvbGRSb290KHZub2RlLCBwYXJlbnQpO1xuXHR9O1xuXG5cdG9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdFx0dm5vZGUuX293bmVyID1cblx0XHRcdG93bmVyU3RhY2subGVuZ3RoID4gMCA/IG93bmVyU3RhY2tbb3duZXJTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG5cdFx0aWYgKG9sZFZOb2RlKSBvbGRWTm9kZSh2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fcmVuZGVyID0gdm5vZGUgPT4ge1xuXHRcdGlmIChpc1Bvc3NpYmxlT3duZXIodm5vZGUpKSB7XG5cdFx0XHRvd25lclN0YWNrLnB1c2godm5vZGUpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRSZW5kZXIpIG9sZFJlbmRlcih2bm9kZSk7XG5cdH07XG59XG4iLCJpbXBvcnQgeyBjaGVja1Byb3BUeXBlcyB9IGZyb20gJy4vY2hlY2stcHJvcHMnO1xuaW1wb3J0IHsgb3B0aW9ucywgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7XG5cdEVMRU1FTlRfTk9ERSxcblx0RE9DVU1FTlRfTk9ERSxcblx0RE9DVU1FTlRfRlJBR01FTlRfTk9ERVxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuXHRnZXRPd25lclN0YWNrLFxuXHRzZXR1cENvbXBvbmVudFN0YWNrLFxuXHRnZXRDdXJyZW50Vk5vZGUsXG5cdGdldERpc3BsYXlOYW1lXG59IGZyb20gJy4vY29tcG9uZW50LXN0YWNrJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGlzV2Vha01hcFN1cHBvcnRlZCA9IHR5cGVvZiBXZWFrTWFwID09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3REb21Ob2RlUGFyZW50KHBhcmVudCkge1xuXHRpZiAoIXBhcmVudCkgcmV0dXJuIHt9O1xuXHRpZiAodHlwZW9mIHBhcmVudC50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQocGFyZW50Ll9wYXJlbnQpO1xuXHR9XG5cdHJldHVybiBwYXJlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGVidWcoKSB7XG5cdHNldHVwQ29tcG9uZW50U3RhY2soKTtcblxuXHRsZXQgaG9va3NBbGxvd2VkID0gZmFsc2U7XG5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXHRsZXQgb2xkQmVmb3JlRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5cdGxldCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcblx0bGV0IG9sZFZub2RlID0gb3B0aW9ucy52bm9kZTtcblx0bGV0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xuXHRsZXQgb2xkUm9vdCA9IG9wdGlvbnMuX3Jvb3Q7XG5cdGxldCBvbGRIb29rID0gb3B0aW9ucy5faG9vaztcblx0Y29uc3Qgd2FybmVkQ29tcG9uZW50cyA9ICFpc1dlYWtNYXBTdXBwb3J0ZWRcblx0XHQ/IG51bGxcblx0XHQ6IHtcblx0XHRcdFx0dXNlRWZmZWN0OiBuZXcgV2Vha01hcCgpLFxuXHRcdFx0XHR1c2VMYXlvdXRFZmZlY3Q6IG5ldyBXZWFrTWFwKCksXG5cdFx0XHRcdGxhenlQcm9wVHlwZXM6IG5ldyBXZWFrTWFwKClcblx0XHQgIH07XG5cdGNvbnN0IGRlcHJlY2F0aW9ucyA9IFtdO1xuXG5cdG9wdGlvbnMuX2NhdGNoRXJyb3IgPSAoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSA9PiB7XG5cdFx0bGV0IGNvbXBvbmVudCA9IHZub2RlICYmIHZub2RlLl9jb21wb25lbnQ7XG5cdFx0aWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgZXJyb3IudGhlbiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjb25zdCBwcm9taXNlID0gZXJyb3I7XG5cdFx0XHRlcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0YE1pc3NpbmcgU3VzcGVuc2UuIFRoZSB0aHJvd2luZyBjb21wb25lbnQgd2FzOiAke2dldERpc3BsYXlOYW1lKHZub2RlKX1gXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgcGFyZW50ID0gdm5vZGU7XG5cdFx0XHRmb3IgKDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0XHRpZiAocGFyZW50Ll9jb21wb25lbnQgJiYgcGFyZW50Ll9jb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZCkge1xuXHRcdFx0XHRcdGVycm9yID0gcHJvbWlzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSBoYXZlbid0IHJlY292ZXJlZCBhbmQgd2Uga25vdyBhdCB0aGlzIHBvaW50IHRoYXQgdGhlcmUgaXMgbm9cblx0XHRcdC8vIFN1c3BlbnNlIGNvbXBvbmVudCBoaWdoZXIgdXAgaW4gdGhlIHRyZWVcblx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRlcnJvckluZm8gPSBlcnJvckluZm8gfHwge307XG5cdFx0XHRlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPSBnZXRPd25lclN0YWNrKHZub2RlKTtcblx0XHRcdG9sZENhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcblxuXHRcdFx0Ly8gd2hlbiBhbiBlcnJvciB3YXMgaGFuZGxlZCBieSBhbiBFcnJvckJvdW5kYXJ5IHdlIHdpbGwgbm9uZXRoZWxlc3MgZW1pdCBhbiBlcnJvclxuXHRcdFx0Ly8gZXZlbnQgb24gdGhlIHdpbmRvdyBvYmplY3QuIFRoaXMgaXMgdG8gbWFrZSB1cCBmb3IgcmVhY3QgY29tcGF0aWJpbGl0eSBpbiBkZXYgbW9kZVxuXHRcdFx0Ly8gYW5kIHRodXMgbWFrZSB0aGUgTmV4dC5qcyBkZXYgb3ZlcmxheSB3b3JrLlxuXHRcdFx0aWYgKHR5cGVvZiBlcnJvci50aGVuICE9ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9O1xuXG5cdG9wdGlvbnMuX3Jvb3QgPSAodm5vZGUsIHBhcmVudE5vZGUpID0+IHtcblx0XHRpZiAoIXBhcmVudE5vZGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J1VuZGVmaW5lZCBwYXJlbnQgcGFzc2VkIHRvIHJlbmRlcigpLCB0aGlzIGlzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuJyArXG5cdFx0XHRcdFx0J0NoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGF2YWlsYWJsZSBpbiB0aGUgRE9NL2hhcyB0aGUgY29ycmVjdCBpZC4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBpc1ZhbGlkO1xuXHRcdHN3aXRjaCAocGFyZW50Tm9kZS5ub2RlVHlwZSkge1xuXHRcdFx0Y2FzZSBFTEVNRU5UX05PREU6XG5cdFx0XHRjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG5cdFx0XHRjYXNlIERPQ1VNRU5UX05PREU6XG5cdFx0XHRcdGlzVmFsaWQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzVmFsaWQpIHtcblx0XHRcdGxldCBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWUodm5vZGUpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgRXhwZWN0ZWQgYSB2YWxpZCBIVE1MIG5vZGUgYXMgYSBzZWNvbmQgYXJndW1lbnQgdG8gcmVuZGVyLlx0UmVjZWl2ZWQgJHtwYXJlbnROb2RlfSBpbnN0ZWFkOiByZW5kZXIoPCR7Y29tcG9uZW50TmFtZX0gLz4sICR7cGFyZW50Tm9kZX0pO2Bcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFJvb3QpIG9sZFJvb3Qodm5vZGUsIHBhcmVudE5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdFx0bGV0IHsgdHlwZSwgX3BhcmVudDogcGFyZW50IH0gPSB2bm9kZTtcblx0XHRsZXQgcGFyZW50Vk5vZGUgPSBnZXRDbG9zZXN0RG9tTm9kZVBhcmVudChwYXJlbnQpO1xuXG5cdFx0aG9va3NBbGxvd2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J1VuZGVmaW5lZCBjb21wb25lbnQgcGFzc2VkIHRvIGNyZWF0ZUVsZW1lbnQoKVxcblxcbicgK1xuXHRcdFx0XHRcdCdZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgb3IgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSAhPSBudWxsICYmIHR5cGVvZiB0eXBlID09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAodHlwZS5fY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlLl9kb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0YEludmFsaWQgdHlwZSBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCgpOiAke3R5cGV9XFxuXFxuYCArXG5cdFx0XHRcdFx0XHQnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIEpTWCBsaXRlcmFsIGFzIEpTWCB0d2ljZT9cXG5cXG4nICtcblx0XHRcdFx0XHRcdGAgIGxldCBNeSR7Z2V0RGlzcGxheU5hbWUodm5vZGUpfSA9ICR7c2VyaWFsaXplVk5vZGUodHlwZSl9O1xcbmAgK1xuXHRcdFx0XHRcdFx0YCAgbGV0IHZub2RlID0gPE15JHtnZXREaXNwbGF5TmFtZSh2bm9kZSl9IC8+O1xcblxcbmAgK1xuXHRcdFx0XHRcdFx0J1RoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4geW91IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGFuZCBub3QgdGhlIGNvbXBvbmVudC4nICtcblx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnSW52YWxpZCB0eXBlIHBhc3NlZCB0byBjcmVhdGVFbGVtZW50KCk6ICcgK1xuXHRcdFx0XHRcdChBcnJheS5pc0FycmF5KHR5cGUpID8gJ2FycmF5JyA6IHR5cGUpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCh0eXBlID09PSAndGhlYWQnIHx8IHR5cGUgPT09ICd0Zm9vdCcgfHwgdHlwZSA9PT0gJ3Rib2R5JykgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0YWJsZSdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0aGVhZC90Ym9keS90Zm9vdD4gc2hvdWxkIGhhdmUgYSA8dGFibGU+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHR5cGUgPT09ICd0cicgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0aGVhZCcgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0Zm9vdCcgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0Ym9keScgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0YWJsZSdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0cj4gc2hvdWxkIGhhdmUgYSA8dGhlYWQvdGJvZHkvdGZvb3QvdGFibGU+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndGQnICYmIHBhcmVudFZOb2RlLnR5cGUgIT09ICd0cicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0ZD4gc2hvdWxkIGhhdmUgYSA8dHI+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndGgnICYmIHBhcmVudFZOb2RlLnR5cGUgIT09ICd0cicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0aD4gc2hvdWxkIGhhdmUgYSA8dHI+LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHR2bm9kZS5yZWYgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0dHlwZW9mIHZub2RlLnJlZiAhPSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2Ygdm5vZGUucmVmICE9ICdvYmplY3QnICYmXG5cdFx0XHQhKCckJHR5cGVvZicgaW4gdm5vZGUpIC8vIGFsbG93IHN0cmluZyByZWZzIHdoZW4gcHJlYWN0LWNvbXBhdCBpcyBpbnN0YWxsZWRcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENvbXBvbmVudCdzIFwicmVmXCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgZnVuY3Rpb24sIG9yIGFuIG9iamVjdCBjcmVhdGVkIGAgK1xuXHRcdFx0XHRcdGBieSBjcmVhdGVSZWYoKSwgYnV0IGdvdCBbJHt0eXBlb2Ygdm5vZGUucmVmfV0gaW5zdGVhZFxcbmAgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ3N0cmluZycpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHZub2RlLnByb3BzKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRrZXlbMF0gPT09ICdvJyAmJlxuXHRcdFx0XHRcdGtleVsxXSA9PT0gJ24nICYmXG5cdFx0XHRcdFx0dHlwZW9mIHZub2RlLnByb3BzW2tleV0gIT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRcdHZub2RlLnByb3BzW2tleV0gIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRgQ29tcG9uZW50J3MgXCIke2tleX1cIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgYCArXG5cdFx0XHRcdFx0XHRcdGBidXQgZ290IFske3R5cGVvZiB2bm9kZS5wcm9wc1trZXldfV0gaW5zdGVhZFxcbmAgK1xuXHRcdFx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIHByb3AtdHlwZXMgaWYgYXZhaWxhYmxlXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgJiYgdm5vZGUudHlwZS5wcm9wVHlwZXMpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dm5vZGUudHlwZS5kaXNwbGF5TmFtZSA9PT0gJ0xhenknICYmXG5cdFx0XHRcdHdhcm5lZENvbXBvbmVudHMgJiZcblx0XHRcdFx0IXdhcm5lZENvbXBvbmVudHMubGF6eVByb3BUeXBlcy5oYXModm5vZGUudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBtID1cblx0XHRcdFx0XHQnUHJvcFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGxhenkoKS4gVXNlIHByb3BUeXBlcyBvbiB0aGUgd3JhcHBlZCBjb21wb25lbnQgaXRzZWxmLiAnO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGxhenlWTm9kZSA9IHZub2RlLnR5cGUoKTtcblx0XHRcdFx0XHR3YXJuZWRDb21wb25lbnRzLmxhenlQcm9wVHlwZXMuc2V0KHZub2RlLnR5cGUsIHRydWUpO1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdG0gKyBgQ29tcG9uZW50IHdyYXBwZWQgaW4gbGF6eSgpIGlzICR7Z2V0RGlzcGxheU5hbWUobGF6eVZOb2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBjYXRjaCAocHJvbWlzZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdG0gKyBcIldlIHdpbGwgbG9nIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIG5hbWUgb25jZSBpdCBpcyBsb2FkZWQuXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCB2YWx1ZXMgPSB2bm9kZS5wcm9wcztcblx0XHRcdGlmICh2bm9kZS50eXBlLl9mb3J3YXJkZWQpIHtcblx0XHRcdFx0dmFsdWVzID0gYXNzaWduKHt9LCB2YWx1ZXMpO1xuXHRcdFx0XHRkZWxldGUgdmFsdWVzLnJlZjtcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tQcm9wVHlwZXMoXG5cdFx0XHRcdHZub2RlLnR5cGUucHJvcFR5cGVzLFxuXHRcdFx0XHR2YWx1ZXMsXG5cdFx0XHRcdCdwcm9wJyxcblx0XHRcdFx0Z2V0RGlzcGxheU5hbWUodm5vZGUpLFxuXHRcdFx0XHQoKSA9PiBnZXRPd25lclN0YWNrKHZub2RlKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5faG9vayA9IChjb21wLCBpbmRleCwgdHlwZSkgPT4ge1xuXHRcdGlmICghY29tcCB8fCAhaG9va3NBbGxvd2VkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hvb2sgY2FuIG9ubHkgYmUgaW52b2tlZCBmcm9tIHJlbmRlciBtZXRob2RzLicpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRIb29rKSBvbGRIb29rKGNvbXAsIGluZGV4LCB0eXBlKTtcblx0fTtcblxuXHQvLyBJZGVhbGx5IHdlJ2Qgd2FudCB0byBwcmludCBhIHdhcm5pbmcgb25jZSBwZXIgY29tcG9uZW50LCBidXQgd2Vcblx0Ly8gZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIHZub2RlIHRoYXQgdHJpZ2dlcmVkIGl0IGhlcmUuIEFzIGFcblx0Ly8gY29tcHJvbWlzZSBhbmQgdG8gYXZvaWQgZmxvb2RpbmcgdGhlIGNvbnNvbGUgd2l0aCB3YXJuaW5ncyB3ZVxuXHQvLyBwcmludCBlYWNoIGRlcHJlY2F0aW9uIHdhcm5pbmcgb25seSBvbmNlLlxuXHRjb25zdCB3YXJuID0gKHByb3BlcnR5LCBtZXNzYWdlKSA9PiAoe1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGtleSA9ICdnZXQnICsgcHJvcGVydHkgKyBtZXNzYWdlO1xuXHRcdFx0aWYgKGRlcHJlY2F0aW9ucyAmJiBkZXByZWNhdGlvbnMuaW5kZXhPZihrZXkpIDwgMCkge1xuXHRcdFx0XHRkZXByZWNhdGlvbnMucHVzaChrZXkpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYGdldHRpbmcgdm5vZGUuJHtwcm9wZXJ0eX0gaXMgZGVwcmVjYXRlZCwgJHttZXNzYWdlfWApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2V0KCkge1xuXHRcdFx0Y29uc3Qga2V5ID0gJ3NldCcgKyBwcm9wZXJ0eSArIG1lc3NhZ2U7XG5cdFx0XHRpZiAoZGVwcmVjYXRpb25zICYmIGRlcHJlY2F0aW9ucy5pbmRleE9mKGtleSkgPCAwKSB7XG5cdFx0XHRcdGRlcHJlY2F0aW9ucy5wdXNoKGtleSk7XG5cdFx0XHRcdGNvbnNvbGUud2Fybihgc2V0dGluZyB2bm9kZS4ke3Byb3BlcnR5fSBpcyBub3QgYWxsb3dlZCwgJHttZXNzYWdlfWApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Y29uc3QgZGVwcmVjYXRlZEF0dHJpYnV0ZXMgPSB7XG5cdFx0bm9kZU5hbWU6IHdhcm4oJ25vZGVOYW1lJywgJ3VzZSB2bm9kZS50eXBlJyksXG5cdFx0YXR0cmlidXRlczogd2FybignYXR0cmlidXRlcycsICd1c2Ugdm5vZGUucHJvcHMnKSxcblx0XHRjaGlsZHJlbjogd2FybignY2hpbGRyZW4nLCAndXNlIHZub2RlLnByb3BzLmNoaWxkcmVuJylcblx0fTtcblxuXHRjb25zdCBkZXByZWNhdGVkUHJvdG8gPSBPYmplY3QuY3JlYXRlKHt9LCBkZXByZWNhdGVkQXR0cmlidXRlcyk7XG5cblx0b3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0XHRjb25zdCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRcdGlmIChcblx0XHRcdHZub2RlLnR5cGUgIT09IG51bGwgJiZcblx0XHRcdHByb3BzICE9IG51bGwgJiZcblx0XHRcdCgnX19zb3VyY2UnIGluIHByb3BzIHx8ICdfX3NlbGYnIGluIHByb3BzKVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgbmV3UHJvcHMgPSAodm5vZGUucHJvcHMgPSB7fSk7XG5cdFx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRcdGNvbnN0IHYgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKGkgPT09ICdfX3NvdXJjZScpIHZub2RlLl9fc291cmNlID0gdjtcblx0XHRcdFx0ZWxzZSBpZiAoaSA9PT0gJ19fc2VsZicpIHZub2RlLl9fc2VsZiA9IHY7XG5cdFx0XHRcdGVsc2UgbmV3UHJvcHNbaV0gPSB2O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXHRcdHZub2RlLl9fcHJvdG9fXyA9IGRlcHJlY2F0ZWRQcm90bztcblx0XHRpZiAob2xkVm5vZGUpIG9sZFZub2RlKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdXNlciBwYXNzZWQgcGxhaW4gb2JqZWN0cyBhcyBjaGlsZHJlbi4gTm90ZSB0aGF0IHdlIGNhbm5vdFxuXHRcdC8vIG1vdmUgdGhpcyBjaGVjayBpbnRvIGBvcHRpb25zLnZub2RlYCBiZWNhdXNlIGNvbXBvbmVudHMgY2FuIHJlY2VpdmVcblx0XHQvLyBjaGlsZHJlbiBpbiBhbnkgc2hhcGUgdGhleSB3YW50IChlLmcuXG5cdFx0Ly8gYDxNeUpTT05Gb3JtYXR0ZXI+e3sgZm9vOiAxMjMsIGJhcjogXCJhYmNcIiB9fTwvTXlKU09ORm9ybWF0dGVyPmApLlxuXHRcdC8vIFB1dHRpbmcgdGhpcyBjaGVjayBpbiBgb3B0aW9ucy5kaWZmZWRgIGVuc3VyZXMgdGhhdFxuXHRcdC8vIGB2bm9kZS5fY2hpbGRyZW5gIGlzIHNldCBhbmQgdGhhdCB3ZSBvbmx5IHZhbGlkYXRlIHRoZSBjaGlsZHJlblxuXHRcdC8vIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZC5cblx0XHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkICYmIGNoaWxkLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGlsZCkuam9pbignLCcpO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdGBPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBjaGlsZC4gRW5jb3VudGVyZWQgYW4gb2JqZWN0IHdpdGggdGhlIGtleXMgeyR7a2V5c319LmAgK1xuXHRcdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aG9va3NBbGxvd2VkID0gZmFsc2U7XG5cblx0XHRpZiAob2xkRGlmZmVkKSBvbGREaWZmZWQodm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRjb25zdCBrZXlzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgPT0gbnVsbCkgY29udGludWU7XG5cblx0XHRcdFx0Y29uc3Qga2V5ID0gY2hpbGQua2V5O1xuXHRcdFx0XHRpZiAoa2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XHRcdCdGb2xsb3dpbmcgY29tcG9uZW50IGhhcyB0d28gb3IgbW9yZSBjaGlsZHJlbiB3aXRoIHRoZSAnICtcblx0XHRcdFx0XHRcdFx0YHNhbWUga2V5IGF0dHJpYnV0ZTogXCIke2tleX1cIi4gVGhpcyBtYXkgY2F1c2UgZ2xpdGNoZXMgYW5kIG1pc2JlaGF2aW9yIGAgK1xuXHRcdFx0XHRcdFx0XHQnaW4gcmVuZGVyaW5nIHByb2Nlc3MuIENvbXBvbmVudDogXFxuXFxuJyArXG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gQnJlYWsgZWFybHkgdG8gbm90IHNwYW0gdGhlIGNvbnNvbGVcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuY29uc3Qgc2V0U3RhdGUgPSBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlO1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSA9PSBudWxsKSB7XG5cdFx0Ly8gYHRoaXMuX3Zub2RlYCB3aWxsIGJlIGBudWxsYCBkdXJpbmcgY29tcG9uZW50V2lsbE1vdW50LiBCdXQgaXRcblx0XHQvLyBpcyBwZXJmZWN0bHkgdmFsaWQgdG8gY2FsbCBgc2V0U3RhdGVgIGR1cmluZyBjV00uIFNvIHdlXG5cdFx0Ly8gbmVlZCBhbiBhZGRpdGlvbmFsIGNoZWNrIHRvIHZlcmlmeSB0aGF0IHdlIGFyZSBkZWFsaW5nIHdpdGggYVxuXHRcdC8vIGNhbGwgaW5zaWRlIGNvbnN0cnVjdG9yLlxuXHRcdGlmICh0aGlzLnN0YXRlID09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0YENhbGxpbmcgXCJ0aGlzLnNldFN0YXRlXCIgaW5zaWRlIHRoZSBjb25zdHJ1Y3RvciBvZiBhIGNvbXBvbmVudCBpcyBhIGAgK1xuXHRcdFx0XHRcdGBuby1vcCBhbmQgbWlnaHQgYmUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gSW5zdGVhZCwgc2V0IGAgK1xuXHRcdFx0XHRcdGBcInRoaXMuc3RhdGUgPSB7fVwiIGRpcmVjdGx5LlxcblxcbiR7Z2V0T3duZXJTdGFjayhnZXRDdXJyZW50Vk5vZGUoKSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc2V0U3RhdGUuY2FsbCh0aGlzLCB1cGRhdGUsIGNhbGxiYWNrKTtcbn07XG5cbmNvbnN0IGZvcmNlVXBkYXRlID0gQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZTtcbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlID09IG51bGwpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgQ2FsbGluZyBcInRoaXMuZm9yY2VVcGRhdGVcIiBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGEgY29tcG9uZW50IGlzIGEgYCArXG5cdFx0XHRcdGBuby1vcCBhbmQgbWlnaHQgYmUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi5cXG5cXG4ke2dldE93bmVyU3RhY2soXG5cdFx0XHRcdFx0Z2V0Q3VycmVudFZOb2RlKClcblx0XHRcdFx0KX1gXG5cdFx0KTtcblx0fSBlbHNlIGlmICh0aGlzLl9wYXJlbnREb20gPT0gbnVsbCkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGBDYW4ndCBjYWxsIFwidGhpcy5mb3JjZVVwZGF0ZVwiIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcCwgYCArXG5cdFx0XHRcdGBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gZml4LCBjYW5jZWwgYWxsIGAgK1xuXHRcdFx0XHRgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuYCArXG5cdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodGhpcy5fdm5vZGUpfWBcblx0XHQpO1xuXHR9XG5cdHJldHVybiBmb3JjZVVwZGF0ZS5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgdm5vZGUgdHJlZSB0byBhIHN0cmluZ1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVWTm9kZSh2bm9kZSkge1xuXHRsZXQgeyBwcm9wcyB9ID0gdm5vZGU7XG5cdGxldCBuYW1lID0gZ2V0RGlzcGxheU5hbWUodm5vZGUpO1xuXG5cdGxldCBhdHRycyA9ICcnO1xuXHRmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG5cdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdjaGlsZHJlbicpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG5cdFx0XHQvLyBJZiBpdCBpcyBhbiBvYmplY3QgYnV0IGRvZXNuJ3QgaGF2ZSB0b1N0cmluZygpLCB1c2UgT2JqZWN0LnRvU3RyaW5nXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSBgZnVuY3Rpb24gJHt2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lfSgpIHt9YDtcblx0XHRcdH1cblxuXHRcdFx0dmFsdWUgPVxuXHRcdFx0XHRPYmplY3QodmFsdWUpID09PSB2YWx1ZSAmJiAhdmFsdWUudG9TdHJpbmdcblx0XHRcdFx0XHQ/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHZhbHVlICsgJyc7XG5cblx0XHRcdGF0dHJzICs9IGAgJHtwcm9wfT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuXHRcdH1cblx0fVxuXG5cdGxldCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXHRyZXR1cm4gYDwke25hbWV9JHthdHRyc30ke1xuXHRcdGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/ICc+Li48LycgKyBuYW1lICsgJz4nIDogJyAvPidcblx0fWA7XG59XG4iLCJleHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gOTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG4iLCJpbXBvcnQgeyBpbml0RGVidWcgfSBmcm9tICcuL2RlYnVnJztcbmltcG9ydCAncHJlYWN0L2RldnRvb2xzJztcblxuaW5pdERlYnVnKCk7XG5cbmV4cG9ydCB7IHJlc2V0UHJvcFdhcm5pbmdzIH0gZnJvbSAnLi9jaGVjay1wcm9wcyc7XG4iLCJpbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG4vKipcclxuICogUmVsYXRpdmVseSBsb3ctbGV2ZWwgaG9vayB0aGF0IGFsbG93cyB5b3UgdG8gaW5zcGVjdFxyXG4gKiB3aGVuIHRoZSBlbnRpcmUgVVJMIGNoYW5nZXMsIGVpdGhlciBiZWNhdXNlIHRoZSBoYXNoIGNoYW5nZWQsXHJcbiAqIG9yIGJlY2F1c2UgdGhlIEJhY2svRm9yd2FyZCBicm93c2VyIGJ1dHRvbnMgd2VyZSBwcmVzc2VkLlxyXG4gKiBcclxuICogKENoYW5naW5nIHF1ZXJ5IHBhcmFtZXRlcnMgcmVsb2FkcyB0aGUgcGFnZSBhbmQgc28gaXNuJ3RcclxuICogdHJhY2tlZCwgdW5sZXNzIG9mIGNvdXJzZSBpdCdzIGJlY2F1c2Ugb2YgdGhlIGJyb3dzZXJcclxuICogbmF2aWdhdGluZyBiYWNrL2ZvcndhcmRzKS5cclxuICogXHJcbiAqIEluIGdlbmVyYWwsIHlvdSdsbCB3YW50IHRvIGluc3BlY3QgYSBzcGVjaWZpYyBkaXJlY3Rvcnkgb2ZcclxuICogYSBwYXRoLCBvciBhIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZSwgbm90IHRoZVxyXG4gKiBlbnRpcmUgVVJMLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVybChvblVybENoYW5nZTogKHVybDogc3RyaW5nKSA9PiB2b2lkKSB7XHJcblxyXG4gICAgY29uc3QgW2dldFVybCwgc2V0VXJsXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhvblVybENoYW5nZSksIHVzZUNhbGxiYWNrKCgpID0+IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLCBbXSkpO1xyXG5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgZSA9PiB7XHJcbiAgICAgICAgc2V0VXJsKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInBvcHN0YXRlXCIsIChlOiBQb3BTdGF0ZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9wb3BzdGF0ZV9ldmVudCN0aGVfaGlzdG9yeV9zdGFja1xyXG4gICAgICAgIC8vIFRPRE86IElmIHRoaXMgYXNzZXJ0IG5ldmVyIGZpcmVzLCBpdCdzICpwcm9iYWJseSogZmluZT8/XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkgPT09IGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHNldFVybCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gW2dldFVybCwgc2V0VXJsXSBhcyBjb25zdDtcclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5cclxuXHJcbi8vZXhwb3J0IGNvbnN0IFJvdXRlckxldmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgaGVscGVyIHRvIHRyaW0gdGhlIGNydXN0cyBvZmYgb2YgYSBoYXNoIHBhdGguXHJcbiAqIEBwYXJhbSBoYXNoIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltSGFzaChoYXNoOiBzdHJpbmcpIHtcclxuICAgIGlmIChoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpKVxyXG4gICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cigxKTtcclxuICAgIGlmIChoYXNoLnN0YXJ0c1dpdGgoXCIvXCIpKVxyXG4gICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cigxKTtcclxuICAgIGlmIChoYXNoLmVuZHNXaXRoKFwiL1wiKSlcclxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMCwgaGFzaC5sZW5ndGggLSAxKTtcclxuICAgIHJldHVybiBoYXNoO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSGFzaFRvUGF0aChoYXNoOiBzdHJpbmcpIHtcclxuICAgIGhhc2ggPSB0cmltSGFzaChoYXNoKTtcclxuICAgIHJldHVybiBoYXNoLnNwbGl0KFwiL1wiKTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeXBlTWFwIHtcclxuICAgIFwiYmlnaW50XCI6IGJpZ2ludDtcclxuICAgIFwibnVtYmVyXCI6IG51bWJlcjtcclxuICAgIFwic3RyaW5nXCI6IHN0cmluZztcclxuICAgIFwiYm9vbGVhblwiOiBib29sZWFuO1xyXG4gICAgXCJ1bmtub3duXCI6IHVua25vd247XHJcbn1cclxuXHJcbi8vIE5vdCBwdWJsaWMgLS0ganVzdCBjb250YWlucyBzaGFyZWQgY29kZSBmb3IgaGlzdG9yeSBtb2RpZmljYXRpb24uXHJcbi8vIFRoaXMgaXMgd2hhdCBhY3R1YWxseSBjaGFuZ2VzIEhpc3RvcnkgYW5kIHVwZGF0ZXMgdGhlIHdpbmRvdydzIFVSTC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudGlyZUhhc2goaGFzaDogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpIHtcclxuICAgIGFjdGlvbiA/Pz0gXCJwdXNoXCI7XHJcbiAgICBoYXNoID0gdHJpbUhhc2goaGFzaCk7XHJcbiAgICBsZXQgb2xkVVJMID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICBsZXQgbmV4dFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgbmV4dFVybC5oYXNoID0gYCMke2hhc2h9YDtcclxuXHJcbiAgICBoaXN0b3J5W2Ake2FjdGlvbn1TdGF0ZWBdKHt9LCBkb2N1bWVudC50aXRsZSwgbmV4dFVybCk7XHJcblxyXG4gICAgLy8gTW9kaWZ5aW5nIGhpc3RvcnkgZG9lc24ndCBhY3R1YWxseSBjYXVzZSBhIGhhc2hjaGFuZ2UgZXZlbnQuXHJcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgSGFzaENoYW5nZUV2ZW50KCdoYXNoY2hhbmdlJywgeyBvbGRVUkwsIG5ld1VSTDogbmV4dFVybC50b1N0cmluZygpIH0pKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1vZGlmaWVzIHRoZSBnaXZlbiBTZWFyY2ggUGFyYW1zIG9iamVjdCB0byBoYXZlIGl0cyBrZXkgYmUgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZS5cclxuICogXHJcbiAqIFNwZWNpZmljYWxseSBmb3IgYm9vbGVhbiB0eXBlcyB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgcGFyYW0gaXMgc2ltcGx5IGV4aXN0YW50L25vbi1leGlzdGFudCxcclxuICogYnV0IGZvciBvdGhlciB0eXBlcyB0aGlzIGlzIHByZXR0eSBzdHJhaWdodGZvcndhcmQuXHJcbiAqIEBwYXJhbSBwYXJhbXMgXHJcbiAqIEBwYXJhbSBrZXkgXHJcbiAqIEBwYXJhbSB2YWx1ZSBcclxuICogQHBhcmFtIHR5cGUgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5wYXJzZVBhcmFtPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4ocGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMsIGtleTogc3RyaW5nLCB2YWx1ZTogVHlwZU1hcFtUXSwgdHlwZTogVCkge1xyXG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoa2V5LCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJhbXMuc2V0KGtleSwgYCR7dmFsdWV9YCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW0gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxyXG4gKiBcclxuICogVGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHBhcnNlZCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGJvb2xlYW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbTxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+KHVybDogVVJMLCBrZXk6IHN0cmluZywgdHlwZTogVCk6IFR5cGVNYXBbVF0gfCBudWxsIHtcclxuICAgIGxldCB2YWx1ZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XHJcblxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGFzIFR5cGVNYXBbVF0pID8/IG51bGw7XHJcblxyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCkgYXMgVHlwZU1hcFtUXTtcclxuXHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShwYXJzZWQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCBhcyBUeXBlTWFwW1RdO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgYXMgVHlwZU1hcFtUXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlIGFzIFR5cGVNYXBbVF0gPz8gbnVsbDtcclxufVxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIFJvdXRlclBhdGhUeXBlID0gbnVsbCB8IHN0cmluZyB8IFJlZ0V4cCB8ICgobG9jYWxQYXRoOiBzdHJpbmcpID0+IGJvb2xlYW4pO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250cm9scyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byBgZGlyYC5cclxuICAgICAqIFxyXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBjbG9zZXIgdG8gdGhlIHJvb3QgYXJlIG5vdCBhZmZlY3RlZC4gIFxyXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBmYXJ0aGVyIGZyb20gdGhlIHJvb3QgYXJlIGRlbGV0ZWQgdW5sZXNzIHJlcXVlc3RlZCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHNldExvY2FsUGF0aChkaXI6IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHbyBvbmUgbGV2ZWwgZGVlcGVyIGludG8gdGhpcyBkaXJlY3RvcnkgYnkgYXBwZW5kaW5nIGAvZGlyYCB0byBpdC5cclxuICAgICAqIFxyXG4gICAgICogKiBUaGUgY3VycmVudCBkaXJlY3RvcnkgaXMgbm90IGFmZmVjdGVkXHJcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkLiAgXHJcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGZhcnRoZXIgZnJvbSB0aGUgcm9vdCBhcmUgZGVsZXRlZCB1bmxlc3MgcmVxdWVzdGVkIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHVzaExvY2FsUGF0aChkaXI6IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHbyBiYWNrIG9uZSBsZXZlbCBieSBzZXR0aW5nIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB0byBlbXB0eSBhbmQsIG9wdGlvbmFsbHksIGNoYW5naW5nIHRoZSBwYXJlbnQgZGlyZWN0b3J5IHRvIGBkaXJgIGFzIHdlbGwuXHJcbiAgICAgKiBcclxuICAgICAqICogVGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHNldCB0byBlbXB0eVxyXG4gICAgICogKiBBbGwgZGlyZWN0b3JpZXMgYWZ0ZXIgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LCBpZiBhbnksIGFyZSBlbXB0aWVkLlxyXG4gICAgICogKiBJZiBwcm92aWRlZCwgdGhlIHBhcmVudCBkaXJlY3RvcnkgdG8gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHNldCB0byBgZGlyYC5cclxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgY2xvc2VyIHRvIHRoZSByb290IGFyZSBub3QgYWZmZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcG9wTG9jYWxQYXRoKGRpcj86IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIik6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nPiB7XHJcbiAgICBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoYW55TWF0Y2hlczogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRleHRUeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSb3V0ZXJDaGlsZEluZm8+IHtcclxuICAgIHJvdXRlckNvbnRleHQ6IHtcclxuICAgICAgICAvLyBUaGUgY3VycmVudCBsZXZlbCB0aGUgY2hpbGQgc2hvdWxkIGNvbnNpZGVyIGl0c2VsZiBhcy0tXHJcbiAgICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0aGlzIHRvIGtub3cgd2hhdCBwYXJ0IG9mIHRoZSBVUkwgdG8gcGFyc2VcclxuICAgICAgICAvLyBhbmQgYWxzbyB0byBpbmZvcm0gKnRoZWlyKiBjaGlsZHJlbiB3aGF0IGxldmVsIHRoZXkgYXJlXHJcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBpbiBvcmRlciB0byBmYWNpbGl0YXRlIHNob3dpbmcgdGhlIGRlZmF1bHQgY2hpbGQgd2hlbiBubyBub24tZGVmYXVsdCBjaGlsZHJlbiBhcmUgYmVpbmcgc2hvd24uXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4IFxyXG4gICAgICAgICAqIEBwYXJhbSBtYXRjaGVzIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4OiBzdHJpbmcsIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsKTogdm9pZDtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZz4ge1xyXG4vLyAgICBub3RpZnlPZlNpYmxpbmdzSGF2ZU5vTWF0Y2hlcyhub01hdGNoZXM6IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgLy9wYXRoOiBSb3V0ZXJQYXRoVHlwZSB8IG51bGw7XHJcbi8vICAgIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsO1xyXG4vL31cclxuIiwiaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0LCBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgUm91dGVyQ2hpbGRJbmZvLCBSb3V0ZXJQYXRoVHlwZSwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2NhbFBhdGhQYXJhbWV0ZXJzIHtcclxuICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IFBpY2s8VXNlQ29uc3VtZVJvdXRlclJldHVybltcImNvbnN1bWVSb3V0ZXJSZXR1cm5cIl0sIFwibGV2ZWxcIj47XHJcbiAgICBsb2NhbFJvdXRlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlOiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250ZXh0VHlwZSBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8Um91dGVyQ2hpbGRJbmZvPiB7XHJcbiAgICByb3V0ZXJDb250ZXh0OiB7XHJcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcclxuICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleDogc3RyaW5nLCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbCk6IHZvaWQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdXRlckNvbnN1bWVyQXJndW1lbnRzIHtcclxuICAgIHJvdXRlckNvbnN1bWVyUGFyYW1ldGVyczogeyBsb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlIHwgbnVsbDsgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIFwiY2hpbGRcIiBwYXJ0IG9mIGEgcm91dGVyLlxyXG4gKiBcclxuICogVGhpcyBpcyByZXNwb25zaWJsZSBmb3Igb2JzZXJ2aW5nIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBpbiB0aGUgaGFzaCxcclxuICogYW5kIG5vdGlmeWluZyB0aGUgcGFyZW50IGFueSB0aW1lIGl0IGJlY29tZXMgdmFsaWQvaW52YWxpZCwgYmVjYXVzZVxyXG4gKiBpZiB0aGlzIHBhdGggYW5kIGFsbCBpdHMgc2libGluZ3MgYXJlIGludmFsaWQgYXQgdGhlIHNhbWUgdGltZSxcclxuICogdGhlIGRlZmF1bHQgcGF0aCBpcyBhbGxvd2VkIHRvIGJlIHNob3duLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29uc3VtZVJvdXRlclBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8Um91dGVyQ2hpbGRJbmZvPiwgXCJpbmZvXCI+IHtcclxuICAgIGNvbnRleHQ6IFJvdXRlckNvbnRleHRUeXBlO1xyXG4gICAgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHtcclxuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcclxuICAgICAgICBsb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlO1xyXG4gICAgfVxyXG4gICAgaW5mbzogT21pdDxSb3V0ZXJDaGlsZEluZm8sIFwic2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzXCI+XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29uc3VtZVJvdXRlclJldHVybiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8Um91dGVyQ2hpbGRJbmZvPiB7XHJcbiAgICBjb25zdW1lUm91dGVyUmV0dXJuOiB7XHJcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcclxuICAgICAgICBtYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcclxuICAgICAgICBnZXRMb2NhbFBhdGg6ICgpID0+IHN0cmluZztcclxuICAgICAgICBzZXRMb2NhbFBhdGg6IChwYXRoOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgICAgICAgcGF0aFdoZW5NYXRjaGluZzogc3RyaW5nIHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnN1bWVSb3V0ZXIoeyBjb250ZXh0LCBpbmZvOiB7IGluZGV4IH0sIGNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzOiB7IG9uTG9jYWxQYXRoQ2hhbmdlLCBsb2NhbFBhdGg6IHdhbnRlZExvY2FsUGF0aCB9IH06IFVzZUNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzKTogVXNlQ29uc3VtZVJvdXRlclJldHVybiB7XHJcbiAgICBjb25zdCB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWwsIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkIH0gfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBbYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3NdID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgYm9vbGVhbik7XHJcblxyXG4gICAgY29uc3QgW3BhdGhXaGVuTWF0Y2hpbmcsIHNldFBhdGhXaGVuTWF0Y2hpbmddID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgc3RyaW5nKTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybiB9ID0gdXNlTWFuYWdlZENoaWxkPFJvdXRlckNoaWxkSW5mbz4oe1xyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgaW5mbzoge1xyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzOiB1c2VTdGFibGVDYWxsYmFjaygoYW55TWF0Y2hlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzKGFueU1hdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlcywgZ2V0TG9jYWxQYXRoKCkpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBnZXRMb2NhbFBhdGgoKSk7XHJcbiAgICB9LCBbd2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3NdKVxyXG5cclxuXHJcbiAgICBjb25zdCBvbkxvY2FsUGF0aENoYW5nZTIgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiAod2FudGVkTG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZSwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzOiBib29sZWFuIHwgbnVsbCwgcGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhdGhDb21wYXJlKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcclxuICAgICAgICBzZXRNYXRjaGVzKG1hdGNoZXMpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAke2luZGV4fTogb25Mb2NhbFBhdGhDaGFuZ2UyKHdscDogJHsod2FudGVkTG9jYWxQYXRoID8/IFwibnVsbFwiKS50b1N0cmluZygpfSwgYW1hbmRzOiAkeyhhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MgPz8gXCJudWxsXCIpLnRvU3RyaW5nKCl9LCBwOiAke3BhdGh9KTogJHsobWF0Y2hlcyA/PyBcIm51bGxcIikudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgIGlmIChtYXRjaGVzKVxyXG4gICAgICAgICAgICBzZXRQYXRoV2hlbk1hdGNoaW5nKHBhdGgpO1xyXG5cclxuICAgICAgICBpZiAod2FudGVkTG9jYWxQYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXgsIG1hdGNoZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXgsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICBjb25zdCBbbWF0Y2hlcywgc2V0TWF0Y2hlc10gPSB1c2VTdGF0ZShudWxsIGFzIG51bGwgfCBib29sZWFuKTtcclxuICAgIGNvbnN0IFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gPSB1c2VMb2NhbFBhdGgoe1xyXG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwgfSxcclxuICAgICAgICBsb2NhbFJvdXRlUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKHBhdGgsIHByZXYsIHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlPy4ocGF0aCwgcHJldiwgcmVhc29uKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcclxuICAgICAgICBjb25zdW1lUm91dGVyUmV0dXJuOiB7XHJcbiAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICBtYXRjaGVzLFxyXG4gICAgICAgICAgICBnZXRMb2NhbFBhdGgsXHJcbiAgICAgICAgICAgIHNldExvY2FsUGF0aCxcclxuICAgICAgICAgICAgcGF0aFdoZW5NYXRjaGluZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZUxvY2FsUGF0aCh7IGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwgfSwgbG9jYWxSb3V0ZVBhcmFtZXRlcnM6IHsgb25Mb2NhbFBhdGhDaGFuZ2UgfSB9OiBVc2VMb2NhbFBhdGhQYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9jYWxQYXRoXCIsIGxldmVsKTtcclxuXHJcbiAgICBjb25zdCB1cmxUb1BhdGggPSB1c2VDYWxsYmFjaygodXJsOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh1cmwpLmhhc2gpKTtcclxuICAgICAgICByZXR1cm4gb2xkSGFzaFBhdGhbbGV2ZWxdO1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3QgW2dldExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhvbkxvY2FsUGF0aENoYW5nZSksIHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gdXJsVG9QYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgIH0sIFt1cmxUb1BhdGhdKSk7XHJcblxyXG5cclxuICAgIC8vIEFueSB0aW1lIHRoZSBVUkwgY2hhbmdlcywgaW5zcGVjdCB0aGUgaGFzaFxyXG4gICAgLy8gYXQgb3VyIGN1cnJlbnQgbGV2ZWwsIGFuZCBjaGFuZ2Ugb3VyIGxvY2FsIGNvcHkgb2Ygb3VyIHBhdGhcclxuICAgIC8vIGluIG91ciBwYXNzaXZlIHN0YXRlLiBUaGlzIHdpbGwgdHJpZ2dlciBvdXIgY2FsbGJhY2sgaWYgdGhleSdyZSBkaWZmZXJlbnQuXHJcbiAgICB1c2VVcmwodXJsID0+IHsgc2V0TG9jYWxQYXRoKHVybFRvUGF0aCh1cmwpKTsgfSk7XHJcblxyXG4gICAgcmV0dXJuIFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gYXMgY29uc3Q7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGF0aENvbXBhcmUocmVxdWVzdGVkTG9jYWxIYXNoOiBudWxsIHwgc3RyaW5nIHwgUmVnRXhwIHwgKChsb2NhbEhhc2g6IHN0cmluZykgPT4gYm9vbGVhbiksIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nczogYm9vbGVhbiB8IG51bGwsIGxvY2FsUGF0aDogc3RyaW5nIHwgbnVsbCkge1xyXG4gICAgbGV0IG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgbG9jYWxQYXRoID8/PSBcIlwiO1xyXG5cclxuICAgIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggaW5zdGFuY2VvZiBSZWdFeHApXHJcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2gudGVzdChsb2NhbFBhdGgpKTtcclxuICAgIGVsc2UgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIG1hdGNoZXMgPSAocmVxdWVzdGVkTG9jYWxIYXNoKGxvY2FsUGF0aCkpO1xyXG5cclxuICAgIGVsc2UgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCA9PSBudWxsKVxyXG4gICAgICAgIG1hdGNoZXMgPSAoYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzID09IG51bGwgPyBudWxsIDogIWFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2ggPT09IGxvY2FsUGF0aCk7XHJcblxyXG4gICAgcmV0dXJuIG1hdGNoZXM7XHJcbn1cclxuIiwiXHJcbi8qKlxyXG4gKiBFcnJvciBjbGFzcyB1c2VkIHdoZW4gYXR0ZW1wcyB0byBtb2RpZnkgdGhlIHJvb3QgZGlyZWN0b3J5IG9jY3VyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJvb3RSb3V0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKGBUaGUgcm9vdCBSb3V0ZXIncyBwYXRoIGNhbiBvbmx5IGJlIHB1c2hlZCB0byBhbmQgY2Fubm90IGJlIHNldCBvciBwb3BwZWQgZnJvbS5gKTtcclxuICAgIH1cclxufSAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUm9vdFJvdXRlckVycm9yIH0gZnJvbSBcIi4vcm9vdC1yb3V0ZXItZXJyb3IuanNcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgZGlyZWN0b3J5IGF0IHRoZSBjdXJyZW50IGxldmVsLCBlZmZlY3RpdmVseSByZXR1cm5pbmdcclxuICogdG8gdGhlIHByZXZpb3VzIGxldmVsLiAgWW91IGNhbiBhbHNvIHN3aXRjaCB0byBhIGRpZmZlcmVudFxyXG4gKiBwcmV2aW91cyBsZXZlbCBpZiB5b3Ugd291bGQgbGlrZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xyXG5cclxuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbihkaXI/OiBzdHJpbmcsIGFjdGlvbjogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiA9IFwicHVzaFwiKSB7XHJcbiAgICAgICAgc2V0RW50aXJlSGFzaChwb3BMb2NhbFBhdGgobGV2ZWwsIGRpciksIGFjdGlvbik7XHJcbiAgICB9LCBbbGV2ZWxdKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvcExvY2FsUGF0aChsZXZlbDogbnVtYmVyLCBkaXI/OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgaWYgKGxldmVsIDwgMClcclxuICAgICAgICB0aHJvdyBuZXcgUm9vdFJvdXRlckVycm9yKCk7XHJcbiAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xyXG4gICAgbGV0IG5ld0hhc2hQYXRoID0gb2xkSGFzaFBhdGguc2xpY2UoMCwgbGV2ZWwpLm1hcChzID0+IChzID8/IFwiXCIpKTtcclxuICAgIGlmIChkaXIpIHtcclxuICAgICAgICBkaXIgPSB0cmltSGFzaChkaXIpO1xyXG4gICAgICAgIG5ld0hhc2hQYXRoW25ld0hhc2hQYXRoLmxlbmd0aCAtIDFdID0gZGlyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXdIYXNoUGF0aC5qb2luKFwiL1wiKTtcclxufVxyXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogQWRkcyBhIGRpcmVjdG9yeSBhdCBvbmUgbGV2ZWwgZGVlcGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVB1c2hMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xyXG5cclxuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiBwdXNoTG9jYWxIYXNoKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xyXG4gICAgICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XHJcbiAgICAgICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcclxuICAgICAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBrZWVwVHJhaWxpbmcgPyB1bmRlZmluZWQgOiBsZXZlbCArIDEpLm1hcChzID0+IChzID8/IFwiXCIpKTtcclxuICAgICAgICBuZXdIYXNoUGF0aC5zcGxpY2UobGV2ZWwgKyAxLCAxLCBkaXIpO1xyXG4gICAgICAgIHNldEVudGlyZUhhc2gobmV3SGFzaFBhdGguam9pbihcIi9cIiksIGFjdGlvbik7XHJcbiAgICB9LCBbbGV2ZWxdKTtcclxufVxyXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUm9vdFJvdXRlckVycm9yIH0gZnJvbSBcIi4vcm9vdC1yb3V0ZXItZXJyb3IuanNcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUmVwbGFjZXMgdGhlIGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCB3aXRoIGEgbmV3IG9uZS4gWW91IGNhblxyXG4gKiBjaG9vc2Ugd2hldGhlciBvciBub3QgYW55IHRyYWlsaW5nIHBhdGhzIGFyZSBrZXB0IC0tIGJ5IGRlZmF1bHQgdGhpcyBpcyBmYWxzZS5cclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXRMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xyXG4gICAgICAgIHNldEVudGlyZUhhc2goc2V0TG9jYWxQYXRoKGxldmVsLCBkaXIsIGtlZXBUcmFpbGluZyB8fCBmYWxzZSksIGFjdGlvbik7XHJcbiAgICB9LCBbbGV2ZWxdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TG9jYWxQYXRoKGxldmVsOiBudW1iZXIsIGRpcjogc3RyaW5nLCBrZWVwVHJhaWxpbmc6IGJvb2xlYW4pIHtcclxuICAgIGlmIChsZXZlbCA8IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IFJvb3RSb3V0ZXJFcnJvcigpO1xyXG5cclxuICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XHJcbiAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xyXG4gICAgbGV0IG5ld0hhc2hQYXRoID0gb2xkSGFzaFBhdGguc2xpY2UoMCwga2VlcFRyYWlsaW5nID8gdW5kZWZpbmVkIDogbGV2ZWwgKyAxKS5tYXAocyA9PiAocyA/PyBcIlwiKSk7XHJcbiAgICBuZXdIYXNoUGF0aC5zcGxpY2UobGV2ZWwsIDEsIGRpcik7XHJcbiAgICByZXR1cm4gbmV3SGFzaFBhdGguam9pbihcIi9cIik7XHJcbn1cclxuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlUG9wTG9jYWxQYXRoIH0gZnJvbSBcIi4vdXNlLXBvcC1sb2NhbC1wYXRoLmpzXCI7XHJcbmltcG9ydCB7IHVzZVB1c2hMb2NhbFBhdGggfSBmcm9tIFwiLi91c2UtcHVzaC1sb2NhbC1wYXRoLmpzXCI7XHJcbmltcG9ydCB7IHVzZVNldExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1zZXQtbG9jYWwtcGF0aC5qc1wiO1xyXG5pbXBvcnQgeyBSb3V0ZXJDb250cm9scyB9IGZyb20gXCIuL3V0aWwuanNcIjtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGVhc3kgYWNjZXNzIHRvIHRoZSBjb250cm9scyBhdCB0aGUgY3VycmVudCBsZXZlbC5cclxuICogXHJcbiAqIFlvdSBjYW4gYWxzbyBnZXQgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIGEgY2hpbGQgPFJvdXRlciAvPlxyXG4gKiBieSBwYXNzaW5nIGluIGEgcmVmIChlLmcuIDxSb3V0ZXIgcmVmPXtzZXRDb250cm9sc30gLz4pLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlckNvbnRyb2xzKGxldmVsOiBudW1iZXIpOiBSb3V0ZXJDb250cm9scyB7XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBoYXNoIGF0IHRoaXMgbGV2ZWwgc3BlY2lmaWNhbGx5LCBcclxuICAgIC8vIHNvIGl0IGNvbnRhaW5zIG5vIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxyXG4gICAgY29uc3QgcG9wTG9jYWxQYXRoID0gdXNlUG9wTG9jYWxQYXRoKGxldmVsKTtcclxuICAgIGNvbnN0IHB1c2hMb2NhbFBhdGggPSB1c2VQdXNoTG9jYWxQYXRoKGxldmVsKTtcclxuICAgIGNvbnN0IHNldExvY2FsUGF0aCA9IHVzZVNldExvY2FsUGF0aChsZXZlbCk7XHJcblxyXG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcclxuICAgICAgICBwb3BMb2NhbFBhdGgsXHJcbiAgICAgICAgcHVzaExvY2FsUGF0aCxcclxuICAgICAgICBzZXRMb2NhbFBhdGgsXHJcbiAgICB9KSwgW3BvcExvY2FsUGF0aCwgcHVzaExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSk7XHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgUm91dGVyQ2hpbGRJbmZvLCBSb3V0ZXJDb250ZXh0VHlwZSB9IGZyb20gXCIuL3V0aWwuanNcIjtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Um91dGVyQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcclxuXHJcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVByb3ZpZGVSb3V0ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxSb3V0ZXJDaGlsZEluZm8+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJvdmlkZVJvdXRlclJldHVyblR5cGUgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPFJvdXRlckNoaWxkSW5mbz4ge1xyXG4gICAgY29udGV4dDogUm91dGVyQ29udGV4dFR5cGU7XHJcbn1cclxuXHJcbi8vY29uc3QgUm91dGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Um91dGVyQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgXCJwYXJlbnRcIiBwYXJ0IG9mIGEgcm91dGVyLlxyXG4gKiBcclxuICogVGhpcyBpcyByZXNwb25zaWJsZSBmb3IgY29vcmRpbmF0aW5nLCBhbW9uZyBhbGwgY2hpbGRyZW4sIHdoaWNoIHJvdXRlIHRvIHNob3cuXHJcbiAqIFRoaXMgY29vcmRpbmF0aW9uIGlzIHJlYWxseSBvbmx5IG5lZWRlZCBmb3IgdGhlIFwiZGVmYXVsdFwiIHBhdGh3YXksIHdoaWNoXHJcbiAqIG5lZWRzIHRvIGtub3cgYXMgcGFpbmxlc3NseSBhcyBwb3NzaWJsZSB3aGV0aGVyIGFueSBvZiBpdHMgc2libGluZ3MgYXJlIGN1cnJlbnRseSB2YWxpZC5cclxuICogXHJcbiAqIEl0IGFsc28gaW5jcmVhc2VzIHRoZSBkZXB0aCBieSBvbmUsIHN0YXJ0aW5nIGF0IGRlcHRoPS0xIGZvciB0aGUgcm9vdCByb3V0ZXIgaXMgKmp1c3QqIGEgcGFyZW50LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm92aWRlUm91dGVyKHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9OiBVc2VQcm92aWRlUm91dGVyUGFyYW1ldGVycyk6IFVzZVByb3ZpZGVSb3V0ZXJSZXR1cm5UeXBlIHtcclxuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48Um91dGVyQ2hpbGRJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XHJcbiAgICBjb25zdCB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWwgfSB9ID0gdXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KSA/PyB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWw6IC0xIH0gfVxyXG5cclxuICAgIGNvbnN0IG1hdGNoaW5nSW5kaWNlcyA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKTtcclxuICAgIGNvbnN0IFtnZXRTaG93aW5nRGVmYXVsdCwgc2V0U2hvd2luZ0RlZmF1bHRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4gfCBudWxsLCBuZXZlcj4odXNlU3RhYmxlQ2FsbGJhY2soc2hvd2luZ0RlZmF1bHQgPT4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZC5zZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoIXNob3dpbmdEZWZhdWx0KTtcclxuICAgICAgICB9KVxyXG4gICAgfSksIHJldHVybk51bGwpO1xyXG4gICAgY29uc3Qgb25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgbWF0Y2hlczogYm9vbGVhbiB8IG51bGwpID0+IHtcclxuICAgICAgICBtYXRjaGluZ0luZGljZXMuY3VycmVudFttYXRjaGVzID8gXCJhZGRcIiA6IFwiZGVsZXRlXCJdKGluZGV4KTtcclxuICAgICAgICBzZXRTaG93aW5nRGVmYXVsdChtYXRjaGluZ0luZGljZXMuY3VycmVudC5zaXplID09IDApO1xyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgIHJvdXRlckNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XHJcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxyXG4gICAgICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQ6IG9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuXHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VDb25zdW1lUm91dGVyLCBVc2VDb25zdW1lUm91dGVyUmV0dXJuIH0gZnJvbSBcIi4vdXNlLXJvdXRlci1jb25zdW1lci5qc1wiO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXJDb250cm9scyB9IGZyb20gXCIuL3VzZS1yb3V0ZXItY29udHJvbHMuanNcIjtcclxuaW1wb3J0IHsgUm91dGVyQ29udGV4dCwgdXNlUHJvdmlkZVJvdXRlciB9IGZyb20gXCIuL3VzZS1yb3V0ZXItcHJvdmlkZXIuanNcIjtcclxuaW1wb3J0IHsgUm91dGVyQ29udHJvbHMsIFJvdXRlclBhdGhUeXBlIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjaGlsZHJlbiB0byBkaXNwbGF5LCBnaXZlbiB0aGUgY3VycmVudCBsb2NhbCBwYXRoLCBpZiBvbmUgbWF0Y2hlcy5cclxuICAgICAqIFxyXG4gICAgICogYG51bGxgIHdpbGwgYmUgcGFzc2VkIHdoZW4geW91IHNob3VsZCBoaWRlIHRoZSBjb250ZW50cywgYW5kIHRoZSBzdHJpbmcgdGhhdCBtYXRjaGVkIHdpbGwgYmUgcGFzc2VkIG90aGVyd2lzZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHBhdGhXaGVuTWF0Y2hpbmcgV2hlbiBgbnVsbGAsIGRvbid0IHNob3csIGJlY2F1c2UgdGhlIFVSTCBpc24ndCBvbiB0aGlzIHBhdGguIEFueSBvdGhlciBzdHJpbmcgdmFsdWUgaXMgdGhlIGN1cnJlbnQgcGF0aCB0aGF0IHRoaXMgYFJvdXRlcmAgbWF0Y2hlcy5cclxuICAgICAqIEByZXR1cm5zIFdoYXQgeW91IHdhbnQgdG8gcmVuZGVyLlxyXG4gICAgICovXHJcbiAgICBjaGlsZHJlbjogKHBhdGhXaGVuTWF0Y2hpbmc6IHN0cmluZyB8IG51bGwsIGNvbnRyb2xzOiBSb3V0ZXJDb250cm9scykgPT4gQ29tcG9uZW50Q2hpbGRyZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGF0IHBhdGggb3IgcGF0aHMgdGhpcyBgUm91dGVyYCBzaG91bGQgc2hvdyBpdHNlbGYgb24uXHJcbiAgICAgKiBcclxuICAgICAqIENhbiBiZSBhIHN0cmluZywgUmVnRXhwLCBvciBgKHA6IHN0cmluZykgPT4gYm9vbGVhbmAuIE9yIGBudWxsYCB0byBiZSBhIFwiZGVmYXVsdFwiIGBSb3V0ZXJgLlxyXG4gICAgICogXHJcbiAgICAgKiBcIkRlZmF1bHRcIiBgUm91dGVyYHMgKGBsb2NhcFBhdGg9e251bGx9YCkgYXJlIHNob3duIHdoZW4gbm8gb3RoZXIgYFJvdXRlcmAgYXQgdGhlIHNhbWUgbGV2ZWwgbWF0Y2hlcy5cclxuICAgICAqL1xyXG4gICAgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsLiBJZiB5b3Ugd291bGQgbGlrZSB0byBrbm93IHdoYXQgdGhlIGN1cnJlbnQgcGF0aCBpcyBldmVuIHdoZW4gbm90IGN1cnJlbnRseSBiZWluZyBzaG93biwgeW91IGNhbiBnZXQgdGhhdCBpbmZvcm1hdGlvbiBoZXJlLlxyXG4gICAgICogXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBwYXNzIGEgbm9ybWFsIGBzZXRTdGF0ZWAgZnVuY3Rpb24gaGVyZS5cclxuICAgICAqL1xyXG4gICAgb25Mb2NhbFBhdGhDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB5b3UgdG8gY29uZGl0aW9uYWxseSBoaWRlL3Nob3cgY29udGVudCBiYXNlZCBvbiBhIHBhdGggaW4gdGhlIGhhc2ggY29tcG9uZW50IG9mIHRoZSBVUkwuXHJcbiAqIFxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcGFyYW0gcmVmIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoeyBsb2NhbFBhdGgsIG9uTG9jYWxQYXRoQ2hhbmdlLCBjaGlsZHJlbiB9OiBSb3V0ZXJQcm9wcywgcmVmPzogUmVmPGFueT4pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFJvdXRlckNvbnRleHQpO1xyXG5cclxuICAgIGNvbnN0IHsgY29udGV4dDogY29udGV4dEZyb21QYXJlbnQsIG1hbmFnZWRDaGlsZHJlblJldHVybiB9ID0gdXNlUHJvdmlkZVJvdXRlcih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9IH0pO1xyXG4gICAgY29uc3QgaW5kZXggPSB1c2VNZW1vKCgpID0+ICgobG9jYWxQYXRoID8/IFwiPGRlZmF1bHQ+XCIpICsgYC0ke01hdGgucmFuZG9tKCl9YCksIFtsb2NhbFBhdGhdKTtcclxuICAgIGxldCBjb25zdW1lUm91dGVyUmV0dXJuOiBVc2VDb25zdW1lUm91dGVyUmV0dXJuIHwgbnVsbCA9IG51bGw7XHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJSb3V0ZXJcIiwgISFjb250ZXh0KTtcclxuXHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm4gPSB1c2VDb25zdW1lUm91dGVyKHsgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHsgbG9jYWxQYXRoLCBvbkxvY2FsUGF0aENoYW5nZSB9LCBjb250ZXh0LCBpbmZvOiB7IGluZGV4IH0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsLCBtYXRjaGVzLCBwYXRoV2hlbk1hdGNoaW5nIH0gfSA9IGNvbnN1bWVSb3V0ZXJSZXR1cm4gPz8geyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsOiAtMSwgbWF0Y2hlczogbnVsbCwgcGF0aFdoZW5NYXRjaGluZzogbnVsbCB9IH1cclxuXHJcbiAgICBjb25zdCBjb250cm9scyA9IHVzZVJvdXRlckNvbnRyb2xzKGxldmVsKTtcclxuXHJcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+ICh7XHJcbiAgICAgICAgbGV2ZWwsXHJcbiAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICBwYXRoV2hlbk1hdGNoaW5nLFxyXG4gICAgICAgIC4uLmNvbnRyb2xzXHJcbiAgICB9KSlcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0RnJvbVBhcmVudH0+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbihsZXZlbCA9PSAtMSA/IFwiL1wiIDogbWF0Y2hlcyA/IHBhdGhXaGVuTWF0Y2hpbmcgOiBudWxsLCB1c2VSb3V0ZXJDb250cm9scyhsZXZlbCkpfVxyXG4gICAgICAgIDwvUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuIiwiXHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcclxuaW1wb3J0IHsgcGFyc2VQYXJhbSwgVHlwZU1hcCwgdW5wYXJzZVBhcmFtIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgT25QYXJhbVZhbHVlQ2hhbmdlZDxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+ID0gT25QYXNzaXZlU3RhdGVDaGFuZ2U8VHlwZU1hcFtUXSB8IG51bGwsIG5ldmVyPjsgLy8odmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsLCByZWFzb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSA9PiB2b2lkO1xyXG5leHBvcnQgdHlwZSBTZXRQYXJhbVdpdGhIaXN0b3J5PFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4gPSAodmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsIHwgKChwcmV2VmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsKSA9PiAoVHlwZU1hcFtUXSB8IG51bGwpKSwgcmVhc29uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikgPT4gdm9pZDtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW0ncyB2YWx1ZVxyXG4gKiBcclxuICogTm90ZSB0aGF0IHdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgbGlrZSB1c2VQYXNzaXZlU3RhdGUgKGl0c2VsZiBsaWtlIHVzZVN0YXRlIGFuZCB1c2VFZmZlY3QgY29tYmluZWQpLFxyXG4gKiB0aGUgYHNldFN0YXRlYCByZXR1cm4gZnVuY3Rpb24gaXMsIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLCBub3Qgc3luY3Jvbm91cywgYnV0IHRoYXQnc1xyXG4gKiBsaWtlIG1vc3QgY2FsbHMgdG8gYHNldFN0YXRlYCBhbnl3YXkgSSBndWVzcz9cclxuICogXHJcbiAqIEBwYXJhbSBwYXJhbUtleSBUaGUgbmFtZSBvZiB0aGUgVVJMIHNlYXJjaCBwYXJhbWV0ZXIgdG8gcmVmZXJlbmNlIFxyXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBkYXRhIGVuY29kZS9kZWNvZGUgKGBcInN0cmluZ1wiYCB8IGBcImJvb2xlYW5cImAgfCBgXCJudW1iZXJcImAgfCBgXCJiaWdpbnRcImApXHJcbiAqIEBwYXJhbSBvblBhcmFtVmFsdWVDaGFuZ2VkIFdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtZXRlcidzIHZhbHVlIGNoYW5nZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4ocGFyYW1LZXk6IHN0cmluZywgdHlwZTogVCwgb25QYXJhbVZhbHVlQ2hhbmdlZD86IE9uUGFyYW1WYWx1ZUNoYW5nZWQ8VD4pIHtcclxuXHJcbiAgICAvLyBXZSBrZWVwIGEgbG9jYWwgY29weSBvZiBvdXIgY3VycmVudCBTZWFyY2ggUGFyYW0gdmFsdWVcclxuICAgIC8vIGJlY2F1c2UgY2hhbmdpbmcgaXQgaXMgYWN0dWFsbHkgYW4gYXN5bmNyb25vdXMgb3BlcmF0aW9uXHJcbiAgICAvLyBhbmQgd2UgY2FuJ3Qga25vdyB3aGVuIGl0IGVuZHMgYXNpZGUgZnJvbSBqdXN0IFwiZGlkIHRoZSBVUkwgY2hhbmdlIG9yIG5vdFwiXHJcbiAgICAvLyBzbyB3ZSBtaWdodCBhcyB3ZWxsIGtlZXAgdGhpcyBzdGF0ZSBhcm91bmQgbG9jYWxseSB0byBjb21wZW5zYXRlLlxyXG4gICAgY29uc3QgW2dldFNhdmVkUGFyYW1WYWx1ZSwgc2V0U2F2ZWRQYXJhbVZhbHVlXSA9IHVzZVBhc3NpdmVTdGF0ZTxUeXBlTWFwW1RdIHwgbnVsbCwgbmV2ZXI+KG9uUGFyYW1WYWx1ZUNoYW5nZWQsIHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKSwgcGFyYW1LZXksIHR5cGUpO1xyXG4gICAgfSwgW10pKTtcclxuICAgIGNvbnN0IHNldFBhcmFtV2l0aEhpc3RvcnkgPSB1c2VTdGFibGVDYWxsYmFjazxTZXRQYXJhbVdpdGhIaXN0b3J5PFQ+PigobmV3VmFsdWVPclVwZGF0ZXIsIHJlYXNvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpID0+IHtcclxuXHJcbiAgICAgICAgbGV0IHByZXZWYWx1ZSA9IHBhcnNlUGFyYW0obmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSksIHBhcmFtS2V5LCB0eXBlKTtcclxuICAgICAgICBsZXQgbmV4dFZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCA9ICh0eXBlb2YgbmV3VmFsdWVPclVwZGF0ZXIgPT0gXCJmdW5jdGlvblwiPyBuZXdWYWx1ZU9yVXBkYXRlcihwcmV2VmFsdWUpIDogbmV3VmFsdWVPclVwZGF0ZXIpO1xyXG5cclxuICAgICAgICBsZXQgbmV3UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuc2VhcmNoUGFyYW1zKSk7XHJcbiAgICAgICAgdW5wYXJzZVBhcmFtKG5ld1BhcmFtcywgcGFyYW1LZXksIG5leHRWYWx1ZSBhcyBUeXBlTWFwW1RdLCB0eXBlKTtcclxuICAgICAgICBsZXQgbmV4dFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIG5leHRVcmwuc2VhcmNoID0gcHJldHR5UHJpbnRQYXJhbXMobmV3UGFyYW1zKTtcclxuICAgICAgICBoaXN0b3J5W2Ake3JlYXNvbiA/PyBcInJlcGxhY2VcIn1TdGF0ZWBdKHt9LCBkb2N1bWVudC50aXRsZSwgbmV4dFVybCk7XHJcbiAgICAgICAgc2V0U2F2ZWRQYXJhbVZhbHVlKG5leHRWYWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gQW55IHRpbWUgdGhlIFVSTCBjaGFuZ2VzLCBpdCBtZWFucyB0aGUgU2VhcmNoIFBhcmFtIHdlIGNhcmUgYWJvdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgLy8gUGFyc2UgaXQgb3V0IGFuZCBzYXZlIGl0LlxyXG4gICAgdXNlVXJsKHVzZVN0YWJsZUNhbGxiYWNrKHVybCA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW0gPSBwYXJzZVBhcmFtKG5ldyBVUkwodXJsKSwgcGFyYW1LZXksIHR5cGUpO1xyXG4gICAgICAgIHNldFNhdmVkUGFyYW1WYWx1ZShuZXdQYXJhbSk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgcmV0dXJuIFtnZXRTYXZlZFBhcmFtVmFsdWUsIHNldFBhcmFtV2l0aEhpc3RvcnldIGFzIGNvbnN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmV0dHlQcmludFBhcmFtcyhwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcykge1xyXG4gICAgY29uc3QgcGFyYW1BcnJheSA9IFsuLi5wYXJhbXMuZW50cmllcygpXS5maWx0ZXIoKGtleSwgdmFsdWUpID0+IHZhbHVlICE9IG51bGwpO1xyXG4gICAgaWYgKHBhcmFtQXJyYXkubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG5cclxuICAgIGxldCBxdWVyeVN0cmluZyA9IHBhcmFtQXJyYXkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIgfHwgKHZhbHVlIGFzIGFueSkgPT09IHRydWUpXHJcbiAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX1gO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcclxuICAgIH0pLmpvaW4oXCImXCIpO1xyXG5cclxuICAgIHJldHVybiBgPyR7cXVlcnlTdHJpbmd9YDtcclxuXHJcbn1cclxuIixudWxsXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJkZWZlciIsImRlcHRoU29ydCIsImkiLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJhc3NpZ24iLCJvYmoiLCJwcm9wcyIsInJlbW92ZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJjaGlsZHJlbiIsImtleSIsInJlZiIsIm5vcm1hbGl6ZWRQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZSIsIm9yaWdpbmFsIiwidm5vZGUiLCJfX2siLCJfXyIsIl9fYiIsIl9fZSIsIl9fZCIsIl9fYyIsIl9faCIsImNvbnN0cnVjdG9yIiwiX192IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwidGhpcyIsImdldERvbVNpYmxpbmciLCJjaGlsZEluZGV4IiwiaW5kZXhPZiIsInNpYmxpbmciLCJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsImNoaWxkIiwiYmFzZSIsImVucXVldWVSZW5kZXIiLCJjIiwicHVzaCIsInByb2Nlc3MiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsInckMiIsInJlbmRlclF1ZXVlTGVuZ3RoIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsInNvcnQiLCJzaGlmdCIsIl9fUCIsImRpZmYiLCJfX24iLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJnZXRMYXN0RG9tIiwibmV4dFNpYmxpbmciLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJzb21lIiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJsYXN0RG9tIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIlByb21pc2UiLCJ0aGVuIiwiYmluZCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZiQyIiwiYSIsImIiLCJpc1N0YXRpY0NoaWxkcmVuIiwiX19zb3VyY2UiLCJfX3NlbGYiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldmlvdXNDb21wb25lbnQiLCJwcmV2UmFmIiwiY3VycmVudEhvb2siLCJhZnRlclBhaW50RWZmZWN0cyIsIkVNUFRZIiwib2xkQmVmb3JlRGlmZiIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJnZXRIb29rU3RhdGUiLCJpbmRleCIsImhvb2tzIiwiX19IIiwiX19WIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiaW52b2tlT3JSZXR1cm4iLCJyZWR1Y2VyIiwiaW5pdCIsImhvb2tTdGF0ZSIsIl9yZWR1Y2VyIiwiYWN0aW9uIiwiY3VycmVudFZhbHVlIiwiX19OIiwibmV4dFZhbHVlIiwiX2hhc1NjdUZyb21Ib29rcyIsInVwZGF0ZUhvb2tTdGF0ZSIsImYiLCJwIiwic3RhdGVIb29rcyIsImZpbHRlciIsIngiLCJldmVyeSIsInByZXZTY3UiLCJzaG91bGRVcGRhdGUiLCJob29rSXRlbSIsInByZXZDV1UiLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUhhbmRsZSIsImNvbmNhdCIsImZhY3RvcnkiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiaW52b2tlQ2xlYW51cCIsImludm9rZUVmZmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFmdGVyTmV4dEZyYW1lIiwiaGFzRXJyb3JlZCIsIkhBU19SQUYiLCJyYWYiLCJkb25lIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaG9vayIsImNvbXAiLCJjbGVhbnVwIiwib2xkQXJncyIsIm5ld0FyZ3MiLCJhcmciLCJjYWNoZWQiLCJnZXRCdWlsZE1vZGVVbm1lbW9pemVkIiwiZ2V0QnVpbGRNb2RlVW5tZW1vaXplZCQxIiwiZW52IiwiTk9ERV9FTlYiLCJfZSIsIl9wcm9jZXNzIiwiX2dsb2JhbFRoaXMkX3Byb2Nlc3MiLCJfZ2xvYmFsVGhpcyRwcm9jZXNzIiwiX2VudiIsIl9nbG9iYWxUaGlzJHByb2Nlc3MkXyIsIl9nbG9iYWxUaGlzJHByb2Nlc3MkZSIsIl9OT0RFX0VOViIsIl9nbG9iYWxUaGlzJHByb2Nlc3MkZTIiLCJnbG9iYWxUaGlzIiwiZ2V0QnVpbGRNb2RlIiwiZ2V0QnVpbGRNb2RlJDEiLCJfY2FjaGVkJCIsIm5vb3AiLCJub29wJDEiLCJfd2luZG93JHJlcXVlc3RJZGxlQ2EiLCJfd2luZG93Iiwid2luZG93IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiY2FsbENvdW50VSIsImNhbGxDb3VudFUkMSIsIlNldCIsInVzZUVuc3VyZVN0YWJpbGl0eSIsInVzZUVuc3VyZVN0YWJpbGl0eSQxIiwicGFyZW50SG9va05hbWUiLCJfbGVuIiwidmFsdWVzIiwiX2tleSIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsInVzZUhlbHBlciIsImNvbnNvbGUiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVib3VuY2VSZW5kZXJpbmckMSIsIl9sJDIkZGVib3VuY2VSZW5kZXJpbiIsInF1ZXVlTWljcm90YXNrIiwidXNlUGFzc2l2ZVN0YXRlIiwidXNlUGFzc2l2ZVN0YXRlJDEiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiX29uQ2hhbmdlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm4iLCJzZXRWYWx1ZSIsInJlYXNvbiIsIkZ1bmN0aW9uIiwibmV4dFJlYXNvbiIsIm5leHREZXAiLCJwcmV2RGVwIiwiX29uQ2hhbmdlMiIsIlN5bWJvbCIsInJldHVybk51bGwiLCJyZXR1cm5OdWxsJDEiLCJydW5JbW1lZGlhdGVseSIsInJ1bkltbWVkaWF0ZWx5JDEiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsInVzZU1lcmdlZENoaWxkcmVuJDEiLCJsaHMiLCJyaHMiLCJyJDEiLCJ0IiwibiIsImNsc3giLCJjbHN4JDEiLCJ1c2VNZXJnZWRDbGFzc2VzIiwidXNlTWVyZ2VkQ2xhc3NlcyQxIiwibGhzQ2xhc3MiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiZnJvbSIsImpvaW4iLCJ0b1J1biIsIk1hcCIsImNvbW1pdE5hbWUiLCJuZXdDb21taXQiLCJuZXdDb21taXQkMSIsImlkIiwiZWZmZWN0SW5mbyIsIm9sZElucHV0cyIsInByZXZJbnB1dHMiLCJpbnB1dHMiLCJfZWZmZWN0SW5mbyRjbGVhbnVwIiwiZWZmZWN0IiwiY2xlYXIiLCJfbGVuMiIsIl9rZXkyIiwib3JpZ2luYWxDb21taXQiLCJpbmNyZW1lbnRpbmdJZCIsIm5leHRJZCIsIm5leHRJZCQxIiwibmV4dCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QkMSIsIl9yZWYkY3VycmVudCIsInNldCIsImRlbGV0ZSIsImFyZ3NDaGFuZ2VkJDEiLCJ1c2VTdGFibGVHZXR0ZXIiLCJ1c2VTdGFibGVHZXR0ZXIkMSIsIkVycm9yIiwidXNlU3RhYmxlT2JqZWN0IiwidXNlU3RhYmxlT2JqZWN0JDEiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiX3JlZiIsIl9rIiwidiIsIldlYWtNYXAiLCJpc1N0YWJsZUdldHRlciIsImlzU3RhYmxlR2V0dGVyJDEiLCJfbWFwJDEkZ2V0IiwiZ2V0Iiwic2V0SXNTdGFibGVHZXR0ZXIiLCJzZXRJc1N0YWJsZUdldHRlciQxIiwidXNlU3RhYmxlQ2FsbGJhY2siLCJ1c2VTdGFibGVDYWxsYmFjayQxIiwiZm4iLCJub0RlcHMiLCJjdXJyZW50Q2FsbGJhY2tHZXR0ZXIiLCJ1c2VDYWxsYmFja05hdGl2ZSIsImFzc2VydCIsInByb2Nlc3NSZWYiLCJwcm9jZXNzUmVmJDEiLCJpbnN0YW5jZSIsInVzZU1lcmdlZFJlZnMiLCJ1c2VNZXJnZWRSZWZzJDEiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJzdHlsZVN0cmluZ1RvT2JqZWN0JDEiLCJmcm9tRW50cmllcyIsInN0YXRlbWVudCIsInVzZU1lcmdlZFN0eWxlcyIsInVzZU1lcmdlZFN0eWxlcyQxIiwibG9nIiwidXNlTWVyZ2VkUHJvcHMiLCJ1c2VNZXJnZWRQcm9wcyQxIiwiX2xlbjMiLCJhbGxQcm9wcyIsIl9rZXkzIiwicmV0IiwibmV4dFByb3BzIiwidXNlTWVyZ2VkUHJvcHMyIiwia25vd25zIiwibWVyZ2VVbmtub3duIiwibWVyZ2VVbmtub3duJDEiLCJsaHNWYWx1ZSIsInJoc1ZhbHVlIiwibWVyZ2VkIiwibWVyZ2VGdW5jdGlvbnMiLCJ1c2VNZXJnZWRQcm9wczIkMSIsImxoc0FsbCIsInJoc0FsbCIsImNsYXNzTmFtZSIsImxoc0tleVUiLCJsaHNLZXkiLCJoYXMiLCJyaHNLZXlVIiwicmhzS2V5IiwibWVyZ2VGdW5jdGlvbnMkMSIsImx2IiwicnYiLCJhbGwiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4kMSIsInBhcmVudFBhcmFtZXRlcnMiLCJtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIiwib25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Iiwib25DaGlsZHJlbk1vdW50Q2hhbmdlIiwib25DaGlsZHJlbkNvdW50Q2hhbmdlIiwicmVzdCIsImdldEhpZ2hlc3RJbmRleCIsIm1hbmFnZWRDaGlsZHJlbkFycmF5IiwiaGlnaGVzdEluZGV4IiwiYXJyIiwicmVjIiwibG93ZXN0SW5kZXgiLCJmb3JFYWNoQ2hpbGQiLCJmaWVsZCIsImdldE1hbmFnZWRDaGlsZEluZm8iLCJoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIiwic2l6ZSIsImFkZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsImdldENoaWxkcmVuIiwiTWF0aCIsIm1heCIsInNoYXZlIiwibWFuYWdlZENoaWxkcmVuIiwiXyIsImdldEF0IiwiYXJyYXlTbGljZSIsIm1hbmFnZWRDaGlsZENvbnRleHQiLCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4iLCJ1c2VNYW5hZ2VkQ2hpbGQiLCJ1c2VNYW5hZ2VkQ2hpbGQkMSIsIl9yZWYyIiwiaW5mbyIsImZsYXQiLCJtYW5hZ2VkQ2hpbGRSZXR1cm4iLCJ1c2VTdGF0ZSQxIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwicHJldlZhbHVlIiwiZ2V0U3RhdGUiLCJ1c2VHbG9iYWxIYW5kbGVyIiwidGFyZ2V0IiwiaGFuZGxlciIsIm1vZGUiLCJ1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZCIsInVzZUdsb2JhbEhhbmRsZXJTaW5nbGUiLCJtYXBUaGluZyIsImRvTWFwVGhpbmciLCJvcCIsIm9wdGlvbnNLZXkiLCJieVR5cGUiLCJieU9wdGlvbnMiLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsImFkZFRvTWFwVGhpbmciLCJoIiwicmVtb3ZlRnJvbU1hcFRoaW5nIiwic3RhYmxlSGFuZGxlciIsInVzZVJlZkVsZW1lbnQiLCJ1c2VSZWZFbGVtZW50JDEiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwicmVmRWxlbWVudFBhcmFtZXRlcnMiLCJnZXRFbGVtZW50Iiwic2V0RWxlbWVudCIsInByb3BzU3RhYmxlIiwicmVmRWxlbWVudFJldHVybiIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsIl90b3BDaGFuZ2VkIiwiX3N3YXBJbmVydGVkU2libGluZyIsIl9pbmVydFNpYmxpbmdzIiwiX3Jlc3RvcmVJbmVydGVkU2libGluZ3MiLCJfZ2V0UGFyZW50cyIsIl9nZXREaXN0cmlidXRlZENoaWxkcmVuIiwiX2lzSW5lcnRhYmxlIiwiX2hhbmRsZU11dGF0aW9ucyIsIkJsb2NraW5nRWxlbWVudHNJbXBsIiwiX2EiLCJfYiIsIl9jIiwiZGVzdHJ1Y3RvciIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJlbGVtZW50IiwicmVtb3ZlIiwicG9wIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsImJvZHkiLCJ0b1NraXAiLCJvbGRJbmVydCIsIm5ld0luZXJ0Iiwic2libGluZ3NUb1Jlc3RvcmUiLCJpbmVydCIsImVsZW1lbnRzIiwibW8iLCJkaXNjb25uZWN0Iiwic2libGluZ3MiLCJwYXJlbnQiLCJpbmVydGVkU2libGluZ3MiLCJNdXRhdGlvbk9ic2VydmVyIiwicGFyZW50VG9PYnNlcnZlIiwibWF5YmVTaGFkeVJvb3QiLCJfX3NoYWR5IiwiaG9zdCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJyZW1vdmVkTm9kZXMiLCJhZGRlZE5vZGVzIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImFzc2lnbmVkU2xvdCIsInNoYWRvd1Jvb3QiLCJyZXN1bHQiLCJub2RlcyIsInNsb3RzIiwicXVlcnlTZWxlY3RvckFsbCIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiJGJsb2NraW5nRWxlbWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NDYWxsQ2hlY2skMSIsIlR5cGVFcnJvciIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiX29uTXV0YXRpb24iLCJzdWJ0cmVlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsIl9vbkRvY3VtZW50TG9hZGVkIiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJpbmVydEVsZW1lbnQiLCJfdGhpcyIsInVuc2hpZnQiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJfaSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsIkhUTUxFbGVtZW50IiwiaGFzT3duUHJvcGVydHkiLCJzaGFsbG93RGlmZmVycyIsIlB1cmVDb21wb25lbnQiLCJtZW1vIiwiY29tcGFyZXIiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiX19mIiwiUkVBQ1RfRk9SV0FSRF9TWU1CT0wiLCJmb3IiLCJmb3J3YXJkUmVmIiwiRm9yd2FyZGVkIiwiY2xvbmUiLCIkJHR5cGVvZiIsIm9sZENhdGNoRXJyb3IiLCJvbGRVbm1vdW50IiwiZGV0YWNoZWRDbG9uZSIsImRldGFjaGVkUGFyZW50IiwicmVtb3ZlT3JpZ2luYWwiLCJvcmlnaW5hbFBhcmVudCIsIlN1c3BlbnNlIiwiX191IiwiX3N1c3BlbmRlcnMiLCJzdXNwZW5kZWQiLCJfX2EiLCJTdXNwZW5zZUxpc3QiLCJfbmV4dCIsIl9tYXAiLCJfX1IiLCJwcm9taXNlIiwic3VzcGVuZGluZ1ZOb2RlIiwic3VzcGVuZGluZ0NvbXBvbmVudCIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJfX08iLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsImZhbGxiYWNrIiwiVyIsImxpc3QiLCJyZXZlYWxPcmRlciIsImRlbGVnYXRlZCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJyZXZlcnNlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiQ0FNRUxfUFJPUFMiLCJPTl9BTkkiLCJDQU1FTF9SRVBMQUNFIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJxIiwib2xkRXZlbnRIb29rIiwiZW1wdHkiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwZXJzaXN0IiwibmF0aXZlRXZlbnQiLCJjbGFzc05hbWVEZXNjcmlwdG9yTm9uRW51bWJlcmFibGUiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsImxvd2VyQ2FzZWQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwiaGFuZGxlRG9tVk5vZGUiLCJvbGREaWZmZWQiLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJodG1sVG9FbGVtZW50IiwiaHRtbFRvRWxlbWVudCQxIiwiaHRtbCIsIl90ZW1wbGF0ZUVsZW1lbnQkIiwib3duZXJEb2N1bWVudCIsInRyaW0iLCJJbXBlcmF0aXZlRWxlbWVudFUiLCJ1c2VJbXBlcmF0aXZlUHJvcHMiLCJ1c2VJbXBlcmF0aXZlUHJvcHMkMSIsIl9yZWYzIiwiY3VycmVudEltcGVyYXRpdmVQcm9wcyIsIm90aGVycyIsImhhc0NsYXNzIiwiY2xzIiwic2V0Q2xhc3MiLCJlbmFibGVkIiwiX2dldEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJwcm9wIiwic3RhcnRzV2l0aCIsInJlbW92ZVByb3BlcnR5Iiwic2V0Q2hpbGRyZW4iLCJkYW5nZXJvdXNseUFwcGVuZEhUTUwiLCJuZXdDaGlsZCIsIl9nZXRFbGVtZW50MiIsIl9nZXRFbGVtZW50MyIsInNldEV2ZW50SGFuZGxlciIsIm1hcHBlZEtleSIsIkV2ZW50TWFwcGluZyIsImltcGVyYXRpdmVIYW5kbGUiLCJJbXBlcmF0aXZlRWxlbWVudFUkMSIsIl9yZWY0IiwidGFnIiwiVGFnIiwiaGFuZGxlIiwiaXByb3BzIiwiYWJvcnQiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25zdGFydCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImJlZm9yZWlucHV0IiwiY2FucGxheSIsImNhbnBsYXl0aHJvdWdoIiwiY2hhbmdlIiwiY2xpY2siLCJjb21wb3NpdGlvbmVuZCIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbnVwZGF0ZSIsImNvbnRleHRtZW51IiwiY3V0IiwiZGJsY2xpY2siLCJkcmFnIiwiZHJhZ2VuZCIsImRyYWdlbnRlciIsImRyYWdsZWF2ZSIsImRyYWdvdmVyIiwiZHJhZ3N0YXJ0IiwiZHJvcCIsImR1cmF0aW9uY2hhbmdlIiwiZW1wdGllZCIsImVuZGVkIiwiZm9jdXNpbiIsImZvY3Vzb3V0IiwiZm9ybWRhdGEiLCJnb3Rwb2ludGVyY2FwdHVyZSIsImlucHV0IiwiaW52YWxpZCIsImtleWRvd24iLCJrZXlwcmVzcyIsImtleXVwIiwibG9hZCIsImxvYWRlZGRhdGEiLCJsb2FkZWRtZXRhZGF0YSIsImxvYWRzdGFydCIsImxvc3Rwb2ludGVyY2FwdHVyZSIsIm1vdXNlZG93biIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwibW91c2Vtb3ZlIiwibW91c2VvdXQiLCJtb3VzZW92ZXIiLCJtb3VzZXVwIiwicGFzdGUiLCJwYXVzZSIsInBsYXkiLCJwbGF5aW5nIiwicG9pbnRlcmNhbmNlbCIsInBvaW50ZXJkb3duIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm1vdmUiLCJwb2ludGVyb3V0IiwicG9pbnRlcm92ZXIiLCJwb2ludGVydXAiLCJwcm9ncmVzcyIsInJlc2V0Iiwic2Nyb2xsIiwic2Vla2VkIiwic2Vla2luZyIsInNlbGVjdCIsInN0YWxsZWQiLCJzdWJtaXQiLCJzdXNwZW5kIiwidGltZXVwZGF0ZSIsInRvZ2dsZSIsInRvdWNoY2FuY2VsIiwidG91Y2hlbmQiLCJ0b3VjaG1vdmUiLCJ0b3VjaHN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInZvbHVtZWNoYW5nZSIsIndhaXRpbmciLCJ3aGVlbCIsIl9wcm9jZXNzMiIsIl9nbG9iYWxUaGlzJF9wcm9jZXNzMiIsIl9nbG9iYWxUaGlzJHByb2Nlc3MyIiwiX2VudjIiLCJfZ2xvYmFsVGhpcyRwcm9jZXNzMiQiLCJfZ2xvYmFsVGhpcyRwcm9jZXNzJGUzIiwiX05PREVfRU5WMiIsIl9nbG9iYWxUaGlzJHByb2Nlc3MkZTQiLCJfY2FjaGVkIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVHbG9iYWwkMSIsImZyZWVTZWxmIiwicm9vdCQxIiwiU3ltYm9sJDIiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnIiwiaXNPd24iLCJ1bm1hc2tlZCIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdCIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImNvcmVKc0RhdGEiLCJjb3JlSnNEYXRhJDEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsImlzTWFza2VkIiwiZnVuYyIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJvYmplY3QiLCJnZXROYXRpdmUiLCJlcSIsIm90aGVyIiwibmF0aXZlQ3JlYXRlIiwibmF0aXZlQ3JlYXRlJDEiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJlbnRyeSIsImxpc3RDYWNoZUNsZWFyIiwiYXNzb2NJbmRleE9mIiwiYXJyYXkiLCJhcnJheVByb3RvIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiTWFwJDIiLCJtYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsImFwcGx5IiwiY2FjaGUiLCJDYWNoZSIsIl93aW5kb3cyJHJlcXVlc3RJZGxlQyIsIl93aW5kb3cyIiwiX2xlbjQiLCJfa2V5NCIsIl9sJDIkZGVib3VuY2VSZW5kZXJpbjIiLCJfb25DaGFuZ2UzIiwiX29uQ2hhbmdlNCIsInJldHVybkZhbHNlIiwiX2VmZmVjdEluZm8kY2xlYW51cDIiLCJfbGVuNSIsIl9rZXk1IiwiX3JlZiRjdXJyZW50MiIsIl9yZWY1IiwiX21hcCRnZXQiLCJfbGVuNiIsIl9rZXk2IiwiX3JlZjYiLCJ1c2VDaGlsZHJlbkZsYWciLCJfcmVmNyIsImluaXRpYWxJbmRleCIsImNsb3Nlc3RGaXQiLCJvbkluZGV4Q2hhbmdlIiwic2V0QXQiLCJpc1ZhbGlkIiwiZ2V0Q3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiZ2V0UmVxdWVzdGVkSW5kZXgiLCJzZXRSZXF1ZXN0ZWRJbmRleCIsImdldENsb3Nlc3RGaXQiLCJyZXF1ZXN0ZWRJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY2xvc2VzdEluZGV4IiwibmV3RGlzdGFuY2UiLCJhYnMiLCJyZWV2YWx1YXRlQ2xvc2VzdEZpdCIsImN1cnJlbnRDaGlsZCIsImNsb3Nlc3RGaXRJbmRleCIsImNsb3Nlc3RGaXRDaGlsZCIsImNoYW5nZUluZGV4IiwibmV3TWF0Y2hpbmdDaGlsZCIsIm9sZE1hdGNoaW5nQ2hpbGQiLCJjaGlsZElzVmFsaWQiLCJfdGVtcGxhdGVFbGVtZW50IiwiX3JlZjgiLCJfZ2V0RWxlbWVudDQiLCJfZ2V0RWxlbWVudDUiLCJfZ2V0RWxlbWVudDYiLCJfcmVmOSIsImdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24iLCJleGNsdXNpdml0eUtleSIsIlN3YXBwYWJsZUNvbnRleHQiLCJnZXRBbmltYXRlT25Nb3VudCIsIkdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0IiwiQ3NzQ2xhc3NDb250ZXh0IiwiR2V0QmFzZUNsYXNzIiwiR2V0RW50ZXJDbGFzcyIsIkdldEV4aXRDbGFzcyIsIkdldE1lYXN1cmVDbGFzcyIsIkdldEluaXRDbGFzcyIsIkdldFRyYW5zaXRpb25DbGFzcyIsIkdldEZpbmFsaXplQ2xhc3MiLCJ1c2VDc3NDbGFzc2VzIiwiR2V0RGlyZWN0aW9uQ2xhc3MiLCJkaXJlY3Rpb24iLCJHZXRQaGFzZUNsYXNzIiwicGhhc2UiLCJnbG9iYWxDb3VudCIsIkV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlciIsIl9yZWYxMCIsImdldE5leHRJbmRleEluTGluZSIsInNldE5leHRJbmRleEluTGluZSIsIm0iLCJzZXRFeGNsdXNpdmVseU9wZW4iLCJnZXRFeGNsdXNpdmVseU9wZW4iLCJvblZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmxlIiwibmV4dEluTGluZSIsImN1cnJlbnRJbkxpbmUiLCJfZ2V0Q2hpbGRyZW4kZ2V0QXQiLCJfZ2V0Q2hpbGRyZW4kZ2V0QXQkZm8iLCJmb3JjZUNsb3NlIiwiY29udGV4dDIiLCJleGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIkV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0IiwiX2pzeCIsInVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24iLCJfcmVmMTEiLCJ0cmFuc2l0aW9uUGFyYW1ldGVycyIsInNob3ciLCJleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVycyIsImV4Y2x1c2l2ZWx5T3BlbiIsInBhcmVudE9uVmlzQ2hhbmdlIiwiZXhjbHVzaXZlVHJhbnNpdGlvblJldHVybiIsImlzRXhjbHVzaXZlIiwiZm9yd2FyZEVsZW1lbnRSZWYiLCJGb3J3YXJkZWRDb21wb25lbnQiLCJ1c2VMYXN0Tm9uTnVsbFZhbHVlIiwibGFzdE5vbk51bGxWYWx1ZSIsInVzZUNyZWF0ZVN3YXBwYWJsZVByb3BzIiwiX3JlZjEyIiwib3RoZXJQcm9wcyIsImlubGluZSIsIlN3YXBwYWJsZSIsIl9yZWYxMyIsIl9pbmxpbmUiLCJjaGlsZHJlbkFuaW1hdGVPbk1vdW50IiwiaW5saW5lRWxlbWVudHMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtZXJnZWRXaXRoQ2hpbGRyZW4iLCJhbmltYXRlT25Nb3VudCIsImdldFRpbWVvdXREdXJhdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic3RyIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJwYXJzZVN0YXRlIiwibmV4dFN0YXRlIiwidXNlVHJhbnNpdGlvbiIsIl9yZWYxNCIsIl9hbmltYXRlT25Nb3VudCIsIl9tZWFzdXJlIiwiX2Vhc2luZ0luIiwiX2Vhc2luZ091dCIsInByb3BzSW5jb21pbmciLCJtZWFzdXJlIiwiZXhpdFZpc2liaWxpdHkiLCJkdXJhdGlvbiIsImRlbGF5TW91bnRVbnRpbFNob3duIiwiZWFzaW5nIiwiZWFzaW5nSW4iLCJlYXNpbmdPdXQiLCJnZXRFeGl0VmlzaWJpbGl0eSIsImdldE1lYXN1cmUiLCJleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZSIsImludGVybmFsT25TaG93Q2hhbmdlZCIsImNzc1Byb3BlcnRpZXMiLCJjbGFzc05hbWVzIiwiaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkIiwidGltZW91dEhhbmRsZSIsIl90aW1lb3V0Q2xlYXJGdW5jdGlvbiIsInRpbWVvdXRDbGVhckZ1bmN0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwiZWxhcHNlZFRpbWUiLCJoYXNNb3VudGVkIiwidXBkYXRlQ2xhc3NlcyIsImFsbENsYXNzZXNUb1JlbW92ZSIsImFsbENsYXNzZXNUb0FkZCIsInVwZGF0ZVNpemVQcm9wZXJ0eSIsInZhck5hbWUiLCJtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMiLCJfc2l6ZSIsIl9zaXplMiIsIl9zaXplMyIsIl9zaXplNCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsIm9uU3RhdGVDaGFuZ2UiLCJwcmV2U3RhdGUiLCJuZXh0RGlyZWN0aW9uIiwibmV4dFBoYXNlIiwiaXNCZWluZ1BhaW50ZWQiLCJmb3JjZVJlZmxvdyIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50UGhhc2UiLCJkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiIsImhhc1JlbmRlcmVkQ2hpbGRyZW4iLCJyZW5kZXJDaGlsZHJlbiIsImNoaWxkcmVuSXNWbm9kZSIsImZpbmFsUHJvcHMiLCJyZXNldENvbnRleHQiLCJtb2RpZmllZENoaWxkcmVuIiwiX2R1bW15Iiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInVzZUJhc2VQcm9wc0ZhZGUiLCJfcmVmMTUiLCJmYWRlUGFyYW1ldGVycyIsImZhZGVNaW4iLCJmYWRlTWF4IiwiRmFkZSIsIl9yZWYxNiIsInVzZUJhc2VQcm9wc0NsaXAiLCJfcmVmMTciLCJfcmVmMTgiLCJfcmVmMTkiLCJfcmVmMjAiLCJfcmVmMjEiLCJjbGlwUGFyYW1ldGVycyIsImNsaXBNaW4iLCJjbGlwTWluQmxvY2siLCJjbGlwTWluSW5saW5lIiwiY2xpcE9yaWdpbiIsImNsaXBPcmlnaW5CbG9jayIsImNsaXBPcmlnaW5JbmxpbmUiLCJDbGlwIiwiX3JlZjIyIiwiQ2xpcEZhZGUiLCJfcmVmMjMiLCJ1c2VCYXNlUHJvcHNDb2xsYXBzZSIsIl9yZWYyNCIsImNvbGxhcHNlUGFyYW1ldGVycyIsIm1pbkJsb2NrU2l6ZSIsIkNvbGxhcHNlIiwiX3JlZjI1IiwiQ29sbGFwc2VGYWRlIiwiX3JlZjI2IiwidXNlQmFzZVByb3BzRmxpcCIsIl9yZWYyNyIsIl91c2VMYXN0Tm9uTnVsbFZhbHVlIiwiX3VzZUxhc3ROb25OdWxsVmFsdWUyIiwiZmxpcFBhcmFtZXRlcnMiLCJmbGlwQW5nbGVCbG9jayIsImZsaXBBbmdsZUlubGluZSIsImZsaXBQZXJzcGVjdGl2ZSIsIkZsaXAiLCJfcmVmMjgiLCJ1c2VCYXNlUHJvcHNTbGlkZSIsIl9yZWYyOSIsIl9zbGlkZVRhcmdldElubGluZSIsIl9zbGlkZVRhcmdldEJsb2NrIiwic2xpZGVQYXJhbWV0ZXJzIiwic2xpZGVUYXJnZXRJbmxpbmUiLCJzbGlkZVRhcmdldEJsb2NrIiwiU2xpZGUiLCJfcmVmMzAiLCJTbGlkZUZhZGUiLCJfcmVmMzEiLCJ1c2VCYXNlUHJvcHNab29tIiwiX3JlZjMyIiwiX3JlZjMzIiwiX3JlZjM0IiwiX3JlZjM1IiwiX3JlZjM2Iiwiem9vbVBhcmFtZXRlcnMiLCJ6b29tT3JpZ2luIiwiem9vbU9yaWdpbklubGluZSIsInpvb21PcmlnaW5CbG9jayIsInpvb21NaW4iLCJ6b29tTWluSW5saW5lIiwiem9vbU1pbkJsb2NrIiwiWm9vbSIsIl9yZWYzNyIsIlNsaWRlWm9vbSIsIl9yZWYzOCIsIlNsaWRlWm9vbUZhZGUiLCJfcmVmMzkiLCJab29tRmFkZSIsIl9yZWY0MCIsIl9fUFJFQUNUX0RFVlRPT0xTX18iLCJhdHRhY2hQcmVhY3QiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJyZXNldFByb3BXYXJuaW5ncyIsImdldERpc3BsYXlOYW1lIiwicmVuZGVyU3RhY2siLCJvd25lclN0YWNrIiwiZ2V0Q3VycmVudFZOb2RlIiwiaGFzQmFiZWxQbHVnaW4iLCJpc1Bvc3NpYmxlT3duZXIiLCJnZXRPd25lclN0YWNrIiwic3RhY2siLCJfX28iLCJyZWR1Y2UiLCJhY2MiLCJvd25lciIsInNvdXJjZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImlzV2Vha01hcFN1cHBvcnRlZCIsImdldENsb3Nlc3REb21Ob2RlUGFyZW50Iiwic2VyaWFsaXplVk5vZGUiLCJhdHRycyIsIm9sZERpZmYiLCJvbGRSb290Iiwib2xkUmVuZGVyIiwic2V0dXBDb21wb25lbnRTdGFjayIsImhvb2tzQWxsb3dlZCIsIm9sZFZub2RlIiwib2xkSG9vayIsIndhcm5lZENvbXBvbmVudHMiLCJsYXp5UHJvcFR5cGVzIiwiZGVwcmVjYXRpb25zIiwiY29tcG9uZW50U3RhY2siLCJjb21wb25lbnROYW1lIiwicHJvcFR5cGVzIiwibGF6eVZOb2RlIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJsb2NhdGlvbiIsImdldFN0YWNrIiwidHlwZVNwZWNOYW1lIiwibWVzc2FnZSIsInciLCJwcm9wZXJ0eSIsImRlcHJlY2F0ZWRBdHRyaWJ1dGVzIiwibm9kZU5hbWUiLCJkZXByZWNhdGVkUHJvdG8iLCJjcmVhdGUiLCJfX3Byb3RvX18iLCJpbml0RGVidWciLCJ1c2VVcmwiLCJvblVybENoYW5nZSIsImdldFVybCIsInNldFVybCIsInRyaW1IYXNoIiwiaGFzaCIsInN1YnN0ciIsIm5vcm1hbGl6ZUhhc2hUb1BhdGgiLCJzZXRFbnRpcmVIYXNoIiwiX2FjdGlvbiIsIm9sZFVSTCIsIm5leHRVcmwiLCJVUkwiLCJoaXN0b3J5IiwidGl0bGUiLCJkaXNwYXRjaEV2ZW50IiwiSGFzaENoYW5nZUV2ZW50IiwibmV3VVJMIiwidW5wYXJzZVBhcmFtIiwicGFyYW1zIiwicGFyc2VQYXJhbSIsInVybCIsInNlYXJjaFBhcmFtcyIsInBhcnNlZCIsImlzRmluaXRlIiwiQmlnSW50IiwidXNlQ29uc3VtZVJvdXRlciIsIl9yZWY0MSIsImNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzIiwib25Mb2NhbFBhdGhDaGFuZ2UiLCJsb2NhbFBhdGgiLCJ3YW50ZWRMb2NhbFBhdGgiLCJyb3V0ZXJDb250ZXh0IiwibGV2ZWwiLCJub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZCIsImFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyIsInNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyIsInBhdGhXaGVuTWF0Y2hpbmciLCJzZXRQYXRoV2hlbk1hdGNoaW5nIiwiYW55TWF0Y2hlcyIsIm9uTG9jYWxQYXRoQ2hhbmdlMiIsImdldExvY2FsUGF0aCIsInBhdGgiLCJwYXRoQ29tcGFyZSIsInNldE1hdGNoZXMiLCJzZXRMb2NhbFBhdGgiLCJ1c2VMb2NhbFBhdGgiLCJjb25zdW1lUm91dGVyUmV0dXJuIiwibG9jYWxSb3V0ZVBhcmFtZXRlcnMiLCJwcmV2IiwiX3JlZjQyIiwidXJsVG9QYXRoIiwib2xkSGFzaFBhdGgiLCJocmVmIiwicmVxdWVzdGVkTG9jYWxIYXNoIiwiX2xvY2FsUGF0aCIsIlJvb3RSb3V0ZXJFcnJvciIsInVzZVBvcExvY2FsUGF0aCIsImRpciIsInBvcExvY2FsUGF0aCIsIm5ld0hhc2hQYXRoIiwidXNlUHVzaExvY2FsUGF0aCIsInB1c2hMb2NhbEhhc2giLCJrZWVwVHJhaWxpbmciLCJ1c2VTZXRMb2NhbFBhdGgiLCJ1c2VSb3V0ZXJDb250cm9scyIsInB1c2hMb2NhbFBhdGgiLCJSb3V0ZXJDb250ZXh0IiwidXNlUHJvdmlkZVJvdXRlciIsIl9yZWY0MyIsIl9xJCIsIm1hdGNoaW5nSW5kaWNlcyIsImdldFNob3dpbmdEZWZhdWx0Iiwic2V0U2hvd2luZ0RlZmF1bHQiLCJzaG93aW5nRGVmYXVsdCIsIm9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkIiwiUm91dGVyIiwiX3JlZjQ0IiwiX2NvbnN1bWVSb3V0ZXJSZXR1cm4iLCJjb250ZXh0RnJvbVBhcmVudCIsInJhbmRvbSIsImNvbnRyb2xzIiwidXNlU2VhcmNoUGFyYW1zIiwicGFyYW1LZXkiLCJvblBhcmFtVmFsdWVDaGFuZ2VkIiwiZ2V0U2F2ZWRQYXJhbVZhbHVlIiwic2V0U2F2ZWRQYXJhbVZhbHVlIiwic2V0UGFyYW1XaXRoSGlzdG9yeSIsIm5ld1ZhbHVlT3JVcGRhdGVyIiwibmV3UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwicHJldHR5UHJpbnRQYXJhbXMiLCJuZXdQYXJhbSIsInBhcmFtQXJyYXkiLCJxdWVyeVN0cmluZyIsIl9yZWY0NSIsImVuY29kZVVSSUNvbXBvbmVudCIsImV4YW1wbGUiLCJzZXRFeGFtcGxlTG9jYWwiLCJnZXRFeGFtcGxlIiwic2V0RXhhbXBsZSIsIl9yZWY0NiIsIl9qc3hzIiwib25DbGljayIsImRpc2FibGVkIiwib25JbnB1dCIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZUFzTnVtYmVyIiwiTGV2ZWwxIiwiX0ZyYWdtZW50IiwiX3JlZjQ3IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7Ozs7RUEwQmFBLElBQUFBLENBQUFBO0lDZlBDLEdDUkZDO0lBQUFBLEdBQUFBO0lDeUtBQyxHQUFBQTtJQVdBQztJQUVFQyxHQTBCQUM7SUFBQUEsR0FBQUE7SUNqTktDLEdDRkVDO0lBQUFBLEdBQUFBLEdBQVksQ0FBQSxDQUNaQztJQUFBQSxHQUFBQSxHQUFZLEVBQ1pDO0lBQUFBLEdBQUFBLEdBQ1osbUVBQUE7RUxNZUMsU0FBQUEsR0FBQUEsQ0FBT0MsQ0FBS0MsRUFBQUEsQ0FBQUEsRUFBQUE7SUFFM0IsS0FBSyxJQUFJTixDQUFBQSxJQUFLTSxDQUFPRCxFQUFBQSxDQUFBQSxDQUFJTCxLQUFLTSxDQUFNTixDQUFBQSxDQUFBQSxDQUFBQTtJQUNwQyxPQUE2QkssQ0FDN0I7RUFBQTtFQVFNLFNBQVNFLEdBQUFBLENBQVdDLENBQzFCLEVBQUE7SUFBQSxJQUFJQyxJQUFhRCxDQUFLQyxDQUFBQSxVQUFBQTtJQUNsQkEsQ0FBWUEsSUFBQUEsQ0FBQUEsQ0FBV0MsV0FBWUYsQ0FBQUEsQ0FBQUE7RUFDdkM7RUVYTSxTQUFTRyxJQUFjQyxDQUFNTixFQUFBQSxDQUFBQSxFQUFPTyxDQUMxQyxFQUFBO0lBQUEsSUFDQ0M7TUFDQUMsQ0FDQWY7TUFBQUEsQ0FBQUE7TUFIR2dCLENBQWtCLEdBQUE7SUFJdEIsS0FBS2hCLENBQUFBLElBQUtNLENBQ0EsRUFBQSxLQUFBLElBQUxOLElBQVljLENBQU1SLEdBQUFBLENBQUFBLENBQU1OLENBQ2QsQ0FBQSxHQUFBLEtBQUEsSUFBTEEsSUFBWWUsQ0FBTVQsR0FBQUEsQ0FBQUEsQ0FBTU4sQ0FDNUJnQixDQUFBQSxH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Q0FBQSxNQUFBLEVBQUE7Y0FBQXRpQyxRQUFBLEVBQU8yeUM7WUFBSSxDQUFBLENBQVE7VUFBSSxDQUFBLENBQUE7U0FBQTtNQUM3QyxDQUVMLENBQUE7SUFBQSxDQUFBLENBa0JWO0VBRVg7RUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnREF6aUMscUJBQXFCLENBQUMsTUFBSztJQUN2QnRJLEdBQU0sQ0FBQzA2QixHQUFBLENBQUNoaEMsU0FBUyxFQUFBLENBQUEsQ0FBQSxDQUFHLEVBQUU4SCxRQUFRLENBQUM2dEMsY0FBYyxDQUFDLE1BQU0sQ0FBRSxDQUFDO0VBQzNELENBQUMsQ0FBQzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxMjcsMTI4XX0=
