(function () {
  'use strict';

  var n,
    l$2,
    u$2,
    t$1,
    r$2,
    o$3,
    f$2,
    e$1 = {},
    c$2 = [],
    s$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function a$2(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function h$2(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function v$2(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return y$2(l, f, t, r, null);
  }
  function y$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$2 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function d$2(n) {
    return n.children;
  }
  function _$2(n, l) {
    this.props = n, this.context = l;
  }
  function k$2(n, l) {
    if (null == l) return n.__ ? k$2(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? k$2(n) : null;
  }
  function b$1(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return b$1(n);
    }
  }
  function g$2(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !m$1.__r++ || r$2 !== l$2.debounceRendering) && ((r$2 = l$2.debounceRendering) || o$3)(m$1);
  }
  function m$1() {
    var n, l, u, i, r, o, f, e;
    for (t$1.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }); n = t$1.shift();) n.__d && (l = t$1.length, i = void 0, r = void 0, f = (o = (u = n).__v).__e, (e = u.__P) && (i = [], (r = a$2({}, o)).__v = o.__v + 1, z$2(e, o, r, u.__n, void 0 !== e.ownerSVGElement, null != o.__h ? [f] : null, i, null == f ? k$2(o) : f, o.__h), L$1(i, o), o.__e != f && b$1(o)), t$1.length > l && t$1.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }));
    m$1.__r = 0;
  }
  function w$2(n, l, u, i, t, r, o, f, s, a) {
    var h,
      v,
      p,
      _,
      b,
      g,
      m,
      w = i && i.__k || c$2,
      A = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$2(null, _, null, null, _) : Array.isArray(_) ? y$2(d$2, {
      children: _
    }, null, null, null) : _.__b > 0 ? y$2(_.type, _.props, _.key, _.ref ? _.ref : null, _.__v) : _)) {
      if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
        if ((p = w[v]) && _.key == p.key && _.type === p.type) {
          w[v] = void 0;
          break;
        }
        p = null;
      }
      z$2(n, _, p = p || e$1, t, r, o, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (m || (m = []), p.ref && m.push(p.ref, null, _), m.push(v, _.__c || b, _)), null != b ? (null == g && (g = b), "function" == typeof _.type && _.__k === p.__k ? _.__d = s = x$1(_, s, n) : s = P(n, _, p, w, b, s), "function" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k$2(p));
    }
    for (u.__e = g, h = A; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = C$1(i).nextSibling), O(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) N$1(m[h], m[++h], m[++h]);
  }
  function x$1(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? x$1(i, l, u) : P(u, i, i, t, i.__e, l));
    return l;
  }
  function A$1(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      A$1(n, l);
    }) : l.push(n)), l;
  }
  function P(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function C$1(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = C$1(u))) return i;
    return null;
  }
  function $(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || I$1(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || I$1(n, r, l[r], u[r], i);
  }
  function H$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || s$2.test(l) ? u : u + "px";
  }
  function I$1(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || H$1(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || H$1(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? j$1 : T$2, r) : n.removeEventListener(l, r ? j$1 : T$2, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function T$2(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function j$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function z$2(n, u, i, t, r, o, f, e, c) {
    var s,
      h,
      v,
      y,
      p,
      k,
      b,
      g,
      m,
      x,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], x = s ? m ? m.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in I && I.prototype.render ? u.__c = h = new I(g, x) : (u.__c = h = new _$2(g, x), h.constructor = I, h.render = S), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != I.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$2({}, h.__s)), a$2(h.__s, I.getDerivedStateFromProps(g, h.__s))), y = h.props, p = h.state, h.__v = u, v) null == I.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
            for (u.__v !== i.__v && (h.props = g, h.state = h.__s, h.__d = !1), h.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < h._sb.length; A++) h.__h.push(h._sb[A]);
            h._sb = [], h.__h.length && f.push(h);
            break n;
          }
          null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
            h.componentDidUpdate(y, p, k);
          });
        }
        if (h.context = x, h.props = g, h.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (h.state = h.__s, h.__d = !1, P && P(u), s = h.render(h.props, h.state, h.context), $ = 0; $ < h._sb.length; $++) h.__h.push(h._sb[$]);
          h._sb = [];
        } else do {
          h.__d = !1, P && P(u), s = h.render(h.props, h.state, h.context), h.state = h.__s;
        } while (h.__d && ++C < 25);
        h.state = h.__s, null != h.getChildContext && (t = a$2(a$2({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === d$2 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = M(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function L$1(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function M(l, u, i, t, r, o, f, c) {
    var s,
      a,
      v,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
      }
      if ($(l, p, y, r, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && k$2(i, 0), c), null != o) for (_ = o.length; _--;) null != o[_] && h$2(o[_]);
      c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && I$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && I$1(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function N$1(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function O(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || N$1(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && O(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || h$2(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function S(n, l, u) {
    return this.constructor(n, u);
  }
  function q$1(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], z$2(i, u = (!r && t || i).__k = v$2(d$2, null, [u]), o || e$1, e$1, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), L$1(f, u);
  }
  function D$1(l, u, i) {
    var t,
      r,
      o,
      f = a$2({}, l.props);
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$2(l.type, f, t || l.key, r || l.ref, null);
  }
  function E(n, l) {
    var u = {
      __c: l = "__cC" + f$2++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(function (n) {
            n.__e = !0, g$2(n);
          });
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = c$2.slice, l$2 = {
    __e: function (n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$2 = 0, _$2.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$2({}, this.state), "function" == typeof n && (n = n(a$2({}, u), this.props)), n && a$2(u, n), null != n && this.__v && (l && this._sb.push(l), g$2(this));
  }, _$2.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), g$2(this));
  }, _$2.prototype.render = d$2, t$1 = [], o$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, m$1.__r = 0, f$2 = 0;
  var _$1 = 0;
  function o$2(o, e, n, t, f, l) {
    var s,
      u,
      a = {};
    for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
    var i = {
      type: o,
      props: a,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: l
    };
    if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
    return l$2.vnode && l$2.vnode(i), i;
  }
  var t,
    r$1,
    u$1,
    i$1,
    o$1 = 0,
    f$1 = [],
    c$1 = [],
    e = l$2.__b,
    a$1 = l$2.__r,
    v$1 = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d$1(t, u) {
    l$2.__h && l$2.__h(r$1, t, o$1 || u), o$1 = 0;
    var i = r$1.__H || (r$1.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c$1
    }), i.__[t];
  }
  function p$1(n) {
    return o$1 = 1, y$1(B$1, n);
  }
  function y$1(n, u, i) {
    var o = d$1(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$1, !r$1.u)) {
      r$1.u = !0;
      var f = r$1.shouldComponentUpdate;
      r$1.shouldComponentUpdate = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !f || f.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
      };
    }
    return o.__N || o.__;
  }
  function h$1(u, i) {
    var o = d$1(t++, 3);
    !l$2.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
  }
  function s$1(u, i) {
    var o = d$1(t++, 4);
    !l$2.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
  }
  function _(n) {
    return o$1 = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o$1 = 6, s$1(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d$1(t++, 7);
    return z$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o$1 = 8, F$1(function () {
      return n;
    }, t);
  }
  function q(n) {
    var u = r$1.context[n.__c],
      i = d$1(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
  }
  function b() {
    for (var t; t = f$1.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$1 = null, e && e(n);
  }, l$2.__r = function (n) {
    a$1 && a$1(n), t = 0;
    var i = (r$1 = n.__c).__H;
    i && (u$1 === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c$1, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u$1 = r$1;
  }, l$2.diffed = function (t) {
    v$1 && v$1(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f$1.push(o) && i$1 === l$2.requestAnimationFrame || ((i$1 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c$1 && (n.__ = n.__V), n.i = void 0, n.__V = c$1;
    })), u$1 = r$1 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$1,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
  }
  function w$1(n) {
    var t = r$1;
    n.__c = n.__(), r$1 = t;
  }
  function z$1(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$2 = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$3 = freeGlobal$2;

  /** Detect free variable `self`. */
  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$2 = freeGlobal$3 || freeSelf$1 || Function('return this')();
  var root$3 = root$2;

  /** Built-in value references. */
  var Symbol$3 = root$3.Symbol;
  var Symbol$4 = Symbol$3;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$3 = objectProto$9.toString;

  /** Built-in value references. */
  var symToStringTag$3 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$7.call(value, symToStringTag$3),
      tag = value[symToStringTag$3];
    try {
      value[symToStringTag$3] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$3.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$3] = tag;
      } else {
        delete value[symToStringTag$3];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$2 = objectProto$8.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString$2.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag$1 = '[object Null]',
    undefinedTag$1 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$2 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$1 : nullTag$1;
    }
    return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag$1 = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag$1 = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$1(value);
    return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData$2 = root$3['__core-js_shared__'];
  var coreJsData$3 = coreJsData$2;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey$1 = function () {
    var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey$1 && maskSrcKey$1 in func;
  }

  /** Used for built-in method references. */
  var funcProto$3 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$3 = funcProto$3.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$3.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
    objectProto$7 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative$1 = RegExp('^' + funcToString$2.call(hasOwnProperty$6).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$1(value) || isMasked$1(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
    return pattern.test(toSource$1(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$1(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative$1(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$1(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate$2 = getNative$1(Object, 'create');
  var nativeCreate$3 = nativeCreate$2;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$3) {
      var result = data[key];
      return result === HASH_UNDEFINED$3 ? undefined : result;
    }
    return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$3 ? data[key] !== undefined : hasOwnProperty$4.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$3 && value === undefined ? HASH_UNDEFINED$2 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear$1;
  Hash$1.prototype['delete'] = hashDelete$1;
  Hash$1.prototype.get = hashGet$1;
  Hash$1.prototype.has = hashHas$1;
  Hash$1.prototype.set = hashSet$1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$1(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto$1 = Array.prototype;

  /** Built-in value references. */
  var splice$1 = arrayProto$1.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice$1.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$1.prototype.clear = listCacheClear$1;
  ListCache$1.prototype['delete'] = listCacheDelete$1;
  ListCache$1.prototype.get = listCacheGet$1;
  ListCache$1.prototype.has = listCacheHas$1;
  ListCache$1.prototype.set = listCacheSet$1;

  /* Built-in method references that are verified to be native. */
  var Map$3 = getNative$1(root$3, 'Map');
  var Map$4 = Map$3;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash$1(),
      'map': new (Map$4 || ListCache$1)(),
      'string': new Hash$1()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable$1(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$1(map, key) {
    var data = map.__data__;
    return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$1(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$1(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData$1(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$1.prototype.clear = mapCacheClear$1;
  MapCache$1.prototype['delete'] = mapCacheDelete$1;
  MapCache$1.prototype.get = mapCacheGet$1;
  MapCache$1.prototype.has = mapCacheHas$1;
  MapCache$1.prototype.set = mapCacheSet$1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache$1)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache$1;
  function getBuildModeUnmemoized$1() {
    try {
      var _process, _process$env;
      if (((_process = process) === null || _process === void 0 ? void 0 : (_process$env = _process.env) === null || _process$env === void 0 ? void 0 : _process$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode$1 = memoize$1(getBuildModeUnmemoized$1);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability$1(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    if (getBuildMode$1() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering$1(f) {
    var _l$2$debounceRenderin;
    ((_l$2$debounceRenderin = l$2.debounceRendering) !== null && _l$2$debounceRenderin !== void 0 ? _l$2$debounceRenderin : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState$1(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$3);
    const reasonRef = _(Unset$3);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$3);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability$1("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$3 && getInitialValue != undefined) {
        try {
          var _onChange;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$3) tryEnsureValue();
      return valueRef.current === Unset$3 ? undefined : valueRef.current;
    }, []);
    s$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$3 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$3 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering$1)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$3 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$3;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$3 = Symbol();
  function returnNull$1() {
    return null;
  }
  const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64$1(value) {
    return Table$1[value];
  }
  function random6Bits$1() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits$1() {
    return [random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId$1(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits$1().map(n => base64$1(n)).join(""));
  }
  const previousInputs$1 = new Map();
  const toRun$1 = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName$1 = "diffed";
  const originalCommit$1 = l$2[commitName$1];
  const newCommit$1 = function () {
    for (const [id, effectInfo] of toRun$1) {
      const oldInputs = previousInputs$1.get(id);
      if (argsChanged$1(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs$1.set(id, effectInfo.inputs);
      }
    }
    toRun$1.clear();
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    originalCommit$1 === null || originalCommit$1 === void 0 ? void 0 : originalCommit$1(...args);
  };
  l$2[commitName$1] = newCommit$1;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect$1(effect, inputs) {
    const [id] = p$1(() => generateRandomId$1());
    if (effect) toRun$1.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun$1.delete(id);
    h$1(() => {
      return () => {
        toRun$1.delete(id);
        previousInputs$1.delete(id);
      };
    }, [id]);
  }
  function argsChanged$1(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset$2 = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter$1(value) {
    const ref = _(Unset$2);
    useBeforeLayoutEffect$1(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset$2) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject$1(t) {
    const e = Object.entries(t);
    useEnsureStability$1("useStableObject", e.length, ...e.map(_ref => {
      let [_k, v] = _ref;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map$1 = new WeakMap();
  function isStableGetter$1(obj) {
    var _map$1$get;
    return (_map$1$get = map$1.get(obj)) !== null && _map$1$get !== void 0 ? _map$1$get : false;
  }
  function setIsStableGetter$1(obj) {
    map$1.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback$1(fn, noDeps) {
    useEnsureStability$1("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter$1(fn));
    if (isStableGetter$1(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter$1(fn);
      return setIsStableGetter$1(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter$1(T$1(fn, []));
    }
  }

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * Due to typing limitations, this function must be called like this:
   *
   * `useEventHandler(element, "input")<InputEvent>(e => {})`
   *
   * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
   *
   * There is a separate version that attaches event handlers to a set of props.
   * It takes different event string types (onEvent vs onevent).
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options, mode) {
    mode || (mode = "grouped");
    useEnsureStability$1("useGlobalHandler", mode);
    if (mode === "grouped") {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      useGlobalHandlerGrouped(target, type, handler, options);
    } else {
      useGlobalHandlerSingle(target, type, handler, options);
    }
  }
  let mapThing = new Map();
  function doMapThing(op, target, type, handler, options) {
    if (handler) {
      const optionsKey = JSON.stringify(options);
      const byType = mapThing.get(target) || new Map();
      const byOptions = byType.get(type) || new Map();
      const info = byOptions.get(optionsKey) || {
        listener: null,
        listeners: new Set()
      };
      op(info, handler);
      byOptions.set(optionsKey, info);
      byType.set(type, byOptions);
      mapThing.set(target, byType);
    }
  }
  function addToMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.add(h);
      if (info.listener == null) target.addEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  function removeFromMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.delete(h);
      if (info.listener == null) target.removeEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  /**
   * This is way faster for large numbers of event handlers.
   *
   * For example, if every button listens for a global click, or something,
   * it would be nice if it was efficient at least.
   */
  function useGlobalHandlerGrouped(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h$1(() => {
      if (stableHandler) {
        addToMapThing(target, type, stableHandler, options);
        return () => removeFromMapThing(target, type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }
  function useGlobalHandlerSingle(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h$1(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck$1(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass$1(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck$1(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass$1(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck$1(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass$1(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren$1(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability$1("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering$1(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering$1(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject$1({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject$1({
        managedChildContext: useStableObject$1({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild$1(info, managedChildParameters) {
    var _info$context;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context = info.context) !== null && _info$context !== void 0 ? _info$context : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState$1(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = p$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }
  function g(n, t) {
    for (var e in t) n[e] = t[e];
    return n;
  }
  function C(n, t) {
    for (var e in n) if ("__source" !== e && !(e in t)) return !0;
    for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function x(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, v$2(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new _$2()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var R = l$2.__b;
  l$2.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$2.__e;
  l$2.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    T(n, t, e, r);
  };
  var I = l$2.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$2.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new _$2()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && v$2(d$2, null, n.fallback);
    return i && (i.__h = null), [v$2(d$2, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) e.pop()();
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  (V.prototype = new _$2()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = A$1(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var z = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    H = "undefined" != typeof document,
    Z = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };
  _$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(_$2.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var G = l$2.event;
  function J() {}
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l$2.event = function (n) {
    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;
  };
  var nn = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    tn = l$2.vnode;
  l$2.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      var o = -1 === t.indexOf("-");
      for (var i in u = {}, e) {
        var l = e[i];
        H && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = A$1(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = A$1(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (nn.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", nn));
    }
    n.$$typeof = z, tn && tn(n);
  };
  var en = l$2.__r;
  l$2.__r = function (n) {
    en && en(n), n.__c;
  };
  var rn = l$2.diffed;
  l$2.diffed = function (n) {
    rn && rn(n);
    var t = n.props,
      e = n.__e;
    null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value);
  };
  E(null);
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();
  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];
  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');
  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;
  function getBuildModeUnmemoized() {
    try {
      var _process2, _process2$env;
      if (((_process2 = process) === null || _process2 === void 0 ? void 0 : (_process2$env = _process2.env) === null || _process2$env === void 0 ? void 0 : _process2$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode = memoize(getBuildModeUnmemoized);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      values[_key3 - 1] = arguments[_key3];
    }
    if (getBuildMode() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$2$debounceRenderin2;
    ((_l$2$debounceRenderin2 = l$2.debounceRendering) !== null && _l$2$debounceRenderin2 !== void 0 ? _l$2$debounceRenderin2 : setTimeout)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$1);
    const reasonRef = _(Unset$1);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$1);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange3;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange3 = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange3 !== void 0 ? _onChange3 : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    s$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange4;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange4 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange4 !== void 0 ? _onChange4 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$1 = Symbol();
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }
  const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  const previousInputs = new Map();
  const toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName = "diffed";
  const originalCommit = l$2[commitName];
  const newCommit = function () {
    for (const [id, effectInfo] of toRun) {
      const oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup2;
        (_effectInfo$cleanup2 = effectInfo.cleanup) === null || _effectInfo$cleanup2 === void 0 ? void 0 : _effectInfo$cleanup2.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$2[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    /*(() => {
        const cleanup = useRef<void | (() => void) | null>(null);
        const prevArgsRef = useRef<Inputs>(null!);
        if (argsChanged(inputs, prevArgsRef.current)) {
            prevArgsRef.current = inputs!;
            if (cleanup.current)
                cleanup.current();
            cleanup.current = effect();
        }
    })();*/
    const [id] = p$1(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    h$1(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    const ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    const e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref2 => {
      let [_k, v] = _ref2;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return v$2(d$2, {}, lhs, rhs);
    }
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
    function combined(current) {
      processRef(current, lhs);
      processRef(current, rhs);
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len5 = arguments.length, allProps = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      allProps[_key5] = arguments[_key5];
    }
    useEnsureStability("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  const knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        return managedChildrenArray.current.arr.slice();
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var _info$context2;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context2 = info.context) !== null && _info$context2 !== void 0 ? _info$context2 : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref3) {
    let {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref3;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    const [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    // Shared between onChildrenMountChange and changeIndex, not public
    // Only called when `closestFit` is false, naturally.
    const getClosestFit = T$1(requestedIndex => {
      const children = getChildren();
      let closestDistance = Infinity;
      let closestIndex = null;
      children.forEach(child => {
        if (child != null && isValid(child)) {
          console.assert(typeof child.index == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    const reevaluateClosestFit = useStableCallback(() => {
      const children = getChildren();
      const requestedIndex = getRequestedIndex();
      const currentIndex = getCurrentIndex();
      const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
        const closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (currentChild) setAt(currentChild, false, closestFitIndex, currentIndex);
        if (closestFitIndex != null) {
          const closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true, closestFitIndex, currentIndex);
        }
      }
    });
    const changeIndex = T$1((arg, reason) => {
      const children = getChildren();
      const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      setRequestedIndex(requestedIndex, reason);
      const currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
        return null;
      } else {
        const childIsValid = newMatchingChild && isValid(newMatchingChild);
        if (childIsValid || !closestFit) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
          if (newMatchingChild) setAt(newMatchingChild, true, requestedIndex, currentIndex);
          return requestedIndex;
        } else {
          console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            setAt(newMatchingChild, true, closestFitIndex, currentIndex);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    s$1(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = p$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = () => {
      return ref.current;
    };
    console.assert(ref.current === state || typeof state === "number" && isNaN(state));
    return [state, setState, getState];
  }
  E(null);
  function getExclusiveTransitionContextPrememoization(exclusivityKey) {
    if (exclusivityKey == null) return null;
    return E(null);
  }
  const SwappableContext = E({
    getAnimateOnMount: () => false
  });
  /**
   * Returns the context for a given `exclusivityKey`, creating one if it doesn't already exist.
   *
   * If
   */
  const GetExclusiveTransitionContext = memoize(getExclusiveTransitionContextPrememoization);
  const CssClassContext = E({
    GetBaseClass: () => "ptl",
    GetEnterClass: () => "n",
    GetExitClass: () => "x",
    GetMeasureClass: () => "m",
    GetInitClass: () => "i",
    GetTransitionClass: () => "t",
    GetFinalizeClass: () => "f"
  });
  function useCssClasses() {
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass
    } = q(CssClassContext);
    const GetDirectionClass = T$1(direction => {
      switch (direction) {
        case "enter":
          return GetEnterClass();
        case "exit":
          return GetExitClass();
      }
    }, []);
    const GetPhaseClass = T$1(phase => {
      switch (phase) {
        case "measure":
          return GetMeasureClass();
        case "init":
          return GetInitClass();
        case "transition":
          return GetTransitionClass();
        case "finalize":
          return GetFinalizeClass();
      }
    }, []);
    return {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    };
  }
  let globalCount = -1;
  function ExclusiveTransitionProvider(_ref4) {
    let {
      exclusivityKey,
      children
    } = _ref4;
    useEnsureStability("ExclusiveTransitionProvider", exclusivityKey);
    const [getNextIndexInLine, setNextIndexInLine] = usePassiveState(null);
    const {
      context,
      managedChildrenReturn,
      managedChildrenReturn: {
        getChildren
      }
    } = useManagedChildren({
      managedChildrenParameters: {}
    });
    const {
      changeIndex,
      getCurrentIndex
    } = useChildrenFlag({
      getChildren,
      closestFit: false,
      initialIndex: null,
      onIndexChange: null,
      setAt: T$1((m, v) => {
        m.setExclusivelyOpen(v);
      }, []),
      getAt: T$1(m => m.getExclusivelyOpen(), []),
      isValid: T$1(m => {
        return true;
      }, [])
    });
    const onVisibilityChange = T$1((index, visible) => {
      debugger;
      const nextInLine = getNextIndexInLine();
      const currentInLine = getCurrentIndex();
      if (visible == "show" && index != currentInLine) {
        /**
         * When a child transition shows itself initially
         * (i.e. requests itself to be the exclusive transition)
         * we either let it open immediately if there's no one finishing their exit,
         * or wait until that aforementioned exit has finished.
         */
        if (currentInLine == null) {
          changeIndex(index);
        } else {
          var _getChildren$getAt, _getChildren$getAt$fo;
          (_getChildren$getAt = getChildren().getAt(currentInLine)) === null || _getChildren$getAt === void 0 ? void 0 : (_getChildren$getAt$fo = _getChildren$getAt.forceClose) === null || _getChildren$getAt$fo === void 0 ? void 0 : _getChildren$getAt$fo.call(_getChildren$getAt);
          setNextIndexInLine(index);
        }
      } else if (visible == "hidden") {
        /**
         * When a child transition has finished its exit transition,
         * make sure that if someone requested to be shown in the meantime
         * that we do so.
         */
        if (nextInLine != null) {
          changeIndex(nextInLine);
          setNextIndexInLine(null);
        }
      }
    }, []);
    const context2 = useStableObject({
      ...context,
      exclusiveTransitionContext: useStableObject({
        exclusivityKey,
        onVisibilityChange
      })
    });
    const ExclusiveTransitionContext = GetExclusiveTransitionContext(exclusivityKey);
    return ExclusiveTransitionContext == null ? children !== null && children !== void 0 ? children : null : o$2(ExclusiveTransitionContext.Provider, {
      value: context2,
      children: children
    });
  }
  function useExclusiveTransition(_ref5) {
    let {
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        forceClose,
        exclusivityKey
      }
    } = _ref5;
    const c = GetExclusiveTransitionContext(exclusivityKey);
    useEnsureStability("useExclusiveTransition", c == null);
    const context = c ? q(c) : null;
    //const index = useMemo(() => generateRandomId(), []);
    const index = F$1(() => {
      globalCount += 1;
      return globalCount.toString();
    }, []);
    const [exclusivelyOpen, setExclusivelyOpen, getExclusivelyOpen] = useState(!!show);
    useManagedChild({
      context,
      managedChildParameters: {
        index
      }
    }, {
      index,
      getExclusivelyOpen,
      setExclusivelyOpen,
      forceClose
    });
    const parentOnVisChange = context === null || context === void 0 ? void 0 : context.exclusiveTransitionContext.onVisibilityChange;
    const onVisibilityChange = T$1(visible => {
      parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, visible == false ? "hidden" : "show");
    }, [parentOnVisChange, index]);
    s$1(() => {
      if (show) parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, "show");
    }, [show, parentOnVisChange, index]);
    return {
      exclusiveTransitionReturn: {
        isExclusive: context != null,
        exclusivelyOpen,
        setExclusivelyOpen,
        getExclusivelyOpen,
        onVisibilityChange
      }
    };
  }

  /**
   * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
   * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
   *
   * TODO: Still needed?
   */
  function forwardElementRef(Component) {
    const ForwardedComponent = k(Component);
    return ForwardedComponent;
  }
  /**
   * Useful in particular for Slides with a Tab Panel --
   * if we do Math.sign(currentIndex - slideIndex), it
   * transitions nicely in the expected direction,
   * but we need to "remember" which direction to use
   * when it's the current panel (and the difference is 0)
   */
  function useLastNonNullValue(value) {
    const lastNonNullValue = _(null);
    h$1(() => {
      if (value != null) lastNonNullValue.current = value;
    }, [value]);
    return value !== null && value !== void 0 ? value : lastNonNullValue.current;
  }

  /**
   * Creates a set of props that implement a swap container.
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useCreateSwappableProps(_ref6, otherProps) {
    let {
      inline
    } = _ref6;
    const {
      GetBaseClass
    } = useCssClasses();
    return useMergedProps({
      className: clsx("".concat(GetBaseClass(), "-swap-container"), inline && "".concat(GetBaseClass(), "-swap-container-inline"))
    }, otherProps);
  }
  /**
   * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
   *
   * You must manage each child `<Transitionable>` component's `show` prop -- this component *does not* manage any sort of state in that regard.
   *
   * If you pass a regular element (like a div) or other single component, then thee props and ref will be forwarded onto that element. Otherwise, all the children will be wrapped in a div or span depending on the `inline` prop.
   * @param param0
   * @returns
   */
  const Swappable = x(forwardElementRef(function Swappable(_ref7, ref) {
    var _inline;
    let {
      children: c,
      inline,
      childrenAnimateOnMount,
      exclusivityKey,
      ...p
    } = _ref7;
    let children = c;
    if (!children.type) children = !inline ? o$2("div", {
      children: children
    }) : o$2("span", {
      children: children
    });
    (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
    const transitionProps = useCreateSwappableProps({
      inline
    }, {
      ...p,
      ref
    });
    const mergedWithChildren = useMergedProps(transitionProps, children.props);
    const animateOnMount = _(childrenAnimateOnMount !== null && childrenAnimateOnMount !== void 0 ? childrenAnimateOnMount : false);
    h$1(() => {
      animateOnMount.current = true;
    }, []);
    const contextValue = _({
      getAnimateOnMount: () => {
        return animateOnMount.current;
      }
    });
    let ret = D$1(children, mergedWithChildren);
    ret = o$2(SwappableContext.Provider, {
      value: contextValue.current,
      children: ret
    });
    if (exclusivityKey) {
      ret = o$2(ExclusiveTransitionProvider, {
        exclusivityKey: exclusivityKey,
        children: ret
      }, exclusivityKey);
    }
    return ret;
  }));
  // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
  // Not perfect, but it's not supposed to be. `inline` is for perfect.
  const inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
  function getTimeoutDuration(element) {
    return Math.max(...window.getComputedStyle(element || document.body).getPropertyValue("transition-duration").split(",").map(str => {
      if (str.endsWith("ms")) return +str.substring(0, str.length - 2);
      if (str.endsWith("s")) return +str.substring(0, str.length - 1) * 1000;
      return 1000;
    }));
  }
  function parseState(nextState) {
    return nextState.split("-");
  }
  /**
   * Provide props that can be used to animate a transition.
   *
   * @param param0
   * @returns
   */
  function useTransition(_ref8) {
    var _animateOnMount, _measure, _easingIn, _easingOut;
    let {
      transitionParameters: {
        propsIncoming: {
          children,
          ...p
        },
        show,
        animateOnMount,
        measure,
        exitVisibility,
        duration,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    } = _ref8;
    useEnsureStability("useTransition", onVisibilityChange);
    const {
      getAnimateOnMount
    } = q(SwappableContext);
    exitVisibility || (exitVisibility = "hidden");
    (_animateOnMount = animateOnMount) !== null && _animateOnMount !== void 0 ? _animateOnMount : animateOnMount = getAnimateOnMount();
    (_measure = measure) !== null && _measure !== void 0 ? _measure : measure = false;
    const getExitVisibility = useStableGetter(exitVisibility);
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    } = useCssClasses();
    const getMeasure = useStableGetter(measure);
    const {
      exclusiveTransitionReturn: {
        exclusivelyOpen,
        isExclusive,
        onVisibilityChange: exclusiveTransitionVisibilityChange
      }
    } = useExclusiveTransition({
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        exclusivityKey,
        forceClose: useStableCallback(() => {
          internalOnShowChanged(false, getMeasure());
        })
      }
    });
    if (isExclusive) {
      show = show && exclusivelyOpen;
    }
    const {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({});
    const cssProperties = _({});
    const classNames = _(new Set([// This is removed during useLayoutEffect on the first render
    // (at least once `show` is non-null)
    "".concat(GetBaseClass(), "-pending")]));
    const handleTransitionFinished = T$1(() => {
      const state = getState();
      console.assert(!!state);
      if (state) {
        const [direction, phase] = parseState(state);
        if (phase == "transition") {
          setState("".concat(direction, "-finalize"));
          if (timeoutHandle.current > 0) {
            var _timeoutClearFunction;
            (_timeoutClearFunction = timeoutClearFunction.current) === null || _timeoutClearFunction === void 0 ? void 0 : _timeoutClearFunction.call(timeoutClearFunction, timeoutHandle.current);
            timeoutHandle.current = -1;
          }
        }
      }
    }, []);
    const otherProps = _({
      onTransitionEnd: e => {
        if (e.target == getElement() && e.elapsedTime) {
          handleTransitionFinished();
        }
      }
    });
    const hasMounted = _(false);
    /**
     * Sets the element's CSS class to match the given direction and phase.
     */
    const updateClasses = T$1((element, direction, phase) => {
      if (element == null) return;
      const exitVisibility = getExitVisibility();
      const allClassesToRemove = ["".concat(GetBaseClass(), "-").concat(GetEnterClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-ev-", "inert"), "".concat(GetBaseClass(), "-ev-", "removed"), "".concat(GetBaseClass(), "-ev-", "hidden"), "".concat(GetBaseClass(), "-ev-", "visible"), "".concat(GetBaseClass(), "-pending")];
      const allClassesToAdd = ["".concat(GetBaseClass()), "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction)), phase ? "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction), "-").concat(GetPhaseClass(phase)) : "", "".concat(GetBaseClass(), "-ev-").concat(exitVisibility)];
      element.classList.remove(...allClassesToRemove);
      allClassesToRemove.map(v => classNames.current.delete(v));
      element.classList.add(...allClassesToAdd);
      allClassesToAdd.map(v => classNames.current.add(v));
    }, []);
    /**
     * Updates a single "measure" variable (or removes it)
     */
    const updateSizeProperty = T$1((element, varName, value) => {
      if (value != null) {
        value = "".concat(value, "px");
        element.style.setProperty(varName, value);
        cssProperties.current[varName] = value;
      } else {
        element.style.removeProperty(varName);
        delete cssProperties.current[varName];
      }
    }, []);
    /**
     * Adds the "measure" variupdateClassesables to the element if requested.
     */
    const measureElementAndUpdateProperties = T$1((element, measure) => {
      if (element) {
        var _size, _size2, _size3, _size4;
        let size = null;
        if (measure) {
          size = element.getBoundingClientRect();
        }
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-top"), (_size = size) === null || _size === void 0 ? void 0 : _size.top);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-left"), (_size2 = size) === null || _size2 === void 0 ? void 0 : _size2.left);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-width"), (_size3 = size) === null || _size3 === void 0 ? void 0 : _size3.width);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-height"), (_size4 = size) === null || _size4 === void 0 ? void 0 : _size4.height);
      }
    }, []);
    // We use both useTimeout and requestAnimationFrame for timing certain things --
    // raf is used for changing from init to transition (would use queueMicrotask but it can't be cancelled)
    // setTimeout is used for changing from transition to finalize (as a backup in case transitionend doesn't fire)
    //
    // In order to avoid stale callbacks running (i.e. when we rapidly switch between visible and not)
    // we need to make sure we accurately cancel anything that can change our state on a delay.
    //
    // Also of note, we store "(f) => window.clearTimeout(f)" instead of just "window.clearTimeout" because
    // of the implicit window object -- problems with a missing `this` object and all that nonsense.
    const timeoutHandle = _(-1);
    const timeoutClearFunction = _(null);
    /**
     * Any time the state changes, there's some logic we need to run:
     *
     * * If we're changing to an `init` phase, update the classes, then wait a moment and then change to the `transition` phase.
     * * If we're changing to a `transition` phase, update the classes, then wait until the transition completes, then change to the `finalize` phase.
     *
     * Any change in state or classes/styles does not implicitly cause a re-render.
     */
    const onStateChange = T$1((nextState, prevState, reason) => {
      if (nextState == null) return;
      const [nextDirection, nextPhase] = parseState(nextState);
      const element = getElement();
      // Make sure no stale change code ever runs
      if (timeoutHandle.current >= 0 && timeoutClearFunction.current) timeoutClearFunction.current(timeoutHandle.current);
      // Handle inert props/property
      const exitVisibility = getExitVisibility();
      if (exitVisibility) {
        const inert = exitVisibility == "inert" && nextDirection == "exit" && nextPhase == "finalize" ? true : undefined;
        if (inert) otherProps.current.inert = true;else delete otherProps.current["inert"];
        if (element) element.inert = inert || false;
      }
      const isBeingPainted = nextDirection == "enter" || nextDirection == "exit" && nextPhase != "finalize";
      onVisibilityChange === null || onVisibilityChange === void 0 ? void 0 : onVisibilityChange(isBeingPainted);
      exclusiveTransitionVisibilityChange === null || exclusiveTransitionVisibilityChange === void 0 ? void 0 : exclusiveTransitionVisibilityChange(isBeingPainted);
      updateClasses(element, nextDirection, nextPhase);
      if (element && (nextPhase == "init" || nextPhase == "transition")) forceReflow(element);
      switch (nextPhase) {
        case "measure":
          {
            if (element) measureElementAndUpdateProperties(element, true);
            //setState(`${nextDirection}-init`);
            updateClasses(element, nextDirection, "init");
            if (element) forceReflow(element);
            // !!Intentional fall-through!!
          }

        case "init":
          {
            timeoutHandle.current = requestAnimationFrame(() => {
              setState("".concat(nextDirection, "-transition"));
            });
            timeoutClearFunction.current = f => cancelAnimationFrame(f);
            break;
          }
        case "transition":
          {
            timeoutHandle.current = setTimeout(() => {
              handleTransitionFinished();
            }, getTimeoutDuration(element) * 1.5);
            timeoutClearFunction.current = f => clearTimeout(f);
            break;
          }
        case "finalize":
          {
            // Nothing to do or schedule or anything -- we just update our classes and we're done.
            timeoutClearFunction.current = null; // Does this make it more or less clear?
            break;
          }
        default:
          {
            debugger; // Intentional
            console.log("Invalid state used in transition: ".concat(nextState, ". Previous state was ").concat(prevState !== null && prevState !== void 0 ? prevState : "null"));
            break;
          }
      }
    }, []);
    const [getState, setState] = usePassiveState(onStateChange, returnNull, runImmediately);
    // When we mount, and every time thereafter that `show` changes,
    // change our current state according to that `show` value.
    s$1(() => internalOnShowChanged(show, measure), [measure, show]);
    // This has no dependences and is relied on in two different areas
    function internalOnShowChanged(show, measure) {
      // If `show` is null, then we don't change anything.
      if (show == null) return;
      // (If `show` is true/false, we'll remove the CSS classes during `onChange`)
      const currentState = getState();
      let nextPhase = measure ? "measure" : "init";
      if (currentState) {
        const [currentDirection, currentPhase] = parseState(currentState);
        if (currentPhase != "finalize") nextPhase = "transition";
      }
      // Note: the setState change handler runs immediately with no debounce.
      if (show) {
        if (hasMounted.current || animateOnMount) setState("enter-".concat(nextPhase));else setState("enter-finalize");
      } else {
        if (hasMounted.current || animateOnMount) setState("exit-".concat(nextPhase));else setState("exit-finalize");
      }
      hasMounted.current = true;
    }
    if (duration != null) cssProperties.current["--".concat(GetBaseClass(), "-duration")] = duration + "ms";else delete cssProperties.current["--".concat(GetBaseClass(), "-duration")];
    (_easingIn = easingIn) !== null && _easingIn !== void 0 ? _easingIn : easingIn = easing;
    (_easingOut = easingOut) !== null && _easingOut !== void 0 ? _easingOut : easingOut = easing;
    if (easingOut != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")] = easingOut;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")];
    if (easingIn != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")] = easingIn;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")];
    // No matter what delayMountUntilShown is,
    // once we've rendered our children once, 
    // ensure that we don't unmount them again and waste all that work.
    // (If you really need this you can just unmount the entire transition itself)
    const definitelyShouldMountChildren = show || !delayMountUntilShown;
    const hasRenderedChildren = _(false);
    const renderChildren = definitelyShouldMountChildren || hasRenderedChildren.current;
    h$1(() => {
      if (definitelyShouldMountChildren) hasRenderedChildren.current || (hasRenderedChildren.current = true);
    }, [hasRenderedChildren.current ? false : definitelyShouldMountChildren]);
    const childrenIsVnode = children && children.type && children.props;
    const finalProps = useMergedProps(p, propsStable, otherProps.current, {
      className: [...classNames.current, "".concat(GetBaseClass()), "".concat(GetBaseClass(), "-ev-").concat(exitVisibility), "".concat(GetBaseClass(), "-inline-direction-", "ltr"), "".concat(GetBaseClass(), "-block-direction-", "ttb")].join(" "),
      style: cssProperties.current
    }, childrenIsVnode ? {
      ref: children.ref,
      ...children.props
    } : {});
    const resetContext = _({
      getAnimateOnMount: returnFalse
    }).current;
    let modifiedChildren;
    if (childrenIsVnode) {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: D$1(children, finalProps)
      });
    } else {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: o$2("span", {
          ...finalProps,
          children: children
        })
      });
    }
    return renderChildren ? modifiedChildren : null;
  }
  function forceReflow(e) {
    // Try really hard to make sure this isn't optimized out by anything.
    // We need it for its document reflow side effect.
    const p = globalThis._dummy;
    globalThis._dummy = e.getBoundingClientRect();
    globalThis._dummy = e.style.opacity;
    globalThis._dummy = e.style.transform;
    globalThis._dummy = p;
    return e;
  }

  /**
   * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useBasePropsFade(_ref9) {
    let {
      fadeParameters: {
        fadeMin,
        fadeMax
      }
    } = _ref9;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-fade"),
      style: {
        ["--".concat(GetBaseClass(), "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
        ["--".concat(GetBaseClass(), "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
   *
   * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
   * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
   * It's generally recommended to either use the components that include a combined fade effect,
   * or just directly a `<Transitionable>` on your own.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Fade(_ref10, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref10;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  function useBasePropsClip(_ref11) {
    var _ref12, _ref13, _ref14, _ref15;
    let {
      clipParameters: {
        clipMin,
        clipMinBlock,
        clipMinInline,
        clipOrigin,
        clipOriginBlock,
        clipOriginInline
      }
    } = _ref11;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: clsx("".concat(GetBaseClass(), "-clip")),
      style: {
        ["--".concat(GetBaseClass(), "-clip-origin-inline")]: (_ref12 = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref12 !== void 0 ? _ref12 : 0.5,
        ["--".concat(GetBaseClass(), "-clip-origin-block")]: (_ref13 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref13 !== void 0 ? _ref13 : 0,
        ["--".concat(GetBaseClass(), "-clip-min-inline")]: (_ref14 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref14 !== void 0 ? _ref14 : 1,
        ["--".concat(GetBaseClass(), "-clip-min-block")]: (_ref15 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref15 !== void 0 ? _ref15 : 0
      }
    };
  }
  x(forwardElementRef(function Clip(_ref16, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref16;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ClipFade(_ref17, ref) {
    let {
      delayMountUntilShown,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      clipMin,
      clipMinBlock,
      clipMinInline,
      clipOrigin,
      clipOriginBlock,
      clipOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref17;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   *
   * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
   *
   * @example <Transitionable measure {...useCreateCollapseProps(...)} />
   */
  function useBasePropsCollapse(_ref18) {
    let {
      collapseParameters: {
        minBlockSize
      }
    } = _ref18;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-collapse"),
      style: {
        ["--".concat(GetBaseClass(), "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
   *
   * *Important*: This component is *not* efficient for the browser to animate!
   * Make sure you do testing on lower power devices, or prefer a lighter
   * alternative, like `<Clip>`.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Collapse(_ref19, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      delayMountUntilShown,
      minBlockSize,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref19;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function CollapseFade(_ref20, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      animateOnMount,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      exitVisibility,
      minBlockSize,
      onVisibilityChange,
      ...rest
    } = _ref20;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsFlip(_ref21) {
    var _useLastNonNullValue, _useLastNonNullValue2;
    let {
      flipParameters: {
        flipAngleBlock,
        flipAngleInline,
        flipPerspective
      }
    } = _ref21;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-flip"),
      style: {
        ["--".concat(GetBaseClass(), "-flip-angle-inline")]: "".concat((_useLastNonNullValue = useLastNonNullValue(flipAngleInline)) !== null && _useLastNonNullValue !== void 0 ? _useLastNonNullValue : 0, "deg"),
        ["--".concat(GetBaseClass(), "-flip-angle-block")]: "".concat((_useLastNonNullValue2 = useLastNonNullValue(flipAngleBlock)) !== null && _useLastNonNullValue2 !== void 0 ? _useLastNonNullValue2 : 0, "deg"),
        ["--".concat(GetBaseClass(), "-perspective")]: "".concat(flipPerspective !== null && flipPerspective !== void 0 ? flipPerspective : 800, "px")
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
   *
   * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * exclusivityKey allows for convenient setups inside of a `SwapContainer`
   * (`flipInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Flip(_ref22, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      flipAngleInline,
      flipAngleBlock,
      flipPerspective,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref22;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFlip({
          flipParameters: {
            flipAngleBlock,
            flipAngleInline,
            flipPerspective
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsSlide(_ref23) {
    var _slideTargetInline, _slideTargetBlock;
    let {
      slideParameters: {
        slideTargetInline,
        slideTargetBlock
      }
    } = _ref23;
    slideTargetInline = useLastNonNullValue(slideTargetInline);
    slideTargetBlock = useLastNonNullValue(slideTargetBlock);
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-slide"),
      style: {
        ["--".concat(GetBaseClass(), "-slide-target-inline")]: "".concat((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 0),
        ["--".concat(GetBaseClass(), "-slide-target-block")]: "".concat((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
   *
   * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * which allows for convenient setups inside of a `SwapContainer`
   * (`slideInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Slide(_ref24, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      onVisibilityChange,
      slideTargetInline,
      slideTargetBlock,
      show,
      animateOnMount,
      exitVisibility,
      delayMountUntilShown,
      ...rest
    } = _ref24;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange,
        propsIncoming: useMergedProps(useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideFade(_ref25, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref25;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsZoom(_ref26) {
    var _ref27, _ref28, _ref29, _ref30;
    let {
      zoomParameters: {
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }
    } = _ref26;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-zoom"),
      style: {
        ["--".concat(GetBaseClass(), "-zoom-origin-inline")]: "".concat((_ref27 = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref27 !== void 0 ? _ref27 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-origin-block")]: "".concat((_ref28 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref28 !== void 0 ? _ref28 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-min-inline")]: "".concat((_ref29 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref29 !== void 0 ? _ref29 : 0),
        ["--".concat(GetBaseClass(), "-zoom-min-block")]: "".concat((_ref30 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref30 !== void 0 ? _ref30 : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
   * @see `Transitionable` `ZoomFade`
   */
  x(forwardElementRef(function Zoom(_ref31, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref31;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoom(_ref32, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref32;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoomFade(_ref33, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      fadeMax,
      fadeMin,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref33;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ZoomFade(_ref34, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref34;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.12.1", l$2, {
    Fragment: d$2,
    Component: _$2
  });
  var o = {};
  function a(e) {
    return e.type === d$2 ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
  }
  var i = [],
    c = [];
  function s() {
    return i.length > 0 ? i[i.length - 1] : null;
  }
  var u = !1;
  function l(e) {
    return "function" == typeof e.type && e.type != d$2;
  }
  function f(n) {
    for (var e = [n], t = n; null != t.__o;) e.push(t.__o), t = t.__o;
    return e.reduce(function (n, e) {
      n += "  in " + a(e);
      var t = e.__source;
      return t ? n += " (at " + t.fileName + ":" + t.lineNumber + ")" : u || (u = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
    }, "");
  }
  var p = "function" == typeof WeakMap;
  function d(n) {
    return n ? "function" == typeof n.type ? d(n.__) : n : {};
  }
  var h = _$2.prototype.setState;
  _$2.prototype.setState = function (n, e) {
    return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(s())), h.call(this, n, e);
  };
  var y = _$2.prototype.forceUpdate;
  function v(n) {
    var e = n.props,
      t = a(n),
      o = "";
    for (var r in e) if (e.hasOwnProperty(r) && "children" !== r) {
      var i = e[r];
      "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), o += " " + r + "=" + JSON.stringify(i);
    }
    var c = e.children;
    return "<" + t + o + (c && c.length ? ">..</" + t + ">" : " />");
  }
  _$2.prototype.forceUpdate = function (n) {
    return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(s())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + f(this.__v)), y.call(this, n);
  }, function () {
    !function () {
      var n = l$2.__b,
        t = l$2.diffed,
        o = l$2.__,
        r = l$2.vnode,
        a = l$2.__r;
      l$2.diffed = function (n) {
        l(n) && c.pop(), i.pop(), t && t(n);
      }, l$2.__b = function (e) {
        l(e) && i.push(e), n && n(e);
      }, l$2.__ = function (n, e) {
        c = [], o && o(n, e);
      }, l$2.vnode = function (n) {
        n.__o = c.length > 0 ? c[c.length - 1] : null, r && r(n);
      }, l$2.__r = function (n) {
        l(n) && c.push(n), a && a(n);
      };
    }();
    var n = !1,
      t = l$2.__b,
      r = l$2.diffed,
      s = l$2.vnode,
      u = l$2.__e,
      h = l$2.__,
      y = l$2.__h,
      m = p ? {
        useEffect: new WeakMap(),
        useLayoutEffect: new WeakMap(),
        lazyPropTypes: new WeakMap()
      } : null,
      b = [];
    l$2.__e = function (n, e, t, o) {
      if (e && e.__c && "function" == typeof n.then) {
        var r = n;
        n = new Error("Missing Suspense. The throwing component was: " + a(e));
        for (var i = e; i; i = i.__) if (i.__c && i.__c.__c) {
          n = r;
          break;
        }
        if (n instanceof Error) throw n;
      }
      try {
        (o = o || {}).componentStack = f(e), u(n, e, t, o), "function" != typeof n.then && setTimeout(function () {
          throw n;
        });
      } catch (n) {
        throw n;
      }
    }, l$2.__ = function (n, e) {
      if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
      var t;
      switch (e.nodeType) {
        case 1:
        case 11:
        case 9:
          t = !0;
          break;
        default:
          t = !1;
      }
      if (!t) {
        var o = a(n);
        throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + o + " />, " + e + ");");
      }
      h && h(n, e);
    }, l$2.__b = function (e) {
      var r = e.type,
        i = d(e.__);
      if (n = !0, void 0 === r) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + v(e) + "\n\n" + f(e));
      if (null != r && "object" == typeof r) {
        if (void 0 !== r.__k && void 0 !== r.__e) throw new Error("Invalid type passed to createElement(): " + r + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + v(r) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
        throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r) ? "array" : r));
      }
      if ("thead" !== r && "tfoot" !== r && "tbody" !== r || "table" === i.type ? "tr" === r && "thead" !== i.type && "tfoot" !== i.type && "tbody" !== i.type && "table" !== i.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + v(e) + "\n\n" + f(e)) : "td" === r && "tr" !== i.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + v(e) + "\n\n" + f(e)) : "th" === r && "tr" !== i.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + v(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + v(e) + "\n\n" + f(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("string" == typeof e.type) for (var c in e.props) if ("o" === c[0] && "n" === c[1] && "function" != typeof e.props[c] && null != e.props[c]) throw new Error("Component's \"" + c + '" property should be a function, but got [' + typeof e.props[c] + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && m && !m.lazyPropTypes.has(e.type)) {
          var s = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
          try {
            var u = e.type();
            m.lazyPropTypes.set(e.type, !0), console.warn(s + "Component wrapped in lazy() is " + a(u));
          } catch (n) {
            console.warn(s + "We will log the wrapped component's name once it is loaded.");
          }
        }
        var l = e.props;
        e.type.__f && delete (l = function (n, e) {
          for (var t in e) n[t] = e[t];
          return n;
        }({}, l)).ref, function (n, e, t, r, a) {
          Object.keys(n).forEach(function (t) {
            var i;
            try {
              i = n[t](e, t, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (n) {
              i = n;
            }
            i && !(i.message in o) && (o[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
          });
        }(e.type.propTypes, l, 0, a(e), function () {
          return f(e);
        });
      }
      t && t(e);
    }, l$2.__h = function (e, t, o) {
      if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
      y && y(e, t, o);
    };
    var w = function (n, e) {
        return {
          get: function () {
            var t = "get" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
          },
          set: function () {
            var t = "set" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
          }
        };
      },
      g = {
        nodeName: w("nodeName", "use vnode.type"),
        attributes: w("attributes", "use vnode.props"),
        children: w("children", "use vnode.props.children")
      },
      E = Object.create({}, g);
    l$2.vnode = function (n) {
      var e = n.props;
      if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
        var t = n.props = {};
        for (var o in e) {
          var r = e[o];
          "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
        }
      }
      n.__proto__ = E, s && s(n);
    }, l$2.diffed = function (e) {
      if (e.__k && e.__k.forEach(function (n) {
        if ("object" == typeof n && n && void 0 === n.type) {
          var t = Object.keys(n).join(",");
          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + f(e));
        }
      }), n = !1, r && r(e), null != e.__k) for (var t = [], o = 0; o < e.__k.length; o++) {
        var a = e.__k[o];
        if (a && null != a.key) {
          var i = a.key;
          if (-1 !== t.indexOf(i)) {
            console.error('Following component has two or more children with the same key attribute: "' + i + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + v(e) + "\n\n" + f(e));
            break;
          }
          t.push(i);
        }
      }
    };
  }();

  /**
   * Relatively low-level hook that allows you to inspect
   * when the entire URL changes, either because the hash changed,
   * or because the Back/Forward browser buttons were pressed.
   *
   * (Changing query parameters reloads the page and so isn't
   * tracked, unless of course it's because of the browser
   * navigating back/forwards).
   *
   * In general, you'll want to inspect a specific directory of
   * a path, or a specific query parameter value, not the
   * entire URL.
   */
  function useUrl(onUrlChange) {
    const [getUrl, setUrl] = usePassiveState$1(useStableCallback$1(onUrlChange), T$1(() => window.location.toString(), []));
    useGlobalHandler(window, "hashchange", e => {
      setUrl(window.location.toString());
    });
    useGlobalHandler(window, "popstate", e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#the_history_stack
      // TODO: If this assert never fires, it's *probably* fine??
      console.assert(window.location.toString() === document.location.toString());
      setUrl(window.location.toString());
    });
    return [getUrl, setUrl];
  }

  //export const RouterLevelContext = createContext(0);
  /**
   * Internal helper to trim the crusts off of a hash path.
   * @param hash
   * @returns
   */
  function trimHash(hash) {
    if (hash.startsWith("#")) hash = hash.substr(1);
    if (hash.startsWith("/")) hash = hash.substr(1);
    if (hash.endsWith("/")) hash = hash.substr(0, hash.length - 1);
    return hash;
  }
  function normalizeHashToPath(hash) {
    hash = trimHash(hash);
    return hash.split("/");
  }
  // Not public -- just contains shared code for history modification.
  // This is what actually changes History and updates the window's URL.
  function setEntireHash(hash, action) {
    var _action;
    (_action = action) !== null && _action !== void 0 ? _action : action = "push";
    hash = trimHash(hash);
    let oldURL = window.location.toString();
    let nextUrl = new URL(window.location.toString());
    nextUrl.hash = "#".concat(hash);
    history["".concat(action, "State")]({}, document.title, nextUrl);
    // Modifying history doesn't actually cause a hashchange event.
    window.dispatchEvent(new HashChangeEvent('hashchange', {
      oldURL,
      newURL: nextUrl.toString()
    }));
  }
  /**
   * Modifies the given Search Params object to have its key be set to the given value.
   *
   * Specifically for boolean types this ensures that the param is simply existant/non-existant,
   * but for other types this is pretty straightforward.
   * @param params
   * @param key
   * @param value
   * @param type
   */
  function unparseParam(params, key, value, type) {
    if (type === "boolean") {
      if (value === true) {
        params.set(key, "");
      } else {
        params.delete(key);
      }
    } else {
      params.set(key, "".concat(value));
    }
  }
  /**
   * Parses the requested Search Param from the given URL.
   *
   * The type will be automatically parsed with special handling for booleans
   */
  function parseParam(url, key, type) {
    let value = url.searchParams.get(key);
    switch (type) {
      case "string":
        return value !== null && value !== void 0 ? value : null;
      case "boolean":
        return value != null;
      case "number":
        if (value == null) return null;
        let parsed = +value;
        if (isFinite(parsed)) return parsed;
        return null;
      case "bigint":
        if (value == null) return null;
        try {
          return BigInt(value);
        } catch (ex) {
          return null;
        }
    }
    return value !== null && value !== void 0 ? value : null;
  }
  //export interface RouterChildInfo extends ManagedChildInfo<string> {
  //    notifyOfSiblingsHaveNoMatches(noMatches: boolean): void;
  //path: RouterPathType | null;
  //    matches: boolean | null;
  //}

  function useConsumeRouter(_ref35) {
    let {
      context,
      managedChildParameters,
      managedChildParameters: {
        index
      },
      consumeRouterParameters: {
        onLocalPathChange,
        localPath: wantedLocalPath
      }
    } = _ref35;
    const {
      routerContext: {
        level,
        notifyParentThatNonDefaultMatchHasChanged
      }
    } = context;
    const [anyMatchesAmongNonDefaultSiblings, setAnyMatchesAmongNonDefaultSiblings] = useState$1(null);
    const [pathWhenMatching, setPathWhenMatching] = useState$1(null);
    const {
      managedChildReturn
    } = useManagedChild$1({
      context,
      managedChildParameters
    }, {
      index,
      setAnyMatchesAmongNonDefaultSiblings: useStableCallback$1(anyMatches => {
        setAnyMatchesAmongNonDefaultSiblings(anyMatches);
        onLocalPathChange2(wantedLocalPath, anyMatches, getLocalPath());
      })
    });
    s$1(() => {
      onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, getLocalPath());
    }, [wantedLocalPath, anyMatchesAmongNonDefaultSiblings]);
    const onLocalPathChange2 = useStableCallback$1(function (wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path) {
      const matches = pathCompare(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
      setMatches(matches);
      console.log("".concat(index, ": onLocalPathChange2(wlp: ").concat((wantedLocalPath !== null && wantedLocalPath !== void 0 ? wantedLocalPath : "null").toString(), ", amands: ").concat((anyMatchesAmongNonDefaultSiblings !== null && anyMatchesAmongNonDefaultSiblings !== void 0 ? anyMatchesAmongNonDefaultSiblings : "null").toString(), ", p: ").concat(path, "): ").concat((matches !== null && matches !== void 0 ? matches : "null").toString()));
      if (matches) setPathWhenMatching(path);
      if (wantedLocalPath != null) {
        notifyParentThatNonDefaultMatchHasChanged(index, matches);
      } else {
        notifyParentThatNonDefaultMatchHasChanged(index, null);
      }
    });
    const [matches, setMatches] = useState$1(null);
    const [getLocalPath, setLocalPath] = useLocalPath({
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange: useStableCallback$1((path, prev, reason) => {
          onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
          onLocalPathChange === null || onLocalPathChange === void 0 ? void 0 : onLocalPathChange(path, prev, reason);
        })
      }
    });
    return {
      managedChildReturn,
      consumeRouterReturn: {
        level,
        matches,
        getLocalPath,
        setLocalPath,
        pathWhenMatching
      }
    };
  }
  function useLocalPath(_ref36) {
    let {
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange
      }
    } = _ref36;
    useEnsureStability$1("useLocalPath", level);
    const urlToPath = T$1(url => {
      const oldHashPath = normalizeHashToPath(trimHash(new URL(url).hash));
      return oldHashPath[level];
    }, []);
    const [getLocalPath, setLocalPath] = usePassiveState$1(useStableCallback$1(onLocalPathChange), T$1(() => {
      return urlToPath(window.location.href);
    }, [urlToPath]));
    // Any time the URL changes, inspect the hash
    // at our current level, and change our local copy of our path
    // in our passive state. This will trigger our callback if they're different.
    useUrl(url => {
      setLocalPath(urlToPath(url));
    });
    return [getLocalPath, setLocalPath];
  }
  function pathCompare(requestedLocalHash, anyMatchesAmongNonDefaultSiblings, localPath) {
    var _localPath;
    let matches;
    (_localPath = localPath) !== null && _localPath !== void 0 ? _localPath : localPath = "";
    if (requestedLocalHash instanceof RegExp) matches = requestedLocalHash.test(localPath);else if (requestedLocalHash instanceof Function) matches = requestedLocalHash(localPath);else if (requestedLocalHash == null) matches = anyMatchesAmongNonDefaultSiblings == null ? null : !anyMatchesAmongNonDefaultSiblings;else matches = requestedLocalHash === localPath;
    return matches;
  }

  /**
   * Error class used when attemps to modify the root directory occur.
   */
  class RootRouterError extends Error {
    constructor() {
      super("The root Router's path can only be pushed to and cannot be set or popped from.");
    }
  }

  /**
   * Removes the directory at the current level, effectively returning
   * to the previous level.  You can also switch to a different
   * previous level if you would like.
   */
  function usePopLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      setEntireHash(popLocalPath(level, dir), action);
    }, [level]);
  }
  function popLocalPath(level, dir) {
    if (level < 0) throw new RootRouterError();
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, level).map(s => s !== null && s !== void 0 ? s : "");
    if (dir) {
      dir = trimHash(dir);
      newHashPath[newHashPath.length - 1] = dir;
    }
    return newHashPath.join("/");
  }

  /**
   * Adds a directory at one level deeper.
   */
  function usePushLocalPath(level) {
    return T$1(function pushLocalHash(dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      dir = trimHash(dir);
      const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
      let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
      newHashPath.splice(level + 1, 1, dir);
      setEntireHash(newHashPath.join("/"), action);
    }, [level]);
  }

  /**
   * Replaces the directory at the current level with a new one. You can
   * choose whether or not any trailing paths are kept -- by default this is false.
   * @returns
   */
  function useSetLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      setEntireHash(setLocalPath(level, dir, keepTrailing || false), action);
    }, [level]);
  }
  function setLocalPath(level, dir, keepTrailing) {
    if (level < 0) throw new RootRouterError();
    dir = trimHash(dir);
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
    newHashPath.splice(level, 1, dir);
    return newHashPath.join("/");
  }

  /**
   * Allows easy access to the controls at the current level.
   *
   * You can also get this information from a child <Router />
   * by passing in a ref (e.g. <Router ref={setControls} />).
   */
  function useRouterControls(level) {
    // This is the hash at this level specifically, 
    // so it contains no directory separators.
    const popLocalPath = usePopLocalPath(level);
    const pushLocalPath = usePushLocalPath(level);
    const setLocalPath = useSetLocalPath(level);
    return F$1(() => ({
      popLocalPath,
      pushLocalPath,
      setLocalPath
    }), [popLocalPath, pushLocalPath, setLocalPath]);
  }
  const RouterContext = E(null);
  //const RouterContext = createContext<RouterContextType | null>(null);
  /**
   * The "parent" part of a router.
   *
   * This is responsible for coordinating, among all children, which route to show.
   * This coordination is really only needed for the "default" pathway, which
   * needs to know as painlessly as possible whether any of its siblings are currently valid.
   *
   * It also increases the depth by one, starting at depth=-1 for the root router is *just* a parent.
   */
  function useProvideRouter(_ref37) {
    var _q;
    let {
      managedChildrenParameters
    } = _ref37;
    const {
      context,
      managedChildrenReturn
    } = useManagedChildren$1({
      managedChildrenParameters
    });
    const {
      routerContext: {
        level
      }
    } = (_q = q(RouterContext)) !== null && _q !== void 0 ? _q : {
      routerContext: {
        level: -1
      }
    };
    const matchingIndices = _(new Set());
    const [getShowingDefault, setShowingDefault] = usePassiveState$1(useStableCallback$1(showingDefault => {
      managedChildrenReturn.getChildren().forEach(child => {
        child.setAnyMatchesAmongNonDefaultSiblings(!showingDefault);
      });
    }), returnNull$1);
    const onNonDefaultChildMatchChanged = useStableCallback$1((index, matches) => {
      matchingIndices.current[matches ? "add" : "delete"](index);
      setShowingDefault(matchingIndices.current.size == 0);
    });
    return {
      context: useStableObject$1({
        ...context,
        routerContext: useStableObject$1({
          level: level + 1,
          notifyParentThatNonDefaultMatchHasChanged: onNonDefaultChildMatchChanged
        })
      }),
      managedChildrenReturn
    };
  }

  /**
   * Allows you to conditionally hide/show content based on a path in the hash component of the URL.
   *
   * @param param0
   * @param ref
   * @returns
   */
  function Router(_ref38, ref) {
    var _consumeRouterReturn;
    let {
      localPath,
      onLocalPathChange,
      children
    } = _ref38;
    const context = q(RouterContext);
    const {
      context: contextFromParent,
      managedChildrenReturn
    } = useProvideRouter({
      managedChildrenParameters: {}
    });
    const index = F$1(() => (localPath !== null && localPath !== void 0 ? localPath : "<default>") + "-".concat(Math.random()), [localPath]);
    let consumeRouterReturn = null;
    useEnsureStability$1("Router", !!context);
    if (context) {
      consumeRouterReturn = useConsumeRouter({
        consumeRouterParameters: {
          localPath,
          onLocalPathChange
        },
        context,
        managedChildParameters: {
          index
        }
      });
    }
    const {
      consumeRouterReturn: {
        level,
        matches,
        pathWhenMatching
      }
    } = (_consumeRouterReturn = consumeRouterReturn) !== null && _consumeRouterReturn !== void 0 ? _consumeRouterReturn : {
      consumeRouterReturn: {
        level: -1,
        matches: null,
        pathWhenMatching: null
      }
    };
    const controls = useRouterControls(level);
    A(ref, () => ({
      level,
      matches,
      pathWhenMatching,
      ...controls
    }));
    return o$2(RouterContext.Provider, {
      value: contextFromParent,
      children: children(level == -1 ? "/" : matches ? pathWhenMatching : null, useRouterControls(level))
    });
  }

  /**
   * Provides access to the requested Search Param's value
   *
   * Note that while this function is like usePassiveState (itself like useState and useEffect combined),
   * the `setState` return function is, due to browser limitations, not syncronous, but that's
   * like most calls to `setState` anyway I guess?
   *
   * @param paramKey The name of the URL search parameter to reference
   * @param type The type of data encode/decode (`"string"` | `"boolean"` | `"number"` | `"bigint"`)
   * @param onParamValueChanged Will be called any time the requested Search Parameter's value changes.
   */
  function useSearchParams(paramKey, type, onParamValueChanged) {
    // We keep a local copy of our current Search Param value
    // because changing it is actually an asyncronous operation
    // and we can't know when it ends aside from just "did the URL change or not"
    // so we might as well keep this state around locally to compensate.
    const [getSavedParamValue, setSavedParamValue] = usePassiveState$1(onParamValueChanged, T$1(() => {
      return parseParam(new URL(window.location.toString()), paramKey, type);
    }, []));
    const setParamWithHistory = useStableCallback$1((newValueOrUpdater, reason) => {
      let prevValue = parseParam(new URL(window.location.toString()), paramKey, type);
      let nextValue = typeof newValueOrUpdater == "function" ? newValueOrUpdater(prevValue) : newValueOrUpdater;
      let newParams = new URLSearchParams(new URL(window.location.toString()).searchParams);
      unparseParam(newParams, paramKey, nextValue, type);
      let nextUrl = new URL(window.location.toString());
      nextUrl.search = prettyPrintParams(newParams);
      history["".concat(reason !== null && reason !== void 0 ? reason : "replace", "State")]({}, document.title, nextUrl);
      setSavedParamValue(nextValue);
    });
    // Any time the URL changes, it means the Search Param we care about might have changed.
    // Parse it out and save it.
    useUrl(useStableCallback$1(url => {
      const newParam = parseParam(new URL(url), paramKey, type);
      setSavedParamValue(newParam);
    }));
    return [getSavedParamValue, setParamWithHistory];
  }
  function prettyPrintParams(params) {
    const paramArray = [...params.entries()].filter((key, value) => value != null);
    if (paramArray.length == 0) return "";
    let queryString = paramArray.map(_ref39 => {
      let [key, value] = _ref39;
      if (value === "" || value === true) return "".concat(encodeURIComponent(key));else return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
    }).join("&");
    return "?".concat(queryString);
  }
  const Component = () => {
    const [url, setUrl] = useState$1("");
    useUrl(setUrl);
    const [example, setExampleLocal] = useState$1(null);
    const [getExample, setExample] = useSearchParams("example", "number");
    return o$2(Router, {
      localPath: null,
      children: (path, _ref40) => {
        let {
          pushLocalPath,
          popLocalPath,
          setLocalPath
        } = _ref40;
        return path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is the current URL: ", o$2("code", {
              children: url
            }), "."]
          }), o$2("p", {
            children: "This is content in the root router. It is always displayed, no matter what."
          }), o$2("p", {
            children: ["The ", o$2("code", {
              children: "Router"
            }), " that's rendering this content cannot have path-related functions performed on it, since the path is always just implicitly ", o$2("code", {
              children: "/"
            }), "."]
          }), o$2("p", {
            children: "Just beneath me is a child component that reads the first path after the root."
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => {
                debugger;
                pushLocalPath("test1");
              },
              children: "Push \"test1\""
            })
          }), o$2("p", {
            children: o$2("button", {
              disabled: true,
              onClick: () => popLocalPath(),
              children: "Pop"
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => setLocalPath("test1"),
              children: "Set \"test1\""
            })
          }), o$2("p", {
            children: o$2("label", {
              children: ["Search param example: ", o$2("input", {
                value: example !== null && example !== void 0 ? example : undefined,
                type: "number",
                onInput: e => setExample(e.currentTarget.valueAsNumber)
              })]
            })
          }), o$2("hr", {}), o$2(Swappable, {
            children: o$2("div", {
              children: o$2(Level1, {})
            })
          })]
        });
      }
    });
  };
  function Level1() {
    //const [{ popLocalPath, pushLocalPath, setLocalPath }, setRouteControls] = useState<Partial<RouterControls>>({});
    return o$2(d$2, {
      children: [o$2(Router, {
        localPath: null,
        children: (path, _ref41) => {
          let {
            popLocalPath,
            pushLocalPath,
            setLocalPath
          } = _ref41;
          return path != null && o$2("div", {
            children: [o$2("p", {
              children: ["This is within the first-level child ", o$2("code", {
                children: "Router"
              }), " that displays ", o$2("em", {
                children: "default content"
              }), ". That is, if no other ", o$2("code", {
                children: "Router"
              }), " at this level matches (which is presumably true if you're reading this), then ", o$2("em", {
                children: "this"
              }), " ", o$2("code", {
                children: "Router"
              }), " will display."]
            }), o$2("p", {
              children: ["The current path is: ", o$2("code", {
                children: path
              })]
            }), o$2("p", {
              children: ["These buttons are hooked up to this ", o$2("code", {
                children: "Router"
              }), "'s ", o$2("code", {
                children: "ref"
              }), ", so they control this level in the path."]
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("");
              },
              children: "(empty string)"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test1");
              },
              children: "test1"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test2");
              },
              children: "test2"
            })]
          });
        }
      }), o$2(Router, {
        localPath: "",
        children: path => path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is within the first-level child ", o$2("code", {
              children: "Router"
            }), " that displays when the path is empty (this is different from the default path, taken when there is no match from anyone at this level)."]
          }), o$2("p", {
            children: ["The current path is: ", o$2("code", {
              children: path
            })]
          })]
        })
      })]
    });
  }
  /*
  function Test1() {
        const [{ popLocalPath: popHash1, pushLocalPath: pushHash1, setLocalPath: setHash1 }, setRouteControls] = useState<Partial<RouterControls>>({});
       return (
          <>
              <p>This is within the first-level child <code>Router</code> that displays when the path is <code>test1</code>.<Test1 /></p>
              <p>Level 1, Test1
                  <button onClick={() => { debugger; pushHash1?.("testa") }}>testA</button>
                  <Router ref={setRouteControls} localPath="testa">
                      <div>A</div>
                  </Router>
              </p>
          </>
       )
  }
   function Test2() {
      const [route0Controls, setRoute0Controls] = useState<RouterRefType | null>(null);
      const [route1Controls, setRoute1Controls] = useState<RouterRefType | null>(null);
       const [param, setParam] = useSearchParams("param", "boolean");
      console.log(param == null ? "<null>" : param);
      return (<>
          Test2: "{param == null ? "<null>" : param}".
          <Swappable>
              <span>
                  <Router ref={setRoute1Controls} localPath="">
                      <div>
                          Test2
                          <button onClick={() => route1Controls?.setLocalPath?.("testa")}>testA</button>
                      </div>
                  </Router>
                  <Router ref={setRoute1Controls} localPath="testa">
                      <div>
                          <div>A</div>
                          <label><input checked={param ?? false} type="checkbox" onInput={e => { e.preventDefault(); setParam(e.currentTarget.checked) }} />Checkbox</label>
                      </div>
                  </Router>
              </span>
          </Swappable>
      </>
      )
  }*/
  requestAnimationFrame(() => {
    q$1(o$2(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jYXRjaC1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDFhNjVmMWRmYWVlMGJlNzk2OWZhNzFmOGVhZWQ1MjM4MmM3YzIwNThfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AxYTY1ZjFkZmFlZTBiZTc5NjlmYTcxZjhlYWVkNTIzODJjN2MyMDU4X3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AxYTY1ZjFkZmFlZTBiZTc5NjlmYTcxZjhlYWVkNTIzODJjN2MyMDU4X3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMWE2NWYxZGZhZWUwYmU3OTY5ZmE3MWY4ZWFlZDUyMzgyYzdjMjA1OF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMWE2NWYxZGZhZWUwYmU3OTY5ZmE3MWY4ZWFlZDUyMzgyYzdjMjA1OF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AxYTY1ZjFkZmFlZTBiZTc5NjlmYTcxZjhlYWVkNTIzODJjN2MyMDU4X3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tpbmctZWxlbWVudHNAMC4xLjEvbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS93aWNnLWluZXJ0QDMuMS4yL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMWE2NWYxZGZhZWUwYmU3OTY5ZmE3MWY4ZWFlZDUyMzgyYzdjMjA1OF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLW1hbmFnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMWE2NWYxZGZhZWUwYmU3OTY5ZmE3MWY4ZWFlZDUyMzgyYzdjMjA1OF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvUHVyZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9wb3J0YWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AxYTY1ZjFkZmFlZTBiZTc5NjlmYTcxZjhlYWVkNTIzODJjN2MyMDU4X3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vY2xzeEAxLjIuMS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXJlZnMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2NraW5nLWVsZW1lbnRzQDAuMS4xL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vd2ljZy1pbmVydEAzLjEuMi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvY29udGV4dC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2V4Y2x1c2l2ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvdXRpbC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3N3YXBwYWJsZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb25hYmxlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvZmFkZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NsaXAudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jbGlwLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jb2xsYXBzZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NvbGxhcHNlLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9mbGlwLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvc2xpZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS1mYWRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvem9vbS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3NsaWRlLXpvb20udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS16b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy96b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGV2dG9vbHMvc3JjL2RldnRvb2xzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NoZWNrLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NvbXBvbmVudC1zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9kZWJ1Zy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9pbmRleC5qcyIsIi4uL3NyYy91c2UtdXJsLnRzeCIsIi4uL3NyYy91dGlsLnRzeCIsIi4uL3NyYy91c2Utcm91dGVyLWNvbnN1bWVyLnRzeCIsIi4uL3NyYy9yb290LXJvdXRlci1lcnJvci50cyIsIi4uL3NyYy91c2UtcG9wLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1wdXNoLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1zZXQtbG9jYWwtcGF0aC50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1jb250cm9scy50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1wcm92aWRlci50c3giLCIuLi9zcmMvcm91dGVyLnRzeCIsIi4uL3NyYy91c2Utc2VhcmNoLXBhcmFtcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHR3aGlsZSAoKGMgPSByZXJlbmRlclF1ZXVlLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKGMuX2RpcnR5KSB7XG5cdFx0XHRsZXQgcmVuZGVyUXVldWVMZW5ndGggPSByZXJlbmRlclF1ZXVlLmxlbmd0aDtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjKTtcblx0XHRcdGlmIChyZXJlbmRlclF1ZXVlLmxlbmd0aCA+IHJlbmRlclF1ZXVlTGVuZ3RoKSB7XG5cdFx0XHRcdC8vIFdoZW4gaS5lLiByZXJlbmRlcmluZyBhIHByb3ZpZGVyIGFkZGl0aW9uYWwgbmV3IGl0ZW1zIGNhbiBiZSBpbmplY3RlZCwgd2Ugd2FudCB0b1xuXHRcdFx0XHQvLyBrZWVwIHRoZSBvcmRlciBmcm9tIHRvcCB0byBib3R0b20gd2l0aCB0aG9zZSBuZXcgaXRlbXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtIGluIGFcblx0XHRcdFx0Ly8gc2luZ2xlIHBhc3Ncblx0XHRcdFx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbn1cblxucHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG4iLCJpbXBvcnQgeyBlbnF1ZXVlUmVuZGVyIH0gZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQgbGV0IGkgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNvbnRleHRJZCkge1xuXHRjb250ZXh0SWQgPSAnX19jQycgKyBpKys7XG5cblx0Y29uc3QgY29udGV4dCA9IHtcblx0XHRfaWQ6IGNvbnRleHRJZCxcblx0XHRfZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dFZhbHVlKSB7XG5cdFx0XHQvLyByZXR1cm4gcHJvcHMuY2hpbGRyZW4oXG5cdFx0XHQvLyBcdGNvbnRleHRbY29udGV4dElkXSA/IGNvbnRleHRbY29udGV4dElkXS5wcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZVxuXHRcdFx0Ly8gKTtcblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbihjb250ZXh0VmFsdWUpO1xuXHRcdH0sXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRQcm92aWRlcihwcm9wcykge1xuXHRcdFx0aWYgKCF0aGlzLmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudFtdfSAqL1xuXHRcdFx0XHRsZXQgc3VicyA9IFtdO1xuXHRcdFx0XHRsZXQgY3R4ID0ge307XG5cdFx0XHRcdGN0eFtjb250ZXh0SWRdID0gdGhpcztcblxuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IGN0eDtcblxuXHRcdFx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKF9wcm9wcykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBfcHJvcHMudmFsdWUpIHtcblx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhlIGZvcmNlZCB2YWx1ZSBwcm9wYWdhdGlvbiBoZXJlIHdhcyBvbmx5IG5lZWRlZCB3aGVuIGBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nYCB3YXMgYmVpbmcgYnlwYXNzZWQ6XG5cdFx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2NvbW1pdC80ZDMzOWZiODAzYmVhMDllOWYxOThhYmYzOGNhMWJmOGVhNGI3NzcxI2RpZmYtNTQ2ODJjZTM4MDkzNWE3MTdlNDFiOGJmYzU0NzM3ZjZSMzU4XG5cdFx0XHRcdFx0XHQvLyBJbiB0aG9zZSBjYXNlcyB0aG91Z2gsIGV2ZW4gd2l0aCB0aGUgdmFsdWUgY29ycmVjdGVkLCB3ZSdyZSBkb3VibGUtcmVuZGVyaW5nIGFsbCBub2Rlcy5cblx0XHRcdFx0XHRcdC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IHRlbGwgZm9sa3Mgbm90IHRvIHVzZSBmb3JjZS1zeW5jIG1vZGUuXG5cdFx0XHRcdFx0XHQvLyBDdXJyZW50bHksIHVzaW5nIGB1c2VDb250ZXh0KClgIGluIGEgY2xhc3MgY29tcG9uZW50IHdpbGwgb3ZlcndyaXRlIGl0cyBgdGhpcy5jb250ZXh0YCB2YWx1ZS5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0ID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0W2NvbnRleHRJZF0gPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0XHRcdHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdFx0Yy5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc3ViID0gYyA9PiB7XG5cdFx0XHRcdFx0c3Vicy5wdXNoKGMpO1xuXHRcdFx0XHRcdGxldCBvbGQgPSBjLmNvbXBvbmVudFdpbGxVbm1vdW50O1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKG9sZCkgb2xkLmNhbGwoYyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuXHRcdH1cblx0fTtcblxuXHQvLyBEZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHdoZW4gaXRcblx0Ly8gZW5jb3VudGVycyBhIFByb3ZpZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0XG5cdC8vIHNldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiB0aGUgY29udGV4dCBvYmplY3QgaW5zdGVhZFxuXHQvLyBvZiBvbiB0aGUgY29tcG9uZW50IGl0c2VsZi4gU2VlOlxuXHQvLyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sI2NvbnRleHRkaXNwbGF5bmFtZVxuXG5cdHJldHVybiAoY29udGV4dC5Qcm92aWRlci5fY29udGV4dFJlZiA9IGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5yZWYgPyBjaGlsZFZOb2RlLnJlZiA6IG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXRMYXN0RG9tKG9sZFBhcmVudFZOb2RlKS5uZXh0U2libGluZztcblx0XHRcdH1cblxuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKHBhcmVudERvbSwgdm5vZGUsIHZub2RlLCBjLCB2bm9kZS5fZG9tLCBvbGREb20pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAxXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGdldExhc3REb20odm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT0gbnVsbCB8fCB0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUuX2RvbTtcblx0fVxuXG5cdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRmb3IgKGxldCBpID0gdm5vZGUuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdFx0bGV0IGxhc3REb20gPSBnZXRMYXN0RG9tKGNoaWxkKTtcblx0XHRcdFx0aWYgKGxhc3REb20pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFzdERvbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnd2lkdGgnICYmXG5cdFx0XHRuYW1lICE9PSAnaGVpZ2h0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlICE9PSBmYWxzZSB8fCBuYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkpIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFByb3h5IGFuIGV2ZW50IHRvIGhvb2tlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGJyb3dzZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuXHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIGZhbHNlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkge1xuXHRcdFx0XHRcdFx0Ly8gV2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgYmFpbCBiZWNhdXNlIG9mIHNDVSB3ZSBoYXZlIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdFx0Ly8gdGhlIHByb3BzLCBzdGF0ZSBhbmQgZGlydHktc3RhdGUuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggc3RyaWN0LWVxdWFsaXR5IHdlIGRvbid0IGFzIHRoZSBjaGlsZCBjb3VsZCBzdGlsbFxuXHRcdFx0XHRcdFx0Ly8gYmUgZGlydGllZCBzZWUgIzM4ODNcblx0XHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEluIGNhc2VzIG9mIGJhaWxpbmcgZHVlIHRvIHN0cmljdC1lcXVhbGl0eSB3ZSBoYXZlIHRvIHJlc2V0IGZvcmNlIGFzIHdlbGxcblx0XHRcdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4uZm9yRWFjaCh2bm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUpIHZub2RlLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblxuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50V2lsbFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjLmNvbXBvbmVudERpZFVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0Yy5fcGFyZW50RG9tID0gcGFyZW50RG9tO1xuXG5cdFx0XHRsZXQgcmVuZGVySG9vayA9IG9wdGlvbnMuX3JlbmRlcixcblx0XHRcdFx0Y291bnQgPSAwO1xuXHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHR9IHdoaWxlIChjLl9kaXJ0eSAmJiArK2NvdW50IDwgMjUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09PSBGcmFnbWVudCAmJiB0bXAua2V5ID09IG51bGw7XG5cdFx0XHRsZXQgcmVuZGVyUmVzdWx0ID0gaXNUb3BMZXZlbEZyYWdtZW50ID8gdG1wLnByb3BzLmNoaWxkcmVuIDogdG1wO1xuXG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShyZW5kZXJSZXN1bHQpID8gcmVuZGVyUmVzdWx0IDogW3JlbmRlclJlc3VsdF0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0Ly8gV2Ugc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgVk5vZGUsIHVuc2V0IGFueSBzdG9yZWQgaHlkcmF0aW9uL2JhaWxvdXQgc3RhdGU6XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0Ly8gaWYgaHlkcmF0aW5nIG9yIGNyZWF0aW5nIGluaXRpYWwgdHJlZSwgYmFpbG91dCBwcmVzZXJ2ZXMgRE9NOlxuXHRcdGlmIChpc0h5ZHJhdGluZyB8fCBleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkRG9tO1xuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9ICEhaXNIeWRyYXRpbmc7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbltleGNlc3NEb21DaGlsZHJlbi5pbmRleE9mKG9sZERvbSldID0gbnVsbDtcblx0XHRcdC8vIF4gY291bGQgcG9zc2libHkgYmUgc2ltcGxpZmllZCB0bzpcblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBSZXVzZSB0aGUgY29tbWl0UXVldWUgdmFyaWFibGUgaGVyZSBzbyB0aGUgdHlwZSBjaGFuZ2VzXG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgU2VlIGFib3ZlIHRzLWlnbm9yZSBvbiBjb21taXRRdWV1ZVxuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cdGxldCBub2RlVHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cdGxldCBpID0gMDtcblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aWYgKG5vZGVUeXBlID09PSAnc3ZnJykgaXNTdmcgPSB0cnVlO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yICg7IGkgPCBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBleGNlc3NEb21DaGlsZHJlbltpXTtcblxuXHRcdFx0Ly8gaWYgbmV3Vk5vZGUgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuIG9yIHRoZSBgZG9tYFxuXHRcdFx0Ly8gYXJndW1lbnQgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuLCByZW1vdmUgaXQgZnJvbVxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4gc28gaXQgaXNuJ3QgbGF0ZXIgcmVtb3ZlZCBpbiBkaWZmQ2hpbGRyZW5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2hpbGQgJiZcblx0XHRcdFx0J3NldEF0dHJpYnV0ZScgaW4gY2hpbGQgPT09ICEhbm9kZVR5cGUgJiZcblx0XHRcdFx0KG5vZGVUeXBlID8gY2hpbGQubG9jYWxOYW1lID09PSBub2RlVHlwZSA6IGNoaWxkLm5vZGVUeXBlID09PSAzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRvbSA9IGNoaWxkO1xuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gPT0gbnVsbCkge1xuXHRcdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBjcmVhdGVUZXh0Tm9kZSByZXR1cm5zIFRleHQsIHdlIGV4cGVjdCBQcmVhY3RFbGVtZW50XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3UHJvcHMpO1xuXHRcdH1cblxuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuXHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlLFxuXHRcdFx0XHRuZXdQcm9wcy5pcyAmJiBuZXdQcm9wc1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHdlIHN0aWxsIGhhdmUgdG8gc3BsaXQgbWVyZ2VkIHRleHQgZnJvbSBTU1InZCBIVE1MLlxuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgKCFpc0h5ZHJhdGluZyB8fCBkb20uZGF0YSAhPT0gbmV3UHJvcHMpKSB7XG5cdFx0XHRkb20uZGF0YSA9IG5ld1Byb3BzO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBJZiBleGNlc3NEb21DaGlsZHJlbiB3YXMgbm90IG51bGwsIHJlcG9wdWxhdGUgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW46XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBleGNlc3NEb21DaGlsZHJlbiAmJiBzbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0Ly8gQnV0LCBpZiB3ZSBhcmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIHVzaW5nIGV4aXN0aW5nIERPTSAoZS5nLiByZXBsYWNlTm9kZSlcblx0XHRcdC8vIHdlIHNob3VsZCByZWFkIHRoZSBleGlzdGluZyBET00gYXR0cmlidXRlcyB0byBkaWZmIHRoZW1cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdG9sZFByb3BzID0ge307XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXdIdG1sIHx8XG5cdFx0XHRcdFx0KCghb2xkSHRtbCB8fCBuZXdIdG1sLl9faHRtbCAhPSBvbGRIdG1sLl9faHRtbCkgJiZcblx0XHRcdFx0XHRcdG5ld0h0bWwuX19odG1sICE9PSBkb20uaW5uZXJIVE1MKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2ZyAmJiBub2RlVHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuXG5cdFx0XHRcdFx0PyBleGNlc3NEb21DaGlsZHJlblswXVxuXHRcdFx0XHRcdDogb2xkVk5vZGUuX2NoaWxkcmVuICYmIGdldERvbVNpYmxpbmcob2xkVk5vZGUsIDApLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW5baV0gIT0gbnVsbCkgcmVtb3ZlTm9kZShleGNlc3NEb21DaGlsZHJlbltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyAjMjc1NiBGb3IgdGhlIDxwcm9ncmVzcz4tZWxlbWVudCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyAwLFxuXHRcdFx0XHQvLyBkZXNwaXRlIHRoZSBhdHRyaWJ1dGUgbm90IGJlaW5nIHByZXNlbnQuIFdoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBpcyBtaXNzaW5nIHRoZSBwcm9ncmVzcyBiYXIgaXMgdHJlYXRlZCBhcyBpbmRldGVybWluYXRlLlxuXHRcdFx0XHQvLyBUbyBmaXggdGhhdCB3ZSdsbCBhbHdheXMgdXBkYXRlIGl0IHdoZW4gaXQgaXMgMCBmb3IgcHJvZ3Jlc3MgZWxlbWVudHNcblx0XHRcdFx0KGkgIT09IGRvbS52YWx1ZSB8fFxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ3Byb2dyZXNzJyAmJiAhaSkgfHxcblx0XHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgZm9yIElFIDExIHRvIGZpeCA8c2VsZWN0PiB2YWx1ZSBub3QgYmVpbmcgdXBkYXRlZC5cblx0XHRcdFx0XHQvLyBUbyBhdm9pZCBhIHN0YWxlIHNlbGVjdCB2YWx1ZSB3ZSBuZWVkIHRvIHNldCB0aGUgb3B0aW9uLnZhbHVlXG5cdFx0XHRcdFx0Ly8gYWdhaW4sIHdoaWNoIHRyaWdnZXJzIElFMTEgdG8gcmUtZXZhbHVhdGUgdGhlIHNlbGVjdCB2YWx1ZVxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ29wdGlvbicgJiYgaSAhPT0gb2xkUHJvcHMudmFsdWUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ3ZhbHVlJywgaSwgb2xkUHJvcHMudmFsdWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0J2NoZWNrZWQnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMuY2hlY2tlZCkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20uY2hlY2tlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ2NoZWNrZWQnLCBpLCBvbGRQcm9wcy5jaGVja2VkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBJbnZva2Ugb3IgdXBkYXRlIGEgcmVmLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uIG9yIG9iamVjdCByZWYuXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcmVmXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSwgdm5vZGUpIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuXHRcdGVsc2UgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgdm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVW5tb3VudCBhIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCBhcHBseSBET00gY2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gdW5tb3VudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHBhcmVudFZOb2RlIFRoZSBwYXJlbnQgb2YgdGhlIFZOb2RlIHRoYXRcbiAqIGluaXRpYXRlZCB0aGUgdW5tb3VudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZV0gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGEgcGFyZW50IG5vZGUgb2YgdGhlXG4gKiBjdXJyZW50IGVsZW1lbnQgaXMgYWxyZWFkeSBkZXRhY2hlZCBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KHZub2RlLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSkge1xuXHRsZXQgcjtcblx0aWYgKG9wdGlvbnMudW5tb3VudCkgb3B0aW9ucy51bm1vdW50KHZub2RlKTtcblxuXHRpZiAoKHIgPSB2bm9kZS5yZWYpKSB7XG5cdFx0aWYgKCFyLmN1cnJlbnQgfHwgci5jdXJyZW50ID09PSB2bm9kZS5fZG9tKSB7XG5cdFx0XHRhcHBseVJlZihyLCBudWxsLCBwYXJlbnRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdFx0dm5vZGUuX2NvbXBvbmVudCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyW2ldKSB7XG5cdFx0XHRcdHVubW91bnQoXG5cdFx0XHRcdFx0cltpXSxcblx0XHRcdFx0XHRwYXJlbnRWTm9kZSxcblx0XHRcdFx0XHRza2lwUmVtb3ZlIHx8IHR5cGVvZiB2bm9kZS50eXBlICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFza2lwUmVtb3ZlICYmIHZub2RlLl9kb20gIT0gbnVsbCkge1xuXHRcdHJlbW92ZU5vZGUodm5vZGUuX2RvbSk7XG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCB0byBgdW5kZWZpbmVkYCB0byBwcm9wZXJseSBjbGVhbiB1cCBgX25leHREb21gXG5cdC8vIGZvciB3aGljaCBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZS4gU2VlIGNvbW1lbnQgaW4gYGNyZWF0ZS1lbGVtZW50LmpzYFxuXHR2bm9kZS5fcGFyZW50ID0gdm5vZGUuX2RvbSA9IHZub2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xufVxuXG4vKiogVGhlIGAucmVuZGVyKClgIG1ldGhvZCBmb3IgYSBQRkMgYmFja2luZyBpbnN0YW5jZS4gKi9cbmZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwiaW1wb3J0IHsgYXNzaWduLCBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBhc3NpZ24oe30sIHZub2RlLnByb3BzKSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUoXG5cdFx0dm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5IHx8IHZub2RlLmtleSxcblx0XHRyZWYgfHwgdm5vZGUucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cbiIsIi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gW29sZFZOb2RlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuRXJyb3JJbmZvfSBbZXJyb3JJbmZvXVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgY3RvciwgaGFuZGxlZDtcblxuXHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5fcHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRpZiAoY3RvciAmJiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyB8fCB7fSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVycm9yIGJvdW5kYXJ5LiBNYXJrIGl0IGFzIGhhdmluZyBiYWlsZWQgb3V0LCBhbmQgd2hldGhlciBpdCB3YXMgbWlkLWh5ZHJhdGlvbi5cblx0XHRcdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGNvbXBvbmVudC5fcGVuZGluZ0Vycm9yID0gY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdwcmVhY3QnKS5WTm9kZX0gVk5vZGUgKi9cblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgZmlsZSBleHBvcnRzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBCYWJlbCdzIFwiYXV0b21hdGljXCIgSlNYIHJ1bnRpbWUgQVBJOlxuICogLSBqc3godHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4cyh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgX19zb3VyY2UsIF9fc2VsZilcbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlVk5vZGUgaGVyZSBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLlxuICogQmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81ZjZiNTRhMGI0NjMyMTAwYTdkY2QyYjNcbiAqL1xuXG4vKipcbiAqIEpTWC5FbGVtZW50IGZhY3RvcnkgdXNlZCBieSBCYWJlbCdzIHtydW50aW1lOlwiYXV0b21hdGljXCJ9IEpTWCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Vk5vZGVbJ3R5cGUnXX0gdHlwZVxuICogQHBhcmFtIHtWTm9kZVsncHJvcHMnXX0gcHJvcHNcbiAqIEBwYXJhbSB7Vk5vZGVbJ2tleSddfSBba2V5XVxuICogQHBhcmFtIHt1bmtub3dufSBbaXNTdGF0aWNDaGlsZHJlbl1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW19fc291cmNlXVxuICogQHBhcmFtIHt1bmtub3dufSBbX19zZWxmXVxuICovXG5mdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBfX3NvdXJjZSwgX19zZWxmKSB7XG5cdC8vIFdlJ2xsIHdhbnQgdG8gcHJlc2VydmUgYHJlZmAgaW4gcHJvcHMgdG8gZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3Jcblx0Ly8gZm9yd2FyZFJlZiBjb21wb25lbnRzIGluIHRoZSBmdXR1cmUsIGJ1dCB0aGF0IHNob3VsZCBoYXBwZW4gdmlhXG5cdC8vIGEgc2VwYXJhdGUgUFIuXG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ3JlZicpIHtcblx0XHRcdHJlZiA9IHByb3BzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzOiBub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogLS12bm9kZUlkLFxuXHRcdF9fc291cmNlLFxuXHRcdF9fc2VsZlxuXHR9O1xuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wcy5cblx0Ly8gTm90ZTogYHR5cGVgIGlzIG9mdGVuIGEgU3RyaW5nLCBhbmQgY2FuIGJlIGB1bmRlZmluZWRgIGluIGRldmVsb3BtZW50LlxuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgKHJlZiA9IHR5cGUuZGVmYXVsdFByb3BzKSkge1xuXHRcdGZvciAoaSBpbiByZWYpXG5cdFx0XHRpZiAodHlwZW9mIG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcmVmW2ldO1xuXHRcdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCB7XG5cdGNyZWF0ZVZOb2RlIGFzIGpzeCxcblx0Y3JlYXRlVk5vZGUgYXMganN4cyxcblx0Y3JlYXRlVk5vZGUgYXMganN4REVWLFxuXHRGcmFnbWVudFxufTtcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Yy5fX2hvb2tzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tTdGF0ZS5fbmV4dFZhbHVlXG5cdFx0XHRcdFx0PyBob29rU3RhdGUuX25leHRWYWx1ZVswXVxuXHRcdFx0XHRcdDogaG9va1N0YXRlLl92YWx1ZVswXTtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGN1cnJlbnRWYWx1ZSwgYWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX25leHRWYWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cblx0XHRpZiAoIWN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcykge1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHByZXZTY3UgPSBjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0Y3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH0gfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICB9XG4gICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRCdWlsZE1vZGUgPSBtZW1vaXplKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQpIGFzIHR5cGVvZiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkOyIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi4vdXRpbC9tb2RlLmpzXCI7XG5cbi8qKiBUYWtlcyBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBhIHZhbHVlLCB1bmxpa2UgYE9uUGFzc2l2ZVN0YXRlQ2hhbmdlYCB3aGljaCByZWFjdHMgdG8gdGhvc2UgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTLCBSPiA9ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCkgOiAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb246IFIpID0+IHZvaWQpO1xuLyoqIFJlc3BvbmRzIHRvIGEgY2hhbmdlIGluIGEgdmFsdWUsIHVubGlrZSBgUGFzc2l2ZVN0YXRlVXBkYXRlcmAgd2hpY2ggY2F1c2VzIHRoZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxTLCBSPiA9ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKSA6ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uOiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG5cblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgaWYgKGdldEJ1aWxkTW9kZSgpID09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmPEFycmF5PFQ+PihbXSk7XG4gICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZjxBcnJheTxib29sZWFuPj4oW10pO1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoIGFzIGFueSwgLTEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VSBleHRlbmRzIFQ+KHZhbHVlOiBVLCBpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgMTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2l9LWluZGV4ZWQgYXJndW1lbnQgKCR7aSA+PSAwPyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbaV0pIDogXCJ0aGUgbnVtYmVyIG9mIHN1cHBvc2VkbHkgc3RhYmxlIGVsZW1lbnRzXCJ9KS5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBxdWV1ZU1pY3JvdGFzaykoZik7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgdXNlU3RhdGVgLCBidXQgZm9yIHZhbHVlcyB0aGF0IGFyZW4ndCBcInJlbmRlci1pbXBvcnRhbnRcIiAmbmRhc2g7IHVwZGF0ZXMgZG9uJ3QgY2F1c2UgYSByZS1yZW5kZXIgYW5kIHNvIHRoZSB2YWx1ZSBzaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgcmVuZGVyICh0aG91Z2ggaXQgY2VydGFpbmx5IGNhbiwgYXQgbGVhc3QgYnkgcmUtcmVuZGVyaW5nIGFnYWluKS5cbiAqIFxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXG4gKiBcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XG4gKiBcbiAqIDEuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgdGhpcyB2ZXJzaW9uIG9mIGBzZXRTdGF0ZWAgZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIGNvbXBvbmVudFxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXG4gKiA0LiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB0aGUgc2luZ2xlIFwiZGVwZW5kZW5jeVwiIGlzIGJhc2VkIG9uIHlvdXIgY2FsbHMgdG8gYHNldFN0YXRlYFxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cbiAqIFxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgQnkgZGVmYXVsdCwgY2hhbmdlcyB0byBwYXNzaXZlIHN0YXRlIGFyZSBkZWxheWVkIGJ5IG9uZSB0aWNrIHNvIHRoYXQgd2Ugb25seSBjaGVjayBmb3IgY2hhbmdlcyBpbiBhIHNpbWlsYXIgd2F5IHRvIFByZWFjdC4gWW91IGNhbiBvdmVycmlkZSB0aGlzIHRvLCBmb3IgZXhhbXBsZSwgYWx3YXlzIHJ1biBpbW1lZGlhdGVseSBpbnN0ZWFkLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VCwgUj4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxULCBSPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmc/OiB0eXBlb2YgZGVib3VuY2VSZW5kZXJpbmcpOiByZWFkb25seSBbZ2V0U3RhdGVTdGFibGU6ICgpID0+IFQsIHNldFN0YXRlU3RhYmxlOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+XSB7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3QgcmVhc29uUmVmID0gdXNlUmVmPFIgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCA9IHVzZVJlZjxUIHwgKHR5cGVvZiBVbnNldCk+KFVuc2V0KTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVBhc3NpdmVTdGF0ZVwiLCBvbkNoYW5nZSwgZ2V0SW5pdGlhbFZhbHVlLCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCEpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzFdKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID09PSBVbnNldCAmJiBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJlYXNvblJlZi5jdXJyZW50ID0gcmVhc29uIGFzIFI7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVhc29uID0gcmVhc29uUmVmLmN1cnJlbnQhIGFzIFI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHByZXZEZXAsIG5leHRSZWFzb24pID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfVxuXG4vKiogXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byB1c2UgZm9yIGBjdXN0b21EZWJvdW5jZVJlbmRlcmluZ2AgdGhhdCBjYXVzZXMgYHVzZVBhc3NpdmVTdGF0ZWAgdG8gcnVuIGNoYW5nZXMgd2l0aG91dCB3YWl0aW5nIGEgdGljay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHsgZigpOyB9IiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuXG5cbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XG5cbmZ1bmN0aW9uIGJhc2U2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDBiMTAwMDAwMCk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTY0Qml0cygpIHtcbiAgICByZXR1cm4gW3JhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCldIGFzIGNvbnN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cbiAqIElEcyB0aGF0IGFyZSBub3QgdmFsaWQgdW5kZXIgSFRNTDQgbWF5IGJlIGdlbmVyYXRlZC4gT2ggbm8uXG4gKiBcbiAqIFxuICogKFRoaXMgaXMgaGVyZSwgaW4gdGhpcyBwYXJ0aWN1bGFyIGZpbGUsIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxuICogT25jZSB3ZSBjYW4gcmVtb3ZlIHRoaXMgaG9vaywgd2UgY2FuIHB1dCB0aGlzIGZ1bmN0aW9uIGJhY2sgd2l0aCB1c2VSYW5kb21JZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XG59XG5cbmNvbnN0IHByZXZpb3VzSW5wdXRzID0gbmV3IE1hcDxzdHJpbmcsIElucHV0cyB8IHVuZGVmaW5lZD4oKTtcbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV0gYXMgKHZub2RlOiBWTm9kZSwgY29tbWl0UXVldWU6IENvbXBvbmVudFtdKSA9PiB2b2lkO1xuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBlZmZlY3RJbmZvXSBvZiB0b1J1bikge1xuICAgICAgICBjb25zdCBvbGRJbnB1dHMgPSBwcmV2aW91c0lucHV0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKC4uLmFyZ3MpO1xufVxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrIHwgbnVsbCwgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcbiAgICBpZiAoZWZmZWN0KVxuICAgICAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG4gICAgZWxzZVxuICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC5qc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKSB7XG5cbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSksIFt2YWx1ZV0pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSk7XG59XG5cblxuLyoqXG4gKiBMaWtlIGB1c2VTdGFibGVHZXR0ZXJgLCBidXQgKioqcmVxdWlyZXMqKiogdGhhdCBldmVyeXRoaW5nIGluIHRoZSBvYmplY3QgaXMgYWxzbyBzdGFibGUsXG4gKiBhbmQgaW4gdHVybiByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGl0c2VsZiBpcyBzdGFibGUuXG4gKiBAcGFyYW0gdCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlT2JqZWN0PFQgZXh0ZW5kcyB7fT4odDogVCk6IFQge1xuICAgIGNvbnN0IGUgPSBPYmplY3QuZW50cmllcyh0KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVPYmplY3RcIiwgZS5sZW5ndGgsIC4uLmUubWFwKChbX2ssIHZdKSA9PiB2KSk7XG4gICAgcmV0dXJuIHVzZVJlZih0KS5jdXJyZW50O1xufVxuXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFja05hdGl2ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG5cbi8vY29uc3QgX0lTX1NUQUJMRV9HRVRURVIgPSBTeW1ib2woXCJTVEFCTEVcIik7XG5leHBvcnQgdHlwZSBTdGFibGU8VD4gPSBUOy8vICYgeyBbX1NUQUJMRV06IHRydWUgfTtcblxuLyoqXG4gKiBXZSBrZWVwIHRyYWNrIG9mIHdoaWNoIGNhbGxiYWNrcyBhcmUgc3RhYmxlIHdpdGggYSBXZWFrTWFwIGluc3RlYWQgb2YsIHNheSwgYSBzeW1ib2wgYmVjYXVzZVxuICogYHVzZUNhbGxiYWNrYCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQncyBzdGFibGUgYWNyb3NzICphbGwqIHJlbmRlcnMsIG1lYW5pbmdcbiAqIHdlIGNhbid0IHVzZSBvdXIgZnVubnkgXCJgaWZgIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYnJlYWsgdGhlIHJ1bGVzIG9mIGhvb2tzXCIgdHJpY2sgdGhlbi5cbiAqL1xuY29uc3QgbWFwID0gbmV3IFdlYWtNYXA8RnVuY3Rpb24sIGJvb2xlYW4+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgRnVuY3Rpb24+KG9iajogVCk6IG9iaiBpcyBTdGFibGU8VD4ge1xuICAgIHJldHVybiAobWFwLmdldChvYmopID8/IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNldElzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KG9iajogVCk6IFN0YWJsZTxUPiB7XG4gICAgbWFwLnNldChvYmosIHRydWUpO1xuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogSW4gZ2VuZXJhbCwganVzdCBwYXNzIHRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBiZSBzdGFibGUgKGJ1dCB5b3UgY2FuJ3QgdXNlIGl0IGR1cmluZyByZW5kZXIsXG4gKiBzbyBiZSBjYXJlZnVsISkuICBBbHRlcm5hdGl2ZWx5LCBpZiB5b3UgbmVlZCBhIHN0YWJsZSBjYWxsYmFjayB0aGF0ICoqY2FuKiogYmUgdXNlZFxuICogZHVyaW5nIHJlbmRlciwgcGFzcyBhbiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5IGFuZCBpdCdsbCBhY3QgbGlrZSBgdXNlQ2FsbGJhY2tgIHdpdGggYW5cbiAqIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXksIGJ1dCB3aXRoIHRoZSBhc3NvY2lhdGVkIHN0YWJsZSB0eXBpbmcuIEluIHRoaXMgY2FzZSwgeW91ICoqKm11c3QqKiogZW5zdXJlIHRoYXQgaXRcbiAqIHRydWx5IGhhcyBubyBkZXBlbmRlbmNpZXMvb25seSBzdGFibGUgZGVwZW5kZW5jaWVzISFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyBGdW5jdGlvbiB8IG51bGwgfCB1bmRlZmluZWQ+KGZuOiBOb25OdWxsYWJsZTxUPiwgbm9EZXBzPzogW10gfCBudWxsIHwgdW5kZWZpbmVkKTogU3RhYmxlPE5vbk51bGxhYmxlPFQ+PiB7XG4gICAgdHlwZSBVID0gKE5vbk51bGxhYmxlPFQ+ICYgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZUNhbGxiYWNrXCIsIG5vRGVwcyA9PSBudWxsLCBub0RlcHM/Lmxlbmd0aCwgaXNTdGFibGVHZXR0ZXI8VT4oZm4gYXMgVSkpO1xuICAgIGlmIChpc1N0YWJsZUdldHRlcihmbikpXG4gICAgICAgIHJldHVybiBmbjtcblxuICAgIGlmIChub0RlcHMgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VT4oZm4pO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgICAgIH0pIGFzIFUsIFtdKSk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5vRGVwcy5sZW5ndGggPT09IDApO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oZm4sIFtdKSk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzLmpzXCI7XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXG4gKiBhbmQgbm90IHRoZSBnZW5lcmljIFwiSSdsbCBhY2NlcHQgYW55IHN0cmluZyBhbmQgYW55IGhhbmRsZXJcIiBvbmUuXG4gKiBcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxuICogbGliLmRvbS50cyBhbHdheXMgZ2l2ZWluZyB0aGUgdHdvIG92ZXJsb2FkcyBpbiB0aGUgc2FtZSBvcmRlciwgd2l0aCB0aGVcbiAqIHR5cGVkIG9uZSBmaXJzdC4gKlRoYXQqIHByb2JhYmx5IHdvbid0IGNoYW5nZSwgYnV0IGlmIG1vcmUgb3ZlcmxvYWRzXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxuICogXG4gKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNzYxMTU2IGZvciBob3cgc2VsZWN0aW5nIHRoZSBjb3JyZWN0IG92ZXJsb2FkIHdvcmtzLlxuICovXG50eXBlIEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPFQ+ID1cbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGluZmVyIFIgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBSKSA9PiBhbnkgPyBSIDogW107XG5cbi8vIEdldCBqdXN0IHRoZSB0eXBlZCB2ZXJzaW9uIG9mIGFkZEV2ZW50TGlzdGVuZXIsIGlmIGl0IGV4aXN0c1xudHlwZSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9ICguLi5hcmdzOiBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczwoVFtcImFkZEV2ZW50TGlzdGVuZXJcIl0pPikgPT4gdm9pZDtcblxuLy8gUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgXCJhZGRFdmVudExpc3RlbmVyXCIgKHRoZSBldmVudCB0eXBlIGFzIGEgc3RyaW5nKVxudHlwZSBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+IGV4dGVuZHMgKCh0eXBlOiBpbmZlciBLMiwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBLMiA6IHN0cmluZztcblxuXG4vLyBUT0RPOiBUaGlzIGlzbid0IHF1aXRlIGFibGUgdG8gbmFycm93IGRvd24gdGhlIGV4YWN0IGV2ZW50IHR5cGUgZm9yIHVua25vd24gcmVhc29ucy5cbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cbi8vIEkgZG9uJ3Qga25vdyB3aHkgYGluZmVyIEhgIGlzIGRvaW5nIHRoYXQgd2hlbiB0aGUgdHlwZSBzaG91bGQgYmUgbmFycm93ZWQgYnkgYFRgIHRob3VnaC4uLlxuLy8gTm90ZSB0aGF0IHRoZSB0eXBlIHBhcmFtZXRlciBpcyBzdGlsbCB1c2VkLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IG5hcnJvdyBkb3duIHRoZSB0eXBlLFxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxudHlwZSBUeXBlZEV2ZW50SGFuZGxlcjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IGluZmVyIEgsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gTm9uTnVsbGFibGU8SD4gOiBuZXZlcjtcbi8vKChUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gJiAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZCwgLi4uYXJnczogYW55W10pID0+IGFueSkpIGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogaW5mZXIgSCkgPT4gYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEggOiBGdW5jdGlvbikgLyomIChUIGV4dGVuZHMga2V5b2YgR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwPyBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXBbVF0gOiAoZTogRXZlbnQpID0+IHZvaWQpKi87XG5cbnR5cGUgUGFyYW1ldGVyczI8VCBleHRlbmRzIChFdmVudExpc3RlbmVyT2JqZWN0IHwgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpPiA9XG4gICAgVCBleHRlbmRzIEV2ZW50TGlzdGVuZXJPYmplY3QgPyBQYXJhbWV0ZXJzPFRbXCJoYW5kbGVFdmVudFwiXT4gOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xuXG5cbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XG5cblxuLyoqXG4gKiBBbGxvd3MgYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW55ICpub24tUHJlYWN0KiBlbGVtZW50LCBhbmQgcmVtb3ZpbmcgaXQgd2hlbiB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBob29rIHVubW91bnRzLiBUaGUgY2FsbGJhY2sgZG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKiBcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxuICogXG4gKiBgdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiaW5wdXRcIik8SW5wdXRFdmVudD4oZSA9PiB7fSlgXG4gKiBcbiAqIFRoZSB0eXBlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBidXQgbmFycm93cyBkb3duIHRoZSB0eXBlIGZyb20gXCJhIHVuaW9uIG9mIGFsbCBldmVudHNcIiB0byB3aGF0ZXZlciB5b3Ugc3BlY2lmeSwgYW5kIGVycm9ycyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICogXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXG4gKiBJdCB0YWtlcyBkaWZmZXJlbnQgZXZlbnQgc3RyaW5nIHR5cGVzIChvbkV2ZW50IHZzIG9uZXZlbnQpLlxuICogXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cbiAqIEByZXR1cm5zXG4gKiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSwgbW9kZT86IFwiZ3JvdXBlZFwiIHwgXCJzaW5nbGVcIik6IHZvaWQge1xuICAgIG1vZGUgfHw9IFwiZ3JvdXBlZFwiO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUdsb2JhbEhhbmRsZXJcIiwgbW9kZSk7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICAgICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cbiAgICAgICAgLy8gTm8gbWF0dGVyIHdoYXQsIGl0IHNlZW1zIGltcG9zc2libGUgdG8gZ2V0IHRoZSBoYW5kbGVyJ3MgZXZlbnQgb2JqZWN0IHR5cGVkIHBlcmZlY3RseS5cbiAgICAgICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cbiAgICAgICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlckdyb3VwZWQ8VCwgRXZlbnRUeXBlLCBIPih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlclNpbmdsZTxULCBFdmVudFR5cGUsIEg+KHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG50eXBlIEdsb2JhbEhhbmRsZXJJbmZvID0geyBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjsgbGlzdGVuZXJzOiBTZXQ8RXZlbnRMaXN0ZW5lcj47IH07XG50eXBlIE1hcE9mT3B0aW9uc1RvSW5mbyA9IE1hcDxzdHJpbmcsIEdsb2JhbEhhbmRsZXJJbmZvPlxudHlwZSBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbyA9IE1hcDxUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFdmVudFRhcmdldD4sIE1hcE9mT3B0aW9uc1RvSW5mbz47XG5sZXQgbWFwVGhpbmcgPSBuZXcgTWFwPEV2ZW50VGFyZ2V0LCBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbz4oKTtcblxuZnVuY3Rpb24gZG9NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+PihvcDogKGk6IEdsb2JhbEhhbmRsZXJJbmZvLCBoOiBFdmVudExpc3RlbmVyKSA9PiB2b2lkLCB0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM6IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGlmIChoYW5kbGVyKSB7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0tleSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBieVR5cGUgPSBtYXBUaGluZy5nZXQodGFyZ2V0KSB8fCAobmV3IE1hcCgpIGFzIE1hcE9mVHlwZVRvTWFwT2ZPcHRpb25zVG9JbmZvKTtcbiAgICAgICAgY29uc3QgYnlPcHRpb25zID0gKGJ5VHlwZS5nZXQodHlwZSkgfHwgKG5ldyBNYXAoKSBhcyBNYXBPZk9wdGlvbnNUb0luZm8pKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGJ5T3B0aW9ucy5nZXQob3B0aW9uc0tleSkgfHwgeyBsaXN0ZW5lcjogbnVsbCEsIGxpc3RlbmVyczogbmV3IFNldCgpIH07XG5cbiAgICAgICAgb3AoaW5mbywgaGFuZGxlcik7XG5cbiAgICAgICAgYnlPcHRpb25zLnNldChvcHRpb25zS2V5LCBpbmZvKTtcbiAgICAgICAgYnlUeXBlLnNldCh0eXBlLCBieU9wdGlvbnMpO1xuICAgICAgICBtYXBUaGluZy5zZXQodGFyZ2V0LCBieVR5cGUpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBhZGRUb01hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9uczogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XG4gICAgZG9NYXBUaGluZygoaW5mbywgaCkgPT4ge1xuICAgICAgICBpbmZvLmxpc3RlbmVycy5hZGQoaCk7XG4gICAgICAgIGlmIChpbmZvLmxpc3RlbmVyID09IG51bGwpXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBpbmZvLmxpc3RlbmVyID0gZSA9PiBpbmZvLmxpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKGUpKSwgb3B0aW9ucyk7XG4gICAgfSwgdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcblxufVxuXG5mdW5jdGlvbiByZW1vdmVGcm9tTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XG4gICAgZG9NYXBUaGluZygoaW5mbywgaCkgPT4ge1xuICAgICAgICBpbmZvLmxpc3RlbmVycy5kZWxldGUoaCk7XG4gICAgICAgIGlmIChpbmZvLmxpc3RlbmVyID09IG51bGwpXG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBpbmZvLmxpc3RlbmVyID0gZSA9PiBpbmZvLmxpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKGUpKSwgb3B0aW9ucyk7XG4gICAgfSwgdGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHdheSBmYXN0ZXIgZm9yIGxhcmdlIG51bWJlcnMgb2YgZXZlbnQgaGFuZGxlcnMuXG4gKiBcbiAqIEZvciBleGFtcGxlLCBpZiBldmVyeSBidXR0b24gbGlzdGVucyBmb3IgYSBnbG9iYWwgY2xpY2ssIG9yIHNvbWV0aGluZyxcbiAqIGl0IHdvdWxkIGJlIG5pY2UgaWYgaXQgd2FzIGVmZmljaWVudCBhdCBsZWFzdC4gXG4gKi9cbmZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXJHcm91cGVkPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrPEV2ZW50TGlzdGVuZXI+KChoYW5kbGVyIGFzIGFueSkgPz8gKCgpID0+IHsgfSkpIGFzIChFdmVudExpc3RlbmVyIHwgbnVsbCk7XG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xuICAgICAgICAgICAgYWRkVG9NYXBUaGluZyh0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlbW92ZUZyb21NYXBUaGluZyh0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW3RhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlcl0pO1xufVxuXG5mdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyU2luZ2xlPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrPEV2ZW50TGlzdGVuZXI+KChoYW5kbGVyIGFzIGFueSkgPz8gKCgpID0+IHsgfSkpIGFzIChFdmVudExpc3RlbmVyIHwgbnVsbCk7XG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxuICogXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIG1vZGlmeSBhIHNldCBvZiBwcm9wcyB0byBhcHBseSB0aGlzIGhhbmRsZXIuXG4gKiBcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAqIFxuICogYGBgXG4gKiBjb25zdCB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfSA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PigpKFwib25Nb3VzZURvd25cIiwgZSA9PiB7ICB9KTtcbiAqIGNvbnN0IGRpdlByb3BzID0gdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyhwcm9wcyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsSGFuZGxlcjxFbGVtZW50VHlwZSBleHRlbmRzIChIVE1MRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwXSB8IFNWR0VsZW1lbnRUYWdOYW1lTWFwW2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwXSk+KCkge1xuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcblxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XG5cbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RWxlbWVudFR5cGU+KHsgW3R5cGVdOiBzdGFibGVIYW5kbGVyIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBwcm9wcykgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+O1xuICAgICAgICB9LCBbdHlwZV0pO1xuXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcblxuICAgIH0sIFtdKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAqL1xuICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAvKipcbiAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAqIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICpcbiAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICpcbiAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgKi9cblxuICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydFJvb3Q7XG4gIH0oKTtcblxuICAvKipcbiAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgKlxuICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgKlxuICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAqL1xuXG5cbiAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdub2RlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnROb2RlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICpcbiAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICB9LFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KSgpO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vdXRpbC9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGRlYm91bmNlUmVuZGVyaW5nLCBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgUGFzc2l2ZVN0YXRlVXBkYXRlciwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdXG5cbiAgICBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IEludGVybmFsQ2hpbGRJbmZvPE0+O1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ6IChpbmRleDogTVtcImluZGV4XCJdLCBtb3VudGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWQ6IChpbmRleDogTVtcImluZGV4XCJdKSA9PiAoKCkgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXG4gKiBcbiAqICogYGluZGV4YCByZWZlcnMgdG8gd2hpY2ggY2hpbGQgdGhpcyBpcy5cbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcbiAqICogYHN1YkluZm9gIGlzIGFueXRoaW5nIHVzZWQgYnkgYSBkZXJpdmVkIGhvb2suIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGZvciBleGFtcGxlLCBuZWVkcyB0byBrbm93IGhvdyB0byBmb2N1cyBhbiBhcmJpdHJhcnkgY2hpbGQsIHNvIHRoZSBjaGlsZCBwb3B1bGF0ZXMgYGluZm9gIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBtZXRob2QgY2FsbGVkIGBmb2N1c1NlbGZgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4ge1xuICAgIGluZGV4OiBUO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgICAgICogXG4gICAgICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRPRE86IFRoaXMgZW5kZWQgdXAgbm90IGJlaW5nIG5lZWRlZCBieSBhbnl0aGluZy4gSXMgaXQgbmVjZXNzYXJ5PyBEb2VzIGl0IGNvc3QgYW55dGhpbmc/XG4gICAgICAgICAqL1xuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PE1bXCJpbmRleFwiXT47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAgICAgKi9cbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxNW1wiaW5kZXhcIl0+O1xuXG4gICAgICAgIG9uQ2hpbGRDb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNvdW50OiBudW1iZXIpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHkgc2hhcmVkIGFtb25nIGFsbCBtYW5hZ2VkIGNoaWxkcmVuLlxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgcmVkdW5kYW50IHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCwgd2hpY2ggaXMuLi5laC4gQnV0IHRoZSB0eXBlcyBhcmUgY2xlYXIuXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxNLCBcImluZGV4XCI+O1xuXG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKioqU1RBQkxFKioqXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCAqKmJvdGgqKiBgZ2V0Q2hpbGRyZW5gIGFuZCB0aGUgYE1hbmFnZWRDaGlsZHJlbmAgb2JqZWN0IGl0IHJldHVybnMgYXJlIHN0YWJsZSFcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgaW5zdGVhZCBvZiBhbiBvYmplY3QgYmVjYXVzZSB3aGVuIGZ1bmN0aW9uIGNhbGxzIGhhcHBlbiBvdXQgb2Ygb3JkZXIgaXQncyBlYXNpZXIgdG8ganVzdCBoYXZlIGFsd2F5cyBiZWVuIHBhc3NpbmcgYW5kIHJldHVybiBnZXR0ZXJzIGV2ZXJ5d2hlcmUgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cbiAgICB9O1xuXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogTVtcImluZGV4XCJdKTogTSB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqICoqVU5TVEFCTEUqKiwgXG4gICAgICogYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgXG4gICAgICogYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbixcbiAgICAgKiBvciBhdCBsZWFzdCBwcm9wZXJseSBuYW1lIGl0LlxuICAgICAqIFxuICAgICAqIFdIQVQgVEhJUyBET0VTOlxuICAgICAqIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIGNoaWxkcmVuLCBzbGljZXMgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlbSwgXG4gICAgICogYW5kLCAqY3J1dGlhbGx5KiwgZmlsbHMgaW4gYW55IGhvbGVzIGluIHRoZSBhcnJheSB3aXRoIGEgcHNldWRvLWNoaWxkIHRoYXQganVzdCBjb250YWlucyBhbiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGJlaGF2aW9yLCB0byBiZSBjbGVhciwgaXMgb25seSBuZWNlc3NhcnkgZm9yIHNvcnRpbmcgYW5kIHJlYXJyYW5naW5nIGJlY2F1c2VcbiAgICAgKiBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyByZXF1aXJlIGtub3dpbmcgcGVyZmVjdGx5IHdoaWNoIGluZGV4IG1hcHMgdG8gd2hpY2guXG4gICAgICogV2UgZG9uJ3QgbmVlZCBhbnkgb3RoZXIgbWlzc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYXJyYXkgYmVzaWRlcyB0aGUgbWlzc2luZyBpbmRleC5cbiAgICAgKiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1bXTtcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ2hpbGRJbmZvPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+IHtcbiAgICBhcnI6IEFycmF5PE0+O1xuICAgIHJlYzogUGFydGlhbDxSZWNvcmQ8TVtcImluZGV4XCJdLCBNPj47XG4gICAgaGlnaGVzdEluZGV4OiBudW1iZXI7XG4gICAgbG93ZXN0SW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcbiAgICB0eXBlIEluZm8gPSBNO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBvbkNoaWxkQ291bnRDaGFuZ2UgfSwgLi4ucmVzdCB9ID0gcGFyZW50UGFyYW1ldGVycztcbiAgICBhc3NlcnRFbXB0eU9iamVjdChyZXN0KTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlKTtcblxuICAgIC8vY29uc3QgW2dldE1vdW50Q291bnQsIHNldE1vdW50Q291bnRdID0gdXNlUGFzc2l2ZVN0YXRlKG9uQ2hpbGRDb3VudENoYW5nZSwgcmV0dXJuWmVybywgcnVuSW1tZWRpYXRlbHkpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjxJbnRlcm5hbENoaWxkSW5mbzxNPj4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkcyB0byBzZWFyY2ggYWxsIGNoaWxkcmVuIGZvciB0aGF0IGNsb3Nlc3QgZml0LlxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgZm9yRWFjaENoaWxkID0gdXNlQ2FsbGJhY2soKGY6IChjaGlsZDogSW5mbykgPT4gdm9pZCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8SW5kZXhUeXBlLCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48TT5bXCJnZXRBdFwiXT4oKGluZGV4OiBJbmRleFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PEluZGV4VHlwZT4sIHVubW91bnRzOiBTZXQ8SW5kZXhUeXBlPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PEluZGV4VHlwZT4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvbkNoaWxkQ291bnRDaGFuZ2UgfHwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkQ291bnRDaGFuZ2U/LihnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlU3RhYmxlT2JqZWN0PE1hbmFnZWRDaGlsZHJlbjxNPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gZ2V0SGlnaGVzdEluZGV4KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbaV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0geyBpbmRleDogaSB9IGFzIE07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuLCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPj4oaW5mbzogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNPiwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogTSk6IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TT4ge1xuICAgIHR5cGUgSW5kZXhUeXBlID0gTVtcImluZGV4XCJdO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7IGdldENoaWxkcmVuLCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSwgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLCByZW1vdGVVTEVDaGlsZENoYW5nZWQgfSB9ID0gKGluZm8uY29udGV4dCA/PyB7IG1hbmFnZWRDaGlsZENvbnRleHQ6IHt9IH0pO1xuICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleDtcbiAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9PSBudWxsIHx8IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgLi4ubWFuYWdlZENoaWxkUGFyYW1ldGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkucmVjW2luZGV4IGFzIEluZGV4VHlwZV0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZGV4IGFzIEluZGV4VHlwZSk7XG4gICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXG5cbiAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cbiAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgZmFsc2UpO1xuICAgIH0sIFtpbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbiEgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55PiwgUj4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcblxuICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+O1xuXG4gICAgc2V0QXQoaW5kZXg6IE0sIHZhbHVlOiBib29sZWFuLCBuZXdTZWxlY3RlZEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsLCBwcmV2U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCk6IHZvaWQ7XG4gICAgZ2V0QXQoaW5kZXg6IE0pOiBib29sZWFuO1xuICAgIGlzVmFsaWQoaW5kZXg6IE0pOiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIE1hbnVhbGx5IGNoYW5nZXMgdGhlIGN1cnJlbnQgaW5kZXggdGhhdCBpcyAoZm9jdXNlZC9zZWxlY3RlZC90YWJiYWJsZS93aGF0ZXZlcikuXG4gICAgICogXG4gICAgICogVGhlIHBhcmVudCBjYW4gdXNlIHRoaXMgdG8gbm90aWZ5IGVhY2ggcmVsZXZhbnQgY2hpbGQgb2Ygd2hhdCBpdCBtdXN0IGRvIGluIG9yZGVyIHRvIG1ha2UgdGhpcyBjaGFuZ2UgaGFwcGVuLlxuICAgICAqIFxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIHRoZSBuZXcgaW5kZXggdGhhdCB3aWxsIGJlIHVzZWQuIElmIGBjbG9zZXN0Rml0YCBpcyBmYWxzZSwgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgd2hhdCB5b3UgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGNoYW5nZUluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+O1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCBvciB3aGVuZXZlciBjYWxsaW5nIGEgY2hpbGQncyBpc1ZhbGlkKCkgd291bGQgY2hhbmdlXG4gICAgICogICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IE1bXCJpbmRleFwiXSB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB5b3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpcGxlIGZsYWdzIHdpdGggdGhlIHNhbWUgY2hpbGRyZW4sIHRoaXMgaG9vayAqZG9lcyBub3QqIHVzZSBgdXNlTWFuYWdlZENoaWxkcmVuYCFcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXG4gKiBcbiAqIEFsc28gYmVjYXVzZSBvZiB0aGF0LCB0aGUgdHlwZXMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgcmF0aGVyIG9kZC4gIEl0J3MgYmV0dGVyIHRvIHN0YXJ0IG9mZiB1c2luZyBhIGhvb2sgdGhhdCBhbHJlYWR5IHVzZXMgYSBmbGFnLCBzdWNoIGFzIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFzIGFuIGV4YW1wbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5GbGFnPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4sIFI+KHsgZ2V0Q2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwgZ2V0QXQsIHNldEF0LCBpc1ZhbGlkLCB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0sIFI+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNLCBSPiB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQ2hpbGRyZW5GbGFnXCIsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCk7XG5cbiAgICAvLyBUT0RPIChtYXliZT8pOiBFdmVuIGlmIHRoZXJlIGlzIGFuIGluaXRpYWwgaW5kZXgsIGl0J3Mgbm90IHNldCB1bnRpbCBtb3VudC4gSXMgdGhhdCBmaW5lP1xuICAgIGNvbnN0IFtnZXRDdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4ob25JbmRleENoYW5nZSk7XG5cbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgTVtcImluZGV4XCJdLCBSPihudWxsKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWNcbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGBjbG9zZXN0Rml0YCBpcyBmYWxzZSwgbmF0dXJhbGx5LlxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBpc1ZhbGlkKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBjaGlsZC5pbmRleCA9PSBcIm51bWJlclwiLCBcImNsb3Nlc3RGaXQgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGVhY2ggY2hpbGQgaGFzIGEgbnVtZXJpYyBpbmRleCwgYW5kIGNhbm5vdCBiZSB1c2VkIHdoZW4gY2hpbGRyZW4gdXNlIHN0cmluZyBpbmRpY2VzIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoKGNoaWxkLmluZGV4IGFzIG51bWJlcikgLSByZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlIHx8IChuZXdEaXN0YW5jZSA9PSBjbG9zZXN0RGlzdGFuY2UgJiYgKGNoaWxkLmluZGV4IGFzIG51bWJlcikgPCByZXF1ZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IChjaGlsZC5pbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcblxuICAgIC8vIEFueSB0aW1lIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB0byBzZWUgaWYgdGhhdCBhZmZlY3RzIFxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXG4gICAgLy8gMi4gQSBjaGlsZCBtb3VudGVkLCBhbmQgaXQgbW91bnRzIHdpdGggdGhlIGluZGV4IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWlzVmFsaWQoY3VycmVudENoaWxkKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiByZXF1ZXN0ZWRJbmRleCA9PSBcIm51bWJlclwiLCBcImNsb3Nlc3RGaXQgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGVhY2ggY2hpbGQgaGFzIGEgbnVtZXJpYyBpbmRleCwgYW5kIGNhbm5vdCBiZSB1c2VkIHdoZW4gY2hpbGRyZW4gdXNlIHN0cmluZyBpbmRpY2VzIGluc3RlYWQuXCIpO1xuXG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4LCB1bmRlZmluZWQhKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hpbGQpXG4gICAgICAgICAgICAgICAgc2V0QXQoY3VycmVudENoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgc2V0QXQoY2xvc2VzdEZpdENoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj5bMV0pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZykgYXMgTVtcImluZGV4XCJdO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09IHJlcXVlc3RlZEluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuXG4gICAgICAgIGxldCBuZXdNYXRjaGluZ0NoaWxkID0gKHJlcXVlc3RlZEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQocmVxdWVzdGVkSW5kZXgpKTtcbiAgICAgICAgY29uc3Qgb2xkTWF0Y2hpbmdDaGlsZCA9IChjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVhc3kgY2FzZVxuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KG51bGwsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCByZXF1ZXN0ZWRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJc1ZhbGlkID0gKG5ld01hdGNoaW5nQ2hpbGQgJiYgaXNWYWxpZChuZXdNYXRjaGluZ0NoaWxkKSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRJc1ZhbGlkIHx8ICFjbG9zZXN0Rml0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KHJlcXVlc3RlZEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCByZXF1ZXN0ZWRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQobmV3TWF0Y2hpbmdDaGlsZCwgdHJ1ZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gUnVuIG9uY2UsIG9uIG1vdW50XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlSW5kZXgoaW5pdGlhbEluZGV4ID8/IG51bGwsIHVuZGVmaW5lZCk7XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xufVxuXG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGVQIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlXG4gKiBAcGFyYW0geyp9IHhcbiAqIEBwYXJhbSB7Kn0geVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdHJldHVybiAoeCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNsYXNzIHdpdGggYSBwcmVkZWZpbmVkIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHApIHtcblx0dGhpcy5wcm9wcyA9IHA7XG59XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcbi8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIE1lbW9pemUgYSBjb21wb25lbnQsIHNvIHRoYXQgaXQgb25seSB1cGRhdGVzIHdoZW4gdGhlIHByb3BzIGFjdHVhbGx5IGhhdmVcbiAqIGNoYW5nZWQuIFRoaXMgd2FzIHByZXZpb3VzbHkga25vd24gYXMgYFJlYWN0LnB1cmVgLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gYyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICogQHBhcmFtIHsocHJldjogb2JqZWN0LCBuZXh0OiBvYmplY3QpID0+IGJvb2xlYW59IFtjb21wYXJlcl0gQ3VzdG9tIGVxdWFsaXR5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vKGMsIGNvbXBhcmVyKSB7XG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0XHRsZXQgcmVmID0gdGhpcy5wcm9wcy5yZWY7XG5cdFx0bGV0IHVwZGF0ZVJlZiA9IHJlZiA9PSBuZXh0UHJvcHMucmVmO1xuXHRcdGlmICghdXBkYXRlUmVmICYmIHJlZikge1xuXHRcdFx0cmVmLmNhbGwgPyByZWYobnVsbCkgOiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBhcmVyKSB7XG5cdFx0XHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIWNvbXBhcmVyKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgIXVwZGF0ZVJlZjtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lbW9lZChwcm9wcykge1xuXHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gc2hvdWxkVXBkYXRlO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGMsIHByb3BzKTtcblx0fVxuXHRNZW1vZWQuZGlzcGxheU5hbWUgPSAnTWVtbygnICsgKGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lKSArICcpJztcblx0TWVtb2VkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblx0TWVtb2VkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTWVtb2VkO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5sZXQgb2xkRGlmZkhvb2sgPSBvcHRpb25zLl9kaWZmO1xub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0aWYgKHZub2RlLnR5cGUgJiYgdm5vZGUudHlwZS5fZm9yd2FyZGVkICYmIHZub2RlLnJlZikge1xuXHRcdHZub2RlLnByb3BzLnJlZiA9IHZub2RlLnJlZjtcblx0XHR2bm9kZS5yZWYgPSBudWxsO1xuXHR9XG5cdGlmIChvbGREaWZmSG9vaykgb2xkRGlmZkhvb2sodm5vZGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0ZPUldBUkRfU1lNQk9MID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRTeW1ib2wuZm9yICYmXG5cdFx0U3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSkgfHxcblx0MHhmNDc7XG5cbi8qKlxuICogUGFzcyByZWYgZG93biB0byBhIGNoaWxkLiBUaGlzIGlzIG1haW5seSB1c2VkIGluIGxpYnJhcmllcyB3aXRoIEhPQ3MgdGhhdFxuICogd3JhcCBjb21wb25lbnRzLiBVc2luZyBgZm9yd2FyZFJlZmAgdGhlcmUgaXMgYW4gZWFzeSB3YXkgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnQgaW5zdGVhZCBvZiBvbmUgb2YgdGhlIHdyYXBwZXIgaXRzZWxmLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Gb3J3YXJkRm59IGZuXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkUmVmKGZuKSB7XG5cdGZ1bmN0aW9uIEZvcndhcmRlZChwcm9wcykge1xuXHRcdGxldCBjbG9uZSA9IGFzc2lnbih7fSwgcHJvcHMpO1xuXHRcdGRlbGV0ZSBjbG9uZS5yZWY7XG5cdFx0cmV0dXJuIGZuKGNsb25lLCBwcm9wcy5yZWYgfHwgbnVsbCk7XG5cdH1cblxuXHQvLyBtb2J4LXJlYWN0IGNoZWNrcyBmb3IgdGhpcyBiZWluZyBwcmVzZW50XG5cdEZvcndhcmRlZC4kJHR5cGVvZiA9IFJFQUNUX0ZPUldBUkRfU1lNQk9MO1xuXHQvLyBtb2J4LXJlYWN0IGhlYXZpbHkgcmVsaWVzIG9uIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG5cdC8vIEl0IGV4cGVjdHMgYW4gb2JqZWN0IGhlcmUgd2l0aCBhIGByZW5kZXJgIHByb3BlcnR5LFxuXHQvLyBhbmQgcHJvdG90eXBlLnJlbmRlciB3aWxsIGZhaWwuIFdpdGhvdXQgdGhpc1xuXHQvLyBtb2J4LXJlYWN0IHRocm93cy5cblx0Rm9yd2FyZGVkLnJlbmRlciA9IEZvcndhcmRlZDtcblxuXHRGb3J3YXJkZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSBGb3J3YXJkZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdEZvcndhcmRlZC5kaXNwbGF5TmFtZSA9ICdGb3J3YXJkUmVmKCcgKyAoZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSkgKyAnKSc7XG5cdHJldHVybiBGb3J3YXJkZWQ7XG59XG4iLCJpbXBvcnQgeyB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCBtYXBGbiA9IChjaGlsZHJlbiwgZm4pID0+IHtcblx0aWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gdG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheShjaGlsZHJlbikubWFwKGZuKSk7XG59O1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxuZXhwb3J0IGNvbnN0IENoaWxkcmVuID0ge1xuXHRtYXA6IG1hcEZuLFxuXHRmb3JFYWNoOiBtYXBGbixcblx0Y291bnQoY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gPyB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLmxlbmd0aCA6IDA7XG5cdH0sXG5cdG9ubHkoY2hpbGRyZW4pIHtcblx0XHRjb25zdCBub3JtYWxpemVkID0gdG9DaGlsZEFycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAobm9ybWFsaXplZC5sZW5ndGggIT09IDEpIHRocm93ICdDaGlsZHJlbi5vbmx5Jztcblx0XHRyZXR1cm4gbm9ybWFsaXplZFswXTtcblx0fSxcblx0dG9BcnJheTogdG9DaGlsZEFycmF5XG59O1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9kb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb24ndCBjYWxsIG9sZENhdGNoRXJyb3IgaWYgd2UgZm91bmQgYSBTdXNwZW5zZVxuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQoZXJyb3IsIG5ld1ZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xufTtcblxuY29uc3Qgb2xkVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcbm9wdGlvbnMudW5tb3VudCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5fb25SZXNvbHZlKSB7XG5cdFx0Y29tcG9uZW50Ll9vblJlc29sdmUoKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgaHlkcmF0aW5nXG5cdC8vIG1vc3QgbGlrZWx5IGl0IGlzIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWRcblx0Ly8gd2Ugc2V0IHRoZSB2bm9kZS50eXBlIGFzIGBudWxsYCBzbyB0aGF0IGl0IGlzIG5vdCBhIHR5cGVvZiBmdW5jdGlvblxuXHQvLyBzbyB0aGUgdW5tb3VudCB3aWxsIHJlbW92ZSB0aGUgdm5vZGUuX2RvbVxuXHRpZiAoY29tcG9uZW50ICYmIHZub2RlLl9oeWRyYXRpbmcgPT09IHRydWUpIHtcblx0XHR2bm9kZS50eXBlID0gbnVsbDtcblx0fVxuXG5cdGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgJiYgdm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzKSB7XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZm9yRWFjaChlZmZlY3QgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVmZmVjdC5fY2xlYW51cCA9PSAnZnVuY3Rpb24nKSBlZmZlY3QuX2NsZWFudXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IGRldGFjaGVkUGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRkZXRhY2hlZENsb25lKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3JpZ2luYWwodm5vZGUsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudCkge1xuXHRpZiAodm5vZGUpIHtcblx0XHR2bm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0cmVtb3ZlT3JpZ2luYWwoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudClcblx0XHRcdCk7XG5cblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gZGV0YWNoZWRQYXJlbnQpIHtcblx0XHRcdFx0aWYgKHZub2RlLl9kb20pIHtcblx0XHRcdFx0XHRvcmlnaW5hbFBhcmVudC5pbnNlcnRCZWZvcmUodm5vZGUuX2RvbSwgdm5vZGUuX25leHREb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gb3JpZ2luYWxQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGU8YW55LCBhbnk+fSBzdXNwZW5kaW5nVk5vZGUgVGhlIHN1c3BlbmRpbmcgY29tcG9uZW50XG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5fY2hpbGREaWRTdXNwZW5kID0gZnVuY3Rpb24ocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBbXTtcbn07XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudFtcInByb3BzXCJdfSBwcm9wc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZVN0YXRlfSBzdGF0ZVxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHQvLyBXaGVuIHRoZSBTdXNwZW5zZSdzIF92bm9kZSB3YXMgY3JlYXRlZCBieSBhIGNhbGwgdG8gY3JlYXRlVk5vZGVcblx0XHQvLyAoaS5lLiBkdWUgdG8gYSBzZXRTdGF0ZSBmdXJ0aGVyIHVwIGluIHRoZSB0cmVlKVxuXHRcdC8vIGl0J3MgX2NoaWxkcmVuIHByb3AgaXMgbnVsbCwgaW4gdGhpcyBjYXNlIHdlIFwiZm9yZ2V0XCIgYWJvdXQgdGhlIHBhcmtlZCB2bm9kZXMgdG8gZGV0YWNoXG5cdFx0aWYgKHRoaXMuX3Zub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnN0IGRldGFjaGVkQ29tcG9uZW50ID0gdGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdLl9jb21wb25lbnQ7XG5cdFx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKFxuXHRcdFx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIsXG5cdFx0XHRcdGRldGFjaGVkUGFyZW50LFxuXHRcdFx0XHQoZGV0YWNoZWRDb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tID0gZGV0YWNoZWRDb21wb25lbnQuX3BhcmVudERvbSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdC8vIFdyYXAgZmFsbGJhY2sgdHJlZSBpbiBhIFZOb2RlIHRoYXQgcHJldmVudHMgaXRzZWxmIGZyb20gYmVpbmcgbWFya2VkIGFzIGFib3J0aW5nIG1pZC1oeWRyYXRpb246XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9ICovXG5cdGNvbnN0IGZhbGxiYWNrID1cblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmZhbGxiYWNrKTtcblx0aWYgKGZhbGxiYWNrKSBmYWxsYmFjay5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdGZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7KCh1bnN1c3BlbmQ6ICgpID0+IHZvaWQpID0+IHZvaWQpP31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1c3BlbmRlZCh2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzdXNwZW5kZWQgfSBmcm9tICcuL3N1c3BlbnNlLmpzJztcblxuLy8gSW5kZXhlcyB0byBsaW5rZWQgbGlzdCBub2RlcyAobm9kZXMgYXJlIHN0b3JlZCBhcyBhcnJheXMgdG8gc2F2ZSBieXRlcykuXG5jb25zdCBTVVNQRU5ERURfQ09VTlQgPSAwO1xuY29uc3QgUkVTT0xWRURfQ09VTlQgPSAxO1xuY29uc3QgTkVYVF9OT0RFID0gMjtcblxuLy8gSGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZUxpc3QoKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBudWxsO1xufVxuXG4vLyBNYXJrIG9uZSBvZiBjaGlsZCdzIGVhcmxpZXIgc3VzcGVuc2lvbnMgYXMgcmVzb2x2ZWQuXG4vLyBTb21lIHBlbmRpbmcgY2FsbGJhY2tzIG1heSBiZWNvbWUgY2FsbGFibGUgZHVlIHRvIHRoaXNcbi8vIChlLmcuIHRoZSBsYXN0IHN1c3BlbmRlZCBkZXNjZW5kYW50IGdldHMgcmVzb2x2ZWQgd2hlblxuLy8gcmV2ZWFsT3JkZXIgPT09ICd0b2dldGhlcicpLiBQcm9jZXNzIHRob3NlIGNhbGxiYWNrcyBhcyB3ZWxsLlxuY29uc3QgcmVzb2x2ZSA9IChsaXN0LCBjaGlsZCwgbm9kZSkgPT4ge1xuXHRpZiAoKytub2RlW1JFU09MVkVEX0NPVU5UXSA9PT0gbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0Ly8gVGhlIG51bWJlciBhIGNoaWxkIChvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYmVlbiBzdXNwZW5kZWRcblx0XHQvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgdGltZXMgaXQncyBiZWVuIHJlc29sdmVkLiBUaGVyZWZvcmUgd2Vcblx0XHQvLyBtYXJrIHRoZSBjaGlsZCBhcyBjb21wbGV0ZWx5IHJlc29sdmVkIGJ5IGRlbGV0aW5nIGl0IGZyb20gLl9tYXAuXG5cdFx0Ly8gVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hlbiAqYWxsKiBjaGlsZHJlbiBoYXZlIGJlZW4gY29tcGxldGVseVxuXHRcdC8vIHJlc29sdmVkIHdoZW4gcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJy5cblx0XHRsaXN0Ll9tYXAuZGVsZXRlKGNoaWxkKTtcblx0fVxuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzIGZhbHN5IHRoZW4gd2UgY2FuIGRvIGFuIGVhcmx5IGV4aXQsIGFzIHRoZVxuXHQvLyBjYWxsYmFja3Mgd29uJ3QgZ2V0IHF1ZXVlZCBpbiB0aGUgbm9kZSBhbnl3YXkuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicgdGhlbiBhbHNvIGRvIGFuIGVhcmx5IGV4aXRcblx0Ly8gaWYgYWxsIHN1c3BlbmRlZCBkZXNjZW5kYW50cyBoYXZlIG5vdCB5ZXQgYmVlbiByZXNvbHZlZC5cblx0aWYgKFxuXHRcdCFsaXN0LnByb3BzLnJldmVhbE9yZGVyIHx8XG5cdFx0KGxpc3QucHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICd0JyAmJiBsaXN0Ll9tYXAuc2l6ZSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gV2FsayB0aGUgY3VycmVudGx5IHN1c3BlbmRlZCBjaGlsZHJlbiBpbiBvcmRlciwgY2FsbGluZyB0aGVpclxuXHQvLyBzdG9yZWQgY2FsbGJhY2tzIG9uIHRoZSB3YXkuIFN0b3AgaWYgd2UgZW5jb3VudGVyIGEgY2hpbGQgdGhhdFxuXHQvLyBoYXMgbm90IGJlZW4gY29tcGxldGVseSByZXNvbHZlZCB5ZXQuXG5cdG5vZGUgPSBsaXN0Ll9uZXh0O1xuXHR3aGlsZSAobm9kZSkge1xuXHRcdHdoaWxlIChub2RlLmxlbmd0aCA+IDMpIHtcblx0XHRcdG5vZGUucG9wKCkoKTtcblx0XHR9XG5cdFx0aWYgKG5vZGVbUkVTT0xWRURfQ09VTlRdIDwgbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0bGlzdC5fbmV4dCA9IG5vZGUgPSBub2RlW05FWFRfTk9ERV07XG5cdH1cbn07XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlTGlzdC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuX3N1c3BlbmRlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRjb25zdCBkZWxlZ2F0ZWQgPSBzdXNwZW5kZWQobGlzdC5fdm5vZGUpO1xuXG5cdGxldCBub2RlID0gbGlzdC5fbWFwLmdldChjaGlsZCk7XG5cdG5vZGVbU1VTUEVOREVEX0NPVU5UXSsrO1xuXG5cdHJldHVybiB1bnN1c3BlbmQgPT4ge1xuXHRcdGNvbnN0IHdyYXBwZWRVbnN1c3BlbmQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIWxpc3QucHJvcHMucmV2ZWFsT3JkZXIpIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRoZSB1bmRlZmluZWQgKGZhbHN5KSByZXZlYWxPcmRlciwgYXMgdGhlcmVcblx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBjb29yZGluYXRlIGEgc3BlY2lmaWMgb3JkZXIgb3IgdW5zdXNwZW5kcy5cblx0XHRcdFx0dW5zdXNwZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnB1c2godW5zdXNwZW5kKTtcblx0XHRcdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRkZWxlZ2F0ZWQod3JhcHBlZFVuc3VzcGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdyYXBwZWRVbnN1c3BlbmQoKTtcblx0XHR9XG5cdH07XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG5cblx0Y29uc3QgY2hpbGRyZW4gPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXHRpZiAocHJvcHMucmV2ZWFsT3JkZXIgJiYgcHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICdiJykge1xuXHRcdC8vIElmIG9yZGVyID09PSAnYmFja3dhcmRzJyAob3IsIHdlbGwsIGFueXRoaW5nIHN0YXJ0aW5nIHdpdGggYSAnYicpXG5cdFx0Ly8gdGhlbiBmbGlwIHRoZSBjaGlsZCBsaXN0IGFyb3VuZCBzbyB0aGF0IHRoZSBsYXN0IGNoaWxkIHdpbGwgYmVcblx0XHQvLyB0aGUgZmlyc3QgaW4gdGhlIGxpbmtlZCBsaXN0LlxuXHRcdGNoaWxkcmVuLnJldmVyc2UoKTtcblx0fVxuXHQvLyBCdWlsZCB0aGUgbGlua2VkIGxpc3QuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2hpbGRyZW4gaW4gcmV2ZXJzZSBvcmRlclxuXHQvLyBzbyB0aGF0IGBfbmV4dGAgcG9pbnRzIHRvIHRoZSBmaXJzdCBsaW5rZWQgbGlzdCBub2RlIHRvIGJlIHJlc29sdmVkLlxuXHRmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBsaW5rZWQgbGlzdCBub2RlIGFzIGFuIGFycmF5IG9mIGZvcm06XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlXVxuXHRcdC8vIHdoZXJlIHN1c3BlbmRlZF9jb3VudCBhbmQgcmVzb2x2ZWRfY291bnQgYXJlIG51bWVyaWMgY291bnRlcnMgZm9yXG5cdFx0Ly8ga2VlcGluZyB0cmFjayBob3cgbWFueSB0aW1lcyBhIG5vZGUgaGFzIGJlZW4gc3VzcGVuZGVkIGFuZCByZXNvbHZlZC5cblx0XHQvL1xuXHRcdC8vIE5vdGUgdGhhdCBzdXNwZW5kZWRfY291bnQgc3RhcnRzIGZyb20gMSBpbnN0ZWFkIG9mIDAsIHNvIHdlIGNhbiBibG9ja1xuXHRcdC8vIHByb2Nlc3NpbmcgY2FsbGJhY2tzIHVudGlsIGNvbXBvbmVudERpZE1vdW50IGhhcyBiZWVuIGNhbGxlZC4gSW4gYSBzZW5zZVxuXHRcdC8vIG5vZGUgaXMgc3VzcGVuZGVkIGF0IGxlYXN0IHVudGlsIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkIVxuXHRcdC8vXG5cdFx0Ly8gUGVuZGluZyBjYWxsYmFja3MgYXJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGU6XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlLCBjYWxsYmFja18wLCBjYWxsYmFja18xLCAuLi5dXG5cdFx0dGhpcy5fbWFwLnNldChjaGlsZHJlbltpXSwgKHRoaXMuX25leHQgPSBbMSwgMCwgdGhpcy5fbmV4dF0pKTtcblx0fVxuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IFN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZnRlciBtb3VudGluZyBmb3IgdHdvIHJlYXNvbnM6XG5cdC8vIDEuIEFzIGVhY2ggbm9kZVtTVVNQRU5ERURfQ09VTlRdIHN0YXJ0cyBmcm9tIDEsIHRoaXMgaXRlcmF0aW9uIGluY3JlYXNlc1xuXHQvLyAgICBlYWNoIG5vZGVbUkVMRUFTRURfQ09VTlRdIGJ5IDEsIHRoZXJlZm9yZSBiYWxhbmNpbmcgdGhlIGNvdW50ZXJzLlxuXHQvLyAgICBUaGUgbm9kZXMgY2FuIG5vdyBiZSBjb21wbGV0ZWx5IGNvbnN1bWVkIGZyb20gdGhlIGxpbmtlZCBsaXN0LlxuXHQvLyAyLiBIYW5kbGUgbm9kZXMgdGhhdCBtaWdodCBoYXZlIGdvdHRlbiByZXNvbHZlZCBiZXR3ZWVuIHJlbmRlciBhbmRcblx0Ly8gICAgY29tcG9uZW50RGlkTW91bnQuXG5cdHRoaXMuX21hcC5mb3JFYWNoKChub2RlLCBjaGlsZCkgPT4ge1xuXHRcdHJlc29sdmUodGhpcywgY2hpbGQsIG5vZGUpO1xuXHR9KTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9zcmMvaW5kZXgnKS5SZW5kZXJhYmxlUHJvcHM8eyBjb250ZXh0OiBhbnkgfT59IHByb3BzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihwcm9wcykge1xuXHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHByb3BzLmNvbnRleHQ7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBQb3J0YWwgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBwcm9wc1xuICpcbiAqIFRPRE86IHVzZSBjcmVhdGVSb290KCkgaW5zdGVhZCBvZiBmYWtlIHJvb3RcbiAqL1xuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG5cdGNvbnN0IF90aGlzID0gdGhpcztcblx0bGV0IGNvbnRhaW5lciA9IHByb3BzLl9jb250YWluZXI7XG5cblx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZW5kZXIobnVsbCwgX3RoaXMuX3RlbXApO1xuXHRcdF90aGlzLl90ZW1wID0gbnVsbDtcblx0XHRfdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0fTtcblxuXHQvLyBXaGVuIHdlIGNoYW5nZSBjb250YWluZXIgd2Ugc2hvdWxkIGNsZWFyIG91ciBvbGQgY29udGFpbmVyIGFuZFxuXHQvLyBpbmRpY2F0ZSBhIG5ldyBtb3VudC5cblx0aWYgKF90aGlzLl9jb250YWluZXIgJiYgX3RoaXMuX2NvbnRhaW5lciAhPT0gY29udGFpbmVyKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxuXG5cdC8vIFdoZW4gcHJvcHMudm5vZGUgaXMgdW5kZWZpbmVkL2ZhbHNlL251bGwgd2UgYXJlIGRlYWxpbmcgd2l0aCBzb21lIGtpbmQgb2Zcblx0Ly8gY29uZGl0aW9uYWwgdm5vZGUuIFRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGEgcmVuZGVyLlxuXHRpZiAocHJvcHMuX3Zub2RlKSB7XG5cdFx0aWYgKCFfdGhpcy5fdGVtcCkge1xuXHRcdFx0X3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgZmFrZSBET00gcGFyZW50IG5vZGUgdGhhdCBtYW5hZ2VzIGEgc3Vic2V0IG9mIGBjb250YWluZXJgJ3MgY2hpbGRyZW46XG5cdFx0XHRfdGhpcy5fdGVtcCA9IHtcblx0XHRcdFx0bm9kZVR5cGU6IDEsXG5cdFx0XHRcdHBhcmVudE5vZGU6IGNvbnRhaW5lcixcblx0XHRcdFx0Y2hpbGROb2RlczogW10sXG5cdFx0XHRcdGFwcGVuZENoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKSA+Pj4gMSwgMSk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIG91ciB3cmFwcGluZyBlbGVtZW50IGludG8gdGVtcC5cblx0XHRyZW5kZXIoXG5cdFx0XHRjcmVhdGVFbGVtZW50KENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBfdGhpcy5jb250ZXh0IH0sIHByb3BzLl92bm9kZSksXG5cdFx0XHRfdGhpcy5fdGVtcFxuXHRcdCk7XG5cdH1cblx0Ly8gV2hlbiB3ZSBjb21lIGZyb20gYSBjb25kaXRpb25hbCByZW5kZXIsIG9uIGEgbW91bnRlZFxuXHQvLyBwb3J0YWwgd2Ugc2hvdWxkIGNsZWFyIHRoZSBET00uXG5cdGVsc2UgaWYgKF90aGlzLl90ZW1wKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBQb3J0YWxgIHRvIGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgdm5vZGUgdHJlZSBhdCBhIGRpZmZlcmVudCBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBub2RlIHRvIGNvbnRpbnVlIHJlbmRlcmluZyBpbiB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgX3Zub2RlOiB2bm9kZSwgX2NvbnRhaW5lcjogY29udGFpbmVyIH0pO1xuXHRlbC5jb250YWluZXJJbmZvID0gY29udGFpbmVyO1xuXHRyZXR1cm4gZWw7XG59XG4iLCJpbXBvcnQge1xuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRoeWRyYXRlIGFzIHByZWFjdEh5ZHJhdGUsXG5cdG9wdGlvbnMsXG5cdHRvQ2hpbGRBcnJheSxcblx0Q29tcG9uZW50XG59IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9pXG5cdFx0OiAvZmlsfGNoZXxyYS9pXG5cdCkudGVzdCh0eXBlKTtcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLy8gYFVOU0FGRV8qYCBsaWZlY3ljbGUgaG9va3Ncbi8vIFByZWFjdCBvbmx5IGV2ZXIgaW52b2tlcyB0aGUgdW5wcmVmaXhlZCBtZXRob2RzLlxuLy8gSGVyZSB3ZSBwcm92aWRlIGEgYmFzZSBcImZhbGxiYWNrXCIgaW1wbGVtZW50YXRpb24gdGhhdCBjYWxscyBhbnkgZGVmaW5lZCBVTlNBRkVfIHByZWZpeGVkIG1ldGhvZC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBpdHMgb3duIGBjb21wb25lbnREaWRNb3VudCgpYCAoaW5jbHVkaW5nIHZpYSBkZWZpbmVQcm9wZXJ0eSksIHVzZSB0aGF0LlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGBVTlNBRkVfY29tcG9uZW50RGlkTW91bnQoKWAsIGBjb21wb25lbnREaWRNb3VudGAgaXMgdGhlIGFsaWFzIGdldHRlci9zZXR0ZXIuXG4vLyAtIElmIGFueXRoaW5nIGFzc2lnbnMgdG8gYW4gYFVOU0FGRV8qYCBwcm9wZXJ0eSwgdGhlIGFzc2lnbm1lbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSB1bnByZWZpeGVkIHByb3BlcnR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE5NDFcbltcblx0J2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0J2NvbXBvbmVudFdpbGxVcGRhdGUnXG5dLmZvckVhY2goa2V5ID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIGtleSwge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHZcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcblxuLyoqXG4gKiBQcm94eSByZW5kZXIoKSBzaW5jZSBSZWFjdCByZXR1cm5zIGEgQ29tcG9uZW50IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFZOb2RlIHRyZWUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudCBET00gbm9kZSB0byByZW5kZXIgdm5vZGUgdHJlZSBpbnRvXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciByZW5kZXJpbmdcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQgfCBudWxsfSBUaGUgcm9vdCBjb21wb25lbnQgcmVmZXJlbmNlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHQvLyBSZWFjdCBkZXN0cm95cyBhbnkgZXhpc3RpbmcgRE9NIG5vZGVzLCBzZWUgIzE3Mjdcblx0Ly8gLi4uYnV0IG9ubHkgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlICMxODI4XG5cdGlmIChwYXJlbnQuX2NoaWxkcmVuID09IG51bGwpIHtcblx0XHRwYXJlbnQudGV4dENvbnRlbnQgPSAnJztcblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSBlbXB0eTtcblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRlLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuXHRyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGU7XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBwcm9wcztcblxuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBub25DdXN0b21FbGVtZW50ID0gdHlwZS5pbmRleE9mKCctJykgPT09IC0xO1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdC8vIEVtdWxhdGUgUmVhY3QncyBiZWhhdmlvciBvZiBub3QgcmVuZGVyaW5nIHRoZSBjb250ZW50cyBvZiBub3NjcmlwdCB0YWdzIG9uIHRoZSBjbGllbnQuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAndmFsdWUnICYmICdkZWZhdWx0VmFsdWUnIGluIHByb3BzICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aSA9PT0gJ2RlZmF1bHRWYWx1ZScgJiZcblx0XHRcdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdFx0XHRwcm9wcy52YWx1ZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICgvb25kb3VibGVjbGljay9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdC9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpICsgdHlwZSkgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0aSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmZvY3VzJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3VzaW4nO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uYmx1ciQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChub25DdXN0b21FbGVtZW50ICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkucmVwbGFjZSgvW0EtWjAtOV0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3VwcG9ydCBmb3Igb25JbnB1dCBhbmQgb25DaGFuZ2UsIHNlZSAjMzU2MVxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBhbiBvbmlucHV0IHByb3AgYWxyZWFkeSBjaGFuZ2UgaXQgdG8gb25pbnB1dENhcHR1cmVcblx0XHRcdGlmICgvXm9uaW5wdXQkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldKSB7XG5cdFx0XHRcdFx0aSA9ICdvbmlucHV0Q2FwdHVyZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIGFycmF5IHNlbGVjdCB2YWx1ZXM6IDxzZWxlY3QgbXVsdGlwbGUgdmFsdWU9e1tdfSAvPlxuXHRcdGlmIChcblx0XHRcdHR5cGUgPT0gJ3NlbGVjdCcgJiZcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSAmJlxuXHRcdFx0QXJyYXkuaXNBcnJheShub3JtYWxpemVkUHJvcHMudmFsdWUpXG5cdFx0KSB7XG5cdFx0XHQvLyBmb3JFYWNoKCkgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB3aGljaCB3ZSBhYnVzZSBoZXJlIHRvIHVuc2V0IHRoZSB2YWx1ZSBwcm9wLlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZGluZyBzdXBwb3J0IGZvciBkZWZhdWx0VmFsdWUgaW4gc2VsZWN0IHRhZ1xuXHRcdGlmICh0eXBlID09ICdzZWxlY3QnICYmIG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSkge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSA9PSBjaGlsZC5wcm9wcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dm5vZGUucHJvcHMgPSBub3JtYWxpemVkUHJvcHM7XG5cblx0XHRpZiAocHJvcHMuY2xhc3MgIT0gcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBwcm9wcztcblx0XHRcdGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkgbm9ybWFsaXplZFByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3NOYW1lO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wcywgJ2NsYXNzTmFtZScsIGNsYXNzTmFtZURlc2NyaXB0b3IpO1xuXHRcdH1cblx0fVxuXG5cdHZub2RlLiQkdHlwZW9mID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cdGlmIChvbGRWTm9kZUhvb2spIG9sZFZOb2RlSG9vayh2bm9kZSk7XG59O1xuXG4vLyBPbmx5IG5lZWRlZCBmb3IgcmVhY3QtcmVsYXlcbmxldCBjdXJyZW50Q29tcG9uZW50O1xuY29uc3Qgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xub3B0aW9ucy5fcmVuZGVyID0gZnVuY3Rpb24odm5vZGUpIHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikge1xuXHRcdG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cdH1cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG59O1xuXG5jb25zdCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcbi8qKiBAdHlwZSB7KHZub2RlOiBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZSl9ICovXG5vcHRpb25zLmRpZmZlZCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGREaWZmZWQpIHtcblx0XHRvbGREaWZmZWQodm5vZGUpO1xuXHR9XG5cblx0Y29uc3QgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0Y29uc3QgZG9tID0gdm5vZGUuX2RvbTtcblx0aWYgKFxuXHRcdGRvbSAhPSBudWxsICYmXG5cdFx0dm5vZGUudHlwZSA9PT0gJ3RleHRhcmVhJyAmJlxuXHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRwcm9wcy52YWx1ZSAhPT0gZG9tLnZhbHVlXG5cdCkge1xuXHRcdGRvbS52YWx1ZSA9IHByb3BzLnZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLnZhbHVlO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG4vLyBUaGlzIGlzIGEgdmVyeSB2ZXJ5IHByaXZhdGUgaW50ZXJuYWwgZnVuY3Rpb24gZm9yIFJlYWN0IGl0XG4vLyBpcyB1c2VkIHRvIHNvcnQtb2YgZG8gcnVudGltZSBkZXBlbmRlbmN5IGluamVjdGlvbi4gU28gZmFyXG4vLyBvbmx5IGByZWFjdC1yZWxheWAgbWFrZXMgdXNlIG9mIGl0LiBJdCB1c2VzIGl0IHRvIHJlYWQgdGhlXG4vLyBjb250ZXh0IHZhbHVlLlxuZXhwb3J0IGNvbnN0IF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0ge1xuXHRSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiB7XG5cdFx0Y3VycmVudDoge1xuXHRcdFx0cmVhZENvbnRleHQoY29udGV4dCkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudENvbXBvbmVudC5fZ2xvYmFsQ29udGV4dFtjb250ZXh0Ll9pZF0ucHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbi8qKlxuICogV2hlbiBhIGJ1bmNoIG9mIHVucmVsYXRlZCBjb21wb25lbnRzIGFsbCB1c2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsXG4gKiB5ZXMsIHRoaXMgYWN0dWFsbHkgaXMgZmFzdGVyLiBJIHdpc2ggaXQgd2Fzbid0LiBJdCdzIGxhbWUuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH0gfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICB9XG4gICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRCdWlsZE1vZGUgPSBtZW1vaXplKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQpIGFzIHR5cGVvZiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkOyIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi4vdXRpbC9tb2RlLmpzXCI7XG5cbi8qKiBUYWtlcyBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBhIHZhbHVlLCB1bmxpa2UgYE9uUGFzc2l2ZVN0YXRlQ2hhbmdlYCB3aGljaCByZWFjdHMgdG8gdGhvc2UgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTLCBSPiA9ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCkgOiAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb246IFIpID0+IHZvaWQpO1xuLyoqIFJlc3BvbmRzIHRvIGEgY2hhbmdlIGluIGEgdmFsdWUsIHVubGlrZSBgUGFzc2l2ZVN0YXRlVXBkYXRlcmAgd2hpY2ggY2F1c2VzIHRoZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxTLCBSPiA9ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKSA6ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uOiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG5cblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgaWYgKGdldEJ1aWxkTW9kZSgpID09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmPEFycmF5PFQ+PihbXSk7XG4gICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZjxBcnJheTxib29sZWFuPj4oW10pO1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoIGFzIGFueSwgLTEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VSBleHRlbmRzIFQ+KHZhbHVlOiBVLCBpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgMTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2l9LWluZGV4ZWQgYXJndW1lbnQgKCR7aSA+PSAwPyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbaV0pIDogXCJ0aGUgbnVtYmVyIG9mIHN1cHBvc2VkbHkgc3RhYmxlIGVsZW1lbnRzXCJ9KS5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxULCBSPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQsIFI+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzFdKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID09PSBVbnNldCAmJiBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJlYXNvblJlZi5jdXJyZW50ID0gcmVhc29uIGFzIFI7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVhc29uID0gcmVhc29uUmVmLmN1cnJlbnQhIGFzIFI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHByZXZEZXAsIG5leHRSZWFzb24pID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfVxuXG4vKiogXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byB1c2UgZm9yIGBjdXN0b21EZWJvdW5jZVJlbmRlcmluZ2AgdGhhdCBjYXVzZXMgYHVzZVBhc3NpdmVTdGF0ZWAgdG8gcnVuIGNoYW5nZXMgd2l0aG91dCB3YWl0aW5nIGEgdGljay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHsgZigpOyB9IiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuXG5cbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XG5cbmZ1bmN0aW9uIGJhc2U2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDBiMTAwMDAwMCk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTY0Qml0cygpIHtcbiAgICByZXR1cm4gW3JhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCldIGFzIGNvbnN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cbiAqIElEcyB0aGF0IGFyZSBub3QgdmFsaWQgdW5kZXIgSFRNTDQgbWF5IGJlIGdlbmVyYXRlZC4gT2ggbm8uXG4gKiBcbiAqIFxuICogKFRoaXMgaXMgaGVyZSwgaW4gdGhpcyBwYXJ0aWN1bGFyIGZpbGUsIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxuICogT25jZSB3ZSBjYW4gcmVtb3ZlIHRoaXMgaG9vaywgd2UgY2FuIHB1dCB0aGlzIGZ1bmN0aW9uIGJhY2sgd2l0aCB1c2VSYW5kb21JZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XG59XG5cbmNvbnN0IHByZXZpb3VzSW5wdXRzID0gbmV3IE1hcDxzdHJpbmcsIElucHV0cyB8IHVuZGVmaW5lZD4oKTtcbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV0gYXMgKHZub2RlOiBWTm9kZSwgY29tbWl0UXVldWU6IENvbXBvbmVudFtdKSA9PiB2b2lkO1xuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBlZmZlY3RJbmZvXSBvZiB0b1J1bikge1xuICAgICAgICBjb25zdCBvbGRJbnB1dHMgPSBwcmV2aW91c0lucHV0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKC4uLmFyZ3MpO1xufVxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrIHwgbnVsbCwgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0pLCBbdmFsdWVdKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xufVxuXG5cbi8qKlxuICogTGlrZSBgdXNlU3RhYmxlR2V0dGVyYCwgYnV0ICoqKnJlcXVpcmVzKioqIHRoYXQgZXZlcnl0aGluZyBpbiB0aGUgb2JqZWN0IGlzIGFsc28gc3RhYmxlLFxuICogYW5kIGluIHR1cm4gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaXMgc3RhYmxlLlxuICogQHBhcmFtIHQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZU9iamVjdDxUIGV4dGVuZHMge30+KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModCk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlT2JqZWN0XCIsIGUubGVuZ3RoLCAuLi5lLm1hcCgoW19rLCB2XSkgPT4gdikpO1xuICAgIHJldHVybiB1c2VSZWYodCkuY3VycmVudDtcbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2tOYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbihsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdLCByaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xudHlwZSBDID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqIFxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxoc0NsYXNzOiBDLCBsaHNDbGFzc05hbWU6IEMsIHJoc0NsYXNzOiBDLCByaHNDbGFzc05hbWU6IEMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxuICogQHBhcmFtIGxocyBcbiAqIEBwYXJhbSByaHMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihyaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdLCBsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdKSB7XG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzITtcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocyE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21iaW5lZChjdXJyZW50OiBFIHwgbnVsbCkge1xuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcblxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cbiAgICAgICAgaWYgKGxocyAmJiAhcmhzKVxuICAgICAgICAgICAgcmV0dXJuIGxocztcbiAgICAgICAgaWYgKCFsaHMgJiYgcmhzKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXG4gICAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoc3R5bGVTdHJpbmdUb09iamVjdChsaHMgYXMgc3RyaW5nKSwgcmhzKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgc3R5bGVTdHJpbmdUb09iamVjdChyaHMgYXMgc3RyaW5nKSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZ2ljPz8/XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihsaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXG4gICAgICAgIC4uLihyaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW4uanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzLmpzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPiksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPik+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5LCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBzYWtlIG9mIGNvbnZlbmllbmNlLFxuICAgICAqIHRoaXMgb25lIGlzIG9wdGlvbmFsLCBzaW5jZSB1c2luZyB0aGlzIGhvb2sgaXMgc28gY29tbW9uLFxuICAgICAqIGJ1dCB1c2luZyBpdHMgcGFyYW1ldGVyIG9wdGlvbnMgaXMgc28gdW5jb21tb24sIGFuZCBpdCdzXG4gICAgICogYWJzZW5zZSBpc24ndCB1c3VhbGx5IGJlY2F1c2UgaXQgd2FzIGZvcmdvdHRlbiwgaXQncyBiZWNhdXNlXG4gICAgICogaXQgZG9lc24ndCBtYXR0ZXIuXG4gICAgICovXG4gICAgcmVmRWxlbWVudFBhcmFtZXRlcnM/OiB7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj47XG4gICAgICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICAgICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncy5yZWZFbGVtZW50UGFyYW1ldGVycyB8fCB7fSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XG5cbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xuXG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGwsIG5ldmVyPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgcHJvcHNTdGFibGUgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHsgcmVmOiBzZXRFbGVtZW50IH0pO1xuXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvL21hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxuXG4gICAgbWFuYWdlZENoaWxkQ29udGV4dDoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5OiBJbnRlcm5hbENoaWxkSW5mbzxNPjtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSwgbW91bnRlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSkgPT4gKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IHtcbiAgICBpbmRleDogVDtcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUT0RPOiBUaGlzIGVuZGVkIHVwIG5vdCBiZWluZyBuZWVkZWQgYnkgYW55dGhpbmcuIElzIGl0IG5lY2Vzc2FyeT8gRG9lcyBpdCBjb3N0IGFueXRoaW5nP1xuICAgICAgICAgKi9cbiAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxNW1wiaW5kZXhcIl0+O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPE1bXCJpbmRleFwiXT47XG4gICAgXG4gICAgICAgIG9uQ2hpbGRDb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNvdW50OiBudW1iZXIpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHkgc2hhcmVkIGFtb25nIGFsbCBtYW5hZ2VkIGNoaWxkcmVuLlxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgcmVkdW5kYW50IHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCwgd2hpY2ggaXMuLi5laC4gQnV0IHRoZSB0eXBlcyBhcmUgY2xlYXIuXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxNLCBcImluZGV4XCI+O1xuXG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKioqU1RBQkxFKioqXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCAqKmJvdGgqKiBgZ2V0Q2hpbGRyZW5gIGFuZCB0aGUgYE1hbmFnZWRDaGlsZHJlbmAgb2JqZWN0IGl0IHJldHVybnMgYXJlIHN0YWJsZSFcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgaW5zdGVhZCBvZiBhbiBvYmplY3QgYmVjYXVzZSB3aGVuIGZ1bmN0aW9uIGNhbGxzIGhhcHBlbiBvdXQgb2Ygb3JkZXIgaXQncyBlYXNpZXIgdG8ganVzdCBoYXZlIGFsd2F5cyBiZWVuIHBhc3NpbmcgYW5kIHJldHVybiBnZXR0ZXJzIGV2ZXJ5d2hlcmUgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cbiAgICB9O1xuXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogTVtcImluZGV4XCJdKTogTSB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRDb3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZENvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChpbmZvLmNvbnRleHQgPz8geyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuQXJyYXkgPT0gbnVsbCB8fCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4hIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbiwgbmV3U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCwgcHJldlNlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwpOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbnRleHQsIGNyZWF0ZUNvbnRleHQsIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRXhjbHVzaXZlQ29udGV4dFR5cGUsIFN3YXBwYWJsZUNvbnRleHRUeXBlLCBUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2UgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBzdHJpbmcpOiBDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD47XG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBudWxsIHwgdW5kZWZpbmVkKTogbnVsbDtcbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD4gfCBudWxsO1xuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbihleGNsdXNpdml0eUtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPiB8IG51bGwge1xuICAgIGlmIChleGNsdXNpdml0eUtleSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dDxFeGNsdXNpdmVDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xufVxuXG5leHBvcnQgY29uc3QgU3dhcHBhYmxlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8U3dhcHBhYmxlQ29udGV4dFR5cGU+KHsgZ2V0QW5pbWF0ZU9uTW91bnQ6ICgpID0+IGZhbHNlIH0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgZm9yIGEgZ2l2ZW4gYGV4Y2x1c2l2aXR5S2V5YCwgY3JlYXRpbmcgb25lIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqIFxuICogSWYgXG4gKi9cbmV4cG9ydCBjb25zdCBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dDogdHlwZW9mIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24gPSBtZW1vaXplKGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24pO1xuXG5pbnRlcmZhY2UgQ3NzQ2xhc3Nlc1Byb3ZpZGVyUHJvcHMge1xuICAgIGJhc2U6IHN0cmluZztcbiAgICBlbnRlcjogc3RyaW5nO1xuICAgIGV4aXQ6IHN0cmluZztcbiAgICBtZWFzdXJlOiBzdHJpbmc7XG4gICAgaW5pdDogc3RyaW5nO1xuICAgIHRyYW5zaXRpb246IHN0cmluZztcbiAgICBmaW5hbGl6ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ3NzQ2xhc3NDb250ZXh0VHlwZSB7XG4gICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RW50ZXJDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEV4aXRDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldE1lYXN1cmVDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEluaXRDbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldFRyYW5zaXRpb25DbGFzczogKCkgPT4gc3RyaW5nO1xuICAgIEdldEZpbmFsaXplQ2xhc3M6ICgpID0+IHN0cmluZztcbn1cblxuY29uc3QgQ3NzQ2xhc3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDc3NDbGFzc0NvbnRleHRUeXBlPih7XG4gICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBcInB0bFwiLFxuICAgIEdldEVudGVyQ2xhc3M6ICgpID0+IFwiblwiLFxuICAgIEdldEV4aXRDbGFzczogKCkgPT4gXCJ4XCIsXG4gICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBcIm1cIixcbiAgICBHZXRJbml0Q2xhc3M6ICgpID0+IFwiaVwiLFxuICAgIEdldFRyYW5zaXRpb25DbGFzczogKCkgPT4gXCJ0XCIsXG4gICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gXCJmXCIsXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gQ3NzQ2xhc3Nlc1Byb3ZpZGVyKHsgYmFzZSwgZW50ZXIsIGV4aXQsIG1lYXN1cmUsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplLCBjaGlsZHJlbiwgLi4ucmVzdCB9OiBSZW5kZXJhYmxlUHJvcHM8UGFydGlhbDxDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcz4+KSB7XG4gICAgY29uc3QgY29udGV4dE9iamVjdCA9IHVzZUNzc0NsYXNzQ29udGV4dFZhbHVlKHsgYmFzZSwgZW50ZXIsIGV4aXQsIG1lYXN1cmUsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplIH0pO1xuICAgIHJldHVybiAoPENzc0NsYXNzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dE9iamVjdH0gIHsuLi5yZXN0fSBjaGlsZHJlbj17Y2hpbGRyZW59IC8+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3NzQ2xhc3NlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIEdldEJhc2VDbGFzcyxcbiAgICAgICAgR2V0RW50ZXJDbGFzcyxcbiAgICAgICAgR2V0RXhpdENsYXNzLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3MsXG4gICAgICAgIEdldEluaXRDbGFzcyxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzXG4gICAgfSA9IHVzZUNvbnRleHQoQ3NzQ2xhc3NDb250ZXh0KTtcbiAgICBjb25zdCBHZXREaXJlY3Rpb25DbGFzcyA9IHVzZUNhbGxiYWNrKChkaXJlY3Rpb246IFRyYW5zaXRpb25EaXJlY3Rpb24pOiBzdHJpbmcgPT4geyBzd2l0Y2ggKGRpcmVjdGlvbikgeyBjYXNlIFwiZW50ZXJcIjogcmV0dXJuIEdldEVudGVyQ2xhc3MoKTsgY2FzZSBcImV4aXRcIjogcmV0dXJuIEdldEV4aXRDbGFzcygpOyB9IH0sIFtdKTtcbiAgICBjb25zdCBHZXRQaGFzZUNsYXNzID0gdXNlQ2FsbGJhY2soKHBoYXNlOiBUcmFuc2l0aW9uUGhhc2UpOiBzdHJpbmcgPT4geyBzd2l0Y2ggKHBoYXNlKSB7IGNhc2UgXCJtZWFzdXJlXCI6IHJldHVybiBHZXRNZWFzdXJlQ2xhc3MoKTsgY2FzZSBcImluaXRcIjogcmV0dXJuIEdldEluaXRDbGFzcygpOyBjYXNlIFwidHJhbnNpdGlvblwiOiByZXR1cm4gR2V0VHJhbnNpdGlvbkNsYXNzKCk7IGNhc2UgXCJmaW5hbGl6ZVwiOiByZXR1cm4gR2V0RmluYWxpemVDbGFzcygpOyB9IH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBHZXRCYXNlQ2xhc3MsXG4gICAgICAgIEdldEVudGVyQ2xhc3MsXG4gICAgICAgIEdldEV4aXRDbGFzcyxcbiAgICAgICAgR2V0TWVhc3VyZUNsYXNzLFxuICAgICAgICBHZXRJbml0Q2xhc3MsXG4gICAgICAgIEdldFRyYW5zaXRpb25DbGFzcyxcbiAgICAgICAgR2V0RmluYWxpemVDbGFzcyxcbiAgICAgICAgR2V0RGlyZWN0aW9uQ2xhc3MsXG4gICAgICAgIEdldFBoYXNlQ2xhc3NcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc0NsYXNzQ29udGV4dFZhbHVlKG5ld1ZhbHVlczogUGFydGlhbDxDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcz4pOiBDc3NDbGFzc0NvbnRleHRUeXBlIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB1c2VDb250ZXh0KENzc0NsYXNzQ29udGV4dCk7XG4gICAgY29uc3QgYmFzZSA9IChuZXdWYWx1ZXM/LmJhc2UgPz8gb2xkVmFsdWVzLkdldEJhc2VDbGFzcygpKTtcbiAgICBjb25zdCBlbnRlciA9IChuZXdWYWx1ZXM/LmVudGVyID8/IG9sZFZhbHVlcy5HZXRFbnRlckNsYXNzKCkpO1xuICAgIGNvbnN0IGV4aXQgPSAobmV3VmFsdWVzPy5leGl0ID8/IG9sZFZhbHVlcy5HZXRFeGl0Q2xhc3MoKSk7XG4gICAgY29uc3QgbWVhc3VyZSA9IChuZXdWYWx1ZXM/Lm1lYXN1cmUgPz8gb2xkVmFsdWVzLkdldE1lYXN1cmVDbGFzcygpKTtcbiAgICBjb25zdCBpbml0ID0gKG5ld1ZhbHVlcz8uaW5pdCA/PyBvbGRWYWx1ZXMuR2V0SW5pdENsYXNzKCkpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSAobmV3VmFsdWVzPy50cmFuc2l0aW9uID8/IG9sZFZhbHVlcy5HZXRUcmFuc2l0aW9uQ2xhc3MoKSk7XG4gICAgY29uc3QgZmluYWxpemUgPSAobmV3VmFsdWVzPy5maW5hbGl6ZSA/PyBvbGRWYWx1ZXMuR2V0RmluYWxpemVDbGFzcygpKTtcblxuICAgIHJldHVybiB1c2VNZW1vPENzc0NsYXNzQ29udGV4dFR5cGU+KCgpID0+ICh7XG4gICAgICAgIEdldEJhc2VDbGFzczogKCkgPT4gYmFzZSEsXG4gICAgICAgIEdldEVudGVyQ2xhc3M6ICgpID0+IGVudGVyISxcbiAgICAgICAgR2V0RXhpdENsYXNzOiAoKSA9PiBleGl0ISxcbiAgICAgICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBtZWFzdXJlISxcbiAgICAgICAgR2V0SW5pdENsYXNzOiAoKSA9PiBpbml0ISxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiB0cmFuc2l0aW9uISxcbiAgICAgICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gZmluYWxpemUhLFxuICAgIH0pLCBbYmFzZSwgZW50ZXIsIGV4aXQsIGluaXQsIHRyYW5zaXRpb24sIGZpbmFsaXplXSlcbn1cblxuIiwiaW1wb3J0IHsgRnJhZ21lbnQsIGgsIFJlbmRlcmFibGVQcm9wcywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDaGlsZHJlbkZsYWcsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlT2JqZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IEV4Y2x1c2l2ZUNvbnRleHRUeXBlLCBFeGNsdXNpdmVJbmZvLCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5cblxuXG5sZXQgZ2xvYmFsQ291bnQgPSAtMTtcblxuZXhwb3J0IGZ1bmN0aW9uIEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcih7IGV4Y2x1c2l2aXR5S2V5LCBjaGlsZHJlbiB9OiBSZW5kZXJhYmxlUHJvcHM8eyBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgfT4pIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXJcIiwgZXhjbHVzaXZpdHlLZXkpO1xuXG4gICAgY29uc3QgW2dldE5leHRJbmRleEluTGluZSwgc2V0TmV4dEluZGV4SW5MaW5lXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcgfCBudWxsLCBuZXZlcj4obnVsbCk7XG5cbiAgICBjb25zdCB7IGNvbnRleHQsIG1hbmFnZWRDaGlsZHJlblJldHVybiwgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxFeGNsdXNpdmVJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIGdldEN1cnJlbnRJbmRleCB9ID0gdXNlQ2hpbGRyZW5GbGFnPEV4Y2x1c2l2ZUluZm8sIG5ldmVyPih7XG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbEluZGV4OiBudWxsLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiBudWxsLFxuICAgICAgICBzZXRBdDogdXNlQ2FsbGJhY2soKG0sIHYpID0+IHsgbS5zZXRFeGNsdXNpdmVseU9wZW4odik7IH0sIFtdKSxcbiAgICAgICAgZ2V0QXQ6IHVzZUNhbGxiYWNrKChtKSA9PiBtLmdldEV4Y2x1c2l2ZWx5T3BlbigpLCBbXSksXG4gICAgICAgIGlzVmFsaWQ6IHVzZUNhbGxiYWNrKChtKSA9PiB7IHJldHVybiB0cnVlIH0sIFtdKSxcbiAgICB9KVxuXG4gICAgY29uc3Qgb25WaXNpYmlsaXR5Q2hhbmdlID0gdXNlQ2FsbGJhY2soKGluZGV4OiBzdHJpbmcsIHZpc2libGU6IFwic2hvd1wiIHwgXCJoaWRkZW5cIikgPT4ge1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc3QgbmV4dEluTGluZSA9IGdldE5leHRJbmRleEluTGluZSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5MaW5lID0gZ2V0Q3VycmVudEluZGV4KCk7XG5cbiAgICAgICAgaWYgKHZpc2libGUgPT0gXCJzaG93XCIgJiYgaW5kZXggIT0gY3VycmVudEluTGluZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIGEgY2hpbGQgdHJhbnNpdGlvbiBzaG93cyBpdHNlbGYgaW5pdGlhbGx5XG4gICAgICAgICAgICAgKiAoaS5lLiByZXF1ZXN0cyBpdHNlbGYgdG8gYmUgdGhlIGV4Y2x1c2l2ZSB0cmFuc2l0aW9uKVxuICAgICAgICAgICAgICogd2UgZWl0aGVyIGxldCBpdCBvcGVuIGltbWVkaWF0ZWx5IGlmIHRoZXJlJ3Mgbm8gb25lIGZpbmlzaGluZyB0aGVpciBleGl0LFxuICAgICAgICAgICAgICogb3Igd2FpdCB1bnRpbCB0aGF0IGFmb3JlbWVudGlvbmVkIGV4aXQgaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoY3VycmVudEluTGluZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW4oKS5nZXRBdChjdXJyZW50SW5MaW5lKT8uZm9yY2VDbG9zZT8uKCk7XG4gICAgICAgICAgICAgICAgc2V0TmV4dEluZGV4SW5MaW5lKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aXNpYmxlID09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIGNoaWxkIHRyYW5zaXRpb24gaGFzIGZpbmlzaGVkIGl0cyBleGl0IHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgKiBtYWtlIHN1cmUgdGhhdCBpZiBzb21lb25lIHJlcXVlc3RlZCB0byBiZSBzaG93biBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAqIHRoYXQgd2UgZG8gc28uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChuZXh0SW5MaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleChuZXh0SW5MaW5lKTtcbiAgICAgICAgICAgICAgICBzZXROZXh0SW5kZXhJbkxpbmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGNvbnRleHQyOiBFeGNsdXNpdmVDb250ZXh0VHlwZSA9IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgZXhjbHVzaXZpdHlLZXksXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBjb25zdCBFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCA9IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0KGV4Y2x1c2l2aXR5S2V5KTtcblxuICAgIHJldHVybiAoRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgPT0gbnVsbCkgPyAoKGNoaWxkcmVuIGFzIFZOb2RlKSA/PyBudWxsKSA6IDxFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dDJ9PntjaGlsZHJlbn08L0V4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyPjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8RXhjbHVzaXZlSW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiIHwgXCJjb250ZXh0XCI+IHtcbiAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczogUGljazxUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8YW55PiwgXCJzaG93XCI+O1xuICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGZvcmNlQ2xvc2U6ICgpID0+IHZvaWQ7IGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXhjbHVzaXZlVHJhbnNpdGlvbih7IHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IHNob3cgfSwgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZm9yY2VDbG9zZSwgZXhjbHVzaXZpdHlLZXkgfSB9OiBVc2VFeGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVycykge1xuICAgIGNvbnN0IGMgPSBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dChleGNsdXNpdml0eUtleSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlRXhjbHVzaXZlVHJhbnNpdGlvblwiLCBjID09IG51bGwpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjPyB1c2VDb250ZXh0KGMpIDogbnVsbDtcblxuICAgIC8vY29uc3QgaW5kZXggPSB1c2VNZW1vKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSwgW10pO1xuICAgIGNvbnN0IGluZGV4ID0gdXNlTWVtbygoKSA9PiB7IGdsb2JhbENvdW50ICs9IDE7IHJldHVybiAoZ2xvYmFsQ291bnQpLnRvU3RyaW5nKCkgfSwgW10pO1xuICAgIGNvbnN0IFtleGNsdXNpdmVseU9wZW4sIHNldEV4Y2x1c2l2ZWx5T3BlbiwgZ2V0RXhjbHVzaXZlbHlPcGVuXSA9IHVzZVN0YXRlPGJvb2xlYW4+KCEhc2hvdyk7XG4gICAgY29uc3Qge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfVxuICAgIH0gPSB1c2VNYW5hZ2VkQ2hpbGQ8RXhjbHVzaXZlSW5mbz4oeyBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSwgeyBpbmRleCwgZ2V0RXhjbHVzaXZlbHlPcGVuLCBzZXRFeGNsdXNpdmVseU9wZW4sIGZvcmNlQ2xvc2UgfSk7XG5cbiAgICBjb25zdCBwYXJlbnRPblZpc0NoYW5nZSA9IGNvbnRleHQ/LmV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0Lm9uVmlzaWJpbGl0eUNoYW5nZTtcblxuICAgIGNvbnN0IG9uVmlzaWJpbGl0eUNoYW5nZSA9IHVzZUNhbGxiYWNrPE5vbk51bGxhYmxlPFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxhbnk+W1wib25WaXNpYmlsaXR5Q2hhbmdlXCJdPj4oKHZpc2libGUpID0+IHtcbiAgICAgICAgcGFyZW50T25WaXNDaGFuZ2U/LihpbmRleCwgdmlzaWJsZSA9PSBmYWxzZSA/IFwiaGlkZGVuXCIgOiBcInNob3dcIik7XG4gICAgfSwgW3BhcmVudE9uVmlzQ2hhbmdlLCBpbmRleF0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNob3cpXG4gICAgICAgICAgICBwYXJlbnRPblZpc0NoYW5nZT8uKGluZGV4LCBcInNob3dcIik7XG4gICAgfSwgW3Nob3csIHBhcmVudE9uVmlzQ2hhbmdlLCBpbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblJldHVybjoge1xuICAgICAgICAgICAgaXNFeGNsdXNpdmU6IChjb250ZXh0ICE9IG51bGwpLFxuICAgICAgICAgICAgZXhjbHVzaXZlbHlPcGVuLFxuICAgICAgICAgICAgc2V0RXhjbHVzaXZlbHlPcGVuLFxuICAgICAgICAgICAgZ2V0RXhjbHVzaXZlbHlPcGVuLFxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbiIsIlxyXG5pbXBvcnQgeyBGdW5jdGlvbmFsQ29tcG9uZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG50eXBlIEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnRQcm9wczxQLCBFPiA9IE9taXQ8UCwgXCJyZWZcIj4gJiB7IHJlZj86IFJlZjxFPiB9XHJcbnR5cGUgRm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudDxQLCBFPiA9IChwOiBGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50UHJvcHM8UCwgRT4pID0+IFZOb2RlPEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnRQcm9wczxQLCBFPj5cclxuXHJcbnR5cGUgRWxlbWVudEZyb21Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4gPSBQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8aW5mZXIgRT4gPyBFIDogRXZlbnRUYXJnZXQ7XHJcbnR5cGUgUHJvcHNGcm9tQ29tcG9uZW50PEMgZXh0ZW5kcyBGdW5jdGlvbmFsQ29tcG9uZW50PGFueT4+ID0gQyBleHRlbmRzIEZ1bmN0aW9uYWxDb21wb25lbnQ8aW5mZXIgUD4gPyBQIDogdW5rbm93bjtcclxuXHJcbi8qKlxyXG4gKiBTaG9ydGN1dCBmb3IgcHJlYWN0L2NvbXBhdCdzIGBmb3J3YXJkUmVmYCB0aGF0IGF1dG8tYXNzdW1lcyBzb21lIHRoaW5ncyB0aGF0IGFyZSB1c2VmdWwgZm9yIGZvcndhcmRpbmcgcmVmcyB0byBgSFRNTEVsZW1lbnRzYCBzcGVjaWZpY2FsbHkuXHJcbiAqIE5hbWVseSBpdCBpbnZvbHZlcyBkZS1ndW5raW5nIHRoZSB0eXBlIHN5c3RlbSBieSBsZXR0aW5nIHVzIHJldHVybiAqZ2VuZXJpYyogZnVuY3Rpb24gYW5kIHBsYXlpbmcgbmljZSB3aXRoIFJlYWN0LiBJbiBhbGwgb3RoZXIgcmVzcGVjdHMsIGl0IGFjdHMgbGlrZSBgZm9yd2FyZFJlZmAuXHJcbiAqIFxyXG4gKiBUT0RPOiBTdGlsbCBuZWVkZWQ/XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZEVsZW1lbnRSZWY8QyBleHRlbmRzIDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHA6IGFueSwgcmVmOiBSZWY8RT4pID0+IChWTm9kZTxhbnk+IHwgbnVsbCk+KENvbXBvbmVudDogQykge1xyXG4gICAgdHlwZSBQID0gUHJvcHNGcm9tQ29tcG9uZW50PEM+O1xyXG5cclxuXHJcbiAgICBjb25zdCBGb3J3YXJkZWRDb21wb25lbnQgPSBmb3J3YXJkUmVmKENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gRm9yd2FyZGVkQ29tcG9uZW50IGFzIEM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VmdWwgaW4gcGFydGljdWxhciBmb3IgU2xpZGVzIHdpdGggYSBUYWIgUGFuZWwgLS1cclxuICogaWYgd2UgZG8gTWF0aC5zaWduKGN1cnJlbnRJbmRleCAtIHNsaWRlSW5kZXgpLCBpdFxyXG4gKiB0cmFuc2l0aW9ucyBuaWNlbHkgaW4gdGhlIGV4cGVjdGVkIGRpcmVjdGlvbixcclxuICogYnV0IHdlIG5lZWQgdG8gXCJyZW1lbWJlclwiIHdoaWNoIGRpcmVjdGlvbiB0byB1c2VcclxuICogd2hlbiBpdCdzIHRoZSBjdXJyZW50IHBhbmVsIChhbmQgdGhlIGRpZmZlcmVuY2UgaXMgMClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXN0Tm9uTnVsbFZhbHVlPFQ+KHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFQgfCBudWxsIHtcclxuICAgIGNvbnN0IGxhc3ROb25OdWxsVmFsdWUgPSB1c2VSZWY8VCB8IG51bGw+KG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbClcclxuICAgICAgICAgICAgbGFzdE5vbk51bGxWYWx1ZS5jdXJyZW50ID0gdmFsdWU7XHJcbiAgICB9LCBbdmFsdWVdKTtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUgPz8gbGFzdE5vbk51bGxWYWx1ZS5jdXJyZW50O1xyXG59XHJcbiIsImltcG9ydCB7IGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQsIENvbXBvbmVudENoaWxkcmVuLCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyIH0gZnJvbSBcIi4vZXhjbHVzaXZlLmpzXCI7XHJcbmltcG9ydCB7IFN3YXBwYWJsZUNvbnRleHQsIHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgTm9uSW50cnVzaXZlRWxlbWVudEF0dHJpYnV0ZXMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN3YXBQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbDxDcmVhdGVTd2FwcGFibGVQcm9wcz4sIE5vbkludHJ1c2l2ZUVsZW1lbnRBdHRyaWJ1dGVzPEU+IHtcclxuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIGVhY2ggY2hpbGQgdHJhbnNpdGlvbnMgaW4vb3V0IGF0IHRoZSBzYW1lIHRpbWUsIGluIHN5bmMgd2l0aCBlYWNoIG90aGVyLlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBndWFyYW50ZWUgdGhhdCwgbm8gbWF0dGVyIHdoYXQsIG9ubHkgb25lIGlzIGV2ZXIgdmlzaWJsZSBhdCBhbGwsXHJcbiAgICAgKiBwYXNzIGEgc3RyaW5nIHRvIGBleGNsdXNpdml0eUtleWAsIGFuZCBhbGwgdHJhbnNpdGlvbnMgdGhhdCB1c2UgdGhhdCBzYW1lXHJcbiAgICAgKiBgZXhjbHVzaXZpdHlLZXlgIHdpbGwgY29vcmRpbmF0ZSB0aGlzIGJlaGF2aW9yIGFtb25nIHRoZW1zZWx2ZXMuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgaXMgYWxzbyBhdmFpbGFibGUgYXMgYSBzZXBhcmF0ZSBjb21wb25lbnQgKGBFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXJgKVxyXG4gICAgICogaWYgeW91IG5lZWQgdGhpcyBiZWhhdmlvciBpbiB1bnJlbGF0ZWQgY2lyY3Vtc3RhbmNlcy5cclxuICAgICAqL1xyXG4gICAgZXhjbHVzaXZpdHlLZXk/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVN3YXBwYWJsZVByb3BzIHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGNvbXBvbmVudCBpcyBpbmxpbmUtZ3JpZCBvciBncmlkLiBcclxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGNoaWxkIGVsZW1lbnQgaXMgbG9va2VkIGF0LiBJZiBpdCdzIGEgc3BhbiBvciBvdGhlciBpbmxpbmUgZWxlbWVudCwgaW5saW5lIGlzIGFzc3VtZWQuIFxyXG4gICAgICogKEEgc2ltcGx5LWZvb2xlZCBoZXVyaXN0aWMtLXByb3ZpZGUgdGhpcyBwcm9wIGlmIG5lY2Vzc2FyeSlcclxuICAgICAqL1xyXG4gICAgaW5saW5lOiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGRlZmF1bHQgdmFsdWVzIHRvIGB1c2VUcmFuc2l0aW9uYCdzIGBhbmltYXRlT25Nb3VudGAuIElmIG51bGwsIHRoZSBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIHdpbGwgYmUgYGZhbHNlYCBpbml0aWFsbHksIHRoZW4gYHRydWVgIGFmdGVyIHRoZSBgU3dhcHBhYmxlYCBpdHNlbGYgaGFzIG1vdW50ZWQuXHJcbiAgICAgKi9cclxuICAgIGNoaWxkcmVuQW5pbWF0ZU9uTW91bnQ/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBzd2FwIGNvbnRhaW5lci5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDcmVhdGVTd2FwcGFibGVQcm9wczxQIGV4dGVuZHMge30+KHsgaW5saW5lIH06IENyZWF0ZVN3YXBwYWJsZVByb3BzLCBvdGhlclByb3BzOiBQKSB7XHJcbiAgICB0eXBlIEUgPSBQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8aW5mZXIgRT4gPyBFIDogSFRNTEVsZW1lbnQ7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHtcclxuICAgICAgICBjbGFzc05hbWU6IGNsc3goYCR7R2V0QmFzZUNsYXNzKCl9LXN3YXAtY29udGFpbmVyYCwgaW5saW5lICYmIGAke0dldEJhc2VDbGFzcygpfS1zd2FwLWNvbnRhaW5lci1pbmxpbmVgKVxyXG4gICAgfSwgb3RoZXJQcm9wcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYSBzZXQgb2YgY2hpbGQgPFRyYW5zaXRpb25hYmxlPiBjb21wb25lbnRzIHRvIGFuaW1hdGUgaW4gJiBvdXQgaW4tcGxhY2UuIFZlcnkgdXNlZnVsIGZvciwgZS5nLiwgdGFiIHBhbmVscy5cclxuICogXHJcbiAqIFlvdSBtdXN0IG1hbmFnZSBlYWNoIGNoaWxkIGA8VHJhbnNpdGlvbmFibGU+YCBjb21wb25lbnQncyBgc2hvd2AgcHJvcCAtLSB0aGlzIGNvbXBvbmVudCAqZG9lcyBub3QqIG1hbmFnZSBhbnkgc29ydCBvZiBzdGF0ZSBpbiB0aGF0IHJlZ2FyZC5cclxuICogXHJcbiAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBlbGVtZW50IChsaWtlIGEgZGl2KSBvciBvdGhlciBzaW5nbGUgY29tcG9uZW50LCB0aGVuIHRoZWUgcHJvcHMgYW5kIHJlZiB3aWxsIGJlIGZvcndhcmRlZCBvbnRvIHRoYXQgZWxlbWVudC4gT3RoZXJ3aXNlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgYmUgd3JhcHBlZCBpbiBhIGRpdiBvciBzcGFuIGRlcGVuZGluZyBvbiB0aGUgYGlubGluZWAgcHJvcC5cclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU3dhcHBhYmxlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTd2FwcGFibGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGNoaWxkcmVuOiBjLCBpbmxpbmUsIGNoaWxkcmVuQW5pbWF0ZU9uTW91bnQsIGV4Y2x1c2l2aXR5S2V5LCAuLi5wIH06IFN3YXBQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIGxldCBjaGlsZHJlbiA9IGMgYXMgVk5vZGU7XHJcbiAgICBpZiAoIShjaGlsZHJlbiBhcyBWTm9kZSkudHlwZSlcclxuICAgICAgICBjaGlsZHJlbiA9ICghaW5saW5lID8gPGRpdj57Y2hpbGRyZW59PC9kaXY+IDogPHNwYW4+e2NoaWxkcmVufTwvc3Bhbj4pXHJcbiAgICBpbmxpbmUgPz89IHR5cGVvZiBjaGlsZHJlbi50eXBlID09PSBcInN0cmluZ1wiICYmIGlubGluZUVsZW1lbnRzLmhhcyhjaGlsZHJlbi50eXBlKTtcclxuXHJcbiAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyh7IGlubGluZSB9LCB7IC4uLnAsIHJlZiB9KTtcclxuICAgIGNvbnN0IG1lcmdlZFdpdGhDaGlsZHJlbiA9IHVzZU1lcmdlZFByb3BzPEU+KHRyYW5zaXRpb25Qcm9wcywgY2hpbGRyZW4ucHJvcHMpO1xyXG5cclxuICAgIGNvbnN0IGFuaW1hdGVPbk1vdW50ID0gdXNlUmVmKGNoaWxkcmVuQW5pbWF0ZU9uTW91bnQgPz8gZmFsc2UpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBhbmltYXRlT25Nb3VudC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIH0sIFtdKVxyXG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlUmVmKHsgZ2V0QW5pbWF0ZU9uTW91bnQ6ICgpID0+IHsgcmV0dXJuIGFuaW1hdGVPbk1vdW50LmN1cnJlbnQ7IH0gfSk7XHJcbiAgICBsZXQgcmV0ID0gY2xvbmVFbGVtZW50KGNoaWxkcmVuLCBtZXJnZWRXaXRoQ2hpbGRyZW4gYXMgdHlwZW9mIHRyYW5zaXRpb25Qcm9wcyk7XHJcbiAgICByZXQgPSAoPFN3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZS5jdXJyZW50fT57cmV0fTwvU3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlcj4pXHJcbiAgICBpZiAoZXhjbHVzaXZpdHlLZXkpIHtcclxuICAgICAgICByZXQgPSAoPEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlciBrZXk9e2V4Y2x1c2l2aXR5S2V5fSBleGNsdXNpdml0eUtleT17ZXhjbHVzaXZpdHlLZXl9PntyZXR9PC9FeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXI+KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufSkpXHJcblxyXG4vLyBJZiBcImlubGluZVwiIGlzbid0IGV4cGxpY2l0bHkgcHJvdmlkZWQsIHdlIHRyeSB0byBpbXBsaWNpdGx5IGRvIGl0IGJhc2VkIG9uIHRoZSBjaGlsZCdzIHRhZy5cclxuLy8gTm90IHBlcmZlY3QsIGJ1dCBpdCdzIG5vdCBzdXBwb3NlZCB0byBiZS4gYGlubGluZWAgaXMgZm9yIHBlcmZlY3QuXHJcbmNvbnN0IGlubGluZUVsZW1lbnRzID0gbmV3IFNldChbXHJcbiAgICBcImFcIixcclxuICAgIFwiYWJiclwiLFxyXG4gICAgXCJhY3JvbnltXCIsXHJcbiAgICBcImF1ZGlvXCIsXHJcbiAgICBcImJcIixcclxuICAgIFwiYmRpXCIsXHJcbiAgICBcImJkb1wiLFxyXG4gICAgXCJiaWdcIixcclxuICAgIFwiYnJcIixcclxuICAgIFwiYnV0dG9uXCIsXHJcbiAgICBcImNhbnZhc1wiLFxyXG4gICAgXCJjaXRlXCIsXHJcbiAgICBcImNvZGVcIixcclxuICAgIFwiZGF0YVwiLFxyXG4gICAgXCJkYXRhbGlzdFwiLFxyXG4gICAgXCJkZWxcIixcclxuICAgIFwiZGZuXCIsXHJcbiAgICBcImVtXCIsXHJcbiAgICBcImVtYmVkXCIsXHJcbiAgICBcImlcIixcclxuICAgIFwiaWZyYW1lXCIsXHJcbiAgICBcImltZ1wiLFxyXG4gICAgXCJpbnB1dFwiLFxyXG4gICAgXCJpbnNcIixcclxuICAgIFwia2JkXCIsXHJcbiAgICBcImxhYmVsXCIsXHJcbiAgICBcIm1hcFwiLFxyXG4gICAgXCJtYXJrXCIsXHJcbiAgICBcIm1ldGVyXCIsXHJcbiAgICBcIm5vc2NyaXB0XCIsXHJcbiAgICBcIm9iamVjdFwiLFxyXG4gICAgXCJvdXRwdXRcIixcclxuICAgIFwicGljdHVyZVwiLFxyXG4gICAgXCJwcm9ncmVzc1wiLFxyXG4gICAgXCJxXCIsXHJcbiAgICBcInJ1YnlcIixcclxuICAgIFwic1wiLFxyXG4gICAgXCJzYW1wXCIsXHJcbiAgICBcInNjcmlwdFwiLFxyXG4gICAgXCJzZWxlY3RcIixcclxuICAgIFwic2xvdFwiLFxyXG4gICAgXCJzbWFsbFwiLFxyXG4gICAgXCJzcGFuXCIsXHJcbiAgICBcInN0cm9uZ1wiLFxyXG4gICAgXCJzdWJcIixcclxuICAgIFwic3VwXCIsXHJcbiAgICBcInN2Z1wiLFxyXG4gICAgXCJ0ZW1wbGF0ZVwiLFxyXG4gICAgXCJ0ZXh0YXJlYVwiLFxyXG4gICAgXCJ0aW1lXCIsXHJcbiAgICBcInVcIixcclxuICAgIFwidHRcIixcclxuICAgIFwidmFyXCIsXHJcbiAgICBcInZpZGVvXCIsXHJcbiAgICBcIndiclwiXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgcnVuSW1tZWRpYXRlbHkgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFeGNsdXNpdmVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vZXhjbHVzaXZlLmpzXCI7XG5pbXBvcnQgeyBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCwgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgU3dhcHBhYmxlQ29udGV4dFR5cGUsIFRyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZSwgVHJhbnNpdGlvblN0YXRlLCBVc2VUcmFuc2l0aW9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IFN3YXBwYWJsZUNvbnRleHQgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcblxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0RHVyYXRpb248RSBleHRlbmRzIEhUTUxFbGVtZW50PihlbGVtZW50OiBFIHwgbnVsbCkge1xuICAgIHJldHVybiBNYXRoLm1heCguLi4od2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5nZXRQcm9wZXJ0eVZhbHVlKGB0cmFuc2l0aW9uLWR1cmF0aW9uYCkpLnNwbGl0KFwiLFwiKS5tYXAoc3RyID0+IHtcbiAgICAgICAgaWYgKHN0ci5lbmRzV2l0aChcIm1zXCIpKVxuICAgICAgICAgICAgcmV0dXJuICtzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgICAgaWYgKHN0ci5lbmRzV2l0aChcInNcIikpXG4gICAgICAgICAgICByZXR1cm4gKCtzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gMTAwMDtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhdGUobmV4dFN0YXRlOiBUcmFuc2l0aW9uU3RhdGUpIHtcbiAgICByZXR1cm4gbmV4dFN0YXRlLnNwbGl0KFwiLVwiKSBhcyBbVHJhbnNpdGlvbkRpcmVjdGlvbiwgVHJhbnNpdGlvblBoYXNlXTtcbn1cblxuLyoqXG4gKiBQcm92aWRlIHByb3BzIHRoYXQgY2FuIGJlIHVzZWQgdG8gYW5pbWF0ZSBhIHRyYW5zaXRpb24uXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYW5zaXRpb248RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IHByb3BzSW5jb21pbmc6IHsgY2hpbGRyZW4sIC4uLnAgfSwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIG1lYXN1cmUsIGV4aXRWaXNpYmlsaXR5LCBkdXJhdGlvbiwgZGVsYXlNb3VudFVudGlsU2hvd24sIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgb25WaXNpYmlsaXR5Q2hhbmdlIH0sIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH0gfTogVXNlVHJhbnNpdGlvblBhcmFtZXRlcnM8RT4pOiBWTm9kZTxoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4gfCBudWxsIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VUcmFuc2l0aW9uXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG5cbiAgICBjb25zdCB7IGdldEFuaW1hdGVPbk1vdW50IH0gPSB1c2VDb250ZXh0KFN3YXBwYWJsZUNvbnRleHQpO1xuICAgIGV4aXRWaXNpYmlsaXR5IHx8PSBcImhpZGRlblwiXG4gICAgYW5pbWF0ZU9uTW91bnQgPz89IGdldEFuaW1hdGVPbk1vdW50KCk7XG4gICAgbWVhc3VyZSA/Pz0gZmFsc2U7XG5cbiAgICBjb25zdCBnZXRFeGl0VmlzaWJpbGl0eSA9IHVzZVN0YWJsZUdldHRlcihleGl0VmlzaWJpbGl0eSk7XG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MsIEdldEVudGVyQ2xhc3MsIEdldEV4aXRDbGFzcywgR2V0TWVhc3VyZUNsYXNzLCBHZXRJbml0Q2xhc3MsIEdldFRyYW5zaXRpb25DbGFzcywgR2V0RmluYWxpemVDbGFzcywgR2V0RGlyZWN0aW9uQ2xhc3MsIEdldFBoYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcbiAgICBjb25zdCBnZXRNZWFzdXJlID0gdXNlU3RhYmxlR2V0dGVyKG1lYXN1cmUpO1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlVHJhbnNpdGlvblJldHVybjogeyBleGNsdXNpdmVseU9wZW4sIGlzRXhjbHVzaXZlLCBvblZpc2liaWxpdHlDaGFuZ2U6IGV4Y2x1c2l2ZVRyYW5zaXRpb25WaXNpYmlsaXR5Q2hhbmdlIH0gfSA9IHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBzaG93IH0sXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5LCBmb3JjZUNsb3NlOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IGludGVybmFsT25TaG93Q2hhbmdlZChmYWxzZSwgZ2V0TWVhc3VyZSgpKTsgfSkgfVxuICAgIH0pO1xuXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XG4gICAgICAgIHNob3cgPSAoc2hvdyAmJiBleGNsdXNpdmVseU9wZW4pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50LCBwcm9wc1N0YWJsZSB9IH0gPSB1c2VSZWZFbGVtZW50PEU+KHt9KVxuICAgIGNvbnN0IGNzc1Byb3BlcnRpZXMgPSB1c2VSZWY8aC5KU1guQ1NTUHJvcGVydGllcz4oe30pO1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB1c2VSZWYobmV3IFNldDxzdHJpbmc+KFtcbiAgICAgICAgLy8gVGhpcyBpcyByZW1vdmVkIGR1cmluZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIGZpcnN0IHJlbmRlclxuICAgICAgICAvLyAoYXQgbGVhc3Qgb25jZSBgc2hvd2AgaXMgbm9uLW51bGwpXG4gICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1wZW5kaW5nYCxcbiAgICBdKSk7XG4gICAgY29uc3QgaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCEhc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtkaXJlY3Rpb24sIHBoYXNlXSA9IHBhcnNlU3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHBoYXNlID09IFwidHJhbnNpdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoYCR7ZGlyZWN0aW9ufS1maW5hbGl6ZWApO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQ/Lih0aW1lb3V0SGFuZGxlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcbiAgICBjb25zdCBvdGhlclByb3BzID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pih7XG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZDogKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PSBnZXRFbGVtZW50KCkgJiYgZS5lbGFwc2VkVGltZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGhhc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxlbWVudCdzIENTUyBjbGFzcyB0byBtYXRjaCB0aGUgZ2l2ZW4gZGlyZWN0aW9uIGFuZCBwaGFzZS5cbiAgICAgKi9cbiAgICBjb25zdCB1cGRhdGVDbGFzc2VzID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsLCBkaXJlY3Rpb246IFRyYW5zaXRpb25EaXJlY3Rpb24sIHBoYXNlPzogVHJhbnNpdGlvblBoYXNlKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cblxuICAgICAgICBjb25zdCBleGl0VmlzaWJpbGl0eSA9IGdldEV4aXRWaXNpYmlsaXR5KCk7XG5cbiAgICAgICAgY29uc3QgYWxsQ2xhc3Nlc1RvUmVtb3ZlID0gW1xuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0TWVhc3VyZUNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldEluaXRDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRUcmFuc2l0aW9uQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0RmluYWxpemVDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tJHtHZXRNZWFzdXJlQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tJHtHZXRJbml0Q2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tJHtHZXRUcmFuc2l0aW9uQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tJHtHZXRGaW5hbGl6ZUNsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke1wiaW5lcnRcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJyZW1vdmVkXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke1wiaGlkZGVuXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke1widmlzaWJsZVwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tcGVuZGluZ2AsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgYWxsQ2xhc3Nlc1RvQWRkID0gW1xuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldERpcmVjdGlvbkNsYXNzKGRpcmVjdGlvbil9YCxcbiAgICAgICAgICAgIHBoYXNlID8gYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RGlyZWN0aW9uQ2xhc3MoZGlyZWN0aW9uKX0tJHtHZXRQaGFzZUNsYXNzKHBoYXNlKX1gIDogXCJcIixcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke2V4aXRWaXNpYmlsaXR5fWBcbiAgICAgICAgXTtcblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4uYWxsQ2xhc3Nlc1RvUmVtb3ZlKTtcbiAgICAgICAgYWxsQ2xhc3Nlc1RvUmVtb3ZlLm1hcCh2ID0+IGNsYXNzTmFtZXMuY3VycmVudC5kZWxldGUodikpO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5hbGxDbGFzc2VzVG9BZGQpO1xuICAgICAgICBhbGxDbGFzc2VzVG9BZGQubWFwKHYgPT4gY2xhc3NOYW1lcy5jdXJyZW50LmFkZCh2KSk7XG5cbiAgICB9LCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgc2luZ2xlIFwibWVhc3VyZVwiIHZhcmlhYmxlIChvciByZW1vdmVzIGl0KVxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZVNpemVQcm9wZXJ0eSA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFLCB2YXJOYW1lOiAoa2V5b2YgaC5KU1guQ1NTUHJvcGVydGllcykgJiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGAke3ZhbHVlfXB4YDtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W3Zhck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHZhck5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGNzc1Byb3BlcnRpZXMuY3VycmVudFt2YXJOYW1lXTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIFwibWVhc3VyZVwiIHZhcml1cGRhdGVDbGFzc2VzYWJsZXMgdG8gdGhlIGVsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIGNvbnN0IG1lYXN1cmVFbGVtZW50QW5kVXBkYXRlUHJvcGVydGllcyA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCwgbWVhc3VyZTogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IHNpemU6IERPTVJlY3RSZWFkT25seSB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtdG9wYCwgc2l6ZT8udG9wKTtcbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLWxlZnRgLCBzaXplPy5sZWZ0KTtcbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLXdpZHRoYCwgc2l6ZT8ud2lkdGgpO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtaGVpZ2h0YCwgc2l6ZT8uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFdlIHVzZSBib3RoIHVzZVRpbWVvdXQgYW5kIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgdGltaW5nIGNlcnRhaW4gdGhpbmdzIC0tXG4gICAgLy8gcmFmIGlzIHVzZWQgZm9yIGNoYW5naW5nIGZyb20gaW5pdCB0byB0cmFuc2l0aW9uICh3b3VsZCB1c2UgcXVldWVNaWNyb3Rhc2sgYnV0IGl0IGNhbid0IGJlIGNhbmNlbGxlZClcbiAgICAvLyBzZXRUaW1lb3V0IGlzIHVzZWQgZm9yIGNoYW5naW5nIGZyb20gdHJhbnNpdGlvbiB0byBmaW5hbGl6ZSAoYXMgYSBiYWNrdXAgaW4gY2FzZSB0cmFuc2l0aW9uZW5kIGRvZXNuJ3QgZmlyZSlcbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIHN0YWxlIGNhbGxiYWNrcyBydW5uaW5nIChpLmUuIHdoZW4gd2UgcmFwaWRseSBzd2l0Y2ggYmV0d2VlbiB2aXNpYmxlIGFuZCBub3QpXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgYWNjdXJhdGVseSBjYW5jZWwgYW55dGhpbmcgdGhhdCBjYW4gY2hhbmdlIG91ciBzdGF0ZSBvbiBhIGRlbGF5LlxuICAgIC8vXG4gICAgLy8gQWxzbyBvZiBub3RlLCB3ZSBzdG9yZSBcIihmKSA9PiB3aW5kb3cuY2xlYXJUaW1lb3V0KGYpXCIgaW5zdGVhZCBvZiBqdXN0IFwid2luZG93LmNsZWFyVGltZW91dFwiIGJlY2F1c2VcbiAgICAvLyBvZiB0aGUgaW1wbGljaXQgd2luZG93IG9iamVjdCAtLSBwcm9ibGVtcyB3aXRoIGEgbWlzc2luZyBgdGhpc2Agb2JqZWN0IGFuZCBhbGwgdGhhdCBub25zZW5zZS5cbiAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gdXNlUmVmPG51bWJlcj4oLTEpO1xuICAgIGNvbnN0IHRpbWVvdXRDbGVhckZ1bmN0aW9uID0gdXNlUmVmPCh0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHwgKHR5cGVvZiBjbGVhclRpbWVvdXQpIHwgbnVsbD4obnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgdGltZSB0aGUgc3RhdGUgY2hhbmdlcywgdGhlcmUncyBzb21lIGxvZ2ljIHdlIG5lZWQgdG8gcnVuOlxuICAgICAqIFxuICAgICAqICogSWYgd2UncmUgY2hhbmdpbmcgdG8gYW4gYGluaXRgIHBoYXNlLCB1cGRhdGUgdGhlIGNsYXNzZXMsIHRoZW4gd2FpdCBhIG1vbWVudCBhbmQgdGhlbiBjaGFuZ2UgdG8gdGhlIGB0cmFuc2l0aW9uYCBwaGFzZS5cbiAgICAgKiAqIElmIHdlJ3JlIGNoYW5naW5nIHRvIGEgYHRyYW5zaXRpb25gIHBoYXNlLCB1cGRhdGUgdGhlIGNsYXNzZXMsIHRoZW4gd2FpdCB1bnRpbCB0aGUgdHJhbnNpdGlvbiBjb21wbGV0ZXMsIHRoZW4gY2hhbmdlIHRvIHRoZSBgZmluYWxpemVgIHBoYXNlLlxuICAgICAqIFxuICAgICAqIEFueSBjaGFuZ2UgaW4gc3RhdGUgb3IgY2xhc3Nlcy9zdHlsZXMgZG9lcyBub3QgaW1wbGljaXRseSBjYXVzZSBhIHJlLXJlbmRlci5cbiAgICAgKi9cbiAgICBjb25zdCBvblN0YXRlQ2hhbmdlID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VHJhbnNpdGlvblN0YXRlIHwgbnVsbCwgdW5kZWZpbmVkPj4oKG5leHRTdGF0ZSwgcHJldlN0YXRlLCByZWFzb24pID0+IHtcbiAgICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IFtuZXh0RGlyZWN0aW9uLCBuZXh0UGhhc2VdID0gcGFyc2VTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBubyBzdGFsZSBjaGFuZ2UgY29kZSBldmVyIHJ1bnNcbiAgICAgICAgaWYgKHRpbWVvdXRIYW5kbGUuY3VycmVudCA+PSAwICYmIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQpXG4gICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50KHRpbWVvdXRIYW5kbGUuY3VycmVudCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGluZXJ0IHByb3BzL3Byb3BlcnR5XG4gICAgICAgIGNvbnN0IGV4aXRWaXNpYmlsaXR5ID0gZ2V0RXhpdFZpc2liaWxpdHkoKTtcbiAgICAgICAgaWYgKGV4aXRWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBpbmVydCA9IChleGl0VmlzaWJpbGl0eSA9PSBcImluZXJ0XCIgJiYgKG5leHREaXJlY3Rpb24gPT0gXCJleGl0XCIgJiYgbmV4dFBoYXNlID09IFwiZmluYWxpemVcIikgPyB0cnVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChpbmVydClcbiAgICAgICAgICAgICAgICAob3RoZXJQcm9wcy5jdXJyZW50IGFzIGFueSkuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvdGhlclByb3BzLmN1cnJlbnRbXCJpbmVydFwiIGFzIG5ldmVyXTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbmVydCA9IChpbmVydCB8fCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0JlaW5nUGFpbnRlZCA9IChuZXh0RGlyZWN0aW9uID09IFwiZW50ZXJcIiB8fCAobmV4dERpcmVjdGlvbiA9PSBcImV4aXRcIiAmJiBuZXh0UGhhc2UgIT0gXCJmaW5hbGl6ZVwiKSk7XG4gICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZT8uKGlzQmVpbmdQYWludGVkKTtcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblZpc2liaWxpdHlDaGFuZ2U/Lihpc0JlaW5nUGFpbnRlZCk7XG5cbiAgICAgICAgdXBkYXRlQ2xhc3NlcyhlbGVtZW50LCBuZXh0RGlyZWN0aW9uLCBuZXh0UGhhc2UpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAobmV4dFBoYXNlID09IFwiaW5pdFwiIHx8IG5leHRQaGFzZSA9PSBcInRyYW5zaXRpb25cIikpXG4gICAgICAgICAgICBmb3JjZVJlZmxvdyhlbGVtZW50KTtcblxuXG5cbiAgICAgICAgc3dpdGNoIChuZXh0UGhhc2UpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZWFzdXJlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZUVsZW1lbnRBbmRVcGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vc2V0U3RhdGUoYCR7bmV4dERpcmVjdGlvbn0taW5pdGApO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNsYXNzZXMoZWxlbWVudCwgbmV4dERpcmVjdGlvbiwgXCJpbml0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZmxvdyhlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vICEhSW50ZW50aW9uYWwgZmFsbC10aHJvdWdoISFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbml0XCI6IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyBzZXRTdGF0ZShgJHtuZXh0RGlyZWN0aW9ufS10cmFuc2l0aW9uYCk7IH0pO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQgPSAoZjogbnVtYmVyKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShmKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRyYW5zaXRpb25cIjoge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVUcmFuc2l0aW9uRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBnZXRUaW1lb3V0RHVyYXRpb24oZWxlbWVudCkgKiAxLjUpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQgPSAoZjogbnVtYmVyKSA9PiBjbGVhclRpbWVvdXQoZilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZVwiOiB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyBvciBzY2hlZHVsZSBvciBhbnl0aGluZyAtLSB3ZSBqdXN0IHVwZGF0ZSBvdXIgY2xhc3NlcyBhbmQgd2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50ID0gbnVsbDsgICAgLy8gRG9lcyB0aGlzIG1ha2UgaXQgbW9yZSBvciBsZXNzIGNsZWFyP1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7IC8vIEludGVudGlvbmFsXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEludmFsaWQgc3RhdGUgdXNlZCBpbiB0cmFuc2l0aW9uOiAke25leHRTdGF0ZX0uIFByZXZpb3VzIHN0YXRlIHdhcyAke3ByZXZTdGF0ZSA/PyBcIm51bGxcIn1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuXG4gICAgY29uc3QgW2dldFN0YXRlLCBzZXRTdGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8VHJhbnNpdGlvblN0YXRlIHwgbnVsbCwgdW5kZWZpbmVkPihvblN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG5cbiAgICAvLyBXaGVuIHdlIG1vdW50LCBhbmQgZXZlcnkgdGltZSB0aGVyZWFmdGVyIHRoYXQgYHNob3dgIGNoYW5nZXMsXG4gICAgLy8gY2hhbmdlIG91ciBjdXJyZW50IHN0YXRlIGFjY29yZGluZyB0byB0aGF0IGBzaG93YCB2YWx1ZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gaW50ZXJuYWxPblNob3dDaGFuZ2VkKHNob3csIG1lYXN1cmUpLCBbbWVhc3VyZSwgc2hvd10pO1xuXG5cbiAgICAvLyBUaGlzIGhhcyBubyBkZXBlbmRlbmNlcyBhbmQgaXMgcmVsaWVkIG9uIGluIHR3byBkaWZmZXJlbnQgYXJlYXNcbiAgICBmdW5jdGlvbiBpbnRlcm5hbE9uU2hvd0NoYW5nZWQoc2hvdzogYm9vbGVhbiB8IG51bGwsIG1lYXN1cmU6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBJZiBgc2hvd2AgaXMgbnVsbCwgdGhlbiB3ZSBkb24ndCBjaGFuZ2UgYW55dGhpbmcuXG4gICAgICAgIGlmIChzaG93ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gKElmIGBzaG93YCBpcyB0cnVlL2ZhbHNlLCB3ZSdsbCByZW1vdmUgdGhlIENTUyBjbGFzc2VzIGR1cmluZyBgb25DaGFuZ2VgKVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgIGxldCBuZXh0UGhhc2U6IFRyYW5zaXRpb25QaGFzZSA9IG1lYXN1cmUgPyBcIm1lYXN1cmVcIiA6IFwiaW5pdFwiO1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBbY3VycmVudERpcmVjdGlvbiwgY3VycmVudFBoYXNlXSA9IHBhcnNlU3RhdGUoY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGhhc2UgIT0gXCJmaW5hbGl6ZVwiKVxuICAgICAgICAgICAgICAgIG5leHRQaGFzZSA9IFwidHJhbnNpdGlvblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogdGhlIHNldFN0YXRlIGNoYW5nZSBoYW5kbGVyIHJ1bnMgaW1tZWRpYXRlbHkgd2l0aCBubyBkZWJvdW5jZS5cbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIGlmIChoYXNNb3VudGVkLmN1cnJlbnQgfHwgYW5pbWF0ZU9uTW91bnQpXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoYGVudGVyLSR7bmV4dFBoYXNlfWApO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoXCJlbnRlci1maW5hbGl6ZVwiKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc01vdW50ZWQuY3VycmVudCB8fCBhbmltYXRlT25Nb3VudClcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShgZXhpdC0ke25leHRQaGFzZX1gKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShcImV4aXQtZmluYWxpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkdXJhdGlvbiAhPSBudWxsKVxuICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZHVyYXRpb25gXSA9IGR1cmF0aW9uICsgXCJtc1wiO1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS1kdXJhdGlvbmBdO1xuXG4gICAgZWFzaW5nSW4gPz89IGVhc2luZztcbiAgICBlYXNpbmdPdXQgPz89IGVhc2luZztcblxuICAgIGlmIChlYXNpbmdPdXQgIT0gbnVsbClcbiAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdID0gZWFzaW5nT3V0O1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXTtcblxuXG4gICAgaWYgKGVhc2luZ0luICE9IG51bGwpXG4gICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF0gPSBlYXNpbmdJbjtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdO1xuXG5cblxuICAgIC8vIFRPRE9cbiAgICBjb25zdCBpbmxpbmVEaXJlY3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IGJsb2NrRGlyZWN0aW9uID0gbnVsbDtcblxuXG5cbiAgICAvLyBObyBtYXR0ZXIgd2hhdCBkZWxheU1vdW50VW50aWxTaG93biBpcyxcbiAgICAvLyBvbmNlIHdlJ3ZlIHJlbmRlcmVkIG91ciBjaGlsZHJlbiBvbmNlLCBcbiAgICAvLyBlbnN1cmUgdGhhdCB3ZSBkb24ndCB1bm1vdW50IHRoZW0gYWdhaW4gYW5kIHdhc3RlIGFsbCB0aGF0IHdvcmsuXG4gICAgLy8gKElmIHlvdSByZWFsbHkgbmVlZCB0aGlzIHlvdSBjYW4ganVzdCB1bm1vdW50IHRoZSBlbnRpcmUgdHJhbnNpdGlvbiBpdHNlbGYpXG4gICAgY29uc3QgZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW4gPSAoc2hvdyB8fCAhZGVsYXlNb3VudFVudGlsU2hvd24pO1xuICAgIGNvbnN0IGhhc1JlbmRlcmVkQ2hpbGRyZW4gPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHJlbmRlckNoaWxkcmVuID0gZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW4gfHwgaGFzUmVuZGVyZWRDaGlsZHJlbi5jdXJyZW50O1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbilcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkQ2hpbGRyZW4uY3VycmVudCB8fD0gdHJ1ZTtcbiAgICB9LCBbaGFzUmVuZGVyZWRDaGlsZHJlbi5jdXJyZW50ID8gZmFsc2UgOiBkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbl0pO1xuXG5cbiAgICBjb25zdCBjaGlsZHJlbklzVm5vZGUgPSAoY2hpbGRyZW4gJiYgKGNoaWxkcmVuIGFzIFZOb2RlKS50eXBlICYmIChjaGlsZHJlbiBhcyBWTm9kZSkucHJvcHMpO1xuICAgIGNvbnN0IGZpbmFsUHJvcHMgPSB1c2VNZXJnZWRQcm9wczxFPihwLCBwcm9wc1N0YWJsZSwgb3RoZXJQcm9wcy5jdXJyZW50LCB7XG4gICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgLi4uY2xhc3NOYW1lcy5jdXJyZW50LFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke2V4aXRWaXNpYmlsaXR5fWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0taW5saW5lLWRpcmVjdGlvbi0ke2lubGluZURpcmVjdGlvbiA/PyBcImx0clwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tYmxvY2stZGlyZWN0aW9uLSR7YmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIn1gXG4gICAgICAgIF0uam9pbihcIiBcIiksXG4gICAgICAgIHN0eWxlOiBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRcbiAgICB9LCBjaGlsZHJlbklzVm5vZGUgPyB7IHJlZjogKGNoaWxkcmVuIGFzIFZOb2RlKS5yZWYsIC4uLihjaGlsZHJlbiBhcyBWTm9kZSkucHJvcHMgfSA6IHt9KTtcblxuXG5cbiAgICBjb25zdCByZXNldENvbnRleHQgPSB1c2VSZWY8U3dhcHBhYmxlQ29udGV4dFR5cGU+KHsgZ2V0QW5pbWF0ZU9uTW91bnQ6IHJldHVybkZhbHNlIH0pLmN1cnJlbnQ7XG5cbiAgICBsZXQgbW9kaWZpZWRDaGlsZHJlbjogVk5vZGU7XG5cbiAgICBpZiAoY2hpbGRyZW5Jc1Zub2RlKSB7XG4gICAgICAgIG1vZGlmaWVkQ2hpbGRyZW4gPSA8U3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cmVzZXRDb250ZXh0fT57Y2xvbmVFbGVtZW50KGNoaWxkcmVuIGFzIFZOb2RlLCBmaW5hbFByb3BzKX08L1N3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtb2RpZmllZENoaWxkcmVuID0gPFN3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Jlc2V0Q29udGV4dH0+PHNwYW4gey4uLmZpbmFsUHJvcHMgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pn0+e2NoaWxkcmVufTwvc3Bhbj48L1N3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlckNoaWxkcmVuID8gbW9kaWZpZWRDaGlsZHJlbiA6IG51bGw7XG59XG5cblxuXG5mdW5jdGlvbiBmb3JjZVJlZmxvdzxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KGU6IEUpIHtcblxuICAgIC8vIFRyeSByZWFsbHkgaGFyZCB0byBtYWtlIHN1cmUgdGhpcyBpc24ndCBvcHRpbWl6ZWQgb3V0IGJ5IGFueXRoaW5nLlxuICAgIC8vIFdlIG5lZWQgaXQgZm9yIGl0cyBkb2N1bWVudCByZWZsb3cgc2lkZSBlZmZlY3QuXG4gICAgY29uc3QgcCA9IChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15O1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IGUuc3R5bGUub3BhY2l0eTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IGUuc3R5bGUudHJhbnNmb3JtO1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gcDtcbiAgICByZXR1cm4gZTtcbn1cbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIG1pbmltdW0gb3IgbWF4aW11bSBvcGFjaXR5IHZhbHVlcyB0byB1c2UgZm9yIHRoZSBmYWRlIGVmZmVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgZmFkZVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3BhY2l0eSB0byB1c2Ugd2hlbiBmYWRlZCBvdXQuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZhZGVNaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIGZhZGVkIGluLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmYWRlTWF4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZhZGUgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0ZhZGU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1pbiwgZmFkZU1heCB9IH06IFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1mYWRlYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmFkZS1taW5gXTogKGZhZGVNaW4gPz8gMCksXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mYWRlLW1heGBdOiAoZmFkZU1heCA/PyAxKSxcclxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmFkZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIEZhZGUgZWZmZWN0LlxyXG4gKiBcclxuICogTm90ZSB0aGF0IHdoaWxlIGl0IGlzIGFic29sdXRlbHkgcG9zc2libGUgdG8gd3JhcCBhbm90aGVyIHRyYW5zaXRpb24gd2l0aCBgPEZhZGU+YCxcclxuICogdGhlcmUgd2lsbCBiZSBzb21lIGR1cGxpY2F0ZSBjb2RlIHJ1biBhcyB0d28gYDxUcmFuc2l0aW9uYWJsZT5gIGNvbXBvbmVudHMgZW5kIHVwIG9wZXJhdGluZyBvbiB0aGUgc2FtZSBlbGVtZW50LlxyXG4gKiBJdCdzIGdlbmVyYWxseSByZWNvbW1lbmRlZCB0byBlaXRoZXIgdXNlIHRoZSBjb21wb25lbnRzIHRoYXQgaW5jbHVkZSBhIGNvbWJpbmVkIGZhZGUgZWZmZWN0LFxyXG4gKiBvciBqdXN0IGRpcmVjdGx5IGEgYDxUcmFuc2l0aW9uYWJsZT5gIG9uIHlvdXIgb3duLlxyXG4gKiBcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KHsgcmVmLCAuLi5yZXN0IH0sIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIGNsaXBQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBjbGlwIGFyb3VuZCAod2l0aCBYICYgWSBjb21wb25lbnRzIGlkZW50aWNhbClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwT3JpZ2luOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIGNsaXAgYXJvdW5kIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE9yaWdpbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBjbGlwIGFyb3VuZCAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwT3JpZ2luQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gY2xpcCB0by9mcm9tLCBmcm9tIDAgdG8gMSAod2l0aCBYICYgWSBjb21wb25lbnRzIGlkZW50aWNhbCkuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBNaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gY2xpcCB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE1pbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBjbGlwIHRvL2Zyb20sIGZyb20gMCB0byAxIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwTWluQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNDbGlwPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGNsaXBQYXJhbWV0ZXJzOiB7IGNsaXBNaW4sIGNsaXBNaW5CbG9jaywgY2xpcE1pbklubGluZSwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwT3JpZ2luSW5saW5lIH0gfTogVXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke0dldEJhc2VDbGFzcygpfS1jbGlwYCksXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcC1vcmlnaW4taW5saW5lYF06IChjbGlwT3JpZ2luSW5saW5lID8/IGNsaXBPcmlnaW4gPz8gMC41KSxcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW9yaWdpbi1ibG9ja2BdOiAoY2xpcE9yaWdpbkJsb2NrID8/IGNsaXBPcmlnaW4gPz8gMCksXHJcbiAgICAgICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcC1taW4taW5saW5lYF06IChjbGlwTWluSW5saW5lID8/IGNsaXBNaW4gPz8gMSksXHJcbiAgICAgICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcC1taW4tYmxvY2tgXTogKGNsaXBNaW5CbG9jayA/PyBjbGlwTWluID8/IDApLFxyXG4gICAgICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENsaXBQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFPiwgXCJjbGlwUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IENsaXAgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENsaXA8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENsaXBQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuXHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDbGlwKHsgY2xpcFBhcmFtZXRlcnM6IHsgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2sgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKVxyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0NsaXAsIFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY2xpcC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEZhZGVQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFPiwgXCJjbGlwUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgQ2xpcEZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENsaXBGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkZWxheU1vdW50VW50aWxTaG93biwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZHVyYXRpb24sIGZhZGVNaW4sIGZhZGVNYXgsIHNob3csIGFuaW1hdGVPbk1vdW50LCBjbGlwTWluLCBjbGlwTWluQmxvY2ssIGNsaXBNaW5JbmxpbmUsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5CbG9jaywgY2xpcE9yaWdpbklubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDbGlwRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ2xpcCh7IGNsaXBQYXJhbWV0ZXJzOiB7IGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG5cclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjb2xsYXBzZSBlZmZlY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcblxyXG4gICAgY29sbGFwc2VQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgc21hbGxlc3Qgc2l6ZSB0aGUgY29tcG9uZW50IGNvbGxhcHNlcyB0by5cclxuICAgICAgICAqL1xyXG4gICAgICAgIG1pbkJsb2NrU2l6ZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICogXHJcbiAqIElNUE9SVEFOVDogSWYgdXNlZCBvdXRzaWRlIG9mIGEgYDxDb2xsYXBzZSAvPmAsIHlvdSBtdXN0IGluY2x1ZGUgdGhlIGBtZWFzdXJlYCBwcm9wIG9uIHRoZSBgPFRyYW5zaXRpb25hYmxlPmAgdGhhdCB5b3UgdXNlLlxyXG4gKiBcclxuICogQGV4YW1wbGUgPFRyYW5zaXRpb25hYmxlIG1lYXN1cmUgey4uLnVzZUNyZWF0ZUNvbGxhcHNlUHJvcHMoLi4uKX0gLz5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNDb2xsYXBzZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBjb2xsYXBzZVBhcmFtZXRlcnM6IHsgbWluQmxvY2tTaXplIH0gfTogVXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1jb2xsYXBzZWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNvbGxhcHNlLW1pbi1ibG9ja2BdOiBtaW5CbG9ja1NpemUgPz8gMFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGFwc2VQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RT4sIFwiY29sbGFwc2VQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIENvbGxhcHNlIGVmZmVjdC5cclxuICogXHJcbiAqICpJbXBvcnRhbnQqOiBUaGlzIGNvbXBvbmVudCBpcyAqbm90KiBlZmZpY2llbnQgZm9yIHRoZSBicm93c2VyIHRvIGFuaW1hdGUhIFxyXG4gKiBNYWtlIHN1cmUgeW91IGRvIHRlc3Rpbmcgb24gbG93ZXIgcG93ZXIgZGV2aWNlcywgb3IgcHJlZmVyIGEgbGlnaHRlclxyXG4gKiBhbHRlcm5hdGl2ZSwgbGlrZSBgPENsaXA+YC5cclxuICogXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENvbGxhcHNlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDb2xsYXBzZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgc2hvdywgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZHVyYXRpb24sIGRlbGF5TW91bnRVbnRpbFNob3duLCBtaW5CbG9ja1NpemUsIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENvbGxhcHNlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcblxyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDb2xsYXBzZSh7IGNvbGxhcHNlUGFyYW1ldGVyczogeyBtaW5CbG9ja1NpemUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzQ29sbGFwc2UsIFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVycyB9IGZyb20gXCIuL2NvbGxhcHNlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbGxhcHNlRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RT4sIFwiY29sbGFwc2VQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgQ29sbGFwc2VGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDb2xsYXBzZUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHNob3csIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGR1cmF0aW9uLCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGZhZGVNaW4sIGZhZGVNYXgsIGV4aXRWaXNpYmlsaXR5LCBtaW5CbG9ja1NpemUsIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDb2xsYXBzZUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NvbGxhcHNlKHsgY29sbGFwc2VQYXJhbWV0ZXJzOiB7IG1pbkJsb2NrU2l6ZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYsIHVzZUxhc3ROb25OdWxsVmFsdWUgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBkaXJlY3Rpb24gYW5kIGV4dGVudCBvZiB0aGUgZmxpcCBlZmZlY3QuIFxuICogVmFsdWVzIGFyZSByZWxhdGl2ZSwgd2l0aCAxIG9yIC0xIGJlaW5nIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQgaW4gdGhhdCBkaXJlY3Rpb24uXG4gKiBgMC41YCwgZm9yIGV4YW1wbGUsIHdvdWxkIGZsaXAgdG8gdGhlIHJpZ2h0IGJ5IDUwJSBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc0ZsaXBQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcbiAgICBmbGlwUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhcmdldCBhbmdsZSAoaW4gZGVncmVlcykgdG8gcm90YXRlIHRvd2FyZHMgb24gdGhlIGlubGluZSBheGlzIChYIGF4aXMgZm9yIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXG4gICAgICAgICAqL1xuICAgICAgICBmbGlwQW5nbGVJbmxpbmU6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgYW5nbGUgKGluIGRlZ3JlZXMpIHRvIHJvdGF0ZSB0b3dhcmRzIG9uIHRoZSBibG9jayBheGlzIChYIGF4aXMgZm9yIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXG4gICAgICAgICAqL1xuICAgICAgICBmbGlwQW5nbGVCbG9jazogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2luY2UgdGhpcyBpcyBhIDNEIGVmZmVjdCwgYSBwZXJzcGVjdGl2ZSB2YWx1ZSBpcyBuZWVkZWQuXG4gICAgICAgICAqIEBkZWZhdWx0IDgwMHB4XG4gICAgICAgICAqL1xuICAgICAgICBmbGlwUGVyc3BlY3RpdmU6IHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIEZsaXAgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzRmxpcDxFIGV4dGVuZHMgRWxlbWVudD4oeyBmbGlwUGFyYW1ldGVyczogeyBmbGlwQW5nbGVCbG9jaywgZmxpcEFuZ2xlSW5saW5lLCBmbGlwUGVyc3BlY3RpdmUgfSB9OiBVc2VCYXNlUHJvcHNGbGlwUGFyYW1ldGVyczxFPikge1xuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tZmxpcGAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmxpcC1hbmdsZS1pbmxpbmVgXTogYCR7KHVzZUxhc3ROb25OdWxsVmFsdWUoZmxpcEFuZ2xlSW5saW5lKSA/PyAwKX1kZWdgLFxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZsaXAtYW5nbGUtYmxvY2tgXTogYCR7KHVzZUxhc3ROb25OdWxsVmFsdWUoZmxpcEFuZ2xlQmxvY2spID8/IDApfWRlZ2AsXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tcGVyc3BlY3RpdmVgXTogYCR7KGZsaXBQZXJzcGVjdGl2ZSA/PyA4MDApfXB4YFxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxpcFByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZsaXBQYXJhbWV0ZXJzPEU+LCBcImZsaXBQYXJhbWV0ZXJzXCI+PiB7IH07XG5cbi8qKlxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIEZsaXAgZWZmZWN0LlxuICogXG4gKiBQcm92aWRlIHRoZSBkaXJlY3Rpb24gdGhlIGVsZW1lbnQgd2lsbCB0cmF2ZWwgaW4gd2l0aCBgZmxpcElubGluZWAgYW5kIGBmbGlwQmxvY2tgLFxuICogd2l0aCBgMWAgYmVpbmcgYDEwMCVgIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0LlxuICogXG4gKiBBIHZhbHVlIG9mIGAwYCBpcyBoYW5kbGVkIHNwZWNpYWxseSwgZWZmZWN0aXZlbHkgbWVhbmluZyBcInVzZSB0aGUgbGFzdCBub24temVybyB2YWx1ZVwiLFxuICogZXhjbHVzaXZpdHlLZXkgYWxsb3dzIGZvciBjb252ZW5pZW50IHNldHVwcyBpbnNpZGUgb2YgYSBgU3dhcENvbnRhaW5lcmAgXG4gKiAoYGZsaXBJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKSBcbiAqIFxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXG4gKi9cbmV4cG9ydCBjb25zdCBGbGlwID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBGbGlwPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGZsaXBBbmdsZUlubGluZSwgZmxpcEFuZ2xlQmxvY2ssIGZsaXBQZXJzcGVjdGl2ZSwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogRmxpcFByb3BzPEU+LCByZWY6IFJlZjxFPikge1xuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxuICAgICAgICAgICAgc2hvdyxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICAgICAgZWFzaW5nLFxuICAgICAgICAgICAgZWFzaW5nSW4sXG4gICAgICAgICAgICBlYXNpbmdPdXQsXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGbGlwKHsgZmxpcFBhcmFtZXRlcnM6IHsgZmxpcEFuZ2xlQmxvY2ssIGZsaXBBbmdsZUlubGluZSwgZmxpcFBlcnNwZWN0aXZlIH0gfSksXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcbiAgICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxuICAgIH0pO1xufSkpO1xuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmLCB1c2VMYXN0Tm9uTnVsbFZhbHVlIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgZGlyZWN0aW9uIGFuZCBleHRlbnQgb2YgdGhlIHNsaWRlIGVmZmVjdC4gXHJcbiAqIFZhbHVlcyBhcmUgcmVsYXRpdmUsIHdpdGggMSBvciAtMSBiZWluZyB0aGUgc2l6ZSBvZiB0aGUgY29tcG9uZW50IGluIHRoYXQgZGlyZWN0aW9uLlxyXG4gKiBgMC41YCwgZm9yIGV4YW1wbGUsIHdvdWxkIHNsaWRlIHRvIHRoZSByaWdodCBieSA1MCUgb2YgdGhlIGVsZW1lbnQncyB3aWR0aC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIHNsaWRlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gc2xpZGUgdG8vZnJvbSAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzbGlkZVRhcmdldElubGluZTogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBzbGlkZSB0by9mcm9tIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNsaWRlVGFyZ2V0QmxvY2s6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgU2xpZGUgdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc1NsaWRlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jayB9IH06IFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPikge1xyXG4gICAgc2xpZGVUYXJnZXRJbmxpbmUgPSB1c2VMYXN0Tm9uTnVsbFZhbHVlKHNsaWRlVGFyZ2V0SW5saW5lKTtcclxuICAgIHNsaWRlVGFyZ2V0QmxvY2sgPSB1c2VMYXN0Tm9uTnVsbFZhbHVlKHNsaWRlVGFyZ2V0QmxvY2spO1xyXG5cclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LXNsaWRlYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tc2xpZGUtdGFyZ2V0LWlubGluZWBdOiBgJHsoc2xpZGVUYXJnZXRJbmxpbmUgPz8gMCl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXNsaWRlLXRhcmdldC1ibG9ja2BdOiBgJHsoc2xpZGVUYXJnZXRCbG9jayA/PyAwKX1gXHJcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBTbGlkZSBlZmZlY3QuXHJcbiAqIFxyXG4gKiBQcm92aWRlIHRoZSBkaXJlY3Rpb24gdGhlIGVsZW1lbnQgd2lsbCB0cmF2ZWwgaW4gd2l0aCBgc2xpZGVJbmxpbmVgIGFuZCBgc2xpZGVCbG9ja2AsXHJcbiAqIHdpdGggYDFgIGJlaW5nIGAxMDAlYCBvZiB0aGUgZWxlbWVudCdzIHdpZHRoIG9yIGhlaWdodC5cclxuICogXHJcbiAqIEEgdmFsdWUgb2YgYDBgIGlzIGhhbmRsZWQgc3BlY2lhbGx5LCBlZmZlY3RpdmVseSBtZWFuaW5nIFwidXNlIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlXCIsXHJcbiAqIHdoaWNoIGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgIFxyXG4gKiAoYHNsaWRlSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLikgXHJcbiAqIFxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTbGlkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBvblZpc2liaWxpdHlDaGFuZ2UsIHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIGRlbGF5TW91bnRVbnRpbFNob3duLCAuLi5yZXN0IH06IFNsaWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzU2xpZGUsIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL3NsaWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVGYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGZhZGVNaW4sIGZhZGVNYXgsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogU2xpZGVGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgb3JpZ2luLCBtaW5pbXVtIHNpemUsIGFuZCBkaXJlY3Rpb24gb2YgdGhlIHpvb20gZWZmZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICB6b29tUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSBvdXQgb2YvaW50byAod2l0aCBYICYgWSBjb21wb25lbnRzIGlkZW50aWNhbClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tT3JpZ2luOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gb3V0IG9mL2ludG8gKFggY29tcG9uZW50KVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21PcmlnaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSBvdXQgb2YvaW50byAoWSBjb21wb25lbnQpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU9yaWdpbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIHNocmluayB0by9mcm9tLCBmcm9tIDAgdG8gMSAod2l0aCBYICYgWSBjb21wb25lbnRzIGlkZW50aWNhbCkuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21NaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gc2hyaW5rIHRvL2Zyb20sIGZyb20gMCB0byAxIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tTWluSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIHNocmluayB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU1pbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc1pvb208RSBleHRlbmRzIEVsZW1lbnQ+KHsgem9vbVBhcmFtZXRlcnM6IHsgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2sgfSB9OiBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LXpvb21gLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW9yaWdpbi1pbmxpbmVgXTogYCR7KHpvb21PcmlnaW5JbmxpbmUgPz8gem9vbU9yaWdpbiA/PyAwLjUpfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW9yaWdpbi1ibG9ja2BdOiBgJHsoem9vbU9yaWdpbkJsb2NrID8/IHpvb21PcmlnaW4gPz8gMC41KX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1taW4taW5saW5lYF06IGAkeyh6b29tTWluSW5saW5lID8/IHpvb21NaW4gPz8gMCl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tbWluLWJsb2NrYF06IGAkeyh6b29tTWluQmxvY2sgPz8gem9vbU1pbiA/PyAwKX1gLFxyXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFpvb21Qcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPiwgXCJ6b29tUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBab29tIGVmZmVjdC5cclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgIGBab29tRmFkZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBab29tID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBab29tPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBab29tUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNab29tKHsgem9vbVBhcmFtZXRlcnM6IHsgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbn0pKTtcclxuXHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzU2xpZGUsIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL3NsaWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzWm9vbSwgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnMgfSBmcm9tIFwiLi96b29tLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlWm9vbVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVab29tID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZVpvb208RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBTbGlkZVpvb21Qcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNab29tKHsgem9vbVBhcmFtZXRlcnM6IHsgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1NsaWRlLCBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9zbGlkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1pvb20sIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vem9vbS5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVpvb21GYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPiwgXCJ6b29tUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNsaWRlWm9vbUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlWm9vbUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSwgZmFkZU1heCwgZmFkZU1pbiwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBTbGlkZVpvb21GYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNab29tKHsgem9vbVBhcmFtZXRlcnM6IHsgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1pvb20sIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vem9vbS5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab29tRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPiwgXCJ6b29tUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFpvb21GYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBab29tRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGZhZGVNaW4sIGZhZGVNYXgsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogWm9vbUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNab29tKHsgem9vbVBhcmFtZXRlcnM6IHsgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGV2VG9vbHMoKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1BSRUFDVF9ERVZUT09MU19fKSB7XG5cdFx0d2luZG93Ll9fUFJFQUNUX0RFVlRPT0xTX18uYXR0YWNoUHJlYWN0KCcxMC4xMi4xJywgb3B0aW9ucywge1xuXHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRDb21wb25lbnRcblx0XHR9KTtcblx0fVxufVxuIiwiY29uc3QgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5sZXQgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogUmVzZXQgdGhlIGhpc3Rvcnkgb2Ygd2hpY2ggcHJvcCB0eXBlIHdhcm5pbmdzIGhhdmUgYmVlbiBsb2dnZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldFByb3BXYXJuaW5ncygpIHtcblx0bG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9wcm9wLXR5cGVzL2Jsb2IvbWFzdGVyL2NoZWNrUHJvcFR5cGVzLmpzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhcblx0dHlwZVNwZWNzLFxuXHR2YWx1ZXMsXG5cdGxvY2F0aW9uLFxuXHRjb21wb25lbnROYW1lLFxuXHRnZXRTdGFja1xuKSB7XG5cdE9iamVjdC5rZXlzKHR5cGVTcGVjcykuZm9yRWFjaCh0eXBlU3BlY05hbWUgPT4ge1xuXHRcdGxldCBlcnJvcjtcblx0XHR0cnkge1xuXHRcdFx0ZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXShcblx0XHRcdFx0dmFsdWVzLFxuXHRcdFx0XHR0eXBlU3BlY05hbWUsXG5cdFx0XHRcdGNvbXBvbmVudE5hbWUsXG5cdFx0XHRcdGxvY2F0aW9uLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRSZWFjdFByb3BUeXBlc1NlY3JldFxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRlcnJvciA9IGU7XG5cdFx0fVxuXHRcdGlmIChlcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuXHRcdFx0bG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdGBGYWlsZWQgJHtsb2NhdGlvbn0gdHlwZTogJHtlcnJvci5tZXNzYWdlfSR7KGdldFN0YWNrICYmXG5cdFx0XHRcdFx0YFxcbiR7Z2V0U3RhY2soKX1gKSB8fFxuXHRcdFx0XHRcdCcnfWBcblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcblxuLyoqXG4gKiBHZXQgaHVtYW4gcmVhZGFibGUgbmFtZSBvZiB0aGUgY29tcG9uZW50L2RvbSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZSh2bm9kZSkge1xuXHRpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcblx0XHRyZXR1cm4gJ0ZyYWdtZW50Jztcblx0fSBlbHNlIGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIHZub2RlLnR5cGUuZGlzcGxheU5hbWUgfHwgdm5vZGUudHlwZS5uYW1lO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLnR5cGU7XG5cdH1cblxuXHRyZXR1cm4gJyN0ZXh0Jztcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBgdm5vZGVgIGFuZCBwcmludCBpdFxuICogaW4gZGVidWcgbWVzc2FnZXMuXG4gKi9cbmxldCByZW5kZXJTdGFjayA9IFtdO1xuXG4vKipcbiAqIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXJzLiBBbiBvd25lciBkZXNjcmliZXMgYSBjb21wb25lbnRcbiAqIHdoaWNoIHdhcyByZXNwb25zaWJsZSB0byByZW5kZXIgYSBzcGVjaWZpYyBgdm5vZGVgLiBUaGlzIGV4Y2x1ZGVcbiAqIGNoaWxkcmVuIHRoYXQgYXJlIHBhc3NlZCB2aWEgYHByb3BzLmNoaWxkcmVuYCwgYmVjYXVzZSB0aGV5IGJlbG9uZ1xuICogdG8gdGhlIHBhcmVudCBvd25lci5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IEZvbyA9IHByb3BzID0+IDxkaXY+e3Byb3BzLmNoaWxkcmVufTwvZGl2PiAvLyBkaXYncyBvd25lciBpcyBGb29cbiAqIGNvbnN0IEJhciA9IHByb3BzID0+IHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9vPjxzcGFuIC8+PC9Gb28+IC8vIEZvbydzIG93bmVyIGlzIEJhciwgc3BhbidzIG93bmVyIGlzIEJhclxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RlOiBBIGB2bm9kZWAgbWF5IGJlIGhvaXN0ZWQgdG8gdGhlIHJvb3Qgc2NvcGUgZHVlIHRvIGNvbXBpbGVyXG4gKiBvcHRpbWl6dGlvbnMuIEluIHRoZXNlIGNhc2VzIHRoZSBgX293bmVyYCB3aWxsIGJlIGRpZmZlcmVudC5cbiAqL1xubGV0IG93bmVyU3RhY2sgPSBbXTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBgdm5vZGVgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFZOb2RlKCkge1xuXHRyZXR1cm4gcmVuZGVyU3RhY2subGVuZ3RoID4gMCA/IHJlbmRlclN0YWNrW3JlbmRlclN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBJZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgYEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXJlYWN0LWpzeC1zb3VyY2VgXG4gKiBzb21ld2hlcmUgaW4gaGlzIHRvb2wgY2hhaW4gd2UgY2FuJ3QgcHJpbnQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2VcbiAqIGxvY2F0aW9uIG9mIGEgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UganVzdCBvbWl0IHRoYXQsIGJ1dCB3ZSdsbFxuICogcHJpbnQgYSBoZWxwZnVsIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUsIG5vdGlmeWluZyB0aGUgdXNlciBvZiBpdC5cbiAqL1xubGV0IGhhc0JhYmVsUGx1Z2luID0gZmFsc2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBgdm5vZGVgIGlzIGEgcG9zc2libGUgb3duZXIuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBpc1Bvc3NpYmxlT3duZXIodm5vZGUpIHtcblx0cmV0dXJuIHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgJiYgdm5vZGUudHlwZSAhPSBGcmFnbWVudDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbXBvbmVudCBzdGFjayB0aGF0IHdhcyBjYXB0dXJlZCB1cCB0byB0aGlzIHBvaW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lclN0YWNrKHZub2RlKSB7XG5cdGNvbnN0IHN0YWNrID0gW3Zub2RlXTtcblx0bGV0IG5leHQgPSB2bm9kZTtcblx0d2hpbGUgKG5leHQuX293bmVyICE9IG51bGwpIHtcblx0XHRzdGFjay5wdXNoKG5leHQuX293bmVyKTtcblx0XHRuZXh0ID0gbmV4dC5fb3duZXI7XG5cdH1cblxuXHRyZXR1cm4gc3RhY2sucmVkdWNlKChhY2MsIG93bmVyKSA9PiB7XG5cdFx0YWNjICs9IGAgIGluICR7Z2V0RGlzcGxheU5hbWUob3duZXIpfWA7XG5cblx0XHRjb25zdCBzb3VyY2UgPSBvd25lci5fX3NvdXJjZTtcblx0XHRpZiAoc291cmNlKSB7XG5cdFx0XHRhY2MgKz0gYCAoYXQgJHtzb3VyY2UuZmlsZU5hbWV9OiR7c291cmNlLmxpbmVOdW1iZXJ9KWA7XG5cdFx0fSBlbHNlIGlmICghaGFzQmFiZWxQbHVnaW4pIHtcblx0XHRcdGhhc0JhYmVsUGx1Z2luID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0J0FkZCBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gtc291cmNlIHRvIGdldCBhIG1vcmUgZGV0YWlsZWQgY29tcG9uZW50IHN0YWNrLiBOb3RlIHRoYXQgeW91IHNob3VsZCBub3QgYWRkIGl0IHRvIHByb2R1Y3Rpb24gYnVpbGRzIG9mIHlvdXIgQXBwIGZvciBidW5kbGUgc2l6ZSByZWFzb25zLidcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChhY2MgKz0gJ1xcbicpO1xuXHR9LCAnJyk7XG59XG5cbi8qKlxuICogU2V0dXAgY29kZSB0byBjYXB0dXJlIHRoZSBjb21wb25lbnQgdHJhY2Ugd2hpbGUgcmVuZGVyaW5nLiBOb3RlIHRoYXRcbiAqIHdlIGNhbm5vdCBzaW1wbHkgdHJhdmVyc2UgYHZub2RlLl9wYXJlbnRgIHVwd2FyZHMsIGJlY2F1c2Ugd2UgaGF2ZSBzb21lXG4gKiBkZWJ1ZyBtZXNzYWdlcyBmb3IgYHRoaXMuc2V0U3RhdGVgIHdoZXJlIHRoZSBgdm5vZGVgIGlzIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBDb21wb25lbnRTdGFjaygpIHtcblx0bGV0IG9sZERpZmYgPSBvcHRpb25zLl9kaWZmO1xuXHRsZXQgb2xkRGlmZmVkID0gb3B0aW9ucy5kaWZmZWQ7XG5cdGxldCBvbGRSb290ID0gb3B0aW9ucy5fcm9vdDtcblx0bGV0IG9sZFZOb2RlID0gb3B0aW9ucy52bm9kZTtcblx0bGV0IG9sZFJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcblxuXHRvcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0XHRpZiAoaXNQb3NzaWJsZU93bmVyKHZub2RlKSkge1xuXHRcdFx0b3duZXJTdGFjay5wb3AoKTtcblx0XHR9XG5cdFx0cmVuZGVyU3RhY2sucG9wKCk7XG5cdFx0aWYgKG9sZERpZmZlZCkgb2xkRGlmZmVkKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRcdGlmIChpc1Bvc3NpYmxlT3duZXIodm5vZGUpKSB7XG5cdFx0XHRyZW5kZXJTdGFjay5wdXNoKHZub2RlKTtcblx0XHR9XG5cdFx0aWYgKG9sZERpZmYpIG9sZERpZmYodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX3Jvb3QgPSAodm5vZGUsIHBhcmVudCkgPT4ge1xuXHRcdG93bmVyU3RhY2sgPSBbXTtcblx0XHRpZiAob2xkUm9vdCkgb2xkUm9vdCh2bm9kZSwgcGFyZW50KTtcblx0fTtcblxuXHRvcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRcdHZub2RlLl9vd25lciA9XG5cdFx0XHRvd25lclN0YWNrLmxlbmd0aCA+IDAgPyBvd25lclN0YWNrW293bmVyU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuXHRcdGlmIChvbGRWTm9kZSkgb2xkVk5vZGUodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0XHRpZiAoaXNQb3NzaWJsZU93bmVyKHZub2RlKSkge1xuXHRcdFx0b3duZXJTdGFjay5wdXNoKHZub2RlKTtcblx0XHR9XG5cblx0XHRpZiAob2xkUmVuZGVyKSBvbGRSZW5kZXIodm5vZGUpO1xuXHR9O1xufVxuIiwiaW1wb3J0IHsgY2hlY2tQcm9wVHlwZXMgfSBmcm9tICcuL2NoZWNrLXByb3BzJztcbmltcG9ydCB7IG9wdGlvbnMsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQge1xuXHRFTEVNRU5UX05PREUsXG5cdERPQ1VNRU5UX05PREUsXG5cdERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0Z2V0T3duZXJTdGFjayxcblx0c2V0dXBDb21wb25lbnRTdGFjayxcblx0Z2V0Q3VycmVudFZOb2RlLFxuXHRnZXREaXNwbGF5TmFtZVxufSBmcm9tICcuL2NvbXBvbmVudC1zdGFjayc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBpc1dlYWtNYXBTdXBwb3J0ZWQgPSB0eXBlb2YgV2Vha01hcCA9PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBnZXRDbG9zZXN0RG9tTm9kZVBhcmVudChwYXJlbnQpIHtcblx0aWYgKCFwYXJlbnQpIHJldHVybiB7fTtcblx0aWYgKHR5cGVvZiBwYXJlbnQudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGdldENsb3Nlc3REb21Ob2RlUGFyZW50KHBhcmVudC5fcGFyZW50KTtcblx0fVxuXHRyZXR1cm4gcGFyZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdERlYnVnKCkge1xuXHRzZXR1cENvbXBvbmVudFN0YWNrKCk7XG5cblx0bGV0IGhvb2tzQWxsb3dlZCA9IGZhbHNlO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0bGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xuXHRsZXQgb2xkRGlmZmVkID0gb3B0aW9ucy5kaWZmZWQ7XG5cdGxldCBvbGRWbm9kZSA9IG9wdGlvbnMudm5vZGU7XG5cdGxldCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcblx0bGV0IG9sZFJvb3QgPSBvcHRpb25zLl9yb290O1xuXHRsZXQgb2xkSG9vayA9IG9wdGlvbnMuX2hvb2s7XG5cdGNvbnN0IHdhcm5lZENvbXBvbmVudHMgPSAhaXNXZWFrTWFwU3VwcG9ydGVkXG5cdFx0PyBudWxsXG5cdFx0OiB7XG5cdFx0XHRcdHVzZUVmZmVjdDogbmV3IFdlYWtNYXAoKSxcblx0XHRcdFx0dXNlTGF5b3V0RWZmZWN0OiBuZXcgV2Vha01hcCgpLFxuXHRcdFx0XHRsYXp5UHJvcFR5cGVzOiBuZXcgV2Vha01hcCgpXG5cdFx0ICB9O1xuXHRjb25zdCBkZXByZWNhdGlvbnMgPSBbXTtcblxuXHRvcHRpb25zLl9jYXRjaEVycm9yID0gKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykgPT4ge1xuXHRcdGxldCBjb21wb25lbnQgPSB2bm9kZSAmJiB2bm9kZS5fY29tcG9uZW50O1xuXHRcdGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGVycm9yLnRoZW4gPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29uc3QgcHJvbWlzZSA9IGVycm9yO1xuXHRcdFx0ZXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdGBNaXNzaW5nIFN1c3BlbnNlLiBUaGUgdGhyb3dpbmcgY29tcG9uZW50IHdhczogJHtnZXREaXNwbGF5TmFtZSh2bm9kZSl9YFxuXHRcdFx0KTtcblxuXHRcdFx0bGV0IHBhcmVudCA9IHZub2RlO1xuXHRcdFx0Zm9yICg7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdFx0aWYgKHBhcmVudC5fY29tcG9uZW50ICYmIHBhcmVudC5fY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0XHRlcnJvciA9IHByb21pc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgaGF2ZW4ndCByZWNvdmVyZWQgYW5kIHdlIGtub3cgYXQgdGhpcyBwb2ludCB0aGF0IHRoZXJlIGlzIG5vXG5cdFx0XHQvLyBTdXNwZW5zZSBjb21wb25lbnQgaGlnaGVyIHVwIGluIHRoZSB0cmVlXG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0ZXJyb3JJbmZvID0gZXJyb3JJbmZvIHx8IHt9O1xuXHRcdFx0ZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID0gZ2V0T3duZXJTdGFjayh2bm9kZSk7XG5cdFx0XHRvbGRDYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbyk7XG5cblx0XHRcdC8vIHdoZW4gYW4gZXJyb3Igd2FzIGhhbmRsZWQgYnkgYW4gRXJyb3JCb3VuZGFyeSB3ZSB3aWxsIG5vbmV0aGVsZXNzIGVtaXQgYW4gZXJyb3Jcblx0XHRcdC8vIGV2ZW50IG9uIHRoZSB3aW5kb3cgb2JqZWN0LiBUaGlzIGlzIHRvIG1ha2UgdXAgZm9yIHJlYWN0IGNvbXBhdGliaWxpdHkgaW4gZGV2IG1vZGVcblx0XHRcdC8vIGFuZCB0aHVzIG1ha2UgdGhlIE5leHQuanMgZGV2IG92ZXJsYXkgd29yay5cblx0XHRcdGlmICh0eXBlb2YgZXJyb3IudGhlbiAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fTtcblxuXHRvcHRpb25zLl9yb290ID0gKHZub2RlLCBwYXJlbnROb2RlKSA9PiB7XG5cdFx0aWYgKCFwYXJlbnROb2RlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdVbmRlZmluZWQgcGFyZW50IHBhc3NlZCB0byByZW5kZXIoKSwgdGhpcyBpcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxcbicgK1xuXHRcdFx0XHRcdCdDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhdmFpbGFibGUgaW4gdGhlIERPTS9oYXMgdGhlIGNvcnJlY3QgaWQuJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRsZXQgaXNWYWxpZDtcblx0XHRzd2l0Y2ggKHBhcmVudE5vZGUubm9kZVR5cGUpIHtcblx0XHRcdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdFx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdFx0Y2FzZSBET0NVTUVOVF9OT0RFOlxuXHRcdFx0XHRpc1ZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpc1ZhbGlkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1ZhbGlkKSB7XG5cdFx0XHRsZXQgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lKHZub2RlKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YEV4cGVjdGVkIGEgdmFsaWQgSFRNTCBub2RlIGFzIGEgc2Vjb25kIGFyZ3VtZW50IHRvIHJlbmRlci5cdFJlY2VpdmVkICR7cGFyZW50Tm9kZX0gaW5zdGVhZDogcmVuZGVyKDwke2NvbXBvbmVudE5hbWV9IC8+LCAke3BhcmVudE5vZGV9KTtgXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRSb290KSBvbGRSb290KHZub2RlLCBwYXJlbnROb2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRcdGxldCB7IHR5cGUsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdm5vZGU7XG5cdFx0bGV0IHBhcmVudFZOb2RlID0gZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQocGFyZW50KTtcblxuXHRcdGhvb2tzQWxsb3dlZCA9IHRydWU7XG5cblx0XHRpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdVbmRlZmluZWQgY29tcG9uZW50IHBhc3NlZCB0byBjcmVhdGVFbGVtZW50KClcXG5cXG4nICtcblx0XHRcdFx0XHQnWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IG9yIG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cycgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlb2YgdHlwZSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKHR5cGUuX2NoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgdHlwZS5fZG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdGBJbnZhbGlkIHR5cGUgcGFzc2VkIHRvIGNyZWF0ZUVsZW1lbnQoKTogJHt0eXBlfVxcblxcbmAgK1xuXHRcdFx0XHRcdFx0J0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBKU1ggbGl0ZXJhbCBhcyBKU1ggdHdpY2U/XFxuXFxuJyArXG5cdFx0XHRcdFx0XHRgICBsZXQgTXkke2dldERpc3BsYXlOYW1lKHZub2RlKX0gPSAke3NlcmlhbGl6ZVZOb2RlKHR5cGUpfTtcXG5gICtcblx0XHRcdFx0XHRcdGAgIGxldCB2bm9kZSA9IDxNeSR7Z2V0RGlzcGxheU5hbWUodm5vZGUpfSAvPjtcXG5cXG5gICtcblx0XHRcdFx0XHRcdCdUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIHlvdSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBhbmQgbm90IHRoZSBjb21wb25lbnQuJyArXG5cdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0ludmFsaWQgdHlwZSBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCgpOiAnICtcblx0XHRcdFx0XHQoQXJyYXkuaXNBcnJheSh0eXBlKSA/ICdhcnJheScgOiB0eXBlKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQodHlwZSA9PT0gJ3RoZWFkJyB8fCB0eXBlID09PSAndGZvb3QnIHx8IHR5cGUgPT09ICd0Ym9keScpICYmXG5cdFx0XHRwYXJlbnRWTm9kZS50eXBlICE9PSAndGFibGUnXG5cdFx0KSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHQnSW1wcm9wZXIgbmVzdGluZyBvZiB0YWJsZS4gWW91ciA8dGhlYWQvdGJvZHkvdGZvb3Q+IHNob3VsZCBoYXZlIGEgPHRhYmxlPiBwYXJlbnQuJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHR0eXBlID09PSAndHInICYmXG5cdFx0XHRwYXJlbnRWTm9kZS50eXBlICE9PSAndGhlYWQnICYmXG5cdFx0XHRwYXJlbnRWTm9kZS50eXBlICE9PSAndGZvb3QnICYmXG5cdFx0XHRwYXJlbnRWTm9kZS50eXBlICE9PSAndGJvZHknICYmXG5cdFx0XHRwYXJlbnRWTm9kZS50eXBlICE9PSAndGFibGUnXG5cdFx0KSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHQnSW1wcm9wZXIgbmVzdGluZyBvZiB0YWJsZS4gWW91ciA8dHI+IHNob3VsZCBoYXZlIGEgPHRoZWFkL3Rib2R5L3Rmb290L3RhYmxlPiBwYXJlbnQuJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RkJyAmJiBwYXJlbnRWTm9kZS50eXBlICE9PSAndHInKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHQnSW1wcm9wZXIgbmVzdGluZyBvZiB0YWJsZS4gWW91ciA8dGQ+IHNob3VsZCBoYXZlIGEgPHRyPiBwYXJlbnQuJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RoJyAmJiBwYXJlbnRWTm9kZS50eXBlICE9PSAndHInKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHQnSW1wcm9wZXIgbmVzdGluZyBvZiB0YWJsZS4gWW91ciA8dGg+IHNob3VsZCBoYXZlIGEgPHRyPi4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0dm5vZGUucmVmICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdHR5cGVvZiB2bm9kZS5yZWYgIT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIHZub2RlLnJlZiAhPSAnb2JqZWN0JyAmJlxuXHRcdFx0ISgnJCR0eXBlb2YnIGluIHZub2RlKSAvLyBhbGxvdyBzdHJpbmcgcmVmcyB3aGVuIHByZWFjdC1jb21wYXQgaXMgaW5zdGFsbGVkXG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDb21wb25lbnQncyBcInJlZlwiIHByb3BlcnR5IHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBvciBhbiBvYmplY3QgY3JlYXRlZCBgICtcblx0XHRcdFx0XHRgYnkgY3JlYXRlUmVmKCksIGJ1dCBnb3QgWyR7dHlwZW9mIHZub2RlLnJlZn1dIGluc3RlYWRcXG5gICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB2bm9kZS5wcm9wcykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0a2V5WzBdID09PSAnbycgJiZcblx0XHRcdFx0XHRrZXlbMV0gPT09ICduJyAmJlxuXHRcdFx0XHRcdHR5cGVvZiB2bm9kZS5wcm9wc1trZXldICE9ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0XHR2bm9kZS5wcm9wc1trZXldICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0YENvbXBvbmVudCdzIFwiJHtrZXl9XCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgZnVuY3Rpb24sIGAgK1xuXHRcdFx0XHRcdFx0XHRgYnV0IGdvdCBbJHt0eXBlb2Ygdm5vZGUucHJvcHNba2V5XX1dIGluc3RlYWRcXG5gICtcblx0XHRcdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBwcm9wLXR5cGVzIGlmIGF2YWlsYWJsZVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmIHZub2RlLnR5cGUucHJvcFR5cGVzKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHZub2RlLnR5cGUuZGlzcGxheU5hbWUgPT09ICdMYXp5JyAmJlxuXHRcdFx0XHR3YXJuZWRDb21wb25lbnRzICYmXG5cdFx0XHRcdCF3YXJuZWRDb21wb25lbnRzLmxhenlQcm9wVHlwZXMuaGFzKHZub2RlLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3QgbSA9XG5cdFx0XHRcdFx0J1Byb3BUeXBlcyBhcmUgbm90IHN1cHBvcnRlZCBvbiBsYXp5KCkuIFVzZSBwcm9wVHlwZXMgb24gdGhlIHdyYXBwZWQgY29tcG9uZW50IGl0c2VsZi4gJztcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBsYXp5Vk5vZGUgPSB2bm9kZS50eXBlKCk7XG5cdFx0XHRcdFx0d2FybmVkQ29tcG9uZW50cy5sYXp5UHJvcFR5cGVzLnNldCh2bm9kZS50eXBlLCB0cnVlKTtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRtICsgYENvbXBvbmVudCB3cmFwcGVkIGluIGxhenkoKSBpcyAke2dldERpc3BsYXlOYW1lKGxhenlWTm9kZSl9YFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKHByb21pc2UpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0XHRtICsgXCJXZSB3aWxsIGxvZyB0aGUgd3JhcHBlZCBjb21wb25lbnQncyBuYW1lIG9uY2UgaXQgaXMgbG9hZGVkLlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgdmFsdWVzID0gdm5vZGUucHJvcHM7XG5cdFx0XHRpZiAodm5vZGUudHlwZS5fZm9yd2FyZGVkKSB7XG5cdFx0XHRcdHZhbHVlcyA9IGFzc2lnbih7fSwgdmFsdWVzKTtcblx0XHRcdFx0ZGVsZXRlIHZhbHVlcy5yZWY7XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrUHJvcFR5cGVzKFxuXHRcdFx0XHR2bm9kZS50eXBlLnByb3BUeXBlcyxcblx0XHRcdFx0dmFsdWVzLFxuXHRcdFx0XHQncHJvcCcsXG5cdFx0XHRcdGdldERpc3BsYXlOYW1lKHZub2RlKSxcblx0XHRcdFx0KCkgPT4gZ2V0T3duZXJTdGFjayh2bm9kZSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZEJlZm9yZURpZmYpIG9sZEJlZm9yZURpZmYodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX2hvb2sgPSAoY29tcCwgaW5kZXgsIHR5cGUpID0+IHtcblx0XHRpZiAoIWNvbXAgfHwgIWhvb2tzQWxsb3dlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdIb29rIGNhbiBvbmx5IGJlIGludm9rZWQgZnJvbSByZW5kZXIgbWV0aG9kcy4nKTtcblx0XHR9XG5cblx0XHRpZiAob2xkSG9vaykgb2xkSG9vayhjb21wLCBpbmRleCwgdHlwZSk7XG5cdH07XG5cblx0Ly8gSWRlYWxseSB3ZSdkIHdhbnQgdG8gcHJpbnQgYSB3YXJuaW5nIG9uY2UgcGVyIGNvbXBvbmVudCwgYnV0IHdlXG5cdC8vIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZSB2bm9kZSB0aGF0IHRyaWdnZXJlZCBpdCBoZXJlLiBBcyBhXG5cdC8vIGNvbXByb21pc2UgYW5kIHRvIGF2b2lkIGZsb29kaW5nIHRoZSBjb25zb2xlIHdpdGggd2FybmluZ3Mgd2Vcblx0Ly8gcHJpbnQgZWFjaCBkZXByZWNhdGlvbiB3YXJuaW5nIG9ubHkgb25jZS5cblx0Y29uc3Qgd2FybiA9IChwcm9wZXJ0eSwgbWVzc2FnZSkgPT4gKHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBrZXkgPSAnZ2V0JyArIHByb3BlcnR5ICsgbWVzc2FnZTtcblx0XHRcdGlmIChkZXByZWNhdGlvbnMgJiYgZGVwcmVjYXRpb25zLmluZGV4T2Yoa2V5KSA8IDApIHtcblx0XHRcdFx0ZGVwcmVjYXRpb25zLnB1c2goa2V5KTtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBnZXR0aW5nIHZub2RlLiR7cHJvcGVydHl9IGlzIGRlcHJlY2F0ZWQsICR7bWVzc2FnZX1gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldCgpIHtcblx0XHRcdGNvbnN0IGtleSA9ICdzZXQnICsgcHJvcGVydHkgKyBtZXNzYWdlO1xuXHRcdFx0aWYgKGRlcHJlY2F0aW9ucyAmJiBkZXByZWNhdGlvbnMuaW5kZXhPZihrZXkpIDwgMCkge1xuXHRcdFx0XHRkZXByZWNhdGlvbnMucHVzaChrZXkpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYHNldHRpbmcgdm5vZGUuJHtwcm9wZXJ0eX0gaXMgbm90IGFsbG93ZWQsICR7bWVzc2FnZX1gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGNvbnN0IGRlcHJlY2F0ZWRBdHRyaWJ1dGVzID0ge1xuXHRcdG5vZGVOYW1lOiB3YXJuKCdub2RlTmFtZScsICd1c2Ugdm5vZGUudHlwZScpLFxuXHRcdGF0dHJpYnV0ZXM6IHdhcm4oJ2F0dHJpYnV0ZXMnLCAndXNlIHZub2RlLnByb3BzJyksXG5cdFx0Y2hpbGRyZW46IHdhcm4oJ2NoaWxkcmVuJywgJ3VzZSB2bm9kZS5wcm9wcy5jaGlsZHJlbicpXG5cdH07XG5cblx0Y29uc3QgZGVwcmVjYXRlZFByb3RvID0gT2JqZWN0LmNyZWF0ZSh7fSwgZGVwcmVjYXRlZEF0dHJpYnV0ZXMpO1xuXG5cdG9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdFx0Y29uc3QgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0XHRpZiAoXG5cdFx0XHR2bm9kZS50eXBlICE9PSBudWxsICYmXG5cdFx0XHRwcm9wcyAhPSBudWxsICYmXG5cdFx0XHQoJ19fc291cmNlJyBpbiBwcm9wcyB8fCAnX19zZWxmJyBpbiBwcm9wcylcblx0XHQpIHtcblx0XHRcdGNvbnN0IG5ld1Byb3BzID0gKHZub2RlLnByb3BzID0ge30pO1xuXHRcdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0XHRjb25zdCB2ID0gcHJvcHNbaV07XG5cdFx0XHRcdGlmIChpID09PSAnX19zb3VyY2UnKSB2bm9kZS5fX3NvdXJjZSA9IHY7XG5cdFx0XHRcdGVsc2UgaWYgKGkgPT09ICdfX3NlbGYnKSB2bm9kZS5fX3NlbGYgPSB2O1xuXHRcdFx0XHRlbHNlIG5ld1Byb3BzW2ldID0gdjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0XHR2bm9kZS5fX3Byb3RvX18gPSBkZXByZWNhdGVkUHJvdG87XG5cdFx0aWYgKG9sZFZub2RlKSBvbGRWbm9kZSh2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5kaWZmZWQgPSB2bm9kZSA9PiB7XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHVzZXIgcGFzc2VkIHBsYWluIG9iamVjdHMgYXMgY2hpbGRyZW4uIE5vdGUgdGhhdCB3ZSBjYW5ub3Rcblx0XHQvLyBtb3ZlIHRoaXMgY2hlY2sgaW50byBgb3B0aW9ucy52bm9kZWAgYmVjYXVzZSBjb21wb25lbnRzIGNhbiByZWNlaXZlXG5cdFx0Ly8gY2hpbGRyZW4gaW4gYW55IHNoYXBlIHRoZXkgd2FudCAoZS5nLlxuXHRcdC8vIGA8TXlKU09ORm9ybWF0dGVyPnt7IGZvbzogMTIzLCBiYXI6IFwiYWJjXCIgfX08L015SlNPTkZvcm1hdHRlcj5gKS5cblx0XHQvLyBQdXR0aW5nIHRoaXMgY2hlY2sgaW4gYG9wdGlvbnMuZGlmZmVkYCBlbnN1cmVzIHRoYXRcblx0XHQvLyBgdm5vZGUuX2NoaWxkcmVuYCBpcyBzZXQgYW5kIHRoYXQgd2Ugb25seSB2YWxpZGF0ZSB0aGUgY2hpbGRyZW5cblx0XHQvLyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWQuXG5cdFx0aWYgKHZub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZCAmJiBjaGlsZC50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hpbGQpLmpvaW4oJywnKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRgT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgY2hpbGQuIEVuY291bnRlcmVkIGFuIG9iamVjdCB3aXRoIHRoZSBrZXlzIHske2tleXN9fS5gICtcblx0XHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGhvb2tzQWxsb3dlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKG9sZERpZmZlZCkgb2xkRGlmZmVkKHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Y29uc3Qga2V5cyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmICghY2hpbGQgfHwgY2hpbGQua2V5ID09IG51bGwpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IGNoaWxkLmtleTtcblx0XHRcdFx0aWYgKGtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFx0XHQnRm9sbG93aW5nIGNvbXBvbmVudCBoYXMgdHdvIG9yIG1vcmUgY2hpbGRyZW4gd2l0aCB0aGUgJyArXG5cdFx0XHRcdFx0XHRcdGBzYW1lIGtleSBhdHRyaWJ1dGU6IFwiJHtrZXl9XCIuIFRoaXMgbWF5IGNhdXNlIGdsaXRjaGVzIGFuZCBtaXNiZWhhdmlvciBgICtcblx0XHRcdFx0XHRcdFx0J2luIHJlbmRlcmluZyBwcm9jZXNzLiBDb21wb25lbnQ6IFxcblxcbicgK1xuXHRcdFx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIEJyZWFrIGVhcmx5IHRvIG5vdCBzcGFtIHRoZSBjb25zb2xlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmNvbnN0IHNldFN0YXRlID0gQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZTtcbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbih1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSA9PSBudWxsKSB7XG5cdFx0Ly8gYHRoaXMuX3Zub2RlYCB3aWxsIGJlIGBudWxsYCBkdXJpbmcgY29tcG9uZW50V2lsbE1vdW50LiBCdXQgaXRcblx0XHQvLyBpcyBwZXJmZWN0bHkgdmFsaWQgdG8gY2FsbCBgc2V0U3RhdGVgIGR1cmluZyBjV00uIFNvIHdlXG5cdFx0Ly8gbmVlZCBhbiBhZGRpdGlvbmFsIGNoZWNrIHRvIHZlcmlmeSB0aGF0IHdlIGFyZSBkZWFsaW5nIHdpdGggYVxuXHRcdC8vIGNhbGwgaW5zaWRlIGNvbnN0cnVjdG9yLlxuXHRcdGlmICh0aGlzLnN0YXRlID09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0YENhbGxpbmcgXCJ0aGlzLnNldFN0YXRlXCIgaW5zaWRlIHRoZSBjb25zdHJ1Y3RvciBvZiBhIGNvbXBvbmVudCBpcyBhIGAgK1xuXHRcdFx0XHRcdGBuby1vcCBhbmQgbWlnaHQgYmUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gSW5zdGVhZCwgc2V0IGAgK1xuXHRcdFx0XHRcdGBcInRoaXMuc3RhdGUgPSB7fVwiIGRpcmVjdGx5LlxcblxcbiR7Z2V0T3duZXJTdGFjayhnZXRDdXJyZW50Vk5vZGUoKSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc2V0U3RhdGUuY2FsbCh0aGlzLCB1cGRhdGUsIGNhbGxiYWNrKTtcbn07XG5cbmNvbnN0IGZvcmNlVXBkYXRlID0gQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZTtcbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUgPT0gbnVsbCkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGBDYWxsaW5nIFwidGhpcy5mb3JjZVVwZGF0ZVwiIGluc2lkZSB0aGUgY29uc3RydWN0b3Igb2YgYSBjb21wb25lbnQgaXMgYSBgICtcblx0XHRcdFx0YG5vLW9wIGFuZCBtaWdodCBiZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxcblxcbiR7Z2V0T3duZXJTdGFjayhcblx0XHRcdFx0XHRnZXRDdXJyZW50Vk5vZGUoKVxuXHRcdFx0XHQpfWBcblx0XHQpO1xuXHR9IGVsc2UgaWYgKHRoaXMuX3BhcmVudERvbSA9PSBudWxsKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YENhbid0IGNhbGwgXCJ0aGlzLmZvcmNlVXBkYXRlXCIgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLCBgICtcblx0XHRcdFx0YGJ1dCBpdCBpbmRpY2F0ZXMgYSBtZW1vcnkgbGVhayBpbiB5b3VyIGFwcGxpY2F0aW9uLiBUbyBmaXgsIGNhbmNlbCBhbGwgYCArXG5cdFx0XHRcdGBzdWJzY3JpcHRpb25zIGFuZCBhc3luY2hyb25vdXMgdGFza3MgaW4gdGhlIGNvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZC5gICtcblx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh0aGlzLl92bm9kZSl9YFxuXHRcdCk7XG5cdH1cblx0cmV0dXJuIGZvcmNlVXBkYXRlLmNhbGwodGhpcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSB2bm9kZSB0cmVlIHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVZOb2RlKHZub2RlKSB7XG5cdGxldCB7IHByb3BzIH0gPSB2bm9kZTtcblx0bGV0IG5hbWUgPSBnZXREaXNwbGF5TmFtZSh2bm9kZSk7XG5cblx0bGV0IGF0dHJzID0gJyc7XG5cdGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcblx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgcHJvcCAhPT0gJ2NoaWxkcmVuJykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbcHJvcF07XG5cblx0XHRcdC8vIElmIGl0IGlzIGFuIG9iamVjdCBidXQgZG9lc24ndCBoYXZlIHRvU3RyaW5nKCksIHVzZSBPYmplY3QudG9TdHJpbmdcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2YWx1ZSA9IGBmdW5jdGlvbiAke3ZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWV9KCkge31gO1xuXHRcdFx0fVxuXG5cdFx0XHR2YWx1ZSA9XG5cdFx0XHRcdE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlICYmICF2YWx1ZS50b1N0cmluZ1xuXHRcdFx0XHRcdD8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxuXHRcdFx0XHRcdDogdmFsdWUgKyAnJztcblxuXHRcdFx0YXR0cnMgKz0gYCAke3Byb3B9PSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cdHJldHVybiBgPCR7bmFtZX0ke2F0dHJzfSR7XG5cdFx0Y2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID8gJz4uLjwvJyArIG5hbWUgKyAnPicgOiAnIC8+J1xuXHR9YDtcbn1cbiIsImV4cG9ydCBjb25zdCBFTEVNRU5UX05PREUgPSAxO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX05PREUgPSA5O1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiIsIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cbiIsImltcG9ydCB7IGluaXREZWJ1ZyB9IGZyb20gJy4vZGVidWcnO1xuaW1wb3J0ICdwcmVhY3QvZGV2dG9vbHMnO1xuXG5pbml0RGVidWcoKTtcblxuZXhwb3J0IHsgcmVzZXRQcm9wV2FybmluZ3MgfSBmcm9tICcuL2NoZWNrLXByb3BzJztcbiIsImltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmVsYXRpdmVseSBsb3ctbGV2ZWwgaG9vayB0aGF0IGFsbG93cyB5b3UgdG8gaW5zcGVjdFxuICogd2hlbiB0aGUgZW50aXJlIFVSTCBjaGFuZ2VzLCBlaXRoZXIgYmVjYXVzZSB0aGUgaGFzaCBjaGFuZ2VkLFxuICogb3IgYmVjYXVzZSB0aGUgQmFjay9Gb3J3YXJkIGJyb3dzZXIgYnV0dG9ucyB3ZXJlIHByZXNzZWQuXG4gKiBcbiAqIChDaGFuZ2luZyBxdWVyeSBwYXJhbWV0ZXJzIHJlbG9hZHMgdGhlIHBhZ2UgYW5kIHNvIGlzbid0XG4gKiB0cmFja2VkLCB1bmxlc3Mgb2YgY291cnNlIGl0J3MgYmVjYXVzZSBvZiB0aGUgYnJvd3NlclxuICogbmF2aWdhdGluZyBiYWNrL2ZvcndhcmRzKS5cbiAqIFxuICogSW4gZ2VuZXJhbCwgeW91J2xsIHdhbnQgdG8gaW5zcGVjdCBhIHNwZWNpZmljIGRpcmVjdG9yeSBvZlxuICogYSBwYXRoLCBvciBhIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZSwgbm90IHRoZVxuICogZW50aXJlIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVVybChvblVybENoYW5nZTogKHVybDogc3RyaW5nKSA9PiB2b2lkKSB7XG5cbiAgICBjb25zdCBbZ2V0VXJsLCBzZXRVcmxdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZywgbmV2ZXI+KHVzZVN0YWJsZUNhbGxiYWNrKG9uVXJsQ2hhbmdlKSwgdXNlQ2FsbGJhY2soKCkgPT4gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCksIFtdKSk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIGUgPT4ge1xuICAgICAgICBzZXRVcmwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwicG9wc3RhdGVcIiwgKGU6IFBvcFN0YXRlRXZlbnQpID0+IHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9wb3BzdGF0ZV9ldmVudCN0aGVfaGlzdG9yeV9zdGFja1xuICAgICAgICAvLyBUT0RPOiBJZiB0aGlzIGFzc2VydCBuZXZlciBmaXJlcywgaXQncyAqcHJvYmFibHkqIGZpbmU/P1xuICAgICAgICBjb25zb2xlLmFzc2VydCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSA9PT0gZG9jdW1lbnQubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgIHNldFVybCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gW2dldFVybCwgc2V0VXJsXSBhcyBjb25zdDtcbn1cblxuXG4iLCJpbXBvcnQgeyBNYW5hZ2VkQ2hpbGRJbmZvLCBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcblxuXG4vL2V4cG9ydCBjb25zdCBSb3V0ZXJMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciB0byB0cmltIHRoZSBjcnVzdHMgb2ZmIG9mIGEgaGFzaCBwYXRoLlxuICogQHBhcmFtIGhhc2ggXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1IYXNoKGhhc2g6IHN0cmluZykge1xuICAgIGlmIChoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpKVxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMSk7XG4gICAgaWYgKGhhc2guc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cigxKTtcbiAgICBpZiAoaGFzaC5lbmRzV2l0aChcIi9cIikpXG4gICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cigwLCBoYXNoLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBoYXNoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSGFzaFRvUGF0aChoYXNoOiBzdHJpbmcpIHtcbiAgICBoYXNoID0gdHJpbUhhc2goaGFzaCk7XG4gICAgcmV0dXJuIGhhc2guc3BsaXQoXCIvXCIpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVNYXAge1xuICAgIFwiYmlnaW50XCI6IGJpZ2ludDtcbiAgICBcIm51bWJlclwiOiBudW1iZXI7XG4gICAgXCJzdHJpbmdcIjogc3RyaW5nO1xuICAgIFwiYm9vbGVhblwiOiBib29sZWFuO1xuICAgIFwidW5rbm93blwiOiB1bmtub3duO1xufVxuXG4vLyBOb3QgcHVibGljIC0tIGp1c3QgY29udGFpbnMgc2hhcmVkIGNvZGUgZm9yIGhpc3RvcnkgbW9kaWZpY2F0aW9uLlxuLy8gVGhpcyBpcyB3aGF0IGFjdHVhbGx5IGNoYW5nZXMgSGlzdG9yeSBhbmQgdXBkYXRlcyB0aGUgd2luZG93J3MgVVJMLlxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudGlyZUhhc2goaGFzaDogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpIHtcbiAgICBhY3Rpb24gPz89IFwicHVzaFwiO1xuICAgIGhhc2ggPSB0cmltSGFzaChoYXNoKTtcbiAgICBsZXQgb2xkVVJMID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgbGV0IG5leHRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICBuZXh0VXJsLmhhc2ggPSBgIyR7aGFzaH1gO1xuXG4gICAgaGlzdG9yeVtgJHthY3Rpb259U3RhdGVgXSh7fSwgZG9jdW1lbnQudGl0bGUsIG5leHRVcmwpO1xuXG4gICAgLy8gTW9kaWZ5aW5nIGhpc3RvcnkgZG9lc24ndCBhY3R1YWxseSBjYXVzZSBhIGhhc2hjaGFuZ2UgZXZlbnQuXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEhhc2hDaGFuZ2VFdmVudCgnaGFzaGNoYW5nZScsIHsgb2xkVVJMLCBuZXdVUkw6IG5leHRVcmwudG9TdHJpbmcoKSB9KSk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIGdpdmVuIFNlYXJjaCBQYXJhbXMgb2JqZWN0IHRvIGhhdmUgaXRzIGtleSBiZSBzZXQgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICogXG4gKiBTcGVjaWZpY2FsbHkgZm9yIGJvb2xlYW4gdHlwZXMgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIHBhcmFtIGlzIHNpbXBseSBleGlzdGFudC9ub24tZXhpc3RhbnQsXG4gKiBidXQgZm9yIG90aGVyIHR5cGVzIHRoaXMgaXMgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqIEBwYXJhbSBwYXJhbXMgXG4gKiBAcGFyYW0ga2V5IFxuICogQHBhcmFtIHZhbHVlIFxuICogQHBhcmFtIHR5cGUgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhcnNlUGFyYW08VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPihwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcywga2V5OiBzdHJpbmcsIHZhbHVlOiBUeXBlTWFwW1RdLCB0eXBlOiBUKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChrZXksIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJhbXMuc2V0KGtleSwgYCR7dmFsdWV9YCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcmVxdWVzdGVkIFNlYXJjaCBQYXJhbSBmcm9tIHRoZSBnaXZlbiBVUkwuXG4gKiBcbiAqIFRoZSB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBwYXJzZWQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBib29sZWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbTxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+KHVybDogVVJMLCBrZXk6IHN0cmluZywgdHlwZTogVCk6IFR5cGVNYXBbVF0gfCBudWxsIHtcbiAgICBsZXQgdmFsdWUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgYXMgVHlwZU1hcFtUXSkgPz8gbnVsbDtcblxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsKSBhcyBUeXBlTWFwW1RdO1xuXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHBhcnNlZDogbnVtYmVyID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHBhcnNlZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCBhcyBUeXBlTWFwW1RdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpIGFzIFR5cGVNYXBbVF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgYXMgVHlwZU1hcFtUXSA/PyBudWxsO1xufVxuXG5cbmV4cG9ydCB0eXBlIFJvdXRlclBhdGhUeXBlID0gbnVsbCB8IHN0cmluZyB8IFJlZ0V4cCB8ICgobG9jYWxQYXRoOiBzdHJpbmcpID0+IGJvb2xlYW4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRyb2xzIHtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGF0IHRoZSBjdXJyZW50IGxldmVsIHRvIGBkaXJgLlxuICAgICAqIFxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgY2xvc2VyIHRvIHRoZSByb290IGFyZSBub3QgYWZmZWN0ZWQuICBcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGZhcnRoZXIgZnJvbSB0aGUgcm9vdCBhcmUgZGVsZXRlZCB1bmxlc3MgcmVxdWVzdGVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZXRMb2NhbFBhdGgoZGlyOiBzdHJpbmcsIGFjdGlvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIsIGtlZXBUcmFpbGluZz86IGJvb2xlYW4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogR28gb25lIGxldmVsIGRlZXBlciBpbnRvIHRoaXMgZGlyZWN0b3J5IGJ5IGFwcGVuZGluZyBgL2RpcmAgdG8gaXQuXG4gICAgICogXG4gICAgICogKiBUaGUgY3VycmVudCBkaXJlY3RvcnkgaXMgbm90IGFmZmVjdGVkXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBjbG9zZXIgdG8gdGhlIHJvb3QgYXJlIG5vdCBhZmZlY3RlZC4gIFxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgZmFydGhlciBmcm9tIHRoZSByb290IGFyZSBkZWxldGVkIHVubGVzcyByZXF1ZXN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1c2hMb2NhbFBhdGgoZGlyOiBzdHJpbmcsIGFjdGlvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIsIGtlZXBUcmFpbGluZz86IGJvb2xlYW4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogR28gYmFjayBvbmUgbGV2ZWwgYnkgc2V0dGluZyB0aGUgY3VycmVudCBkaXJlY3RvcnkgdG8gZW1wdHkgYW5kLCBvcHRpb25hbGx5LCBjaGFuZ2luZyB0aGUgcGFyZW50IGRpcmVjdG9yeSB0byBgZGlyYCBhcyB3ZWxsLlxuICAgICAqIFxuICAgICAqICogVGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHNldCB0byBlbXB0eVxuICAgICAqICogQWxsIGRpcmVjdG9yaWVzIGFmdGVyIHRoZSBjdXJyZW50IGRpcmVjdG9yeSwgaWYgYW55LCBhcmUgZW1wdGllZC5cbiAgICAgKiAqIElmIHByb3ZpZGVkLCB0aGUgcGFyZW50IGRpcmVjdG9yeSB0byB0aGUgY3VycmVudCBkaXJlY3RvcnkgaXMgc2V0IHRvIGBkaXJgLlxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgY2xvc2VyIHRvIHRoZSByb290IGFyZSBub3QgYWZmZWN0ZWRcbiAgICAgKi9cbiAgICBwb3BMb2NhbFBhdGgoZGlyPzogc3RyaW5nLCBhY3Rpb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKTogdm9pZDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nPiB7XG4gICAgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzKGFueU1hdGNoZXM6IGJvb2xlYW4pOiB2b2lkO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyQ29udGV4dFR5cGUgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PFJvdXRlckNoaWxkSW5mbz4ge1xuICAgIHJvdXRlckNvbnRleHQ6IHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgbGV2ZWwgdGhlIGNoaWxkIHNob3VsZCBjb25zaWRlciBpdHNlbGYgYXMtLVxuICAgICAgICAvLyBjaGlsZHJlbiBuZWVkIHRoaXMgdG8ga25vdyB3aGF0IHBhcnQgb2YgdGhlIFVSTCB0byBwYXJzZVxuICAgICAgICAvLyBhbmQgYWxzbyB0byBpbmZvcm0gKnRoZWlyKiBjaGlsZHJlbiB3aGF0IGxldmVsIHRoZXkgYXJlXG4gICAgICAgIGxldmVsOiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgaW4gb3JkZXIgdG8gZmFjaWxpdGF0ZSBzaG93aW5nIHRoZSBkZWZhdWx0IGNoaWxkIHdoZW4gbm8gbm9uLWRlZmF1bHQgY2hpbGRyZW4gYXJlIGJlaW5nIHNob3duLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIGluZGV4IFxuICAgICAgICAgKiBAcGFyYW0gbWF0Y2hlcyBcbiAgICAgICAgICovXG4gICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4OiBzdHJpbmcsIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsKTogdm9pZDtcbiAgICB9O1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgUm91dGVyQ2hpbGRJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmc+IHtcbi8vICAgIG5vdGlmeU9mU2libGluZ3NIYXZlTm9NYXRjaGVzKG5vTWF0Y2hlczogYm9vbGVhbik6IHZvaWQ7XG4gICAgLy9wYXRoOiBSb3V0ZXJQYXRoVHlwZSB8IG51bGw7XG4vLyAgICBtYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcbi8vfVxuIiwiaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0LCBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlVXJsIH0gZnJvbSBcIi4vdXNlLXVybC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgUm91dGVyQ2hpbGRJbmZvLCBSb3V0ZXJQYXRoVHlwZSwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2NhbFBhdGhQYXJhbWV0ZXJzIHtcbiAgICBjb25zdW1lUm91dGVyUmV0dXJuOiBQaWNrPFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm5bXCJjb25zdW1lUm91dGVyUmV0dXJuXCJdLCBcImxldmVsXCI+O1xuICAgIGxvY2FsUm91dGVQYXJhbWV0ZXJzOiB7XG4gICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlOiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyQ29udGV4dFR5cGUgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PFJvdXRlckNoaWxkSW5mbz4ge1xuICAgIHJvdXRlckNvbnRleHQ6IHtcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcbiAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXg6IHN0cmluZywgbWF0Y2hlczogYm9vbGVhbiB8IG51bGwpOiB2b2lkO1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm91dGVyQ29uc3VtZXJBcmd1bWVudHMge1xuICAgIHJvdXRlckNvbnN1bWVyUGFyYW1ldGVyczogeyBsb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlIHwgbnVsbDsgfVxufVxuXG4vKipcbiAqIFRoZSBcImNoaWxkXCIgcGFydCBvZiBhIHJvdXRlci5cbiAqIFxuICogVGhpcyBpcyByZXNwb25zaWJsZSBmb3Igb2JzZXJ2aW5nIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBpbiB0aGUgaGFzaCxcbiAqIGFuZCBub3RpZnlpbmcgdGhlIHBhcmVudCBhbnkgdGltZSBpdCBiZWNvbWVzIHZhbGlkL2ludmFsaWQsIGJlY2F1c2VcbiAqIGlmIHRoaXMgcGF0aCBhbmQgYWxsIGl0cyBzaWJsaW5ncyBhcmUgaW52YWxpZCBhdCB0aGUgc2FtZSB0aW1lLFxuICogdGhlIGRlZmF1bHQgcGF0aCBpcyBhbGxvd2VkIHRvIGJlIHNob3duLlxuICovXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29uc3VtZVJvdXRlclBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFJvdXRlckNoaWxkSW5mbz4ge1xuICAgIGNvbnRleHQ6IFJvdXRlckNvbnRleHRUeXBlO1xuICAgIGNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzOiB7XG4gICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZywgbmV2ZXI+O1xuICAgICAgICBsb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDb25zdW1lUm91dGVyUmV0dXJuIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICBjb25zdW1lUm91dGVyUmV0dXJuOiB7XG4gICAgICAgIGxldmVsOiBudW1iZXI7XG4gICAgICAgIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsO1xuICAgICAgICBnZXRMb2NhbFBhdGg6ICgpID0+IHN0cmluZztcbiAgICAgICAgc2V0TG9jYWxQYXRoOiAocGF0aDogc3RyaW5nKSA9PiB2b2lkO1xuICAgICAgICBwYXRoV2hlbk1hdGNoaW5nOiBzdHJpbmcgfCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnN1bWVSb3V0ZXIoeyBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sIGNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzOiB7IG9uTG9jYWxQYXRoQ2hhbmdlLCBsb2NhbFBhdGg6IHdhbnRlZExvY2FsUGF0aCB9IH06IFVzZUNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzKTogVXNlQ29uc3VtZVJvdXRlclJldHVybiB7XG4gICAgY29uc3QgeyByb3V0ZXJDb250ZXh0OiB7IGxldmVsLCBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZCB9IH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IFthbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MsIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nc10gPSB1c2VTdGF0ZShudWxsIGFzIG51bGwgfCBib29sZWFuKTtcblxuICAgIGNvbnN0IFtwYXRoV2hlbk1hdGNoaW5nLCBzZXRQYXRoV2hlbk1hdGNoaW5nXSA9IHVzZVN0YXRlKG51bGwgYXMgbnVsbCB8IHN0cmluZyk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybiB9ID0gdXNlTWFuYWdlZENoaWxkPFJvdXRlckNoaWxkSW5mbz4oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXG4gICAgfSwge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzOiB1c2VTdGFibGVDYWxsYmFjaygoYW55TWF0Y2hlcykgPT4ge1xuICAgICAgICAgICAgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzKGFueU1hdGNoZXMpO1xuICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlcywgZ2V0TG9jYWxQYXRoKCkpO1xuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBnZXRMb2NhbFBhdGgoKSk7XG4gICAgfSwgW3dhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzXSlcblxuXG4gICAgY29uc3Qgb25Mb2NhbFBhdGhDaGFuZ2UyID0gdXNlU3RhYmxlQ2FsbGJhY2soZnVuY3Rpb24gKHdhbnRlZExvY2FsUGF0aDogUm91dGVyUGF0aFR5cGUsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nczogYm9vbGVhbiB8IG51bGwsIHBhdGg6IHN0cmluZykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcGF0aENvbXBhcmUod2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MsIHBhdGgpO1xuICAgICAgICBzZXRNYXRjaGVzKG1hdGNoZXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRleH06IG9uTG9jYWxQYXRoQ2hhbmdlMih3bHA6ICR7KHdhbnRlZExvY2FsUGF0aCA/PyBcIm51bGxcIikudG9TdHJpbmcoKX0sIGFtYW5kczogJHsoYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzID8/IFwibnVsbFwiKS50b1N0cmluZygpfSwgcDogJHtwYXRofSk6ICR7KG1hdGNoZXMgPz8gXCJudWxsXCIpLnRvU3RyaW5nKCl9YClcbiAgICAgICAgaWYgKG1hdGNoZXMpXG4gICAgICAgICAgICBzZXRQYXRoV2hlbk1hdGNoaW5nKHBhdGgpO1xuXG4gICAgICAgIGlmICh3YW50ZWRMb2NhbFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXgsIG1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXgsIG51bGwpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBbbWF0Y2hlcywgc2V0TWF0Y2hlc10gPSB1c2VTdGF0ZShudWxsIGFzIG51bGwgfCBib29sZWFuKTtcbiAgICBjb25zdCBbZ2V0TG9jYWxQYXRoLCBzZXRMb2NhbFBhdGhdID0gdXNlTG9jYWxQYXRoKHtcbiAgICAgICAgY29uc3VtZVJvdXRlclJldHVybjogeyBsZXZlbCB9LFxuICAgICAgICBsb2NhbFJvdXRlUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChwYXRoLCBwcmV2LCByZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTIod2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MsIHBhdGgpO1xuICAgICAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlPy4ocGF0aCwgcHJldiwgcmVhc29uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgY29uc3VtZVJvdXRlclJldHVybjoge1xuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgZ2V0TG9jYWxQYXRoLFxuICAgICAgICAgICAgc2V0TG9jYWxQYXRoLFxuICAgICAgICAgICAgcGF0aFdoZW5NYXRjaGluZ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHVzZUxvY2FsUGF0aCh7IGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwgfSwgbG9jYWxSb3V0ZVBhcmFtZXRlcnM6IHsgb25Mb2NhbFBhdGhDaGFuZ2UgfSB9OiBVc2VMb2NhbFBhdGhQYXJhbWV0ZXJzKSB7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMb2NhbFBhdGhcIiwgbGV2ZWwpO1xuXG4gICAgY29uc3QgdXJsVG9QYXRoID0gdXNlQ2FsbGJhY2soKHVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZEhhc2hQYXRoID0gbm9ybWFsaXplSGFzaFRvUGF0aCh0cmltSGFzaChuZXcgVVJMKHVybCkuaGFzaCkpO1xuICAgICAgICByZXR1cm4gb2xkSGFzaFBhdGhbbGV2ZWxdO1xuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhvbkxvY2FsUGF0aENoYW5nZSksIHVzZUNhbGxiYWNrKCgpID0+IHsgXG4gICAgICAgIHJldHVybiB1cmxUb1BhdGgod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0sIFt1cmxUb1BhdGhdKSk7XG5cblxuICAgIC8vIEFueSB0aW1lIHRoZSBVUkwgY2hhbmdlcywgaW5zcGVjdCB0aGUgaGFzaFxuICAgIC8vIGF0IG91ciBjdXJyZW50IGxldmVsLCBhbmQgY2hhbmdlIG91ciBsb2NhbCBjb3B5IG9mIG91ciBwYXRoXG4gICAgLy8gaW4gb3VyIHBhc3NpdmUgc3RhdGUuIFRoaXMgd2lsbCB0cmlnZ2VyIG91ciBjYWxsYmFjayBpZiB0aGV5J3JlIGRpZmZlcmVudC5cbiAgICB1c2VVcmwodXJsID0+IHsgc2V0TG9jYWxQYXRoKHVybFRvUGF0aCh1cmwpKTsgfSk7XG5cbiAgICByZXR1cm4gW2dldExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSBhcyBjb25zdDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aENvbXBhcmUocmVxdWVzdGVkTG9jYWxIYXNoOiBudWxsIHwgc3RyaW5nIHwgUmVnRXhwIHwgKChsb2NhbEhhc2g6IHN0cmluZykgPT4gYm9vbGVhbiksIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nczogYm9vbGVhbiB8IG51bGwsIGxvY2FsUGF0aDogc3RyaW5nIHwgbnVsbCkge1xuICAgIGxldCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcbiAgICBsb2NhbFBhdGggPz89IFwiXCI7XG5cbiAgICBpZiAocmVxdWVzdGVkTG9jYWxIYXNoIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICBtYXRjaGVzID0gKHJlcXVlc3RlZExvY2FsSGFzaC50ZXN0KGxvY2FsUGF0aCkpO1xuICAgIGVsc2UgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICBtYXRjaGVzID0gKHJlcXVlc3RlZExvY2FsSGFzaChsb2NhbFBhdGgpKTtcblxuICAgIGVsc2UgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCA9PSBudWxsKVxuICAgICAgICBtYXRjaGVzID0gKGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyA9PSBudWxsPyBudWxsIDogIWFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyk7XG4gICAgZWxzZVxuICAgICAgICBtYXRjaGVzID0gKHJlcXVlc3RlZExvY2FsSGFzaCA9PT0gbG9jYWxQYXRoKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xufVxuIiwiXG4vKipcbiAqIEVycm9yIGNsYXNzIHVzZWQgd2hlbiBhdHRlbXBzIHRvIG1vZGlmeSB0aGUgcm9vdCBkaXJlY3Rvcnkgb2NjdXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb290Um91dGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGBUaGUgcm9vdCBSb3V0ZXIncyBwYXRoIGNhbiBvbmx5IGJlIHB1c2hlZCB0byBhbmQgY2Fubm90IGJlIHNldCBvciBwb3BwZWQgZnJvbS5gKTtcbiAgICB9XG59ICIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUm9vdFJvdXRlckVycm9yIH0gZnJvbSBcIi4vcm9vdC1yb3V0ZXItZXJyb3IuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIHNldEVudGlyZUhhc2gsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCwgZWZmZWN0aXZlbHkgcmV0dXJuaW5nXG4gKiB0byB0aGUgcHJldmlvdXMgbGV2ZWwuICBZb3UgY2FuIGFsc28gc3dpdGNoIHRvIGEgZGlmZmVyZW50XG4gKiBwcmV2aW91cyBsZXZlbCBpZiB5b3Ugd291bGQgbGlrZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBvcExvY2FsUGF0aChsZXZlbDogbnVtYmVyKSB7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24oZGlyPzogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIikge1xuICAgICAgICBzZXRFbnRpcmVIYXNoKHBvcExvY2FsUGF0aChsZXZlbCwgZGlyKSwgYWN0aW9uKTtcbiAgICB9LCBbbGV2ZWxdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcExvY2FsUGF0aChsZXZlbDogbnVtYmVyLCBkaXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChsZXZlbCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSb290Um91dGVyRXJyb3IoKTtcbiAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xuICAgIGxldCBuZXdIYXNoUGF0aCA9IG9sZEhhc2hQYXRoLnNsaWNlKDAsIGxldmVsKS5tYXAocyA9PiAocyA/PyBcIlwiKSk7XG4gICAgaWYgKGRpcikge1xuICAgICAgICBkaXIgPSB0cmltSGFzaChkaXIpO1xuICAgICAgICBuZXdIYXNoUGF0aFtuZXdIYXNoUGF0aC5sZW5ndGggLSAxXSA9IGRpcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SGFzaFBhdGguam9pbihcIi9cIik7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIHNldEVudGlyZUhhc2gsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG4vKipcbiAqIEFkZHMgYSBkaXJlY3RvcnkgYXQgb25lIGxldmVsIGRlZXBlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVB1c2hMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHB1c2hMb2NhbEhhc2goZGlyOiBzdHJpbmcsIGFjdGlvbjogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiA9IFwicHVzaFwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKSB7XG4gICAgICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XG4gICAgICAgIGNvbnN0IG9sZEhhc2hQYXRoID0gbm9ybWFsaXplSGFzaFRvUGF0aCh0cmltSGFzaChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKS5oYXNoKSk7XG4gICAgICAgIGxldCBuZXdIYXNoUGF0aCA9IG9sZEhhc2hQYXRoLnNsaWNlKDAsIGtlZXBUcmFpbGluZyA/IHVuZGVmaW5lZCA6IGxldmVsICsgMSkubWFwKHMgPT4gKHMgPz8gXCJcIikpO1xuICAgICAgICBuZXdIYXNoUGF0aC5zcGxpY2UobGV2ZWwgKyAxLCAxLCBkaXIpO1xuICAgICAgICBzZXRFbnRpcmVIYXNoKG5ld0hhc2hQYXRoLmpvaW4oXCIvXCIpLCBhY3Rpb24pO1xuICAgIH0sIFtsZXZlbF0pO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBSb290Um91dGVyRXJyb3IgfSBmcm9tIFwiLi9yb290LXJvdXRlci1lcnJvci5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCB3aXRoIGEgbmV3IG9uZS4gWW91IGNhblxuICogY2hvb3NlIHdoZXRoZXIgb3Igbm90IGFueSB0cmFpbGluZyBwYXRocyBhcmUga2VwdCAtLSBieSBkZWZhdWx0IHRoaXMgaXMgZmFsc2UuXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2V0TG9jYWxQYXRoKGxldmVsOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24oZGlyOiBzdHJpbmcsIGFjdGlvbjogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiA9IFwicHVzaFwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKSB7XG4gICAgICAgIHNldEVudGlyZUhhc2goc2V0TG9jYWxQYXRoKGxldmVsLCBkaXIsIGtlZXBUcmFpbGluZyB8fCBmYWxzZSksIGFjdGlvbik7XG4gICAgfSwgW2xldmVsXSk7XG59XG5cbmZ1bmN0aW9uIHNldExvY2FsUGF0aChsZXZlbDogbnVtYmVyLCBkaXI6IHN0cmluZywga2VlcFRyYWlsaW5nOiBib29sZWFuKSB7XG4gICAgaWYgKGxldmVsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJvb3RSb3V0ZXJFcnJvcigpO1xuXG4gICAgZGlyID0gdHJpbUhhc2goZGlyKTtcbiAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xuICAgIGxldCBuZXdIYXNoUGF0aCA9IG9sZEhhc2hQYXRoLnNsaWNlKDAsIGtlZXBUcmFpbGluZyA/IHVuZGVmaW5lZCA6IGxldmVsICsgMSkubWFwKHMgPT4gKHMgPz8gXCJcIikpO1xuICAgIG5ld0hhc2hQYXRoLnNwbGljZShsZXZlbCwgMSwgZGlyKTtcbiAgICByZXR1cm4gbmV3SGFzaFBhdGguam9pbihcIi9cIik7XG59XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlUG9wTG9jYWxQYXRoIH0gZnJvbSBcIi4vdXNlLXBvcC1sb2NhbC1wYXRoLmpzXCI7XG5pbXBvcnQgeyB1c2VQdXNoTG9jYWxQYXRoIH0gZnJvbSBcIi4vdXNlLXB1c2gtbG9jYWwtcGF0aC5qc1wiO1xuaW1wb3J0IHsgdXNlU2V0TG9jYWxQYXRoIH0gZnJvbSBcIi4vdXNlLXNldC1sb2NhbC1wYXRoLmpzXCI7XG5pbXBvcnQgeyBSb3V0ZXJDb250cm9scyB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuXG4vKipcbiAqIEFsbG93cyBlYXN5IGFjY2VzcyB0byB0aGUgY29udHJvbHMgYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gKiBcbiAqIFlvdSBjYW4gYWxzbyBnZXQgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIGEgY2hpbGQgPFJvdXRlciAvPlxuICogYnkgcGFzc2luZyBpbiBhIHJlZiAoZS5nLiA8Um91dGVyIHJlZj17c2V0Q29udHJvbHN9IC8+KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlckNvbnRyb2xzKGxldmVsOiBudW1iZXIpOiBSb3V0ZXJDb250cm9scyB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGFzaCBhdCB0aGlzIGxldmVsIHNwZWNpZmljYWxseSwgXG4gICAgLy8gc28gaXQgY29udGFpbnMgbm8gZGlyZWN0b3J5IHNlcGFyYXRvcnMuXG4gICAgY29uc3QgcG9wTG9jYWxQYXRoID0gdXNlUG9wTG9jYWxQYXRoKGxldmVsKTtcbiAgICBjb25zdCBwdXNoTG9jYWxQYXRoID0gdXNlUHVzaExvY2FsUGF0aChsZXZlbCk7XG4gICAgY29uc3Qgc2V0TG9jYWxQYXRoID0gdXNlU2V0TG9jYWxQYXRoKGxldmVsKTtcblxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHBvcExvY2FsUGF0aCxcbiAgICAgICAgcHVzaExvY2FsUGF0aCxcbiAgICAgICAgc2V0TG9jYWxQYXRoLFxuICAgIH0pLCBbcG9wTG9jYWxQYXRoLCBwdXNoTG9jYWxQYXRoLCBzZXRMb2NhbFBhdGhdKTtcbn1cblxuXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUm91dGVyQ2hpbGRJbmZvLCBSb3V0ZXJDb250ZXh0VHlwZSB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Um91dGVyQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJvdmlkZVJvdXRlclBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFJvdXRlckNoaWxkSW5mbz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJvdmlkZVJvdXRlclJldHVyblR5cGUgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPFJvdXRlckNoaWxkSW5mbz4ge1xuICAgIGNvbnRleHQ6IFJvdXRlckNvbnRleHRUeXBlO1xufVxuXG4vL2NvbnN0IFJvdXRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFJvdXRlckNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbi8qKlxuICogVGhlIFwicGFyZW50XCIgcGFydCBvZiBhIHJvdXRlci5cbiAqIFxuICogVGhpcyBpcyByZXNwb25zaWJsZSBmb3IgY29vcmRpbmF0aW5nLCBhbW9uZyBhbGwgY2hpbGRyZW4sIHdoaWNoIHJvdXRlIHRvIHNob3cuXG4gKiBUaGlzIGNvb3JkaW5hdGlvbiBpcyByZWFsbHkgb25seSBuZWVkZWQgZm9yIHRoZSBcImRlZmF1bHRcIiBwYXRod2F5LCB3aGljaFxuICogbmVlZHMgdG8ga25vdyBhcyBwYWlubGVzc2x5IGFzIHBvc3NpYmxlIHdoZXRoZXIgYW55IG9mIGl0cyBzaWJsaW5ncyBhcmUgY3VycmVudGx5IHZhbGlkLlxuICogXG4gKiBJdCBhbHNvIGluY3JlYXNlcyB0aGUgZGVwdGggYnkgb25lLCBzdGFydGluZyBhdCBkZXB0aD0tMSBmb3IgdGhlIHJvb3Qgcm91dGVyIGlzICpqdXN0KiBhIHBhcmVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJvdmlkZVJvdXRlcih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfTogVXNlUHJvdmlkZVJvdXRlclBhcmFtZXRlcnMpOiBVc2VQcm92aWRlUm91dGVyUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxSb3V0ZXJDaGlsZEluZm8+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWwgfSB9ID0gdXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KSA/PyB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWw6IC0xIH0gfVxuXG4gICAgY29uc3QgbWF0Y2hpbmdJbmRpY2VzID0gdXNlUmVmPFNldDxzdHJpbmc+PihuZXcgU2V0KCkpO1xuICAgIGNvbnN0IFtnZXRTaG93aW5nRGVmYXVsdCwgc2V0U2hvd2luZ0RlZmF1bHRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4gfCBudWxsLCBuZXZlcj4odXNlU3RhYmxlQ2FsbGJhY2soc2hvd2luZ0RlZmF1bHQgPT4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4uZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyghc2hvd2luZ0RlZmF1bHQpO1xuICAgICAgICB9KVxuICAgIH0pLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBvbk5vbkRlZmF1bHRDaGlsZE1hdGNoQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChpbmRleDogc3RyaW5nLCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbCkgPT4ge1xuICAgICAgICBtYXRjaGluZ0luZGljZXMuY3VycmVudFttYXRjaGVzID8gXCJhZGRcIiA6IFwiZGVsZXRlXCJdKGluZGV4KTtcbiAgICAgICAgc2V0U2hvd2luZ0RlZmF1bHQobWF0Y2hpbmdJbmRpY2VzLmN1cnJlbnQuc2l6ZSA9PSAwKTtcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICByb3V0ZXJDb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCArIDEsXG4gICAgICAgICAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQ6IG9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuXG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQ29uc3VtZVJvdXRlciwgVXNlQ29uc3VtZVJvdXRlclJldHVybiB9IGZyb20gXCIuL3VzZS1yb3V0ZXItY29uc3VtZXIuanNcIjtcbmltcG9ydCB7IHVzZVJvdXRlckNvbnRyb2xzIH0gZnJvbSBcIi4vdXNlLXJvdXRlci1jb250cm9scy5qc1wiO1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCwgdXNlUHJvdmlkZVJvdXRlciB9IGZyb20gXCIuL3VzZS1yb3V0ZXItcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IFJvdXRlckNvbnRyb2xzLCBSb3V0ZXJQYXRoVHlwZSB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNoaWxkcmVuIHRvIGRpc3BsYXksIGdpdmVuIHRoZSBjdXJyZW50IGxvY2FsIHBhdGgsIGlmIG9uZSBtYXRjaGVzLlxuICAgICAqIFxuICAgICAqIGBudWxsYCB3aWxsIGJlIHBhc3NlZCB3aGVuIHlvdSBzaG91bGQgaGlkZSB0aGUgY29udGVudHMsIGFuZCB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlZCB3aWxsIGJlIHBhc3NlZCBvdGhlcndpc2UuXG4gICAgICogXG4gICAgICogQHBhcmFtIHBhdGhXaGVuTWF0Y2hpbmcgV2hlbiBgbnVsbGAsIGRvbid0IHNob3csIGJlY2F1c2UgdGhlIFVSTCBpc24ndCBvbiB0aGlzIHBhdGguIEFueSBvdGhlciBzdHJpbmcgdmFsdWUgaXMgdGhlIGN1cnJlbnQgcGF0aCB0aGF0IHRoaXMgYFJvdXRlcmAgbWF0Y2hlcy5cbiAgICAgKiBAcmV0dXJucyBXaGF0IHlvdSB3YW50IHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogKHBhdGhXaGVuTWF0Y2hpbmc6IHN0cmluZyB8IG51bGwsIGNvbnRyb2xzOiBSb3V0ZXJDb250cm9scykgPT4gQ29tcG9uZW50Q2hpbGRyZW47XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IHBhdGggb3IgcGF0aHMgdGhpcyBgUm91dGVyYCBzaG91bGQgc2hvdyBpdHNlbGYgb24uXG4gICAgICogXG4gICAgICogQ2FuIGJlIGEgc3RyaW5nLCBSZWdFeHAsIG9yIGAocDogc3RyaW5nKSA9PiBib29sZWFuYC4gT3IgYG51bGxgIHRvIGJlIGEgXCJkZWZhdWx0XCIgYFJvdXRlcmAuXG4gICAgICogXG4gICAgICogXCJEZWZhdWx0XCIgYFJvdXRlcmBzIChgbG9jYXBQYXRoPXtudWxsfWApIGFyZSBzaG93biB3aGVuIG5vIG90aGVyIGBSb3V0ZXJgIGF0IHRoZSBzYW1lIGxldmVsIG1hdGNoZXMuXG4gICAgICovXG4gICAgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsLiBJZiB5b3Ugd291bGQgbGlrZSB0byBrbm93IHdoYXQgdGhlIGN1cnJlbnQgcGF0aCBpcyBldmVuIHdoZW4gbm90IGN1cnJlbnRseSBiZWluZyBzaG93biwgeW91IGNhbiBnZXQgdGhhdCBpbmZvcm1hdGlvbiBoZXJlLlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHBhc3MgYSBub3JtYWwgYHNldFN0YXRlYCBmdW5jdGlvbiBoZXJlLlxuICAgICAqL1xuICAgIG9uTG9jYWxQYXRoQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nLCBuZXZlcj47XG59XG5cbi8qKlxuICogQWxsb3dzIHlvdSB0byBjb25kaXRpb25hbGx5IGhpZGUvc2hvdyBjb250ZW50IGJhc2VkIG9uIGEgcGF0aCBpbiB0aGUgaGFzaCBjb21wb25lbnQgb2YgdGhlIFVSTC5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEBwYXJhbSByZWYgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcih7IGxvY2FsUGF0aCwgb25Mb2NhbFBhdGhDaGFuZ2UsIGNoaWxkcmVuIH06IFJvdXRlclByb3BzLCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFJvdXRlckNvbnRleHQpO1xuXG4gICAgY29uc3QgeyBjb250ZXh0OiBjb250ZXh0RnJvbVBhcmVudCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VQcm92aWRlUm91dGVyKHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgaW5kZXggPSB1c2VNZW1vKCgpID0+ICgobG9jYWxQYXRoID8/IFwiPGRlZmF1bHQ+XCIpICsgYC0ke01hdGgucmFuZG9tKCl9YCksIFtsb2NhbFBhdGhdKTtcbiAgICBsZXQgY29uc3VtZVJvdXRlclJldHVybjogVXNlQ29uc3VtZVJvdXRlclJldHVybiB8IG51bGwgPSBudWxsO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcIlJvdXRlclwiLCAhIWNvbnRleHQpO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3VtZVJvdXRlclJldHVybiA9IHVzZUNvbnN1bWVSb3V0ZXIoeyBjb25zdW1lUm91dGVyUGFyYW1ldGVyczogeyBsb2NhbFBhdGgsIG9uTG9jYWxQYXRoQ2hhbmdlIH0sIGNvbnRleHQsIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwsIG1hdGNoZXMsIHBhdGhXaGVuTWF0Y2hpbmcgfSB9ID0gY29uc3VtZVJvdXRlclJldHVybiA/PyB7IGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWw6IC0xLCBtYXRjaGVzOiBudWxsLCBwYXRoV2hlbk1hdGNoaW5nOiBudWxsIH0gfVxuXG4gICAgY29uc3QgY29udHJvbHMgPSB1c2VSb3V0ZXJDb250cm9scyhsZXZlbCk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+ICh7XG4gICAgICAgIGxldmVsLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBwYXRoV2hlbk1hdGNoaW5nLFxuICAgICAgICAuLi5jb250cm9sc1xuICAgIH0pKVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRGcm9tUGFyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbihsZXZlbCA9PSAtMSA/IFwiL1wiIDogbWF0Y2hlcyA/IHBhdGhXaGVuTWF0Y2hpbmcgOiBudWxsLCB1c2VSb3V0ZXJDb250cm9scyhsZXZlbCkpfVxuICAgICAgICA8L1JvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG4iLCJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlVXJsIH0gZnJvbSBcIi4vdXNlLXVybC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VQYXJhbSwgVHlwZU1hcCwgdW5wYXJzZVBhcmFtIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5leHBvcnQgdHlwZSBPblBhcmFtVmFsdWVDaGFuZ2VkPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4gPSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUeXBlTWFwW1RdIHwgbnVsbCwgbmV2ZXI+OyAvLyh2YWx1ZTogVHlwZU1hcFtUXSB8IG51bGwsIHJlYXNvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBTZXRQYXJhbVdpdGhIaXN0b3J5PFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4gPSAodmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsIHwgKChwcmV2VmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsKSA9PiAoVHlwZU1hcFtUXSB8IG51bGwpKSwgcmVhc29uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikgPT4gdm9pZDtcblxuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW0ncyB2YWx1ZVxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgdGhpcyBmdW5jdGlvbiBpcyBsaWtlIHVzZVBhc3NpdmVTdGF0ZSAoaXRzZWxmIGxpa2UgdXNlU3RhdGUgYW5kIHVzZUVmZmVjdCBjb21iaW5lZCksXG4gKiB0aGUgYHNldFN0YXRlYCByZXR1cm4gZnVuY3Rpb24gaXMsIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLCBub3Qgc3luY3Jvbm91cywgYnV0IHRoYXQnc1xuICogbGlrZSBtb3N0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgYW55d2F5IEkgZ3Vlc3M/XG4gKiBcbiAqIEBwYXJhbSBwYXJhbUtleSBUaGUgbmFtZSBvZiB0aGUgVVJMIHNlYXJjaCBwYXJhbWV0ZXIgdG8gcmVmZXJlbmNlIFxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZGF0YSBlbmNvZGUvZGVjb2RlIChgXCJzdHJpbmdcImAgfCBgXCJib29sZWFuXCJgIHwgYFwibnVtYmVyXCJgIHwgYFwiYmlnaW50XCJgKVxuICogQHBhcmFtIG9uUGFyYW1WYWx1ZUNoYW5nZWQgV2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW1ldGVyJ3MgdmFsdWUgY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtczxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+KHBhcmFtS2V5OiBzdHJpbmcsIHR5cGU6IFQsIG9uUGFyYW1WYWx1ZUNoYW5nZWQ/OiBPblBhcmFtVmFsdWVDaGFuZ2VkPFQ+KSB7XG5cbiAgICAvLyBXZSBrZWVwIGEgbG9jYWwgY29weSBvZiBvdXIgY3VycmVudCBTZWFyY2ggUGFyYW0gdmFsdWVcbiAgICAvLyBiZWNhdXNlIGNoYW5naW5nIGl0IGlzIGFjdHVhbGx5IGFuIGFzeW5jcm9ub3VzIG9wZXJhdGlvblxuICAgIC8vIGFuZCB3ZSBjYW4ndCBrbm93IHdoZW4gaXQgZW5kcyBhc2lkZSBmcm9tIGp1c3QgXCJkaWQgdGhlIFVSTCBjaGFuZ2Ugb3Igbm90XCJcbiAgICAvLyBzbyB3ZSBtaWdodCBhcyB3ZWxsIGtlZXAgdGhpcyBzdGF0ZSBhcm91bmQgbG9jYWxseSB0byBjb21wZW5zYXRlLlxuICAgIGNvbnN0IFtnZXRTYXZlZFBhcmFtVmFsdWUsIHNldFNhdmVkUGFyYW1WYWx1ZV0gPSB1c2VQYXNzaXZlU3RhdGU8VHlwZU1hcFtUXSB8IG51bGwsIG5ldmVyPihvblBhcmFtVmFsdWVDaGFuZ2VkLCB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJzZVBhcmFtKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLCBwYXJhbUtleSwgdHlwZSk7XG4gICAgfSwgW10pKTtcbiAgICBjb25zdCBzZXRQYXJhbVdpdGhIaXN0b3J5ID0gdXNlU3RhYmxlQ2FsbGJhY2s8U2V0UGFyYW1XaXRoSGlzdG9yeTxUPj4oKG5ld1ZhbHVlT3JVcGRhdGVyLCByZWFzb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSA9PiB7XG5cbiAgICAgICAgbGV0IHByZXZWYWx1ZSA9IHBhcnNlUGFyYW0obmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSksIHBhcmFtS2V5LCB0eXBlKTtcbiAgICAgICAgbGV0IG5leHRWYWx1ZTogVHlwZU1hcFtUXSB8IG51bGwgPSAodHlwZW9mIG5ld1ZhbHVlT3JVcGRhdGVyID09IFwiZnVuY3Rpb25cIj8gbmV3VmFsdWVPclVwZGF0ZXIocHJldlZhbHVlKSA6IG5ld1ZhbHVlT3JVcGRhdGVyKTtcblxuICAgICAgICBsZXQgbmV3UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuc2VhcmNoUGFyYW1zKSk7XG4gICAgICAgIHVucGFyc2VQYXJhbShuZXdQYXJhbXMsIHBhcmFtS2V5LCBuZXh0VmFsdWUgYXMgVHlwZU1hcFtUXSwgdHlwZSk7XG4gICAgICAgIGxldCBuZXh0VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgIG5leHRVcmwuc2VhcmNoID0gcHJldHR5UHJpbnRQYXJhbXMobmV3UGFyYW1zKTtcbiAgICAgICAgaGlzdG9yeVtgJHtyZWFzb24gPz8gXCJyZXBsYWNlXCJ9U3RhdGVgXSh7fSwgZG9jdW1lbnQudGl0bGUsIG5leHRVcmwpO1xuICAgICAgICBzZXRTYXZlZFBhcmFtVmFsdWUobmV4dFZhbHVlKTtcbiAgICB9KTtcblxuXG4gICAgLy8gQW55IHRpbWUgdGhlIFVSTCBjaGFuZ2VzLCBpdCBtZWFucyB0aGUgU2VhcmNoIFBhcmFtIHdlIGNhcmUgYWJvdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxuICAgIC8vIFBhcnNlIGl0IG91dCBhbmQgc2F2ZSBpdC5cbiAgICB1c2VVcmwodXNlU3RhYmxlQ2FsbGJhY2sodXJsID0+IHtcbiAgICAgICAgY29uc3QgbmV3UGFyYW0gPSBwYXJzZVBhcmFtKG5ldyBVUkwodXJsKSwgcGFyYW1LZXksIHR5cGUpO1xuICAgICAgICBzZXRTYXZlZFBhcmFtVmFsdWUobmV3UGFyYW0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBbZ2V0U2F2ZWRQYXJhbVZhbHVlLCBzZXRQYXJhbVdpdGhIaXN0b3J5XSBhcyBjb25zdDtcbn1cblxuZnVuY3Rpb24gcHJldHR5UHJpbnRQYXJhbXMocGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbUFycmF5ID0gWy4uLnBhcmFtcy5lbnRyaWVzKCldLmZpbHRlcigoa2V5LCB2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCk7XG4gICAgaWYgKHBhcmFtQXJyYXkubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBcIlwiO1xuXG5cbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBwYXJhbUFycmF5Lm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCAodmFsdWUgYXMgYW55KSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX1gO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgIH0pLmpvaW4oXCImXCIpO1xuXG4gICAgcmV0dXJuIGA/JHtxdWVyeVN0cmluZ31gO1xuXG59XG4iLG51bGxdLCJuYW1lcyI6WyJzbGljZSIsIm9wdGlvbnMiLCJ2bm9kZUlkIiwicmVyZW5kZXJRdWV1ZSIsInByZXZEZWJvdW5jZSIsImRlZmVyIiwiaSIsIkVNUFRZX09CSiIsIkVNUFRZX0FSUiIsIklTX05PTl9ESU1FTlNJT05BTCIsImFzc2lnbiIsIm9iaiIsInByb3BzIiwicmVtb3ZlTm9kZSIsIm5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImNoaWxkcmVuIiwia2V5IiwicmVmIiwibm9ybWFsaXplZFByb3BzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2FsbCIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsImNyZWF0ZVZOb2RlIiwib3JpZ2luYWwiLCJ2bm9kZSIsIl9fayIsIl9fIiwiX19iIiwiX19lIiwiX19kIiwiX19jIiwiX19oIiwiY29uc3RydWN0b3IiLCJfX3YiLCJGcmFnbWVudCIsIkNvbXBvbmVudCIsImNvbnRleHQiLCJ0aGlzIiwiZ2V0RG9tU2libGluZyIsImNoaWxkSW5kZXgiLCJpbmRleE9mIiwic2libGluZyIsInVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIiwiY2hpbGQiLCJiYXNlIiwiZW5xdWV1ZVJlbmRlciIsImMiLCJwdXNoIiwicHJvY2VzcyIsIl9fciIsImRlYm91bmNlUmVuZGVyaW5nIiwicmVuZGVyUXVldWVMZW5ndGgiLCJjb21wb25lbnQiLCJjb21taXRRdWV1ZSIsIm9sZFZOb2RlIiwib2xkRG9tIiwicGFyZW50RG9tIiwic29ydCIsImEiLCJiIiwic2hpZnQiLCJkaWZmIiwib3duZXJTVkdFbGVtZW50IiwiY29tbWl0Um9vdCIsImRpZmZDaGlsZHJlbiIsInJlbmRlclJlc3VsdCIsIm5ld1BhcmVudFZOb2RlIiwib2xkUGFyZW50Vk5vZGUiLCJnbG9iYWxDb250ZXh0IiwiaXNTdmciLCJleGNlc3NEb21DaGlsZHJlbiIsImlzSHlkcmF0aW5nIiwiaiIsImNoaWxkVk5vZGUiLCJuZXdEb20iLCJmaXJzdENoaWxkRG9tIiwicmVmcyIsIm9sZENoaWxkcmVuIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJyZW9yZGVyQ2hpbGRyZW4iLCJwbGFjZUNoaWxkIiwiZ2V0TGFzdERvbSIsIm5leHRTaWJsaW5nIiwidW5tb3VudCIsImFwcGx5UmVmIiwidG1wIiwidG9DaGlsZEFycmF5Iiwib3V0Iiwic29tZSIsIm5leHREb20iLCJzaWJEb20iLCJvdXRlciIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwibGFzdERvbSIsImRpZmZQcm9wcyIsImRvbSIsIm5ld1Byb3BzIiwib2xkUHJvcHMiLCJoeWRyYXRlIiwic2V0UHJvcGVydHkiLCJzZXRTdHlsZSIsInN0eWxlIiwidmFsdWUiLCJ0ZXN0IiwibmFtZSIsIm9sZFZhbHVlIiwidXNlQ2FwdHVyZSIsIm8iLCJjc3NUZXh0IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwibCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudFByb3h5Q2FwdHVyZSIsImV2ZW50UHJveHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImV2ZW50IiwibmV3Vk5vZGUiLCJpc05ldyIsIm9sZFN0YXRlIiwic25hcHNob3QiLCJjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24iLCJwcm92aWRlciIsImNvbXBvbmVudENvbnRleHQiLCJyZW5kZXJIb29rIiwiY291bnQiLCJuZXdUeXBlIiwiY29udGV4dFR5cGUiLCJfX0UiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJkb1JlbmRlciIsInN1YiIsInN0YXRlIiwiX19uIiwiX3NiIiwiX19zIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiZm9yRWFjaCIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJfX1AiLCJnZXRDaGlsZENvbnRleHQiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImRpZmZFbGVtZW50Tm9kZXMiLCJkaWZmZWQiLCJyb290IiwiY2IiLCJvbGRIdG1sIiwibmV3SHRtbCIsIm5vZGVUeXBlIiwibG9jYWxOYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsImlzIiwiZGF0YSIsImNoaWxkTm9kZXMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImF0dHJpYnV0ZXMiLCJfX2h0bWwiLCJpbm5lckhUTUwiLCJjaGVja2VkIiwiY3VycmVudCIsInBhcmVudFZOb2RlIiwic2tpcFJlbW92ZSIsInIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlcGxhY2VOb2RlIiwiZmlyc3RDaGlsZCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJjb250ZXh0SWQiLCJDb25zdW1lciIsImNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwic3VicyIsImN0eCIsIl9wcm9wcyIsIm9sZCIsInNwbGljZSIsImVycm9yIiwiZXJyb3JJbmZvIiwiY3RvciIsImhhbmRsZWQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJzZXRTdGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwidXBkYXRlIiwiY2FsbGJhY2siLCJzIiwiZm9yY2VVcGRhdGUiLCJQcm9taXNlIiwidGhlbiIsImJpbmQiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImlzU3RhdGljQ2hpbGRyZW4iLCJfX3NvdXJjZSIsIl9fc2VsZiIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRDb21wb25lbnQiLCJwcmV2aW91c0NvbXBvbmVudCIsInByZXZSYWYiLCJjdXJyZW50SG9vayIsImFmdGVyUGFpbnRFZmZlY3RzIiwiRU1QVFkiLCJvbGRCZWZvcmVEaWZmIiwib2xkQmVmb3JlUmVuZGVyIiwib2xkQWZ0ZXJEaWZmIiwib2xkQ29tbWl0Iiwib2xkQmVmb3JlVW5tb3VudCIsImdldEhvb2tTdGF0ZSIsImluZGV4IiwiaG9va3MiLCJfX0giLCJfX1YiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJhY3Rpb24iLCJjdXJyZW50VmFsdWUiLCJfX04iLCJuZXh0VmFsdWUiLCJfaGFzU2N1RnJvbUhvb2tzIiwicHJldlNjdSIsInAiLCJzdGF0ZUhvb2tzIiwiZmlsdGVyIiwieCIsImV2ZXJ5Iiwic2hvdWxkVXBkYXRlIiwiaG9va0l0ZW0iLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUhhbmRsZSIsImNvbmNhdCIsImZhY3RvcnkiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiaW52b2tlQ2xlYW51cCIsImludm9rZUVmZmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFmdGVyTmV4dEZyYW1lIiwiaGFzRXJyb3JlZCIsIkhBU19SQUYiLCJyYWYiLCJkb25lIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaG9vayIsImNvbXAiLCJjbGVhbnVwIiwib2xkQXJncyIsIm5ld0FyZ3MiLCJhcmciLCJmIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIk9iamVjdCIsImZyZWVHbG9iYWwkMyIsImZyZWVTZWxmIiwic2VsZiIsIkZ1bmN0aW9uIiwicm9vdCQzIiwiU3ltYm9sIiwiU3ltYm9sJDQiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInRhZyIsInVubWFza2VkIiwicmVzdWx0Iiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsImNvcmVKc0RhdGEkMyIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwia2V5cyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsImdldFZhbHVlIiwib2JqZWN0IiwiZ2V0TmF0aXZlIiwiZXEiLCJvdGhlciIsIm5hdGl2ZUNyZWF0ZSIsIm5hdGl2ZUNyZWF0ZSQzIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiaGFzaERlbGV0ZSIsImhhcyIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwibGlzdENhY2hlQ2xlYXIiLCJhc3NvY0luZGV4T2YiLCJhcnJheSIsImFycmF5UHJvdG8iLCJsaXN0Q2FjaGVEZWxldGUiLCJsYXN0SW5kZXgiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJNYXAiLCJNYXAkNCIsIm1hcENhY2hlQ2xlYXIiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemUiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsIm1lbW9pemVkIiwiYXBwbHkiLCJjYWNoZSIsIkNhY2hlIiwibWVtb2l6ZSQxIiwiZ2V0QnVpbGRNb2RlVW5tZW1vaXplZCIsImVudiIsIk5PREVfRU5WIiwiX2UiLCJnZXRCdWlsZE1vZGUiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsInVzZUhlbHBlciIsImNvbnNvbGUiLCJKU09OIiwic3RyaW5naWZ5IiwicXVldWVNaWNyb3Rhc2siLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiZXgiLCJ3YXJuIiwic2V0VmFsdWUiLCJyZWFzb24iLCJuZXh0UmVhc29uIiwibmV4dERlcCIsInByZXZEZXAiLCJyZXR1cm5OdWxsIiwiVGFibGUiLCJiYXNlNjQiLCJyYW5kb202Qml0cyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJhbmRvbTY0Qml0cyIsImdlbmVyYXRlUmFuZG9tSWQiLCJwcmVmaXgiLCJuIiwiam9pbiIsInByZXZpb3VzSW5wdXRzIiwidG9SdW4iLCJjb21taXROYW1lIiwib3JpZ2luYWxDb21taXQiLCJuZXdDb21taXQiLCJpZCIsImVmZmVjdEluZm8iLCJvbGRJbnB1dHMiLCJpbnB1dHMiLCJlZmZlY3QiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJkZWxldGUiLCJ1c2VTdGFibGVHZXR0ZXIiLCJFcnJvciIsInVzZVN0YWJsZU9iamVjdCIsInQiLCJfayIsInYiLCJXZWFrTWFwIiwiaXNTdGFibGVHZXR0ZXIiLCJzZXRJc1N0YWJsZUdldHRlciIsInVzZVN0YWJsZUNhbGxiYWNrIiwiZm4iLCJub0RlcHMiLCJjdXJyZW50Q2FsbGJhY2tHZXR0ZXIiLCJ1c2VDYWxsYmFja05hdGl2ZSIsImFzc2VydCIsInVzZUdsb2JhbEhhbmRsZXIiLCJ0YXJnZXQiLCJoYW5kbGVyIiwibW9kZSIsInVzZUdsb2JhbEhhbmRsZXJHcm91cGVkIiwidXNlR2xvYmFsSGFuZGxlclNpbmdsZSIsIm1hcFRoaW5nIiwiZG9NYXBUaGluZyIsIm9wIiwib3B0aW9uc0tleSIsImJ5VHlwZSIsImJ5T3B0aW9ucyIsImluZm8iLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsIlNldCIsImFkZFRvTWFwVGhpbmciLCJoIiwiYWRkIiwicmVtb3ZlRnJvbU1hcFRoaW5nIiwic3RhYmxlSGFuZGxlciIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsIl90b3BDaGFuZ2VkIiwiX3N3YXBJbmVydGVkU2libGluZyIsIl9pbmVydFNpYmxpbmdzIiwiX3Jlc3RvcmVJbmVydGVkU2libGluZ3MiLCJfZ2V0UGFyZW50cyIsIl9nZXREaXN0cmlidXRlZENoaWxkcmVuIiwiX2lzSW5lcnRhYmxlIiwiX2hhbmRsZU11dGF0aW9ucyIsIkJsb2NraW5nRWxlbWVudHNJbXBsIiwiX2EiLCJfYiIsIl9jIiwiZGVzdHJ1Y3RvciIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJlbGVtZW50IiwicmVtb3ZlIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsImJvZHkiLCJ0b1NraXAiLCJvbGRJbmVydCIsIm5ld0luZXJ0Iiwic2libGluZ3NUb1Jlc3RvcmUiLCJpbmVydCIsImVsZW1lbnRzIiwibW8iLCJkaXNjb25uZWN0Iiwic2libGluZ3MiLCJwYXJlbnQiLCJpbmVydGVkU2libGluZ3MiLCJNdXRhdGlvbk9ic2VydmVyIiwicGFyZW50VG9PYnNlcnZlIiwibWF5YmVTaGFkeVJvb3QiLCJfX3NoYWR5IiwiaG9zdCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJyZW1vdmVkTm9kZXMiLCJhZGRlZE5vZGVzIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImFzc2lnbmVkU2xvdCIsInNoYWRvd1Jvb3QiLCJub2RlcyIsInNsb3RzIiwicXVlcnlTZWxlY3RvckFsbCIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiJGJsb2NraW5nRWxlbWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIndpbmRvdyIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiX29uTXV0YXRpb24iLCJzdWJ0cmVlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwicmVjb3JkIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsInRhYkluZGV4IiwiaGFzU2F2ZWRUYWJJbmRleCIsImFkZEluZXJ0Um9vdCIsInJlbW92ZUluZXJ0Um9vdCIsIkluZXJ0TWFuYWdlciIsIl9kb2N1bWVudCIsIl93YXRjaEZvckluZXJ0IiwiYWRkSW5lcnRTdHlsZSIsImhlYWQiLCJkb2N1bWVudEVsZW1lbnQiLCJyZWFkeVN0YXRlIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJfaW5lcnRSb290IiwiaW5lcnRFbGVtZW50cyIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsImNvbnRlbnQiLCJkaXN0cmlidXRlZE5vZGVzIiwiZ2V0RGlzdHJpYnV0ZWROb2RlcyIsInNsb3QiLCJfZGlzdHJpYnV0ZWROb2RlcyIsIl9pIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiSFRNTEVsZW1lbnQiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsIm9uQ2hpbGRDb3VudENoYW5nZSIsInJlc3QiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZmllbGQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsImdldENoaWxkcmVuIiwibWF4Iiwic2hhdmUiLCJtYW5hZ2VkQ2hpbGRyZW4iLCJfIiwiZ2V0QXQiLCJhcnJheVNsaWNlIiwicmV0IiwibWFuYWdlZENoaWxkQ29udGV4dCIsIm1hbmFnZWRDaGlsZHJlblJldHVybiIsInVzZU1hbmFnZWRDaGlsZCIsIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMiLCJmbGF0IiwibWFuYWdlZENoaWxkUmV0dXJuIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwicHJldlZhbHVlIiwiZ2V0U3RhdGUiLCJzaGFsbG93RGlmZmVycyIsIlB1cmVDb21wb25lbnQiLCJtZW1vIiwiY29tcGFyZXIiLCJuZXh0UHJvcHMiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX2YiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiUkVBQ1RfRk9SV0FSRF9TWU1CT0wiLCJmb3IiLCJmb3J3YXJkUmVmIiwiRm9yd2FyZGVkIiwiY2xvbmUiLCIkJHR5cGVvZiIsIm1hcEZuIiwib2xkQ2F0Y2hFcnJvciIsIm9sZFVubW91bnQiLCJkZXRhY2hlZENsb25lIiwiZGV0YWNoZWRQYXJlbnQiLCJyZW1vdmVPcmlnaW5hbCIsIm9yaWdpbmFsUGFyZW50IiwiU3VzcGVuc2UiLCJfX3UiLCJfc3VzcGVuZGVycyIsInN1c3BlbmRlZCIsIl9fYSIsIlN1c3BlbnNlTGlzdCIsIl9uZXh0IiwiX21hcCIsIl9fUiIsInByb21pc2UiLCJzdXNwZW5kaW5nVk5vZGUiLCJzdXNwZW5kaW5nQ29tcG9uZW50IiwicmVzb2x2ZWQiLCJvblJlc29sdmVkIiwib25TdXNwZW5zaW9uQ29tcGxldGUiLCJzdXNwZW5kZWRWTm9kZSIsIl9fTyIsIndhc0h5ZHJhdGluZyIsImRldGFjaGVkQ29tcG9uZW50IiwiZmFsbGJhY2siLCJsaXN0IiwicmV2ZWFsT3JkZXIiLCJkZWxlZ2F0ZWQiLCJ1bnN1c3BlbmQiLCJ3cmFwcGVkVW5zdXNwZW5kIiwicmV2ZXJzZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIkNBTUVMX1BST1BTIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJvbGRFdmVudEhvb2siLCJlbXB0eSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsIm5vbkN1c3RvbUVsZW1lbnQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwiY2xhc3NOYW1lIiwib2xkRGlmZmVkIiwiY2xzeCIsImZyZWVHbG9iYWwkMSIsInJvb3QkMSIsIlN5bWJvbCQyIiwiY29yZUpzRGF0YSQxIiwibmF0aXZlQ3JlYXRlJDEiLCJNYXAkMiIsInJldHVybkZhbHNlIiwicnVuSW1tZWRpYXRlbHkiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsInVzZU1lcmdlZENsYXNzZXMiLCJsaHNDbGFzcyIsImxoc0NsYXNzTmFtZSIsInJoc0NsYXNzIiwicmhzQ2xhc3NOYW1lIiwibGhzQ2xhc3NlcyIsInNwbGl0IiwicmhzQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJmcm9tIiwicHJvY2Vzc1JlZiIsInVzZU1lcmdlZFJlZnMiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJmcm9tRW50cmllcyIsInN0YXRlbWVudCIsInVzZU1lcmdlZFN0eWxlcyIsImxvZyIsInVzZU1lcmdlZFByb3BzIiwiYWxsUHJvcHMiLCJ1c2VNZXJnZWRQcm9wczIiLCJrbm93bnMiLCJtZXJnZVVua25vd24iLCJsaHNWYWx1ZSIsInJoc1ZhbHVlIiwibWVyZ2VkIiwibWVyZ2VGdW5jdGlvbnMiLCJsaHNBbGwiLCJyaHNBbGwiLCJsaHNLZXlVIiwibGhzS2V5IiwicmhzS2V5VSIsInJoc0tleSIsImx2IiwicnYiLCJhbGwiLCJ1c2VSZWZFbGVtZW50Iiwib25FbGVtZW50Q2hhbmdlIiwib25Nb3VudCIsIm9uVW5tb3VudCIsInJlZkVsZW1lbnRQYXJhbWV0ZXJzIiwiZ2V0RWxlbWVudCIsInNldEVsZW1lbnQiLCJwcm9wc1N0YWJsZSIsInJlZkVsZW1lbnRSZXR1cm4iLCJ1c2VDaGlsZHJlbkZsYWciLCJpbml0aWFsSW5kZXgiLCJjbG9zZXN0Rml0Iiwib25JbmRleENoYW5nZSIsInNldEF0IiwiaXNWYWxpZCIsImdldEN1cnJlbnRJbmRleCIsInNldEN1cnJlbnRJbmRleCIsImdldFJlcXVlc3RlZEluZGV4Iiwic2V0UmVxdWVzdGVkSW5kZXgiLCJnZXRDbG9zZXN0Rml0IiwicmVxdWVzdGVkSW5kZXgiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsImNsb3Nlc3RJbmRleCIsIm5ld0Rpc3RhbmNlIiwiYWJzIiwicmVldmFsdWF0ZUNsb3Nlc3RGaXQiLCJjdXJyZW50Q2hpbGQiLCJjbG9zZXN0Rml0SW5kZXgiLCJjbG9zZXN0Rml0Q2hpbGQiLCJjaGFuZ2VJbmRleCIsIm5ld01hdGNoaW5nQ2hpbGQiLCJvbGRNYXRjaGluZ0NoaWxkIiwiY2hpbGRJc1ZhbGlkIiwiaXNOYU4iLCJnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uIiwiZXhjbHVzaXZpdHlLZXkiLCJTd2FwcGFibGVDb250ZXh0IiwiZ2V0QW5pbWF0ZU9uTW91bnQiLCJHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIkNzc0NsYXNzQ29udGV4dCIsIkdldEJhc2VDbGFzcyIsIkdldEVudGVyQ2xhc3MiLCJHZXRFeGl0Q2xhc3MiLCJHZXRNZWFzdXJlQ2xhc3MiLCJHZXRJbml0Q2xhc3MiLCJHZXRUcmFuc2l0aW9uQ2xhc3MiLCJHZXRGaW5hbGl6ZUNsYXNzIiwidXNlQ3NzQ2xhc3NlcyIsIkdldERpcmVjdGlvbkNsYXNzIiwiZGlyZWN0aW9uIiwiR2V0UGhhc2VDbGFzcyIsInBoYXNlIiwiZ2xvYmFsQ291bnQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIiLCJnZXROZXh0SW5kZXhJbkxpbmUiLCJzZXROZXh0SW5kZXhJbkxpbmUiLCJtIiwic2V0RXhjbHVzaXZlbHlPcGVuIiwiZ2V0RXhjbHVzaXZlbHlPcGVuIiwib25WaXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJsZSIsIm5leHRJbkxpbmUiLCJjdXJyZW50SW5MaW5lIiwiZm9yY2VDbG9zZSIsImNvbnRleHQyIiwiZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIl9qc3giLCJ1c2VFeGNsdXNpdmVUcmFuc2l0aW9uIiwidHJhbnNpdGlvblBhcmFtZXRlcnMiLCJzaG93IiwiZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMiLCJleGNsdXNpdmVseU9wZW4iLCJwYXJlbnRPblZpc0NoYW5nZSIsImV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm4iLCJpc0V4Y2x1c2l2ZSIsImZvcndhcmRFbGVtZW50UmVmIiwiRm9yd2FyZGVkQ29tcG9uZW50IiwidXNlTGFzdE5vbk51bGxWYWx1ZSIsImxhc3ROb25OdWxsVmFsdWUiLCJ1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyIsIm90aGVyUHJvcHMiLCJpbmxpbmUiLCJTd2FwcGFibGUiLCJjaGlsZHJlbkFuaW1hdGVPbk1vdW50IiwiaW5saW5lRWxlbWVudHMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtZXJnZWRXaXRoQ2hpbGRyZW4iLCJhbmltYXRlT25Nb3VudCIsImdldFRpbWVvdXREdXJhdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic3RyIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJwYXJzZVN0YXRlIiwibmV4dFN0YXRlIiwidXNlVHJhbnNpdGlvbiIsInByb3BzSW5jb21pbmciLCJtZWFzdXJlIiwiZXhpdFZpc2liaWxpdHkiLCJkdXJhdGlvbiIsImRlbGF5TW91bnRVbnRpbFNob3duIiwiZWFzaW5nIiwiZWFzaW5nSW4iLCJlYXNpbmdPdXQiLCJnZXRFeGl0VmlzaWJpbGl0eSIsImdldE1lYXN1cmUiLCJleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZSIsImludGVybmFsT25TaG93Q2hhbmdlZCIsImNzc1Byb3BlcnRpZXMiLCJjbGFzc05hbWVzIiwiaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkIiwidGltZW91dEhhbmRsZSIsInRpbWVvdXRDbGVhckZ1bmN0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwiZWxhcHNlZFRpbWUiLCJoYXNNb3VudGVkIiwidXBkYXRlQ2xhc3NlcyIsImFsbENsYXNzZXNUb1JlbW92ZSIsImFsbENsYXNzZXNUb0FkZCIsImNsYXNzTGlzdCIsInVwZGF0ZVNpemVQcm9wZXJ0eSIsInZhck5hbWUiLCJyZW1vdmVQcm9wZXJ0eSIsIm1lYXN1cmVFbGVtZW50QW5kVXBkYXRlUHJvcGVydGllcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsIm9uU3RhdGVDaGFuZ2UiLCJwcmV2U3RhdGUiLCJuZXh0RGlyZWN0aW9uIiwibmV4dFBoYXNlIiwiaXNCZWluZ1BhaW50ZWQiLCJmb3JjZVJlZmxvdyIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50UGhhc2UiLCJkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiIsImhhc1JlbmRlcmVkQ2hpbGRyZW4iLCJyZW5kZXJDaGlsZHJlbiIsImNoaWxkcmVuSXNWbm9kZSIsImZpbmFsUHJvcHMiLCJyZXNldENvbnRleHQiLCJtb2RpZmllZENoaWxkcmVuIiwiZ2xvYmFsVGhpcyIsIl9kdW1teSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJ1c2VCYXNlUHJvcHNGYWRlIiwiZmFkZVBhcmFtZXRlcnMiLCJmYWRlTWluIiwiZmFkZU1heCIsIkZhZGUiLCJ1c2VCYXNlUHJvcHNDbGlwIiwiY2xpcFBhcmFtZXRlcnMiLCJjbGlwTWluIiwiY2xpcE1pbkJsb2NrIiwiY2xpcE1pbklubGluZSIsImNsaXBPcmlnaW4iLCJjbGlwT3JpZ2luQmxvY2siLCJjbGlwT3JpZ2luSW5saW5lIiwiQ2xpcCIsIkNsaXBGYWRlIiwidXNlQmFzZVByb3BzQ29sbGFwc2UiLCJjb2xsYXBzZVBhcmFtZXRlcnMiLCJtaW5CbG9ja1NpemUiLCJDb2xsYXBzZSIsIkNvbGxhcHNlRmFkZSIsInVzZUJhc2VQcm9wc0ZsaXAiLCJmbGlwUGFyYW1ldGVycyIsImZsaXBBbmdsZUJsb2NrIiwiZmxpcEFuZ2xlSW5saW5lIiwiZmxpcFBlcnNwZWN0aXZlIiwiRmxpcCIsInVzZUJhc2VQcm9wc1NsaWRlIiwic2xpZGVQYXJhbWV0ZXJzIiwic2xpZGVUYXJnZXRJbmxpbmUiLCJzbGlkZVRhcmdldEJsb2NrIiwiU2xpZGUiLCJTbGlkZUZhZGUiLCJ1c2VCYXNlUHJvcHNab29tIiwiem9vbVBhcmFtZXRlcnMiLCJ6b29tT3JpZ2luIiwiem9vbU9yaWdpbklubGluZSIsInpvb21PcmlnaW5CbG9jayIsInpvb21NaW4iLCJ6b29tTWluSW5saW5lIiwiem9vbU1pbkJsb2NrIiwiWm9vbSIsIlNsaWRlWm9vbSIsIlNsaWRlWm9vbUZhZGUiLCJab29tRmFkZSIsIl9fUFJFQUNUX0RFVlRPT0xTX18iLCJhdHRhY2hQcmVhY3QiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJyZXNldFByb3BXYXJuaW5ncyIsImdldERpc3BsYXlOYW1lIiwicmVuZGVyU3RhY2siLCJvd25lclN0YWNrIiwiZ2V0Q3VycmVudFZOb2RlIiwiaGFzQmFiZWxQbHVnaW4iLCJpc1Bvc3NpYmxlT3duZXIiLCJnZXRPd25lclN0YWNrIiwic3RhY2siLCJuZXh0IiwiX19vIiwicmVkdWNlIiwiYWNjIiwib3duZXIiLCJzb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJpc1dlYWtNYXBTdXBwb3J0ZWQiLCJnZXRDbG9zZXN0RG9tTm9kZVBhcmVudCIsInNlcmlhbGl6ZVZOb2RlIiwiYXR0cnMiLCJwcm9wIiwib2xkRGlmZiIsIm9sZFJvb3QiLCJvbGRSZW5kZXIiLCJzZXR1cENvbXBvbmVudFN0YWNrIiwiaG9va3NBbGxvd2VkIiwib2xkVm5vZGUiLCJvbGRIb29rIiwid2FybmVkQ29tcG9uZW50cyIsImxhenlQcm9wVHlwZXMiLCJkZXByZWNhdGlvbnMiLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudE5hbWUiLCJwcm9wVHlwZXMiLCJsYXp5Vk5vZGUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJtZXNzYWdlIiwicHJvcGVydHkiLCJkZXByZWNhdGVkQXR0cmlidXRlcyIsIm5vZGVOYW1lIiwiZGVwcmVjYXRlZFByb3RvIiwiY3JlYXRlIiwiX19wcm90b19fIiwiaW5pdERlYnVnIiwidXNlVXJsIiwib25VcmxDaGFuZ2UiLCJnZXRVcmwiLCJzZXRVcmwiLCJ0cmltSGFzaCIsImhhc2giLCJzdGFydHNXaXRoIiwic3Vic3RyIiwibm9ybWFsaXplSGFzaFRvUGF0aCIsInNldEVudGlyZUhhc2giLCJvbGRVUkwiLCJuZXh0VXJsIiwiVVJMIiwiaGlzdG9yeSIsInRpdGxlIiwiZGlzcGF0Y2hFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsIm5ld1VSTCIsInVucGFyc2VQYXJhbSIsInBhcmFtcyIsInBhcnNlUGFyYW0iLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJwYXJzZWQiLCJpc0Zpbml0ZSIsIkJpZ0ludCIsInVzZUNvbnN1bWVSb3V0ZXIiLCJjb25zdW1lUm91dGVyUGFyYW1ldGVycyIsIm9uTG9jYWxQYXRoQ2hhbmdlIiwibG9jYWxQYXRoIiwid2FudGVkTG9jYWxQYXRoIiwicm91dGVyQ29udGV4dCIsImxldmVsIiwibm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQiLCJhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MiLCJzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MiLCJwYXRoV2hlbk1hdGNoaW5nIiwic2V0UGF0aFdoZW5NYXRjaGluZyIsImFueU1hdGNoZXMiLCJvbkxvY2FsUGF0aENoYW5nZTIiLCJnZXRMb2NhbFBhdGgiLCJwYXRoIiwicGF0aENvbXBhcmUiLCJzZXRNYXRjaGVzIiwic2V0TG9jYWxQYXRoIiwidXNlTG9jYWxQYXRoIiwiY29uc3VtZVJvdXRlclJldHVybiIsImxvY2FsUm91dGVQYXJhbWV0ZXJzIiwicHJldiIsInVybFRvUGF0aCIsIm9sZEhhc2hQYXRoIiwiaHJlZiIsInJlcXVlc3RlZExvY2FsSGFzaCIsIlJvb3RSb3V0ZXJFcnJvciIsInVzZVBvcExvY2FsUGF0aCIsImRpciIsInBvcExvY2FsUGF0aCIsIm5ld0hhc2hQYXRoIiwidXNlUHVzaExvY2FsUGF0aCIsInB1c2hMb2NhbEhhc2giLCJrZWVwVHJhaWxpbmciLCJ1c2VTZXRMb2NhbFBhdGgiLCJ1c2VSb3V0ZXJDb250cm9scyIsInB1c2hMb2NhbFBhdGgiLCJSb3V0ZXJDb250ZXh0IiwidXNlUHJvdmlkZVJvdXRlciIsIm1hdGNoaW5nSW5kaWNlcyIsImdldFNob3dpbmdEZWZhdWx0Iiwic2V0U2hvd2luZ0RlZmF1bHQiLCJzaG93aW5nRGVmYXVsdCIsIm9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkIiwiUm91dGVyIiwiY29udGV4dEZyb21QYXJlbnQiLCJjb250cm9scyIsInVzZVNlYXJjaFBhcmFtcyIsInBhcmFtS2V5Iiwib25QYXJhbVZhbHVlQ2hhbmdlZCIsImdldFNhdmVkUGFyYW1WYWx1ZSIsInNldFNhdmVkUGFyYW1WYWx1ZSIsInNldFBhcmFtV2l0aEhpc3RvcnkiLCJuZXdWYWx1ZU9yVXBkYXRlciIsIm5ld1BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsInByZXR0eVByaW50UGFyYW1zIiwibmV3UGFyYW0iLCJwYXJhbUFycmF5IiwicXVlcnlTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJleGFtcGxlIiwic2V0RXhhbXBsZUxvY2FsIiwiZ2V0RXhhbXBsZSIsInNldEV4YW1wbGUiLCJfanN4cyIsIm9uQ2xpY2siLCJkaXNhYmxlZCIsIm9uSW5wdXQiLCJjdXJyZW50VGFyZ2V0IiwidmFsdWVBc051bWJlciIsIkxldmVsMSIsIl9GcmFnbWVudCIsImdldEVsZW1lbnRCeUlkIl0sIm1hcHBpbmdzIjoiOzs7RUEwQmFBLElBQUFBLENBQUFBO0lDZlBDLEdDUkZDO0lBQUFBLEdBQUFBO0lDeUtBQyxHQUFBQTtJQVdBQztJQUVFQyxHQ3ZMS0M7SUFBQUEsR0FBQUE7SUNGRUMsR0FBWSxHQUFBO0lBQ1pDLEdBQVksR0FBQSxFQUFBO0lB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
