(function () {
  'use strict';

  var n,
    l$2,
    u$2,
    t$1,
    r$3,
    o$3,
    f$2,
    e$1,
    c$2 = {},
    s$2 = [],
    a$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h$2(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function v$2(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function y$2(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return p$2(l, f, t, r, null);
  }
  function p$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$2 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function _$2(n) {
    return n.children;
  }
  function k$2(n, l) {
    this.props = n, this.context = l;
  }
  function b$1(n, l) {
    if (null == l) return n.__ ? b$1(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? b$1(n) : null;
  }
  function g$2(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return g$2(n);
    }
  }
  function m$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !w$2.__r++ || r$3 !== l$2.debounceRendering) && ((r$3 = l$2.debounceRendering) || o$3)(w$2);
  }
  function w$2() {
    var n, l, u, i, r, o, e, c;
    for (t$1.sort(f$2); n = t$1.shift();) n.__d && (l = t$1.length, i = void 0, r = void 0, e = (o = (u = n).__v).__e, (c = u.__P) && (i = [], (r = h$2({}, o)).__v = o.__v + 1, L$1(c, o, r, u.__n, void 0 !== c.ownerSVGElement, null != o.__h ? [e] : null, i, null == e ? b$1(o) : e, o.__h), M(i, o), o.__e != e && g$2(o)), t$1.length > l && t$1.sort(f$2));
    w$2.__r = 0;
  }
  function x$1(n, l, u, i, t, r, o, f, e, a) {
    var h,
      v,
      y,
      d,
      k,
      g,
      m,
      w = i && i.__k || s$2,
      x = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (d = u.__k[h] = null == (d = l[h]) || "boolean" == typeof d || "function" == typeof d ? null : "string" == typeof d || "number" == typeof d || "bigint" == typeof d ? p$2(null, d, null, null, d) : Array.isArray(d) ? p$2(_$2, {
      children: d
    }, null, null, null) : d.__b > 0 ? p$2(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {
      if (d.__ = u, d.__b = u.__b + 1, null === (y = w[h]) || y && d.key == y.key && d.type === y.type) w[h] = void 0;else for (v = 0; v < x; v++) {
        if ((y = w[v]) && d.key == y.key && d.type === y.type) {
          w[v] = void 0;
          break;
        }
        y = null;
      }
      L$1(n, d, y = y || c$2, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (m || (m = []), y.ref && m.push(y.ref, null, d), m.push(v, d.__c || k, d)), null != k ? (null == g && (g = k), "function" == typeof d.type && d.__k === y.__k ? d.__d = e = A$1(d, e, n) : e = C$1(n, d, y, w, k, e), "function" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = b$1(y));
    }
    for (u.__e = g, h = x; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = $$1(i).nextSibling), S(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) O(m[h], m[++h], m[++h]);
  }
  function A$1(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? A$1(i, l, u) : C$1(u, i, i, t, i.__e, l));
    return l;
  }
  function P(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      P(n, l);
    }) : l.push(n)), l;
  }
  function C$1(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function $$1(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = $$1(u))) return i;
    return null;
  }
  function H$1(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || T$2(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || T$2(n, r, l[r], u[r], i);
  }
  function I$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a$2.test(l) ? u : u + "px";
  }
  function T$2(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || I$1(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || I$1(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? z$1 : j$1, r) : n.removeEventListener(l, r ? z$1 : j$1, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function j$1(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function z$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function L$1(n, u, i, t, r, o, f, e, c) {
    var s,
      a,
      v,
      y,
      p,
      d,
      b,
      g,
      m,
      w,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], w = s ? m ? m.props.value : s.__ : t, i.__c ? b = (a = u.__c = i.__c).__ = a.__E : ("prototype" in I && I.prototype.render ? u.__c = a = new I(g, w) : (u.__c = a = new k$2(g, w), a.constructor = I, a.render = q$2), m && m.sub(a), a.props = g, a.state || (a.state = {}), a.context = w, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != I.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h$2({}, a.__s)), h$2(a.__s, I.getDerivedStateFromProps(g, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == I.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(g, w), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(g, a.__s, w) || u.__v === i.__v) {
            for (u.__v !== i.__v && (a.props = g, a.state = a.__s, a.__d = !1), a.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < a._sb.length; A++) a.__h.push(a._sb[A]);
            a._sb = [], a.__h.length && f.push(a);
            break n;
          }
          null != a.componentWillUpdate && a.componentWillUpdate(g, a.__s, w), null != a.componentDidUpdate && a.__h.push(function () {
            a.componentDidUpdate(y, p, d);
          });
        }
        if (a.context = w, a.props = g, a.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (a.state = a.__s, a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), $ = 0; $ < a._sb.length; $++) a.__h.push(a._sb[$]);
          a._sb = [];
        } else do {
          a.__d = !1, P && P(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;
        } while (a.__d && ++C < 25);
        a.state = a.__s, null != a.getChildContext && (t = h$2(h$2({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === _$2 && null == s.key ? s.props.children : s, x$1(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), b && (a.__E = a.__ = null), a.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = N$1(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function M(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function N$1(l, u, i, t, r, o, f, e) {
    var s,
      a,
      h,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, e = !1;
    }
    if (null === d) y === p || e && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || c$2).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || ""));
      }
      if (H$1(l, p, y, r, e), h) u.__k = [];else if (_ = u.props.children, x$1(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && b$1(i, 0), e), null != o) for (_ = o.length; _--;) null != o[_] && v$2(o[_]);
      e || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && T$2(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && T$2(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function O(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function S(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || O(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && S(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || v$2(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function q$2(n, l, u) {
    return this.constructor(n, u);
  }
  function B$2(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], L$1(i, u = (!r && t || i).__k = y$2(_$2, null, [u]), o || c$2, c$2, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), M(f, u);
  }
  function E(l, u, i) {
    var t,
      r,
      o,
      f = h$2({}, l.props);
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p$2(l.type, f, t || l.key, r || l.ref, null);
  }
  function F$2(n, l) {
    var u = {
      __c: l = "__cC" + e$1++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(function (n) {
            n.__e = !0, m$1(n);
          });
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = s$2.slice, l$2 = {
    __e: function (n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$2 = 0, k$2.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h$2({}, this.state), "function" == typeof n && (n = n(h$2({}, u), this.props)), n && h$2(u, n), null != n && this.__v && (l && this._sb.push(l), m$1(this));
  }, k$2.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
  }, k$2.prototype.render = _$2, t$1 = [], o$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$2 = function (n, l) {
    return n.__v.__b - l.__v.__b;
  }, w$2.__r = 0, e$1 = 0;
  var _$1 = 0;
  function o$2(o, e, n, t, f, l) {
    var s,
      u,
      a = {};
    for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
    var i = {
      type: o,
      props: a,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: l
    };
    if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
    return l$2.vnode && l$2.vnode(i), i;
  }
  var t,
    r$2,
    u$1,
    i$1,
    o$1 = 0,
    f$1 = [],
    c$1 = [],
    e = l$2.__b,
    a$1 = l$2.__r,
    v$1 = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d$1(t, u) {
    l$2.__h && l$2.__h(r$2, t, o$1 || u), o$1 = 0;
    var i = r$2.__H || (r$2.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c$1
    }), i.__[t];
  }
  function h$1(n) {
    return o$1 = 1, s$1(B$1, n);
  }
  function s$1(n, u, i) {
    var o = d$1(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$2, !r$2.u)) {
      var f = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !c || c.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
      };
      r$2.u = !0;
      var c = r$2.shouldComponentUpdate,
        e = r$2.componentWillUpdate;
      r$2.componentWillUpdate = function (n, t, r) {
        if (this.__e) {
          var u = c;
          c = void 0, f(n, t, r), c = u;
        }
        e && e.call(this, n, t, r);
      }, r$2.shouldComponentUpdate = f;
    }
    return o.__N || o.__;
  }
  function p$1(u, i) {
    var o = d$1(t++, 3);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__H.__h.push(o));
  }
  function y$1(u, i) {
    var o = d$1(t++, 4);
    !l$2.__s && z(o.__H, i) && (o.__ = u, o.i = i, r$2.__h.push(o));
  }
  function _(n) {
    return o$1 = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o$1 = 6, y$1(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d$1(t++, 7);
    return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o$1 = 8, F$1(function () {
      return n;
    }, t);
  }
  function q$1(n) {
    var u = r$2.context[n.__c],
      i = d$1(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$2)), u.props.value) : n.__;
  }
  function b() {
    for (var t; t = f$1.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$2 = null, e && e(n);
  }, l$2.__r = function (n) {
    a$1 && a$1(n), t = 0;
    var i = (r$2 = n.__c).__H;
    i && (u$1 === r$2 ? (i.__h = [], r$2.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c$1, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u$1 = r$2;
  }, l$2.diffed = function (t) {
    v$1 && v$1(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f$1.push(o) && i$1 === l$2.requestAnimationFrame || ((i$1 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c$1 && (n.__ = n.__V), n.i = void 0, n.__V = c$1;
    })), u$1 = r$2 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$2,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$2 = t;
  }
  function w$1(n) {
    var t = r$2;
    n.__c = n.__(), r$2 = t;
  }
  function z(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  function getBuildModeUnmemoized$1() {
    try {
      if (process.env.NODE_ENV === "development") return "development";
      return "production";
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode$1 = getBuildModeUnmemoized$1; //memoize(getBuildModeUnmemoized) as typeof getBuildModeUnmemoized;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }
  let timeoutHandle = null;
  function callCountU(hook) {
    var _window, _window$_hookCallCoun, _window$_hookCallCoun2, _window$_hookCallCoun3;
    const name = hook.name;
    if (filters.has(name)) return;
    console.assert(name.length > 0);
    (_window$_hookCallCoun = (_window = window)._hookCallCount) !== null && _window$_hookCallCoun !== void 0 ? _window$_hookCallCoun : _window._hookCallCount = {
      callCounts: {}
    };
    (_window$_hookCallCoun3 = (_window$_hookCallCoun2 = window._hookCallCount.callCounts)[name]) !== null && _window$_hookCallCoun3 !== void 0 ? _window$_hookCallCoun3 : _window$_hookCallCoun2[name] = {
      moment: 0,
      total: 0
    };
    window._hookCallCount.callCounts[name].moment += 1;
    window._hookCallCount.callCounts[name].total += 1;
    if (timeoutHandle == null) {
      timeoutHandle = requestIdleCallback(() => {
        //console.log((window as WindowWithHookCallCount)._hookCallCount.callCountsMoment);
        //(window as WindowWithHookCallCount)._hookCallCount.callCountsMoment = {};
        const o = Object.entries(window._hookCallCount.callCounts).map(_ref => {
          let [hook, counts] = _ref;
          return {
            Hook: hook || "?",
            Now: (counts === null || counts === void 0 ? void 0 : counts.moment) || 0,
            Total: (counts === null || counts === void 0 ? void 0 : counts.total) || 0
          };
        }).filter(_ref2 => {
          let {
            Now
          } = _ref2;
          return !!Now;
        }).sort((_ref3, _ref4) => {
          let {
            Now: lhsM
          } = _ref3;
          let {
            Now: rhsM
          } = _ref4;
          if (!lhsM && !rhsM) return 0;
          lhsM || (lhsM = Infinity);
          rhsM || (rhsM = Infinity);
          return lhsM - rhsM;
        });
        console.table(o, ['Hook', 'Now', 'Total']);
        Object.entries(window._hookCallCount.callCounts).forEach(_ref5 => {
          let [, counts] = _ref5;
          counts.moment = 0;
        });
        timeoutHandle = null;
      });
    }
  }
  const filters = new Set();
  const monitorCallCount = getBuildMode$1() == "development" ? callCountU : noop;

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability$1(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    if (getBuildMode$1() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering$1(f) {
    var _l$2$debounceRenderin;
    ((_l$2$debounceRenderin = l$2.debounceRendering) !== null && _l$2$debounceRenderin !== void 0 ? _l$2$debounceRenderin : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState$1(onChange, getInitialValue, customDebounceRendering) {
    monitorCallCount(usePassiveState$1);
    const valueRef = _(Unset$3);
    const reasonRef = _(Unset$3);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$3);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability$1("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$3 && getInitialValue != undefined) {
        try {
          var _onChange;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$3) tryEnsureValue();
      return valueRef.current === Unset$3 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$3 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$3 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering$1)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$3 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$3;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$3 = Symbol();
  function returnNull$1() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately$1(f) {
    f();
  }
  function useMergedChildren$1(lhs, rhs) {
    monitorCallCount(useMergedChildren$1);
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }
  function r$1(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx$1() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses$1(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    monitorCallCount(useMergedClasses$1);
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx$1(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx$1(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64$1(value) {
    return Table$1[value];
  }
  function random6Bits$1() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits$1() {
    return [random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * because useBeforeLayoutEffect also needs random IDs for its own reasons)
   */
  function generateRandomId$1(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits$1().map(n => base64$1(n)).join(""));
  }
  const toRun$1 = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  //
  // Also, in theory this could be replaced with `useInsertionEffect`,
  // but that probably won't be available in Preact for awhile.
  const commitName$1 = "diffed";
  const newCommit$1 = function (vnode) {
    for (const [id, effectInfo] of toRun$1) {
      const oldInputs = effectInfo.prevInputs;
      if (argsChanged$1(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        effectInfo.prevInputs = effectInfo.inputs;
      }
    }
    toRun$1.clear();
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    originalCommit$1 === null || originalCommit$1 === void 0 ? void 0 : originalCommit$1(vnode, ...args);
  };
  const originalCommit$1 = l$2[commitName$1];
  l$2[commitName$1] = newCommit$1;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect$1(effect, inputs) {
    monitorCallCount(useBeforeLayoutEffect$1);
    const [id] = h$1(() => generateRandomId$1());
    if (effect) toRun$1.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun$1.delete(id);
    p$1(() => {
      return () => {
        toRun$1.delete(id);
      };
    }, [id]);
  }
  function argsChanged$1(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset$2 = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter$1(value) {
    monitorCallCount(useStableGetter$1);
    const ref = _(Unset$2);
    useBeforeLayoutEffect$1(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset$2) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject$1(t) {
    const e = Object.entries(t);
    useEnsureStability$1("useStableObject", e.length, ...e.map(_ref6 => {
      let [_k, v] = _ref6;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map$1 = new WeakMap();
  function isStableGetter$1(obj) {
    var _map$1$get;
    return (_map$1$get = map$1.get(obj)) !== null && _map$1$get !== void 0 ? _map$1$get : false;
  }
  function setIsStableGetter$1(obj) {
    map$1.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback$1(fn, noDeps) {
    monitorCallCount(useStableCallback$1);
    useEnsureStability$1("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter$1(fn));
    if (isStableGetter$1(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter$1(fn);
      return setIsStableGetter$1(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter$1(T$1(fn, []));
    }
  }
  function processRef$1(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs$1(rhs, lhs) {
    monitorCallCount(useMergedRefs$1);
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback$1(function combined(current) {
      processRef$1(current, lhs);
      processRef$1(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject$1(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles$1(lhs, rhs) {
    monitorCallCount(useMergedStyles$1);
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles$1(styleStringToObject$1(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles$1(lhs, styleStringToObject$1(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log$1 = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps$1() {
    monitorCallCount(useMergedProps$1);
    for (var _len3 = arguments.length, allProps = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      allProps[_key3] = arguments[_key3];
    }
    useEnsureStability$1("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2$1(ret, nextProps);
    }
    return ret;
  }
  const knowns$1 = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown$1(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions$1(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log$1 === null || log$1 === void 0 ? void 0 : log$1("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2$1(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs$1(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles$1(lhsAll.style, rhsAll.style),
      className: useMergedClasses$1(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren$1(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns$1.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns$1.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown$1(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions$1(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren$1(parentParameters) {
    monitorCallCount(useManagedChildren$1);
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildrenCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability$1("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildrenCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildrenCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) {
          if (f(child) == 'break') return;
        }
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) if (f(child) == 'break') return;
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering$1(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildrenCountChange || onChildrenMountChange) {
          debounceRendering$1(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildrenCountChange === null || onChildrenCountChange === void 0 ? void 0 : onChildrenCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject$1({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject$1({
        managedChildContext: useStableObject$1({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild$1(_ref7) {
    let {
      context,
      info
    } = _ref7;
    monitorCallCount(useManagedChild$1);
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = context !== null && context !== void 0 ? context : {
      managedChildContext: {}
    };
    const index = info.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...info
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...info
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState$1(initialState) {
    monitorCallCount(useState$1);
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * `"mode"` controls if there's one handler that calls all your functions (default), or one handler added per function (`"single"`).
   *
   * The default, `"grouped"`, is faster when you have, say, a button component, used hundreds of times on a page, that each installs a global event handler.
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options, mode) {
    monitorCallCount(useGlobalHandler);
    mode || (mode = "grouped");
    useEnsureStability$1("useGlobalHandler", mode);
    if (mode === "grouped") {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      useGlobalHandlerGrouped(target, type, handler, options);
    } else {
      useGlobalHandlerSingle(target, type, handler, options);
    }
  }
  let mapThing = new Map();
  function doMapThing(op, target, type, handler, options) {
    if (handler) {
      const optionsKey = JSON.stringify(options);
      const byType = mapThing.get(target) || new Map();
      const byOptions = byType.get(type) || new Map();
      const info = byOptions.get(optionsKey) || {
        listener: null,
        listeners: new Set()
      };
      op(info, handler);
      byOptions.set(optionsKey, info);
      byType.set(type, byOptions);
      mapThing.set(target, byType);
    }
  }
  function addToMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.add(h);
      if (info.listener == null) target.addEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  function removeFromMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.delete(h);
      if (info.listener == null) target.removeEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  /**
   * This is way faster for large numbers of event handlers.
   *
   * For example, if every button listens for a global click, or something,
   * it would be nice if it was efficient at least.
   */
  function useGlobalHandlerGrouped(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        addToMapThing(target, type, stableHandler, options);
        return () => removeFromMapThing(target, type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }
  function useGlobalHandlerSingle(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    p$1(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: ElementProps<E>[]): ElementProps<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement$1(args) {
    monitorCallCount(useRefElement$1);
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability$1("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState$1(handler, returnNull$1, runImmediately$1);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      propsStable: propsStable.current,
      refElementReturn: {
        getElement
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck$1(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass$1(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck$1(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass$1(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck$1(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass$1(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();
  function g(n, t) {
    for (var e in t) n[e] = t[e];
    return n;
  }
  function C(n, t) {
    for (var e in n) if ("__source" !== e && !(e in t)) return !0;
    for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function x(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, y$2(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new k$2()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var R = l$2.__b;
  l$2.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$2.__e;
  l$2.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    T(n, t, e, r);
  };
  var I = l$2.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$2.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new k$2()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && y$2(_$2, null, n.fallback);
    return i && (i.__h = null), [y$2(_$2, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) e.pop()();
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  (V.prototype = new k$2()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = P(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var B = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    H = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
    Y = /[A-Z0-9]/g,
    $ = "undefined" != typeof document,
    q = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n);
    };
  k$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(k$2.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var K = l$2.event;
  function Q() {}
  function X() {
    return this.cancelBubble;
  }
  function nn() {
    return this.defaultPrevented;
  }
  l$2.event = function (n) {
    return K && (n = K(n)), n.persist = Q, n.isPropagationStopped = X, n.isDefaultPrevented = nn, n.nativeEvent = n;
  };
  var en = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    rn = l$2.vnode;
  l$2.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      for (var o in u = {}, e) {
        var i = e[o];
        if (!("value" === o && "defaultValue" in e && null == i || $ && "children" === o && "noscript" === t)) {
          var l = o.toLowerCase();
          "defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : "ondoubleclick" === l ? o = "ondblclick" : "onchange" !== l || "input" !== t && "textarea" !== t || q(e.type) ? "onfocus" === l ? o = "onfocusin" : "onblur" === l ? o = "onfocusout" : Z.test(o) ? o = l : -1 === t.indexOf("-") && H.test(o) ? o = o.replace(Y, "-$&").toLowerCase() : null === i && (i = void 0) : l = o = "oninput", "oninput" === l && u[o = l] && (o = "oninputCapture"), u[o] = i;
        }
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = P(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = P(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (en.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", en));
    }
    n.$$typeof = B, rn && rn(n);
  };
  var un = l$2.__r;
  l$2.__r = function (n) {
    un && un(n), n.__c;
  };
  var on = l$2.diffed;
  l$2.diffed = function (n) {
    on && on(n);
    var t = n.props,
      e = n.__e;
    null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value);
  };

  /**
   * Easy access to an HTMLElement that can be controlled imperatively.
   *
   * The HTMLElement rendered is controlled by the `tag` prop (e.g. "span", "div").
   *
   * The `handle` prop should be e.g. `useRef<ImperativeHandle<HTMLDivElement>>(null)`
   */
  x(k(ImperativeElementU));
  function useImperativeProps(_ref8) {
    let {
      refElementReturn: {
        getElement
      }
    } = _ref8;
    monitorCallCount(useImperativeProps);
    const currentImperativeProps = _({
      className: new Set(),
      style: {},
      children: null,
      others: {}
    });
    const hasClass = T$1(cls => {
      return currentImperativeProps.current.className.has(cls);
    }, []);
    const setClass = T$1((cls, enabled) => {
      if (hasClass(cls) == !enabled) {
        var _getElement;
        (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.classList[enabled ? "add" : "remove"](cls);
        currentImperativeProps.current.className[enabled ? "add" : "delete"](cls);
      }
    }, []);
    const setStyle = T$1((prop, value) => {
      const element = getElement();
      if (element) {
        if (currentImperativeProps.current.style[prop] != value) {
          currentImperativeProps.current.style[prop] = value;
          if (prop.startsWith("--")) {
            if (value != null) element.style.setProperty(prop, "".concat(value));else element.style.removeProperty(prop);
          } else {
            element.style[prop] = value !== null && value !== void 0 ? value : "";
          }
        }
      }
    }, []);
    const setChildren = T$1(children => {
      let e = getElement();
      if (e && currentImperativeProps.current.children != children) {
        currentImperativeProps.current.children = children;
        e.textContent = children;
      }
    }, []);
    const getAttribute = T$1(prop => {
      return currentImperativeProps.current.others[prop];
    }, []);
    const setAttribute = T$1((prop, value) => {
      if (value != null) {
        var _getElement2;
        currentImperativeProps.current.others[prop] = value;
        (_getElement2 = getElement()) === null || _getElement2 === void 0 ? void 0 : _getElement2.setAttribute(prop, value);
      } else {
        var _getElement3;
        delete currentImperativeProps.current.others[prop];
        (_getElement3 = getElement()) === null || _getElement3 === void 0 ? void 0 : _getElement3.removeAttribute(prop);
      }
    }, []);
    const setEventHandler = T$1((type, handler, options) => {
      const element = getElement();
      const mappedKey = EventMapping[type];
      if (element) {
        if (handler) {
          element.addEventListener(type, handler, options);
          currentImperativeProps.current.others[mappedKey] = handler;
        } else if (currentImperativeProps.current.others[mappedKey]) {
          element.removeEventListener(type, currentImperativeProps.current.others[mappedKey], options);
          currentImperativeProps.current.others[mappedKey] = undefined;
        }
      }
    }, []);
    return {
      imperativeHandle: _({
        hasClass,
        setClass,
        setStyle,
        getAttribute,
        setAttribute,
        setEventHandler,
        setChildren
      }).current,
      props: useMergedProps$1({
        className: [...currentImperativeProps.current.className].join(" "),
        style: currentImperativeProps.current.style
      }, currentImperativeProps.current.others)
    };
  }
  function ImperativeElementU(_ref9, ref) {
    let {
      tag: Tag,
      handle,
      ...props
    } = _ref9;
    const {
      propsStable,
      refElementReturn
    } = useRefElement$1({
      refElementParameters: {}
    });
    const {
      props: iprops,
      imperativeHandle
    } = useImperativeProps({
      refElementReturn
    });
    A(handle, () => imperativeHandle);
    return y$2(Tag, useMergedProps$1(propsStable, iprops, props, {
      ref
    }));
  }
  const EventMapping = {
    abort: "onAbort",
    animationend: "onAnimationEnd",
    animationstart: "onAnimationStart",
    animationiteration: "onAnimationIteration",
    beforeinput: "onBeforeInput",
    blur: "onBlur",
    canplay: "onCanPlay",
    canplaythrough: "onCanPlayThrough",
    change: "onChange",
    click: "onClick",
    compositionend: "onCompositionEnd",
    compositionstart: "onCompositionStart",
    compositionupdate: "onCompositionUpdate",
    contextmenu: "onContextMenu",
    cut: "onCut",
    dblclick: "onDblClick",
    drag: "onDrag",
    dragend: "onDragEnd",
    dragenter: "onDragEnter",
    dragleave: "onDragLeave",
    dragover: "onDragOver",
    dragstart: "onDragStart",
    drop: "onDrop",
    durationchange: "onDurationChange",
    emptied: "onEmptied",
    ended: "onEnded",
    error: "onError",
    focus: "onFocus",
    focusin: "onfocusin",
    focusout: "onfocusout",
    formdata: "onFormData",
    gotpointercapture: "onGotPointerCapture",
    input: "onInput",
    invalid: "onInvalid",
    keydown: "onKeyDown",
    keypress: "onKeyPress",
    keyup: "onKeyUp",
    load: "onLoad",
    loadeddata: "onLoadedData",
    loadedmetadata: "onLoadedMetadata",
    loadstart: "onLoadStart",
    lostpointercapture: "onLostPointerCapture",
    mousedown: "onMouseDown",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseover: "onMouseOver",
    mouseup: "onMouseUp",
    paste: "onPaste",
    pause: "onPause",
    play: "onPlay",
    playing: "onPlaying",
    pointercancel: "onPointerCancel",
    pointerdown: "onPointerDown",
    pointerenter: "onPointerEnter",
    pointerleave: "onPointerLeave",
    pointermove: "onPointerMove",
    pointerout: "onPointerOut",
    pointerover: "onPointerOver",
    pointerup: "onPointerUp",
    progress: "onProgress",
    reset: "onReset",
    scroll: "onScroll",
    seeked: "onSeeked",
    seeking: "onSeeking",
    select: "onSelect",
    stalled: "onStalled",
    submit: "onSubmit",
    suspend: "onSuspend",
    timeupdate: "onTimeUpdate",
    toggle: "onToggle",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart",
    transitionend: "onTransitionEnd",
    volumechange: "onVolumeChange",
    waiting: "onWaiting",
    wheel: "onWheel"
  };
  F$2(null);
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();
  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];
  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');
  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;
  function getBuildModeUnmemoized() {
    try {
      var _process, _process$env;
      if (((_process = process) === null || _process === void 0 ? void 0 : (_process$env = _process.env) === null || _process$env === void 0 ? void 0 : _process$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode = memoize(getBuildModeUnmemoized);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      values[_key4 - 1] = arguments[_key4];
    }
    if (getBuildMode() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$2$debounceRenderin2;
    ((_l$2$debounceRenderin2 = l$2.debounceRendering) !== null && _l$2$debounceRenderin2 !== void 0 ? _l$2$debounceRenderin2 : queueMicrotask)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$1);
    const reasonRef = _(Unset$1);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$1);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange3;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange3 = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange3 !== void 0 ? _onChange3 : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    y$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange4;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange4 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange4 !== void 0 ? _onChange4 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$1 = Symbol();
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }
  const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  const previousInputs = new Map();
  const toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName = "diffed";
  const originalCommit = l$2[commitName];
  const newCommit = function () {
    for (const [id, effectInfo] of toRun) {
      const oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup2;
        (_effectInfo$cleanup2 = effectInfo.cleanup) === null || _effectInfo$cleanup2 === void 0 ? void 0 : _effectInfo$cleanup2.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$2[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    const [id] = h$1(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    p$1(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    const ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    const e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref10 => {
      let [_k, v] = _ref10;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return y$2(_$2, {}, lhs, rhs);
    }
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    // This *must* be stable in order to prevent repeated reset `null` calls after every render.
    const combined = useStableCallback(function combined(current) {
      processRef(current, lhs);
      processRef(current, rhs);
    });
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len6 = arguments.length, allProps = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      allProps[_key6] = arguments[_key6];
    }
    useEnsureStability("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  const knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        let ret = managedChildrenArray.current.arr.slice();
        const max = getHighestIndex();
        for (let i = 0; i <= max; ++i) {
          if (ret[i] == null) ret[i] = {
            index: i
          };
        }
        return ret;
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var _info$context;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context = info.context) !== null && _info$context !== void 0 ? _info$context : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    y$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    y$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref11) {
    let {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref11;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    const [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    // Shared between onChildrenMountChange and changeIndex, not public
    // Only called when `closestFit` is false, naturally.
    const getClosestFit = T$1(requestedIndex => {
      const children = getChildren();
      let closestDistance = Infinity;
      let closestIndex = null;
      children.forEach(child => {
        if (child != null && isValid(child)) {
          console.assert(typeof child.index == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    const reevaluateClosestFit = useStableCallback(() => {
      const children = getChildren();
      const requestedIndex = getRequestedIndex();
      const currentIndex = getCurrentIndex();
      const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
        const closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (currentChild) setAt(currentChild, false, closestFitIndex, currentIndex);
        if (closestFitIndex != null) {
          const closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true, closestFitIndex, currentIndex);
        }
      }
    });
    const changeIndex = T$1((arg, reason) => {
      const children = getChildren();
      const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      setRequestedIndex(requestedIndex, reason);
      const currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
        return null;
      } else {
        const childIsValid = newMatchingChild && isValid(newMatchingChild);
        if (childIsValid || !closestFit) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
          if (newMatchingChild) setAt(newMatchingChild, true, requestedIndex, currentIndex);
          return requestedIndex;
        } else {
          console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            setAt(newMatchingChild, true, closestFitIndex, currentIndex);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    y$1(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = h$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = T$1(() => {
      return ref.current;
    }, []);
    return [state, setState, getState];
  }
  F$2(null);
  function getExclusiveTransitionContextPrememoization(exclusivityKey) {
    if (exclusivityKey == null) return null;
    return F$2(null);
  }
  const SwappableContext = F$2({
    getAnimateOnMount: () => false
  });
  /**
   * Returns the context for a given `exclusivityKey`, creating one if it doesn't already exist.
   *
   * If
   */
  const GetExclusiveTransitionContext = memoize(getExclusiveTransitionContextPrememoization);
  const CssClassContext = F$2({
    GetBaseClass: () => "ptl",
    GetEnterClass: () => "n",
    GetExitClass: () => "x",
    GetMeasureClass: () => "m",
    GetInitClass: () => "i",
    GetTransitionClass: () => "t",
    GetFinalizeClass: () => "f"
  });
  function useCssClasses() {
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass
    } = q$1(CssClassContext);
    const GetDirectionClass = T$1(direction => {
      switch (direction) {
        case "enter":
          return GetEnterClass();
        case "exit":
          return GetExitClass();
      }
    }, []);
    const GetPhaseClass = T$1(phase => {
      switch (phase) {
        case "measure":
          return GetMeasureClass();
        case "init":
          return GetInitClass();
        case "transition":
          return GetTransitionClass();
        case "finalize":
          return GetFinalizeClass();
      }
    }, []);
    return {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    };
  }
  let globalCount = -1;
  function ExclusiveTransitionProvider(_ref12) {
    let {
      exclusivityKey,
      children
    } = _ref12;
    useEnsureStability("ExclusiveTransitionProvider", exclusivityKey);
    const [getNextIndexInLine, setNextIndexInLine] = usePassiveState(null);
    const {
      context,
      managedChildrenReturn,
      managedChildrenReturn: {
        getChildren
      }
    } = useManagedChildren({
      managedChildrenParameters: {}
    });
    const {
      changeIndex,
      getCurrentIndex
    } = useChildrenFlag({
      getChildren,
      closestFit: false,
      initialIndex: null,
      onIndexChange: null,
      setAt: T$1((m, v) => {
        m.setExclusivelyOpen(v);
      }, []),
      getAt: T$1(m => m.getExclusivelyOpen(), []),
      isValid: T$1(m => {
        return true;
      }, [])
    });
    const onVisibilityChange = T$1((index, visible) => {
      const nextInLine = getNextIndexInLine();
      const currentInLine = getCurrentIndex();
      if (visible == "show" && index != currentInLine) {
        /**
         * When a child transition shows itself initially
         * (i.e. requests itself to be the exclusive transition)
         * we either let it open immediately if there's no one finishing their exit,
         * or wait until that aforementioned exit has finished.
         */
        if (currentInLine == null) {
          changeIndex(index);
        } else {
          var _getChildren$getAt, _getChildren$getAt$fo;
          (_getChildren$getAt = getChildren().getAt(currentInLine)) === null || _getChildren$getAt === void 0 ? void 0 : (_getChildren$getAt$fo = _getChildren$getAt.forceClose) === null || _getChildren$getAt$fo === void 0 ? void 0 : _getChildren$getAt$fo.call(_getChildren$getAt);
          setNextIndexInLine(index);
        }
      } else if (visible == "hidden") {
        /**
         * When a child transition has finished its exit transition,
         * make sure that if someone requested to be shown in the meantime
         * that we do so.
         */
        if (nextInLine != null) {
          changeIndex(nextInLine);
          setNextIndexInLine(null);
        }
      }
    }, []);
    const context2 = useStableObject({
      ...context,
      exclusiveTransitionContext: useStableObject({
        exclusivityKey,
        onVisibilityChange
      })
    });
    const ExclusiveTransitionContext = GetExclusiveTransitionContext(exclusivityKey);
    return ExclusiveTransitionContext == null ? children !== null && children !== void 0 ? children : null : o$2(ExclusiveTransitionContext.Provider, {
      value: context2,
      children: children
    });
  }
  function useExclusiveTransition(_ref13) {
    let {
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        forceClose,
        exclusivityKey
      }
    } = _ref13;
    const c = GetExclusiveTransitionContext(exclusivityKey);
    useEnsureStability("useExclusiveTransition", c == null);
    const context = c ? q$1(c) : null;
    const index = F$1(() => {
      globalCount += 1;
      return globalCount.toString();
    }, []);
    const [exclusivelyOpen, setExclusivelyOpen, getExclusivelyOpen] = useState(!!show);
    useManagedChild({
      context,
      managedChildParameters: {
        index
      }
    }, {
      index,
      getExclusivelyOpen,
      setExclusivelyOpen,
      forceClose
    });
    const parentOnVisChange = context === null || context === void 0 ? void 0 : context.exclusiveTransitionContext.onVisibilityChange;
    const onVisibilityChange = T$1(visible => {
      parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, visible == false ? "hidden" : "show");
    }, [parentOnVisChange, index]);
    y$1(() => {
      if (show) parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, "show");
    }, [show, parentOnVisChange, index]);
    return {
      exclusiveTransitionReturn: {
        isExclusive: context != null,
        exclusivelyOpen,
        setExclusivelyOpen,
        getExclusivelyOpen,
        onVisibilityChange
      }
    };
  }

  /**
   * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
   * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
   *
   * TODO: Still needed?
   */
  function forwardElementRef(Component) {
    const ForwardedComponent = k(Component);
    return ForwardedComponent;
  }
  /**
   * Useful in particular for Slides with a Tab Panel --
   * if we do Math.sign(currentIndex - slideIndex), it
   * transitions nicely in the expected direction,
   * but we need to "remember" which direction to use
   * when it's the current panel (and the difference is 0)
   */
  function useLastNonNullValue(value) {
    const lastNonNullValue = _(null);
    p$1(() => {
      if (value != null) lastNonNullValue.current = value;
    }, [value]);
    return value !== null && value !== void 0 ? value : lastNonNullValue.current;
  }

  /**
   * Creates a set of props that implement a swap container.
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useCreateSwappableProps(_ref14, otherProps) {
    let {
      inline
    } = _ref14;
    const {
      GetBaseClass
    } = useCssClasses();
    return useMergedProps({
      className: clsx("".concat(GetBaseClass(), "-swap-container"), inline && "".concat(GetBaseClass(), "-swap-container-inline"))
    }, otherProps);
  }
  /**
   * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
   *
   * You must manage each child `<Transitionable>` component's `show` prop -- this component *does not* manage any sort of state in that regard.
   *
   * If you pass a regular element (like a div) or other single component, then thee props and ref will be forwarded onto that element. Otherwise, all the children will be wrapped in a div or span depending on the `inline` prop.
   * @param param0
   * @returns
   */
  const Swappable = x(forwardElementRef(function Swappable(_ref15, ref) {
    var _inline;
    let {
      children: c,
      inline,
      childrenAnimateOnMount,
      exclusivityKey,
      ...p
    } = _ref15;
    let children = c;
    if (!children.type) children = !inline ? o$2("div", {
      children: children
    }) : o$2("span", {
      children: children
    });
    (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
    const transitionProps = useCreateSwappableProps({
      inline
    }, {
      ...p,
      ref
    });
    const mergedWithChildren = useMergedProps(transitionProps, children.props);
    const animateOnMount = _(childrenAnimateOnMount !== null && childrenAnimateOnMount !== void 0 ? childrenAnimateOnMount : false);
    p$1(() => {
      animateOnMount.current = true;
    }, []);
    const contextValue = _({
      getAnimateOnMount: () => {
        return animateOnMount.current;
      }
    });
    let ret = E(children, mergedWithChildren);
    ret = o$2(SwappableContext.Provider, {
      value: contextValue.current,
      children: ret
    });
    if (exclusivityKey) {
      ret = o$2(ExclusiveTransitionProvider, {
        exclusivityKey: exclusivityKey,
        children: ret
      }, exclusivityKey);
    }
    return ret;
  }));
  // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
  // Not perfect, but it's not supposed to be. `inline` is for perfect.
  const inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
  function getTimeoutDuration(element) {
    return Math.max(...window.getComputedStyle(element || document.body).getPropertyValue("transition-duration").split(",").map(str => {
      if (str.endsWith("ms")) return +str.substring(0, str.length - 2);
      if (str.endsWith("s")) return +str.substring(0, str.length - 1) * 1000;
      return 1000;
    }));
  }
  function parseState(nextState) {
    return nextState.split("-");
  }
  /**
   * Provide props that can be used to animate a transition.
   *
   * @param param0
   * @returns
   */
  function useTransition(_ref16) {
    var _animateOnMount, _measure, _easingIn, _easingOut;
    let {
      transitionParameters: {
        propsIncoming: {
          children,
          ...p
        },
        show,
        animateOnMount,
        measure,
        exitVisibility,
        duration,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    } = _ref16;
    useEnsureStability("useTransition", onVisibilityChange);
    const {
      getAnimateOnMount
    } = q$1(SwappableContext);
    exitVisibility || (exitVisibility = "hidden");
    (_animateOnMount = animateOnMount) !== null && _animateOnMount !== void 0 ? _animateOnMount : animateOnMount = getAnimateOnMount();
    (_measure = measure) !== null && _measure !== void 0 ? _measure : measure = false;
    const getExitVisibility = useStableGetter(exitVisibility);
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    } = useCssClasses();
    const getMeasure = useStableGetter(measure);
    const {
      exclusiveTransitionReturn: {
        exclusivelyOpen,
        isExclusive,
        onVisibilityChange: exclusiveTransitionVisibilityChange
      }
    } = useExclusiveTransition({
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        exclusivityKey,
        forceClose: useStableCallback(() => {
          internalOnShowChanged(false, getMeasure());
        })
      }
    });
    if (isExclusive) {
      show = show && exclusivelyOpen;
    }
    const {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({});
    const cssProperties = _({});
    const classNames = _(new Set([// This is removed during useLayoutEffect on the first render
    // (at least once `show` is non-null)
    "".concat(GetBaseClass(), "-pending")]));
    const handleTransitionFinished = T$1(() => {
      const state = getState();
      console.assert(!!state);
      if (state) {
        const [direction, phase] = parseState(state);
        if (phase == "transition") {
          setState("".concat(direction, "-finalize"));
          if (timeoutHandle.current > 0) {
            var _timeoutClearFunction;
            (_timeoutClearFunction = timeoutClearFunction.current) === null || _timeoutClearFunction === void 0 ? void 0 : _timeoutClearFunction.call(timeoutClearFunction, timeoutHandle.current);
            timeoutHandle.current = -1;
          }
        }
      }
    }, []);
    const otherProps = _({
      onTransitionEnd: e => {
        if (e.target == getElement() && e.elapsedTime) {
          handleTransitionFinished();
        }
      }
    });
    const hasMounted = _(false);
    /**
     * Sets the element's CSS class to match the given direction and phase.
     */
    const updateClasses = T$1((element, direction, phase) => {
      if (element == null) return;
      const exitVisibility = getExitVisibility();
      const allClassesToRemove = ["".concat(GetBaseClass(), "-").concat(GetEnterClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-ev-", "inert"), "".concat(GetBaseClass(), "-ev-", "removed"), "".concat(GetBaseClass(), "-ev-", "hidden"), "".concat(GetBaseClass(), "-ev-", "visible"), "".concat(GetBaseClass(), "-pending")];
      const allClassesToAdd = ["".concat(GetBaseClass()), "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction)), phase ? "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction), "-").concat(GetPhaseClass(phase)) : "", "".concat(GetBaseClass(), "-ev-").concat(exitVisibility)];
      element.classList.remove(...allClassesToRemove);
      allClassesToRemove.map(v => classNames.current.delete(v));
      element.classList.add(...allClassesToAdd);
      allClassesToAdd.map(v => classNames.current.add(v));
    }, []);
    /**
     * Updates a single "measure" variable (or removes it)
     */
    const updateSizeProperty = T$1((element, varName, value) => {
      if (value != null) {
        value = "".concat(value, "px");
        element.style.setProperty(varName, value);
        cssProperties.current[varName] = value;
      } else {
        element.style.removeProperty(varName);
        delete cssProperties.current[varName];
      }
    }, []);
    /**
     * Adds the "measure" variupdateClassesables to the element if requested.
     */
    const measureElementAndUpdateProperties = T$1((element, measure) => {
      if (element) {
        var _size, _size2, _size3, _size4;
        let size = null;
        if (measure) {
          size = element.getBoundingClientRect();
        }
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-top"), (_size = size) === null || _size === void 0 ? void 0 : _size.top);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-left"), (_size2 = size) === null || _size2 === void 0 ? void 0 : _size2.left);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-width"), (_size3 = size) === null || _size3 === void 0 ? void 0 : _size3.width);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-height"), (_size4 = size) === null || _size4 === void 0 ? void 0 : _size4.height);
      }
    }, []);
    // We use both useTimeout and requestAnimationFrame for timing certain things --
    // raf is used for changing from init to transition (would use queueMicrotask but it can't be cancelled)
    // setTimeout is used for changing from transition to finalize (as a backup in case transitionend doesn't fire)
    //
    // In order to avoid stale callbacks running (i.e. when we rapidly switch between visible and not)
    // we need to make sure we accurately cancel anything that can change our state on a delay.
    //
    // Also of note, we store "(f) => window.clearTimeout(f)" instead of just "window.clearTimeout" because
    // of the implicit window object -- problems with a missing `this` object and all that nonsense.
    const timeoutHandle = _(-1);
    const timeoutClearFunction = _(null);
    /**
     * Any time the state changes, there's some logic we need to run:
     *
     * * If we're changing to an `init` phase, update the classes, then wait a moment and then change to the `transition` phase.
     * * If we're changing to a `transition` phase, update the classes, then wait until the transition completes, then change to the `finalize` phase.
     *
     * Any change in state or classes/styles does not implicitly cause a re-render.
     */
    const onStateChange = T$1((nextState, prevState, reason) => {
      if (nextState == null) return;
      const [nextDirection, nextPhase] = parseState(nextState);
      const element = getElement();
      // Make sure no stale change code ever runs
      if (timeoutHandle.current >= 0 && timeoutClearFunction.current) timeoutClearFunction.current(timeoutHandle.current);
      // Handle inert props/property
      const exitVisibility = getExitVisibility();
      if (exitVisibility) {
        const inert = exitVisibility == "inert" && nextDirection == "exit" && nextPhase == "finalize" ? true : undefined;
        if (inert) otherProps.current.inert = true;else delete otherProps.current["inert"];
        if (element) element.inert = inert || false;
      }
      const isBeingPainted = nextDirection == "enter" || nextDirection == "exit" && nextPhase != "finalize";
      onVisibilityChange === null || onVisibilityChange === void 0 ? void 0 : onVisibilityChange(isBeingPainted);
      exclusiveTransitionVisibilityChange === null || exclusiveTransitionVisibilityChange === void 0 ? void 0 : exclusiveTransitionVisibilityChange(isBeingPainted);
      updateClasses(element, nextDirection, nextPhase);
      if (element && (nextPhase == "init" || nextPhase == "transition")) forceReflow(element);
      switch (nextPhase) {
        case "measure":
          {
            if (element) measureElementAndUpdateProperties(element, true);
            //setState(`${nextDirection}-init`);
            updateClasses(element, nextDirection, "init");
            if (element) forceReflow(element);
            // !!Intentional fall-through!!
          }

        case "init":
          {
            timeoutHandle.current = requestAnimationFrame(() => {
              setState("".concat(nextDirection, "-transition"));
            });
            timeoutClearFunction.current = f => cancelAnimationFrame(f);
            break;
          }
        case "transition":
          {
            timeoutHandle.current = setTimeout(() => {
              handleTransitionFinished();
            }, getTimeoutDuration(element) * 1.5);
            timeoutClearFunction.current = f => clearTimeout(f);
            break;
          }
        case "finalize":
          {
            // Nothing to do or schedule or anything -- we just update our classes and we're done.
            timeoutClearFunction.current = null; // Does this make it more or less clear?
            break;
          }
        default:
          {
            debugger; // Intentional
            console.log("Invalid state used in transition: ".concat(nextState, ". Previous state was ").concat(prevState !== null && prevState !== void 0 ? prevState : "null"));
            break;
          }
      }
    }, []);
    const [getState, setState] = usePassiveState(onStateChange, returnNull, runImmediately);
    // When we mount, and every time thereafter that `show` changes,
    // change our current state according to that `show` value.
    y$1(() => internalOnShowChanged(show, measure), [measure, show]);
    // This has no dependences and is relied on in two different areas
    function internalOnShowChanged(show, measure) {
      // If `show` is null, then we don't change anything.
      if (show == null) return;
      // (If `show` is true/false, we'll remove the CSS classes during `onChange`)
      const currentState = getState();
      let nextPhase = measure ? "measure" : "init";
      if (currentState) {
        const [currentDirection, currentPhase] = parseState(currentState);
        if (currentPhase != "finalize") nextPhase = "transition";
      }
      // Note: the setState change handler runs immediately with no debounce.
      if (show) {
        if (hasMounted.current || animateOnMount) setState("enter-".concat(nextPhase));else setState("enter-finalize");
      } else {
        if (hasMounted.current || animateOnMount) setState("exit-".concat(nextPhase));else setState("exit-finalize");
      }
      hasMounted.current = true;
    }
    if (duration != null) cssProperties.current["--".concat(GetBaseClass(), "-duration")] = duration + "ms";else delete cssProperties.current["--".concat(GetBaseClass(), "-duration")];
    (_easingIn = easingIn) !== null && _easingIn !== void 0 ? _easingIn : easingIn = easing;
    (_easingOut = easingOut) !== null && _easingOut !== void 0 ? _easingOut : easingOut = easing;
    if (easingOut != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")] = easingOut;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")];
    if (easingIn != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")] = easingIn;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")];
    // No matter what delayMountUntilShown is,
    // once we've rendered our children once, 
    // ensure that we don't unmount them again and waste all that work.
    // (If you really need this you can just unmount the entire transition itself)
    const definitelyShouldMountChildren = show || !delayMountUntilShown;
    const hasRenderedChildren = _(false);
    const renderChildren = definitelyShouldMountChildren || hasRenderedChildren.current;
    p$1(() => {
      if (definitelyShouldMountChildren) hasRenderedChildren.current || (hasRenderedChildren.current = true);
    }, [hasRenderedChildren.current ? false : definitelyShouldMountChildren]);
    const childrenIsVnode = children && children.type && children.props;
    const finalProps = useMergedProps(p, propsStable, otherProps.current, {
      className: [...classNames.current, "".concat(GetBaseClass()), "".concat(GetBaseClass(), "-ev-").concat(exitVisibility), "".concat(GetBaseClass(), "-inline-direction-", "ltr"), "".concat(GetBaseClass(), "-block-direction-", "ttb")].join(" "),
      style: cssProperties.current
    }, childrenIsVnode ? {
      ref: children.ref,
      ...children.props
    } : {});
    const resetContext = _({
      getAnimateOnMount: returnFalse
    }).current;
    let modifiedChildren;
    if (childrenIsVnode) {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: E(children, finalProps)
      });
    } else {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: o$2("span", {
          ...finalProps,
          children: children
        })
      });
    }
    return renderChildren ? modifiedChildren : null;
  }
  function forceReflow(e) {
    // Try really hard to make sure this isn't optimized out by anything.
    // We need it for its document reflow side effect.
    const p = globalThis._dummy;
    globalThis._dummy = e.getBoundingClientRect();
    globalThis._dummy = e.style.opacity;
    globalThis._dummy = e.style.transform;
    globalThis._dummy = p;
    return e;
  }

  /**
   * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useBasePropsFade(_ref17) {
    let {
      fadeParameters: {
        fadeMin,
        fadeMax
      }
    } = _ref17;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-fade"),
      style: {
        ["--".concat(GetBaseClass(), "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
        ["--".concat(GetBaseClass(), "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
   *
   * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
   * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
   * It's generally recommended to either use the components that include a combined fade effect,
   * or just directly a `<Transitionable>` on your own.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Fade(_ref18, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref18;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  function useBasePropsClip(_ref19) {
    var _ref20, _ref21, _ref22, _ref23;
    let {
      clipParameters: {
        clipMin,
        clipMinBlock,
        clipMinInline,
        clipOrigin,
        clipOriginBlock,
        clipOriginInline
      }
    } = _ref19;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: clsx("".concat(GetBaseClass(), "-clip")),
      style: {
        ["--".concat(GetBaseClass(), "-clip-origin-inline")]: (_ref20 = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref20 !== void 0 ? _ref20 : 0.5,
        ["--".concat(GetBaseClass(), "-clip-origin-block")]: (_ref21 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref21 !== void 0 ? _ref21 : 0,
        ["--".concat(GetBaseClass(), "-clip-min-inline")]: (_ref22 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref22 !== void 0 ? _ref22 : 1,
        ["--".concat(GetBaseClass(), "-clip-min-block")]: (_ref23 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref23 !== void 0 ? _ref23 : 0
      }
    };
  }
  x(forwardElementRef(function Clip(_ref24, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref24;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ClipFade(_ref25, ref) {
    let {
      delayMountUntilShown,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      clipMin,
      clipMinBlock,
      clipMinInline,
      clipOrigin,
      clipOriginBlock,
      clipOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref25;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   *
   * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
   *
   * @example <Transitionable measure {...useCreateCollapseProps(...)} />
   */
  function useBasePropsCollapse(_ref26) {
    let {
      collapseParameters: {
        minBlockSize
      }
    } = _ref26;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-collapse"),
      style: {
        ["--".concat(GetBaseClass(), "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
   *
   * *Important*: This component is *not* efficient for the browser to animate!
   * Make sure you do testing on lower power devices, or prefer a lighter
   * alternative, like `<Clip>`.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Collapse(_ref27, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      delayMountUntilShown,
      minBlockSize,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref27;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function CollapseFade(_ref28, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      animateOnMount,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      exitVisibility,
      minBlockSize,
      onVisibilityChange,
      ...rest
    } = _ref28;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsFlip(_ref29) {
    var _useLastNonNullValue, _useLastNonNullValue2;
    let {
      flipParameters: {
        flipAngleBlock,
        flipAngleInline,
        flipPerspective
      }
    } = _ref29;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-flip"),
      style: {
        ["--".concat(GetBaseClass(), "-flip-angle-inline")]: "".concat((_useLastNonNullValue = useLastNonNullValue(flipAngleInline)) !== null && _useLastNonNullValue !== void 0 ? _useLastNonNullValue : 0, "deg"),
        ["--".concat(GetBaseClass(), "-flip-angle-block")]: "".concat((_useLastNonNullValue2 = useLastNonNullValue(flipAngleBlock)) !== null && _useLastNonNullValue2 !== void 0 ? _useLastNonNullValue2 : 0, "deg"),
        ["--".concat(GetBaseClass(), "-perspective")]: "".concat(flipPerspective !== null && flipPerspective !== void 0 ? flipPerspective : 800, "px")
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
   *
   * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * exclusivityKey allows for convenient setups inside of a `SwapContainer`
   * (`flipInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Flip(_ref30, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      flipAngleInline,
      flipAngleBlock,
      flipPerspective,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref30;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFlip({
          flipParameters: {
            flipAngleBlock,
            flipAngleInline,
            flipPerspective
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsSlide(_ref31) {
    var _slideTargetInline, _slideTargetBlock;
    let {
      slideParameters: {
        slideTargetInline,
        slideTargetBlock
      }
    } = _ref31;
    slideTargetInline = useLastNonNullValue(slideTargetInline);
    slideTargetBlock = useLastNonNullValue(slideTargetBlock);
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-slide"),
      style: {
        ["--".concat(GetBaseClass(), "-slide-target-inline")]: "".concat((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 0),
        ["--".concat(GetBaseClass(), "-slide-target-block")]: "".concat((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
   *
   * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * which allows for convenient setups inside of a `SwapContainer`
   * (`slideInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Slide(_ref32, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      onVisibilityChange,
      slideTargetInline,
      slideTargetBlock,
      show,
      animateOnMount,
      exitVisibility,
      delayMountUntilShown,
      ...rest
    } = _ref32;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange,
        propsIncoming: useMergedProps(useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideFade(_ref33, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref33;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsZoom(_ref34) {
    var _ref35, _ref36, _ref37, _ref38;
    let {
      zoomParameters: {
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }
    } = _ref34;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-zoom"),
      style: {
        ["--".concat(GetBaseClass(), "-zoom-origin-inline")]: "".concat((_ref35 = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref35 !== void 0 ? _ref35 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-origin-block")]: "".concat((_ref36 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref36 !== void 0 ? _ref36 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-min-inline")]: "".concat((_ref37 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref37 !== void 0 ? _ref37 : 0),
        ["--".concat(GetBaseClass(), "-zoom-min-block")]: "".concat((_ref38 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref38 !== void 0 ? _ref38 : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
   * @see `Transitionable` `ZoomFade`
   */
  x(forwardElementRef(function Zoom(_ref39, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref39;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoom(_ref40, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref40;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoomFade(_ref41, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      fadeMax,
      fadeMin,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref41;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ZoomFade(_ref42, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref42;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.13.1", l$2, {
    Fragment: _$2,
    Component: k$2
  });
  var o = {};
  function a(e) {
    return e.type === _$2 ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
  }
  var i = [],
    c = [];
  function s() {
    return i.length > 0 ? i[i.length - 1] : null;
  }
  var u = !1;
  function l(e) {
    return "function" == typeof e.type && e.type != _$2;
  }
  function f(n) {
    for (var e = [n], t = n; null != t.__o;) e.push(t.__o), t = t.__o;
    return e.reduce(function (n, e) {
      n += "  in " + a(e);
      var t = e.__source;
      return t ? n += " (at " + t.fileName + ":" + t.lineNumber + ")" : u || (u = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
    }, "");
  }
  var p = "function" == typeof WeakMap;
  function d(n) {
    return n ? "function" == typeof n.type ? d(n.__) : n : {};
  }
  var h = k$2.prototype.setState;
  k$2.prototype.setState = function (n, e) {
    return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(s())), h.call(this, n, e);
  };
  var y = k$2.prototype.forceUpdate;
  function v(n) {
    var e = n.props,
      t = a(n),
      o = "";
    for (var r in e) if (e.hasOwnProperty(r) && "children" !== r) {
      var i = e[r];
      "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), o += " " + r + "=" + JSON.stringify(i);
    }
    var c = e.children;
    return "<" + t + o + (c && c.length ? ">..</" + t + ">" : " />");
  }
  k$2.prototype.forceUpdate = function (n) {
    return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(s())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + f(this.__v)), y.call(this, n);
  }, function () {
    !function () {
      var n = l$2.__b,
        t = l$2.diffed,
        o = l$2.__,
        r = l$2.vnode,
        a = l$2.__r;
      l$2.diffed = function (n) {
        l(n) && c.pop(), i.pop(), t && t(n);
      }, l$2.__b = function (e) {
        l(e) && i.push(e), n && n(e);
      }, l$2.__ = function (n, e) {
        c = [], o && o(n, e);
      }, l$2.vnode = function (n) {
        n.__o = c.length > 0 ? c[c.length - 1] : null, r && r(n);
      }, l$2.__r = function (n) {
        l(n) && c.push(n), a && a(n);
      };
    }();
    var n = !1,
      t = l$2.__b,
      r = l$2.diffed,
      s = l$2.vnode,
      u = l$2.__e,
      h = l$2.__,
      y = l$2.__h,
      m = p ? {
        useEffect: new WeakMap(),
        useLayoutEffect: new WeakMap(),
        lazyPropTypes: new WeakMap()
      } : null,
      b = [];
    l$2.__e = function (n, e, t, o) {
      if (e && e.__c && "function" == typeof n.then) {
        var r = n;
        n = new Error("Missing Suspense. The throwing component was: " + a(e));
        for (var i = e; i; i = i.__) if (i.__c && i.__c.__c) {
          n = r;
          break;
        }
        if (n instanceof Error) throw n;
      }
      try {
        (o = o || {}).componentStack = f(e), u(n, e, t, o), "function" != typeof n.then && setTimeout(function () {
          throw n;
        });
      } catch (n) {
        throw n;
      }
    }, l$2.__ = function (n, e) {
      if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
      var t;
      switch (e.nodeType) {
        case 1:
        case 11:
        case 9:
          t = !0;
          break;
        default:
          t = !1;
      }
      if (!t) {
        var o = a(n);
        throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + o + " />, " + e + ");");
      }
      h && h(n, e);
    }, l$2.__b = function (e) {
      var r = e.type,
        i = d(e.__);
      if (n = !0, void 0 === r) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + v(e) + "\n\n" + f(e));
      if (null != r && "object" == typeof r) {
        if (void 0 !== r.__k && void 0 !== r.__e) throw new Error("Invalid type passed to createElement(): " + r + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + v(r) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
        throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r) ? "array" : r));
      }
      if ("thead" !== r && "tfoot" !== r && "tbody" !== r || "table" === i.type ? "tr" === r && "thead" !== i.type && "tfoot" !== i.type && "tbody" !== i.type && "table" !== i.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + v(e) + "\n\n" + f(e)) : "td" === r && "tr" !== i.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + v(e) + "\n\n" + f(e)) : "th" === r && "tr" !== i.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + v(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + v(e) + "\n\n" + f(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("string" == typeof e.type) for (var c in e.props) if ("o" === c[0] && "n" === c[1] && "function" != typeof e.props[c] && null != e.props[c]) throw new Error("Component's \"" + c + '" property should be a function, but got [' + typeof e.props[c] + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && m && !m.lazyPropTypes.has(e.type)) {
          var s = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
          try {
            var u = e.type();
            m.lazyPropTypes.set(e.type, !0), console.warn(s + "Component wrapped in lazy() is " + a(u));
          } catch (n) {
            console.warn(s + "We will log the wrapped component's name once it is loaded.");
          }
        }
        var l = e.props;
        e.type.__f && delete (l = function (n, e) {
          for (var t in e) n[t] = e[t];
          return n;
        }({}, l)).ref, function (n, e, t, r, a) {
          Object.keys(n).forEach(function (t) {
            var i;
            try {
              i = n[t](e, t, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (n) {
              i = n;
            }
            i && !(i.message in o) && (o[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
          });
        }(e.type.propTypes, l, 0, a(e), function () {
          return f(e);
        });
      }
      t && t(e);
    }, l$2.__h = function (e, t, o) {
      if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
      y && y(e, t, o);
    };
    var w = function (n, e) {
        return {
          get: function () {
            var t = "get" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
          },
          set: function () {
            var t = "set" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
          }
        };
      },
      g = {
        nodeName: w("nodeName", "use vnode.type"),
        attributes: w("attributes", "use vnode.props"),
        children: w("children", "use vnode.props.children")
      },
      E = Object.create({}, g);
    l$2.vnode = function (n) {
      var e = n.props;
      if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
        var t = n.props = {};
        for (var o in e) {
          var r = e[o];
          "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
        }
      }
      n.__proto__ = E, s && s(n);
    }, l$2.diffed = function (e) {
      if (e.__k && e.__k.forEach(function (n) {
        if ("object" == typeof n && n && void 0 === n.type) {
          var t = Object.keys(n).join(",");
          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + f(e));
        }
      }), n = !1, r && r(e), null != e.__k) for (var t = [], o = 0; o < e.__k.length; o++) {
        var a = e.__k[o];
        if (a && null != a.key) {
          var i = a.key;
          if (-1 !== t.indexOf(i)) {
            console.error('Following component has two or more children with the same key attribute: "' + i + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + v(e) + "\n\n" + f(e));
            break;
          }
          t.push(i);
        }
      }
    };
  }();

  /**
   * Relatively low-level hook that allows you to inspect
   * when the entire URL changes, either because the hash changed,
   * or because the Back/Forward browser buttons were pressed.
   *
   * (Changing query parameters reloads the page and so isn't
   * tracked, unless of course it's because of the browser
   * navigating back/forwards).
   *
   * In general, you'll want to inspect a specific directory of
   * a path, or a specific query parameter value, not the
   * entire URL.
   */
  function useUrl(onUrlChange) {
    const [getUrl, setUrl] = usePassiveState$1(useStableCallback$1(onUrlChange), T$1(() => window.location.toString(), []));
    useGlobalHandler(window, "hashchange", e => {
      setUrl(window.location.toString());
    });
    useGlobalHandler(window, "popstate", e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#the_history_stack
      // TODO: If this assert never fires, it's *probably* fine??
      console.assert(window.location.toString() === document.location.toString());
      setUrl(window.location.toString());
    });
    return [getUrl, setUrl];
  }

  //export const RouterLevelContext = createContext(0);
  /**
   * Internal helper to trim the crusts off of a hash path.
   * @param hash
   * @returns
   */
  function trimHash(hash) {
    if (hash.startsWith("#")) hash = hash.substr(1);
    if (hash.startsWith("/")) hash = hash.substr(1);
    if (hash.endsWith("/")) hash = hash.substr(0, hash.length - 1);
    return hash;
  }
  function normalizeHashToPath(hash) {
    hash = trimHash(hash);
    return hash.split("/");
  }
  // Not public -- just contains shared code for history modification.
  // This is what actually changes History and updates the window's URL.
  function setEntireHash(hash, action) {
    var _action;
    (_action = action) !== null && _action !== void 0 ? _action : action = "push";
    hash = trimHash(hash);
    let oldURL = window.location.toString();
    let nextUrl = new URL(window.location.toString());
    nextUrl.hash = "#".concat(hash);
    history["".concat(action, "State")]({}, document.title, nextUrl);
    // Modifying history doesn't actually cause a hashchange event.
    window.dispatchEvent(new HashChangeEvent('hashchange', {
      oldURL,
      newURL: nextUrl.toString()
    }));
  }
  /**
   * Modifies the given Search Params object to have its key be set to the given value.
   *
   * Specifically for boolean types this ensures that the param is simply existant/non-existant,
   * but for other types this is pretty straightforward.
   * @param params
   * @param key
   * @param value
   * @param type
   */
  function unparseParam(params, key, value, type) {
    if (type === "boolean") {
      if (value === true) {
        params.set(key, "");
      } else {
        params.delete(key);
      }
    } else {
      params.set(key, "".concat(value));
    }
  }
  /**
   * Parses the requested Search Param from the given URL.
   *
   * The type will be automatically parsed with special handling for booleans
   */
  function parseParam(url, key, type) {
    let value = url.searchParams.get(key);
    switch (type) {
      case "string":
        return value !== null && value !== void 0 ? value : null;
      case "boolean":
        return value != null;
      case "number":
        if (value == null) return null;
        let parsed = +value;
        if (isFinite(parsed)) return parsed;
        return null;
      case "bigint":
        if (value == null) return null;
        try {
          return BigInt(value);
        } catch (ex) {
          return null;
        }
    }
    return value !== null && value !== void 0 ? value : null;
  }
  //export interface RouterChildInfo extends ManagedChildInfo<string> {
  //    notifyOfSiblingsHaveNoMatches(noMatches: boolean): void;
  //path: RouterPathType | null;
  //    matches: boolean | null;
  //}

  function useConsumeRouter(_ref43) {
    let {
      context,
      managedChildParameters,
      managedChildParameters: {
        index
      },
      consumeRouterParameters: {
        onLocalPathChange,
        localPath: wantedLocalPath
      }
    } = _ref43;
    const {
      routerContext: {
        level,
        notifyParentThatNonDefaultMatchHasChanged
      }
    } = context;
    const [anyMatchesAmongNonDefaultSiblings, setAnyMatchesAmongNonDefaultSiblings] = useState$1(null);
    const [pathWhenMatching, setPathWhenMatching] = useState$1(null);
    const {
      managedChildReturn
    } = useManagedChild$1({
      context,
      managedChildParameters
    }, {
      index,
      setAnyMatchesAmongNonDefaultSiblings: useStableCallback$1(anyMatches => {
        setAnyMatchesAmongNonDefaultSiblings(anyMatches);
        onLocalPathChange2(wantedLocalPath, anyMatches, getLocalPath());
      })
    });
    y$1(() => {
      onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, getLocalPath());
    }, [wantedLocalPath, anyMatchesAmongNonDefaultSiblings]);
    const onLocalPathChange2 = useStableCallback$1(function (wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path) {
      const matches = pathCompare(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
      setMatches(matches);
      console.log("".concat(index, ": onLocalPathChange2(wlp: ").concat((wantedLocalPath !== null && wantedLocalPath !== void 0 ? wantedLocalPath : "null").toString(), ", amands: ").concat((anyMatchesAmongNonDefaultSiblings !== null && anyMatchesAmongNonDefaultSiblings !== void 0 ? anyMatchesAmongNonDefaultSiblings : "null").toString(), ", p: ").concat(path, "): ").concat((matches !== null && matches !== void 0 ? matches : "null").toString()));
      if (matches) setPathWhenMatching(path);
      if (wantedLocalPath != null) {
        notifyParentThatNonDefaultMatchHasChanged(index, matches);
      } else {
        notifyParentThatNonDefaultMatchHasChanged(index, null);
      }
    });
    const [matches, setMatches] = useState$1(null);
    const [getLocalPath, setLocalPath] = useLocalPath({
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange: useStableCallback$1((path, prev, reason) => {
          onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
          onLocalPathChange === null || onLocalPathChange === void 0 ? void 0 : onLocalPathChange(path, prev, reason);
        })
      }
    });
    return {
      managedChildReturn,
      consumeRouterReturn: {
        level,
        matches,
        getLocalPath,
        setLocalPath,
        pathWhenMatching
      }
    };
  }
  function useLocalPath(_ref44) {
    let {
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange
      }
    } = _ref44;
    useEnsureStability$1("useLocalPath", level);
    const urlToPath = T$1(url => {
      const oldHashPath = normalizeHashToPath(trimHash(new URL(url).hash));
      return oldHashPath[level];
    }, []);
    const [getLocalPath, setLocalPath] = usePassiveState$1(useStableCallback$1(onLocalPathChange), T$1(() => {
      return urlToPath(window.location.href);
    }, [urlToPath]));
    // Any time the URL changes, inspect the hash
    // at our current level, and change our local copy of our path
    // in our passive state. This will trigger our callback if they're different.
    useUrl(url => {
      setLocalPath(urlToPath(url));
    });
    return [getLocalPath, setLocalPath];
  }
  function pathCompare(requestedLocalHash, anyMatchesAmongNonDefaultSiblings, localPath) {
    var _localPath;
    let matches;
    (_localPath = localPath) !== null && _localPath !== void 0 ? _localPath : localPath = "";
    if (requestedLocalHash instanceof RegExp) matches = requestedLocalHash.test(localPath);else if (requestedLocalHash instanceof Function) matches = requestedLocalHash(localPath);else if (requestedLocalHash == null) matches = anyMatchesAmongNonDefaultSiblings == null ? null : !anyMatchesAmongNonDefaultSiblings;else matches = requestedLocalHash === localPath;
    return matches;
  }

  /**
   * Error class used when attemps to modify the root directory occur.
   */
  class RootRouterError extends Error {
    constructor() {
      super("The root Router's path can only be pushed to and cannot be set or popped from.");
    }
  }

  /**
   * Removes the directory at the current level, effectively returning
   * to the previous level.  You can also switch to a different
   * previous level if you would like.
   */
  function usePopLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      setEntireHash(popLocalPath(level, dir), action);
    }, [level]);
  }
  function popLocalPath(level, dir) {
    if (level < 0) throw new RootRouterError();
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, level).map(s => s !== null && s !== void 0 ? s : "");
    if (dir) {
      dir = trimHash(dir);
      newHashPath[newHashPath.length - 1] = dir;
    }
    return newHashPath.join("/");
  }

  /**
   * Adds a directory at one level deeper.
   */
  function usePushLocalPath(level) {
    return T$1(function pushLocalHash(dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      dir = trimHash(dir);
      const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
      let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
      newHashPath.splice(level + 1, 1, dir);
      setEntireHash(newHashPath.join("/"), action);
    }, [level]);
  }

  /**
   * Replaces the directory at the current level with a new one. You can
   * choose whether or not any trailing paths are kept -- by default this is false.
   * @returns
   */
  function useSetLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      setEntireHash(setLocalPath(level, dir, keepTrailing || false), action);
    }, [level]);
  }
  function setLocalPath(level, dir, keepTrailing) {
    if (level < 0) throw new RootRouterError();
    dir = trimHash(dir);
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
    newHashPath.splice(level, 1, dir);
    return newHashPath.join("/");
  }

  /**
   * Allows easy access to the controls at the current level.
   *
   * You can also get this information from a child <Router />
   * by passing in a ref (e.g. <Router ref={setControls} />).
   */
  function useRouterControls(level) {
    // This is the hash at this level specifically, 
    // so it contains no directory separators.
    const popLocalPath = usePopLocalPath(level);
    const pushLocalPath = usePushLocalPath(level);
    const setLocalPath = useSetLocalPath(level);
    return F$1(() => ({
      popLocalPath,
      pushLocalPath,
      setLocalPath
    }), [popLocalPath, pushLocalPath, setLocalPath]);
  }
  const RouterContext = F$2(null);
  //const RouterContext = createContext<RouterContextType | null>(null);
  /**
   * The "parent" part of a router.
   *
   * This is responsible for coordinating, among all children, which route to show.
   * This coordination is really only needed for the "default" pathway, which
   * needs to know as painlessly as possible whether any of its siblings are currently valid.
   *
   * It also increases the depth by one, starting at depth=-1 for the root router is *just* a parent.
   */
  function useProvideRouter(_ref45) {
    var _q$;
    let {
      managedChildrenParameters
    } = _ref45;
    const {
      context,
      managedChildrenReturn
    } = useManagedChildren$1({
      managedChildrenParameters
    });
    const {
      routerContext: {
        level
      }
    } = (_q$ = q$1(RouterContext)) !== null && _q$ !== void 0 ? _q$ : {
      routerContext: {
        level: -1
      }
    };
    const matchingIndices = _(new Set());
    const [getShowingDefault, setShowingDefault] = usePassiveState$1(useStableCallback$1(showingDefault => {
      managedChildrenReturn.getChildren().forEach(child => {
        child.setAnyMatchesAmongNonDefaultSiblings(!showingDefault);
      });
    }), returnNull$1);
    const onNonDefaultChildMatchChanged = useStableCallback$1((index, matches) => {
      matchingIndices.current[matches ? "add" : "delete"](index);
      setShowingDefault(matchingIndices.current.size == 0);
    });
    return {
      context: useStableObject$1({
        ...context,
        routerContext: useStableObject$1({
          level: level + 1,
          notifyParentThatNonDefaultMatchHasChanged: onNonDefaultChildMatchChanged
        })
      }),
      managedChildrenReturn
    };
  }

  /**
   * Allows you to conditionally hide/show content based on a path in the hash component of the URL.
   *
   * @param param0
   * @param ref
   * @returns
   */
  function Router(_ref46, ref) {
    var _consumeRouterReturn;
    let {
      localPath,
      onLocalPathChange,
      children
    } = _ref46;
    const context = q$1(RouterContext);
    const {
      context: contextFromParent,
      managedChildrenReturn
    } = useProvideRouter({
      managedChildrenParameters: {}
    });
    const index = F$1(() => (localPath !== null && localPath !== void 0 ? localPath : "<default>") + "-".concat(Math.random()), [localPath]);
    let consumeRouterReturn = null;
    useEnsureStability$1("Router", !!context);
    if (context) {
      consumeRouterReturn = useConsumeRouter({
        consumeRouterParameters: {
          localPath,
          onLocalPathChange
        },
        context,
        managedChildParameters: {
          index
        }
      });
    }
    const {
      consumeRouterReturn: {
        level,
        matches,
        pathWhenMatching
      }
    } = (_consumeRouterReturn = consumeRouterReturn) !== null && _consumeRouterReturn !== void 0 ? _consumeRouterReturn : {
      consumeRouterReturn: {
        level: -1,
        matches: null,
        pathWhenMatching: null
      }
    };
    const controls = useRouterControls(level);
    A(ref, () => ({
      level,
      matches,
      pathWhenMatching,
      ...controls
    }));
    return o$2(RouterContext.Provider, {
      value: contextFromParent,
      children: children(level == -1 ? "/" : matches ? pathWhenMatching : null, useRouterControls(level))
    });
  }

  /**
   * Provides access to the requested Search Param's value
   *
   * Note that while this function is like usePassiveState (itself like useState and useEffect combined),
   * the `setState` return function is, due to browser limitations, not syncronous, but that's
   * like most calls to `setState` anyway I guess?
   *
   * @param paramKey The name of the URL search parameter to reference
   * @param type The type of data encode/decode (`"string"` | `"boolean"` | `"number"` | `"bigint"`)
   * @param onParamValueChanged Will be called any time the requested Search Parameter's value changes.
   */
  function useSearchParams(paramKey, type, onParamValueChanged) {
    // We keep a local copy of our current Search Param value
    // because changing it is actually an asyncronous operation
    // and we can't know when it ends aside from just "did the URL change or not"
    // so we might as well keep this state around locally to compensate.
    const [getSavedParamValue, setSavedParamValue] = usePassiveState$1(onParamValueChanged, T$1(() => {
      return parseParam(new URL(window.location.toString()), paramKey, type);
    }, []));
    const setParamWithHistory = useStableCallback$1((newValueOrUpdater, reason) => {
      let prevValue = parseParam(new URL(window.location.toString()), paramKey, type);
      let nextValue = typeof newValueOrUpdater == "function" ? newValueOrUpdater(prevValue) : newValueOrUpdater;
      let newParams = new URLSearchParams(new URL(window.location.toString()).searchParams);
      unparseParam(newParams, paramKey, nextValue, type);
      let nextUrl = new URL(window.location.toString());
      nextUrl.search = prettyPrintParams(newParams);
      history["".concat(reason !== null && reason !== void 0 ? reason : "replace", "State")]({}, document.title, nextUrl);
      setSavedParamValue(nextValue);
    });
    // Any time the URL changes, it means the Search Param we care about might have changed.
    // Parse it out and save it.
    useUrl(useStableCallback$1(url => {
      const newParam = parseParam(new URL(url), paramKey, type);
      setSavedParamValue(newParam);
    }));
    return [getSavedParamValue, setParamWithHistory];
  }
  function prettyPrintParams(params) {
    const paramArray = [...params.entries()].filter((key, value) => value != null);
    if (paramArray.length == 0) return "";
    let queryString = paramArray.map(_ref47 => {
      let [key, value] = _ref47;
      if (value === "" || value === true) return "".concat(encodeURIComponent(key));else return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
    }).join("&");
    return "?".concat(queryString);
  }
  const Component = () => {
    const [url, setUrl] = useState$1("");
    useUrl(setUrl);
    const [example, setExampleLocal] = useState$1(null);
    const [getExample, setExample] = useSearchParams("example", "number");
    return o$2(Router, {
      localPath: null,
      children: (path, _ref48) => {
        let {
          pushLocalPath,
          popLocalPath,
          setLocalPath
        } = _ref48;
        return path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is the current URL: ", o$2("code", {
              children: url
            }), "."]
          }), o$2("p", {
            children: "This is content in the root router. It is always displayed, no matter what."
          }), o$2("p", {
            children: ["The ", o$2("code", {
              children: "Router"
            }), " that's rendering this content cannot have path-related functions performed on it, since the path is always just implicitly ", o$2("code", {
              children: "/"
            }), "."]
          }), o$2("p", {
            children: "Just beneath me is a child component that reads the first path after the root."
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => {
                debugger;
                pushLocalPath("test1");
              },
              children: "Push \"test1\""
            })
          }), o$2("p", {
            children: o$2("button", {
              disabled: true,
              onClick: () => popLocalPath(),
              children: "Pop"
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => setLocalPath("test1"),
              children: "Set \"test1\""
            })
          }), o$2("p", {
            children: o$2("label", {
              children: ["Search param example: ", o$2("input", {
                value: example !== null && example !== void 0 ? example : undefined,
                type: "number",
                onInput: e => setExample(e.currentTarget.valueAsNumber)
              })]
            })
          }), o$2("hr", {}), o$2(Swappable, {
            children: o$2("div", {
              children: o$2(Level1, {})
            })
          })]
        });
      }
    });
  };
  function Level1() {
    //const [{ popLocalPath, pushLocalPath, setLocalPath }, setRouteControls] = useState<Partial<RouterControls>>({});
    return o$2(_$2, {
      children: [o$2(Router, {
        localPath: null,
        children: (path, _ref49) => {
          let {
            popLocalPath,
            pushLocalPath,
            setLocalPath
          } = _ref49;
          return path != null && o$2("div", {
            children: [o$2("p", {
              children: ["This is within the first-level child ", o$2("code", {
                children: "Router"
              }), " that displays ", o$2("em", {
                children: "default content"
              }), ". That is, if no other ", o$2("code", {
                children: "Router"
              }), " at this level matches (which is presumably true if you're reading this), then ", o$2("em", {
                children: "this"
              }), " ", o$2("code", {
                children: "Router"
              }), " will display."]
            }), o$2("p", {
              children: ["The current path is: ", o$2("code", {
                children: path
              })]
            }), o$2("p", {
              children: ["These buttons are hooked up to this ", o$2("code", {
                children: "Router"
              }), "'s ", o$2("code", {
                children: "ref"
              }), ", so they control this level in the path."]
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("");
              },
              children: "(empty string)"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test1");
              },
              children: "test1"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test2");
              },
              children: "test2"
            })]
          });
        }
      }), o$2(Router, {
        localPath: "",
        children: path => path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is within the first-level child ", o$2("code", {
              children: "Router"
            }), " that displays when the path is empty (this is different from the default path, taken when there is no match from anyone at this level)."]
          }), o$2("p", {
            children: ["The current path is: ", o$2("code", {
              children: path
            })]
          })]
        })
      })]
    });
  }
  /*
  function Test1() {
        const [{ popLocalPath: popHash1, pushLocalPath: pushHash1, setLocalPath: setHash1 }, setRouteControls] = useState<Partial<RouterControls>>({});
       return (
          <>
              <p>This is within the first-level child <code>Router</code> that displays when the path is <code>test1</code>.<Test1 /></p>
              <p>Level 1, Test1
                  <button onClick={() => { debugger; pushHash1?.("testa") }}>testA</button>
                  <Router ref={setRouteControls} localPath="testa">
                      <div>A</div>
                  </Router>
              </p>
          </>
       )
  }
   function Test2() {
      const [route0Controls, setRoute0Controls] = useState<RouterRefType | null>(null);
      const [route1Controls, setRoute1Controls] = useState<RouterRefType | null>(null);
       const [param, setParam] = useSearchParams("param", "boolean");
      console.log(param == null ? "<null>" : param);
      return (<>
          Test2: "{param == null ? "<null>" : param}".
          <Swappable>
              <span>
                  <Router ref={setRoute1Controls} localPath="">
                      <div>
                          Test2
                          <button onClick={() => route1Controls?.setLocalPath?.("testa")}>testA</button>
                      </div>
                  </Router>
                  <Router ref={setRoute1Controls} localPath="testa">
                      <div>
                          <div>A</div>
                          <label><input checked={param ?? false} type="checkbox" onInput={e => { e.preventDefault(); setParam(e.currentTarget.checked) }} />Checkbox</label>
                      </div>
                  </Router>
              </span>
          </Swappable>
      </>
      )
  }*/
  requestAnimationFrame(() => {
    B$2(o$2(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jYXRjaC1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMzFmODAyMTMxNGJjMmNmZTg2NTJhMzNlNWY2YTFjNDdlMmIyMDg0OF9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXRpbC91c2UtY2FsbC1jb3VudC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDEuMi4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAMzFmODAyMTMxNGJjMmNmZTg2NTJhMzNlNWY2YTFjNDdlMmIyMDg0OF9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jbGFzc2VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvcmFuZG9tLWlkLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXByb3BzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDMxZjgwMjEzMTRiYzJjZmU4NjUyYTMzZTVmNmExYzQ3ZTJiMjA4NDhfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2NraW5nLWVsZW1lbnRzQDAuMS4xL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vd2ljZy1pbmVydEAzLjEuMi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvUHVyZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9wb3J0YWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtaW1wZXJhdGl2ZS1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0AzMWY4MDIxMzE0YmMyY2ZlODY1MmEzM2U1ZjZhMWM0N2UyYjIwODQ4X3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vY2xzeEAxLjIuMS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXJlZnMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNANDlmMjQ3ZTA4NTg3MTFmODYzNjdhNDA2MTNhZjZmYjFiMmQxYjg1Zl9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2NraW5nLWVsZW1lbnRzQDAuMS4xL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vd2ljZy1pbmVydEAzLjEuMi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDQ5ZjI0N2UwODU4NzExZjg2MzY3YTQwNjEzYWY2ZmIxYjJkMWI4NWZfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A0OWYyNDdlMDg1ODcxMWY4NjM2N2E0MDYxM2FmNmZiMWIyZDFiODVmX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvY29udGV4dC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2V4Y2x1c2l2ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvdXRpbC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3N3YXBwYWJsZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb25hYmxlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvZmFkZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NsaXAudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jbGlwLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jb2xsYXBzZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NvbGxhcHNlLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9mbGlwLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvc2xpZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS1mYWRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkA2ZjM0YWUzNjQ3YWFhZGFkMDM4MWExZWFlYTYwZjQ0MTA1MjZlZTgzX3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvem9vbS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25ANmYzNGFlMzY0N2FhYWRhZDAzODFhMWVhZWE2MGY0NDEwNTI2ZWU4M19wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3NsaWRlLXpvb20udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS16b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQDZmMzRhZTM2NDdhYWFkYWQwMzgxYTFlYWVhNjBmNDQxMDUyNmVlODNfcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy96b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGV2dG9vbHMvc3JjL2RldnRvb2xzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NoZWNrLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4xL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NvbXBvbmVudC1zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjEvbm9kZV9tb2R1bGVzL3ByZWFjdC9kZWJ1Zy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMS9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9pbmRleC5qcyIsIi4uL3NyYy91c2UtdXJsLnRzeCIsIi4uL3NyYy91dGlsLnRzeCIsIi4uL3NyYy91c2Utcm91dGVyLWNvbnN1bWVyLnRzeCIsIi4uL3NyYy9yb290LXJvdXRlci1lcnJvci50cyIsIi4uL3NyYy91c2UtcG9wLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1wdXNoLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1zZXQtbG9jYWwtcGF0aC50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1jb250cm9scy50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1wcm92aWRlci50c3giLCIuLi9zcmMvcm91dGVyLnRzeCIsIi4uL3NyYy91c2Utc2VhcmNoLXBhcmFtcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBhXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYlxuICovXG5jb25zdCBkZXB0aFNvcnQgPSAoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoO1xuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdHdoaWxlICgoYyA9IHJlcmVuZGVyUXVldWUuc2hpZnQoKSkpIHtcblx0XHRpZiAoYy5fZGlydHkpIHtcblx0XHRcdGxldCByZW5kZXJRdWV1ZUxlbmd0aCA9IHJlcmVuZGVyUXVldWUubGVuZ3RoO1xuXHRcdFx0cmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdFx0aWYgKHJlcmVuZGVyUXVldWUubGVuZ3RoID4gcmVuZGVyUXVldWVMZW5ndGgpIHtcblx0XHRcdFx0Ly8gV2hlbiBpLmUuIHJlcmVuZGVyaW5nIGEgcHJvdmlkZXIgYWRkaXRpb25hbCBuZXcgaXRlbXMgY2FuIGJlIGluamVjdGVkLCB3ZSB3YW50IHRvXG5cdFx0XHRcdC8vIGtlZXAgdGhlIG9yZGVyIGZyb20gdG9wIHRvIGJvdHRvbSB3aXRoIHRob3NlIG5ldyBpdGVtcyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW0gaW4gYVxuXHRcdFx0XHQvLyBzaW5nbGUgcGFzc1xuXHRcdFx0XHRyZXJlbmRlclF1ZXVlLnNvcnQoZGVwdGhTb3J0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRbXX0gKi9cblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChcblx0XHRcdGNoaWxkVk5vZGUgPT0gbnVsbCB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tICE9IG51bGwgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSA9PSBuZXdQYXJlbnRWTm9kZS5fbmV4dERvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXdQYXJlbnRWTm9kZS5fX25leHREb20gcG9pbnRzIHRvIGEgZG9tIG5vZGUgdGhhdCBpcyBhYm91dCB0b1xuXHRcdFx0XHQvLyBiZSB1bm1vdW50ZWQsIHRoZW4gZ2V0IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhhdCB2bm9kZSBhbmQgc2V0XG5cdFx0XHRcdC8vIF9uZXh0RG9tIHRvIGl0XG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gZ2V0TGFzdERvbShvbGRQYXJlbnRWTm9kZSkubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBnZXRMYXN0RG9tKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09IG51bGwgfHwgdHlwZW9mIHZub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLl9kb207XG5cdH1cblxuXHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0Zm9yIChsZXQgaSA9IHZub2RlLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdGxldCBsYXN0RG9tID0gZ2V0TGFzdERvbShjaGlsZCk7XG5cdFx0XHRcdGlmIChsYXN0RG9tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhc3REb207XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ3dpZHRoJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hlaWdodCcgJiZcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZS5pbmRleE9mKCctJykgIT0gLTEpKSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIHRydWVdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUsIHNsaWNlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQvLyBJZiB0aGUgcHJldmlvdXMgZGlmZiBiYWlsZWQgb3V0LCByZXN1bWUgY3JlYXRpbmcvaHlkcmF0aW5nLlxuXHRpZiAob2xkVk5vZGUuX2h5ZHJhdGluZyAhPSBudWxsKSB7XG5cdFx0aXNIeWRyYXRpbmcgPSBvbGRWTm9kZS5faHlkcmF0aW5nO1xuXHRcdG9sZERvbSA9IG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdC8vIGlmIHdlIHJlc3VtZSwgd2Ugd2FudCB0aGUgdHJlZSB0byBiZSBcInVubG9ja2VkXCJcblx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IFtvbGREb21dO1xuXHR9XG5cblx0aWYgKCh0bXAgPSBvcHRpb25zLl9kaWZmKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHR0cnkge1xuXHRcdG91dGVyOiBpZiAodHlwZW9mIG5ld1R5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0bGV0IGMsIGlzTmV3LCBvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90LCBjbGVhclByb2Nlc3NpbmdFeGNlcHRpb247XG5cdFx0XHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBjcmVhdGVDb250ZXh0IGFwaS4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHdpbGwgcGFzc1xuXHRcdFx0Ly8gdGhlIGNvbnRleHQgdmFsdWUgYXMgYHRoaXMuY29udGV4dGAganVzdCBmb3IgdGhpcyBjb21wb25lbnQuXG5cdFx0XHR0bXAgPSBuZXdUeXBlLmNvbnRleHRUeXBlO1xuXHRcdFx0bGV0IHByb3ZpZGVyID0gdG1wICYmIGdsb2JhbENvbnRleHRbdG1wLl9pZF07XG5cdFx0XHRsZXQgY29tcG9uZW50Q29udGV4dCA9IHRtcFxuXHRcdFx0XHQ/IHByb3ZpZGVyXG5cdFx0XHRcdFx0PyBwcm92aWRlci5wcm9wcy52YWx1ZVxuXHRcdFx0XHRcdDogdG1wLl9kZWZhdWx0VmFsdWVcblx0XHRcdFx0OiBnbG9iYWxDb250ZXh0O1xuXG5cdFx0XHQvLyBHZXQgY29tcG9uZW50IGFuZCBzZXQgaXQgdG8gYGNgXG5cdFx0XHRpZiAob2xkVk5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0XHRjID0gbmV3Vk5vZGUuX2NvbXBvbmVudCA9IG9sZFZOb2RlLl9jb21wb25lbnQ7XG5cdFx0XHRcdGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wZW5kaW5nRXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbmV3IGNvbXBvbmVudFxuXHRcdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRoZSBjaGVjayBhYm92ZSB2ZXJpZmllcyB0aGF0IG5ld1R5cGUgaXMgc3VwcG9zZSB0byBiZSBjb25zdHJ1Y3RlZFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRydXN0IG1lLCBDb21wb25lbnQgaW1wbGVtZW50cyB0aGUgaW50ZXJmYWNlIHdlIHdhbnRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIHtcblx0XHRcdFx0XHRcdC8vIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBhIGJhaWwgYmVjYXVzZSBvZiBzQ1Ugd2UgaGF2ZSB0byB1cGRhdGVcblx0XHRcdFx0XHRcdC8vIHRoZSBwcm9wcywgc3RhdGUgYW5kIGRpcnR5LXN0YXRlLlxuXHRcdFx0XHRcdFx0Ly8gd2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIHN0cmljdC1lcXVhbGl0eSB3ZSBkb24ndCBhcyB0aGUgY2hpbGQgY291bGQgc3RpbGxcblx0XHRcdFx0XHRcdC8vIGJlIGRpcnRpZWQgc2VlICMzODgzXG5cdFx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJbiBjYXNlcyBvZiBiYWlsaW5nIGR1ZSB0byBzdHJpY3QtZXF1YWxpdHkgd2UgaGF2ZSB0byByZXNldCBmb3JjZSBhcyB3ZWxsXG5cdFx0XHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuLmZvckVhY2godm5vZGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlKSB2bm9kZS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkge1xuXHRcdFx0YXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHRcdHZub2RlLl9jb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KFxuXHRcdFx0XHRcdHJbaV0sXG5cdFx0XHRcdFx0cGFyZW50Vk5vZGUsXG5cdFx0XHRcdFx0c2tpcFJlbW92ZSB8fCB0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHtcblx0XHRyZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX3BhcmVudCA9IHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG9iamVjdH0gW3JlcGxhY2VOb2RlXSBPcHRpb25hbDogQXR0ZW1wdCB0byByZS11c2UgYW5cbiAqIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgcmVwbGFjZU5vZGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudERvbSwgcmVwbGFjZU5vZGUpIHtcblx0aWYgKG9wdGlvbnMuX3Jvb3QpIG9wdGlvbnMuX3Jvb3Qodm5vZGUsIHBhcmVudERvbSk7XG5cblx0Ly8gV2UgYWJ1c2UgdGhlIGByZXBsYWNlTm9kZWAgcGFyYW1ldGVyIGluIGBoeWRyYXRlKClgIHRvIHNpZ25hbCBpZiB3ZSBhcmUgaW5cblx0Ly8gaHlkcmF0aW9uIG1vZGUgb3Igbm90IGJ5IHBhc3NpbmcgdGhlIGBoeWRyYXRlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgRE9NXG5cdC8vIGVsZW1lbnQuLlxuXHRsZXQgaXNIeWRyYXRpbmcgPSB0eXBlb2YgcmVwbGFjZU5vZGUgPT09ICdmdW5jdGlvbic7XG5cblx0Ly8gVG8gYmUgYWJsZSB0byBzdXBwb3J0IGNhbGxpbmcgYHJlbmRlcigpYCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZVxuXHQvLyBET00gbm9kZSwgd2UgbmVlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRyZWUuIFdlIGRvXG5cdC8vIHRoaXMgYnkgYXNzaWduaW5nIGEgbmV3IGBfY2hpbGRyZW5gIHByb3BlcnR5IHRvIERPTSBub2RlcyB3aGljaCBwb2ludHNcblx0Ly8gdG8gdGhlIGxhc3QgcmVuZGVyZWQgdHJlZS4gQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50LCB3aGljaFxuXHQvLyBtZWFucyB0aGF0IHdlIGFyZSBtb3VudGluZyBhIG5ldyB0cmVlIGZvciB0aGUgZmlyc3QgdGltZS5cblx0bGV0IG9sZFZOb2RlID0gaXNIeWRyYXRpbmdcblx0XHQ/IG51bGxcblx0XHQ6IChyZXBsYWNlTm9kZSAmJiByZXBsYWNlTm9kZS5fY2hpbGRyZW4pIHx8IHBhcmVudERvbS5fY2hpbGRyZW47XG5cblx0dm5vZGUgPSAoXG5cdFx0KCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZSkgfHxcblx0XHRwYXJlbnREb21cblx0KS5fY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsImltcG9ydCB7IGFzc2lnbiwgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKFxuXHRcdHZub2RlLnR5cGUsXG5cdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSB8fCB2bm9kZS5rZXksXG5cdFx0cmVmIHx8IHZub2RlLnJlZixcblx0XHRudWxsXG5cdCk7XG59XG4iLCIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgncHJlYWN0JykuVk5vZGV9IFZOb2RlICovXG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGZpbGUgZXhwb3J0cyB2YXJpb3VzIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQmFiZWwncyBcImF1dG9tYXRpY1wiIEpTWCBydW50aW1lIEFQSTpcbiAqIC0ganN4KHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeHModHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIF9fc291cmNlLCBfX3NlbGYpXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGNyZWF0ZVZOb2RlIGhlcmUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cbiAqIEJlbmNobWFya3M6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWY2YjU0YTBiNDYzMjEwMGE3ZGNkMmIzXG4gKi9cblxuLyoqXG4gKiBKU1guRWxlbWVudCBmYWN0b3J5IHVzZWQgYnkgQmFiZWwncyB7cnVudGltZTpcImF1dG9tYXRpY1wifSBKU1ggdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1ZOb2RlWyd0eXBlJ119IHR5cGVcbiAqIEBwYXJhbSB7Vk5vZGVbJ3Byb3BzJ119IHByb3BzXG4gKiBAcGFyYW0ge1ZOb2RlWydrZXknXX0gW2tleV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW2lzU3RhdGljQ2hpbGRyZW5dXG4gKiBAcGFyYW0ge3Vua25vd259IFtfX3NvdXJjZV1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW19fc2VsZl1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgX19zb3VyY2UsIF9fc2VsZikge1xuXHQvLyBXZSdsbCB3YW50IHRvIHByZXNlcnZlIGByZWZgIGluIHByb3BzIHRvIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yXG5cdC8vIGZvcndhcmRSZWYgY29tcG9uZW50cyBpbiB0aGUgZnV0dXJlLCBidXQgdGhhdCBzaG91bGQgaGFwcGVuIHZpYVxuXHQvLyBhIHNlcGFyYXRlIFBSLlxuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdyZWYnKSB7XG5cdFx0XHRyZWYgPSBwcm9wc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wczogbm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IC0tdm5vZGVJZCxcblx0XHRfX3NvdXJjZSxcblx0XHRfX3NlbGZcblx0fTtcblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHMuXG5cdC8vIE5vdGU6IGB0eXBlYCBpcyBvZnRlbiBhIFN0cmluZywgYW5kIGNhbiBiZSBgdW5kZWZpbmVkYCBpbiBkZXZlbG9wbWVudC5cblx0aWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIChyZWYgPSB0eXBlLmRlZmF1bHRQcm9wcykpIHtcblx0XHRmb3IgKGkgaW4gcmVmKVxuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkUHJvcHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHJlZltpXTtcblx0XHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQge1xuXHRjcmVhdGVWTm9kZSBhcyBqc3gsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeHMsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeERFVixcblx0RnJhZ21lbnRcbn07XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRsZXQgcHJldlNjdSA9IGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuXHRcdFx0Y29uc3QgcHJldkNXVSA9IGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgZm9yY2VkIHVwZGF0ZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCB3aWxsXG5cdFx0XHQvLyBub3QgYmUgY2FsbGVkLiBCdXQgd2UgdXNlIHRoYXQgdG8gdXBkYXRlIHRoZSBob29rIHZhbHVlcywgc28gd2Vcblx0XHRcdC8vIG5lZWQgdG8gY2FsbCBpdC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uKHAsIHMsIGMpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2ZvcmNlKSB7XG5cdFx0XHRcdFx0bGV0IHRtcCA9IHByZXZTY3U7XG5cdFx0XHRcdFx0Ly8gQ2xlYXIgdG8gYXZvaWQgb3RoZXIgc0NVIGhvb2tzIGZyb20gYmVpbmcgY2FsbGVkXG5cdFx0XHRcdFx0cHJldlNjdSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR1cGRhdGVIb29rU3RhdGUocCwgcywgYyk7XG5cdFx0XHRcdFx0cHJldlNjdSA9IHRtcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcmV2Q1dVKSBwcmV2Q1dVLmNhbGwodGhpcywgcCwgcywgYyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBUaGlzIFNDVSBoYXMgdGhlIHB1cnBvc2Ugb2YgYmFpbGluZyBvdXQgYWZ0ZXIgcmVwZWF0ZWQgdXBkYXRlc1xuXHRcdFx0Ly8gdG8gc3RhdGVmdWwgaG9va3MuXG5cdFx0XHQvLyB3ZSBzdG9yZSB0aGUgbmV4dCB2YWx1ZSBpbiBfbmV4dFZhbHVlWzBdIGFuZCBrZWVwIGRvaW5nIHRoYXQgZm9yIGFsbFxuXHRcdFx0Ly8gc3RhdGUgc2V0dGVycywgaWYgd2UgaGF2ZSBuZXh0IHN0YXRlcyBhbmRcblx0XHRcdC8vIGFsbCBuZXh0IHN0YXRlcyB3aXRoaW4gYSBjb21wb25lbnQgZW5kIHVwIGJlaW5nIGVxdWFsIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG5cdFx0XHQvLyB3ZSBhcmUgc2FmZSB0byBiYWlsIG91dCBmb3IgdGhpcyBzcGVjaWZpYyBjb21wb25lbnQuXG5cdFx0XHQvKipcblx0XHRcdCAqXG5cdFx0XHQgKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50W1wic2hvdWxkQ29tcG9uZW50VXBkYXRlXCJdfVxuXHRcdFx0ICovXG5cdFx0XHQvLyBAdHMtaWdub3JlIC0gV2UgZG9uJ3QgdXNlIFRTIHRvIGRvd250cmFuc3BpbGVcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZUhvb2tTdGF0ZShwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdXBkYXRlSG9va1N0YXRlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCJcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH07XG59XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKTogXCJwcm9kdWN0aW9uXCIgfCBcImRldmVsb3BtZW50XCIge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudiEuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBcImRldmVsb3BtZW50XCI7XG5cbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEJ1aWxkTW9kZSA9IGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQ7Ly9tZW1vaXplKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQpIGFzIHR5cGVvZiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkOyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vb3A7XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgZ2V0QnVpbGRNb2RlIH0gZnJvbSBcIi4vbW9kZS5qc1wiO1xuXG5sZXQgdGltZW91dEhhbmRsZSA9IG51bGwgYXMgbnVtYmVyIHwgbnVsbDtcblxuaW50ZXJmYWNlIEhvb2tDYWxsQ291bnQge1xuICAgIGNhbGxDb3VudHM6IHsgW0s6IHN0cmluZ106IHsgdG90YWw6IG51bWJlciwgbW9tZW50OiBudW1iZXIgfSB8IHVuZGVmaW5lZCB9O1xufVxuXG50eXBlIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50ID0gKFdpbmRvdyAmIHR5cGVvZiBnbG9iYWxUaGlzKSAmIHtcbiAgICBfaG9va0NhbGxDb3VudDogSG9va0NhbGxDb3VudDtcbn1cblxuZnVuY3Rpb24gY2FsbENvdW50VShob29rOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IG5hbWUgPSBob29rLm5hbWU7XG4gICAgaWYgKGZpbHRlckFsbCB8fCBmaWx0ZXJzLmhhcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgY29uc29sZS5hc3NlcnQobmFtZS5sZW5ndGggPiAwKTtcblxuICAgICh3aW5kb3cgYXMgV2luZG93V2l0aEhvb2tDYWxsQ291bnQpLl9ob29rQ2FsbENvdW50ID8/PSB7IGNhbGxDb3VudHM6IHt9IH07XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSA/Pz0geyBtb21lbnQ6IDAsIHRvdGFsOiAwIH07XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSEubW9tZW50ICs9IDE7XG4gICAgKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c1tuYW1lXSEudG90YWwgKz0gMTtcblxuICAgIGlmICh0aW1lb3V0SGFuZGxlID09IG51bGwpIHtcbiAgICAgICAgdGltZW91dEhhbmRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygod2luZG93IGFzIFdpbmRvd1dpdGhIb29rQ2FsbENvdW50KS5faG9va0NhbGxDb3VudC5jYWxsQ291bnRzTW9tZW50KTtcbiAgICAgICAgICAgIC8vKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50c01vbWVudCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbzogQXJyYXk8eyByZWFkb25seSBIb29rOiBzdHJpbmc7IHJlYWRvbmx5IE5vdzogbnVtYmVyOyByZWFkb25seSBUb3RhbDogbnVtYmVyOyB9PiA9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2hvb2ssIGNvdW50c10pID0+IHsgcmV0dXJuIHsgSG9vazogaG9vayB8fCBcIj9cIiwgTm93OiBjb3VudHM/Lm1vbWVudCB8fCAwLCBUb3RhbDogY291bnRzPy50b3RhbCB8fCAwIH0gYXMgY29uc3QgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoeyBOb3cgfSkgPT4geyByZXR1cm4gISFOb3cgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKHsgTm93OiBsaHNNIH0sIHsgTm93OiByaHNNIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGhzTSAmJiAhcmhzTSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxoc00gfHw9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmhzTSB8fD0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGhzTSAtIHJoc007XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShvLCBbJ0hvb2snLCAnTm93JywgJ1RvdGFsJ10pO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoKHdpbmRvdyBhcyBXaW5kb3dXaXRoSG9va0NhbGxDb3VudCkuX2hvb2tDYWxsQ291bnQuY2FsbENvdW50cykuZm9yRWFjaCgoWywgY291bnRzXSkgPT4geyBjb3VudHMhLm1vbWVudCA9IDA7IH0pO1xuICAgICAgICAgICAgdGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubGV0IGZpbHRlckFsbCA9IGZhbHNlO1xuY29uc3QgZmlsdGVycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUNhbGxDb3VudChob29rOiBGdW5jdGlvbiB8IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJBbGwgPSAoaG9vayA9PT0gXCJhbGxcIik7XG5cbiAgICBpZiAoaG9vayAhPSBcImFsbFwiKVxuICAgICAgICBmaWx0ZXJzLmFkZChob29rLm5hbWUpO1xufVxuXG5leHBvcnQgY29uc3QgbW9uaXRvckNhbGxDb3VudDogdHlwZW9mIGNhbGxDb3VudFUgPSAoZ2V0QnVpbGRNb2RlKCkgPT0gXCJkZXZlbG9wbWVudFwiKSA/IGNhbGxDb3VudFUgOiBub29wO1xuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldEJ1aWxkTW9kZSB9IGZyb20gXCIuLi91dGlsL21vZGUuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKiogVGFrZXMgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgYSB2YWx1ZSwgdW5saWtlIGBPblBhc3NpdmVTdGF0ZUNoYW5nZWAgd2hpY2ggcmVhY3RzIHRvIHRob3NlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8UywgUj4gPSAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpIDogKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uOiBSKSA9PiB2b2lkKTtcbi8qKiBSZXNwb25kcyB0byBhIGNoYW5nZSBpbiBhIHZhbHVlLCB1bmxpa2UgYFBhc3NpdmVTdGF0ZVVwZGF0ZXJgIHdoaWNoIGNhdXNlcyB0aGUgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8UywgUj4gPSAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSkgOiAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbjogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuXG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIGlmIChnZXRCdWlsZE1vZGUoKSA9PSAncHJvZHVjdGlvbicpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZjxBcnJheTxUPj4oW10pO1xuICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWY8QXJyYXk8Ym9vbGVhbj4+KFtdKTtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCBhcyBhbnksIC0xKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFUgZXh0ZW5kcyBUPih2YWx1ZTogVSwgaTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSArIDE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpfS1pbmRleGVkIGFyZ3VtZW50ICgke2kgPj0gMD8gSlNPTi5zdHJpbmdpZnkodmFsdWVzW2ldKSA6IFwidGhlIG51bWJlciBvZiBzdXBwb3NlZGx5IHN0YWJsZSBlbGVtZW50c1wifSkuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gcXVldWVNaWNyb3Rhc2spKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlUGFzc2l2ZVN0YXRlKTtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMV0pID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0aGlzIGhlcmUgKGFzIHdlbGwgYXMgYmVsb3cpIGluIGNhc2UgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgaW52b2tlcyB0aGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmVhc29uUmVmLmN1cnJlbnQgPSByZWFzb24gYXMgUjtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWFzb24gPSByZWFzb25SZWYuY3VycmVudCEgYXMgUjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogcHJldkRlcCwgbmV4dFJlYXNvbikgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9XG5cbi8qKiBcbiAqIEFuIGFsdGVybmF0aXZlIHRvIHVzZSBmb3IgYGN1c3RvbURlYm91bmNlUmVuZGVyaW5nYCB0aGF0IGNhdXNlcyBgdXNlUGFzc2l2ZVN0YXRlYCB0byBydW4gY2hhbmdlcyB3aXRob3V0IHdhaXRpbmcgYSB0aWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuSW1tZWRpYXRlbHkoZjogKCkgPT4gdm9pZCkgeyBmKCk7IH0iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKGxoczogRWxlbWVudFByb3BzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdLCByaHM6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSk6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRDaGlsZHJlbik7XG4gICAgXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbnR5cGUgQyA9IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJjbGFzc05hbWVcIl07XG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlaXIgYGNsYXNzYCBhbmQgYGNsYXNzTmFtZWAgcHJvcGVydGllcy5cbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxuICogXG4gKiBAcGFyYW0gbGhzIENsYXNzZXMgb2YgdGhlIGZpcnN0IGNvbXBvbmVudFxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXMobGhzQ2xhc3M6IEMsIGxoc0NsYXNzTmFtZTogQywgcmhzQ2xhc3M6IEMsIHJoc0NsYXNzTmFtZTogQyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNZXJnZWRDbGFzc2VzKTtcblxuICAgIC8vIE5vdGU6IEZvciB0aGUgc2FrZSBvZiBmb3J3YXJkIGNvbXBhdGliaWxpdHksIHRoaXMgZnVuY3Rpb24gaXMgbGFiZWxsZWQgYXNcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cblxuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pXG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsIlxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIGJlY2F1c2UgdXNlQmVmb3JlTGF5b3V0RWZmZWN0IGFsc28gbmVlZHMgcmFuZG9tIElEcyBmb3IgaXRzIG93biByZWFzb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn0iLCJcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuLi91dGlsL3JhbmRvbS1pZC5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgcHJldklucHV0cz86IElucHV0cyB8IHVuZGVmaW5lZCwgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbi8vXG4vLyBBbHNvLCBpbiB0aGVvcnkgdGhpcyBjb3VsZCBiZSByZXBsYWNlZCB3aXRoIGB1c2VJbnNlcnRpb25FZmZlY3RgLFxuLy8gYnV0IHRoYXQgcHJvYmFibHkgd29uJ3QgYmUgYXZhaWxhYmxlIGluIFByZWFjdCBmb3IgYXdoaWxlLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKHZub2RlLCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IGVmZmVjdEluZm8ucHJldklucHV0cztcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8ucHJldklucHV0cyA9IGVmZmVjdEluZm8uaW5wdXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/Lih2bm9kZSwgLi4uYXJncyk7XG59XG5cblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdO1xub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrIHwgbnVsbCwgaW5wdXRzPzogSW5wdXRzKSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VCZWZvcmVMYXlvdXRFZmZlY3QpO1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgdXNlQmVmb3JlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LmpzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gaW5wdXQgdmFsdWUsIHJldHVybnMgYSBjb25zdGFudCBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBcbiAqIGluc2lkZSBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGluY2x1ZGluZyBpdCBpbiB0aGUgZGVwZW5kZW5jeSBhcnJheS5cbiAqIFxuICogVGhpcyB1c2VzIGBvcHRpb25zLmRpZmZlZGAgaW4gb3JkZXIgdG8gcnVuIGJlZm9yZSBldmVyeXRoaW5nLCBldmVuXG4gKiByZWYgYXNzaWdubWVudC4gVGhpcyBtZWFucyB0aGlzIGdldHRlciBpcyBzYWZlIHRvIHVzZSBhbnl3aGVyZSAqKipleGNlcHQgdGhlIHJlbmRlciBwaGFzZSoqKi5cbiAqIFxuICogQHBhcmFtIHZhbHVlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVHZXR0ZXI8VD4odmFsdWU6IFQpIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZVN0YWJsZUdldHRlcik7XG5cbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSksIFt2YWx1ZV0pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSk7XG59XG5cblxuLyoqXG4gKiBMaWtlIGB1c2VTdGFibGVHZXR0ZXJgLCBidXQgKioqcmVxdWlyZXMqKiogdGhhdCBldmVyeXRoaW5nIGluIHRoZSBvYmplY3QgaXMgYWxzbyBzdGFibGUsXG4gKiBhbmQgaW4gdHVybiByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGl0c2VsZiBpcyBzdGFibGUuXG4gKiBAcGFyYW0gdCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlT2JqZWN0PFQgZXh0ZW5kcyB7fT4odDogVCk6IFQge1xuICAgIGNvbnN0IGUgPSBPYmplY3QuZW50cmllcyh0KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVPYmplY3RcIiwgZS5sZW5ndGgsIC4uLmUubWFwKChbX2ssIHZdKSA9PiB2KSk7XG4gICAgcmV0dXJuIHVzZVJlZih0KS5jdXJyZW50O1xufVxuXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFja05hdGl2ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyLmpzXCI7XG5cblxuLy9jb25zdCBfSVNfU1RBQkxFX0dFVFRFUiA9IFN5bWJvbChcIlNUQUJMRVwiKTtcbmV4cG9ydCB0eXBlIFN0YWJsZTxUPiA9IFQ7Ly8gJiB7IFtfU1RBQkxFXTogdHJ1ZSB9O1xuXG4vKipcbiAqIFdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggY2FsbGJhY2tzIGFyZSBzdGFibGUgd2l0aCBhIFdlYWtNYXAgaW5zdGVhZCBvZiwgc2F5LCBhIHN5bWJvbCBiZWNhdXNlXG4gKiBgdXNlQ2FsbGJhY2tgIHdpbGwgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCdzIHN0YWJsZSBhY3Jvc3MgKmFsbCogcmVuZGVycywgbWVhbmluZ1xuICogd2UgY2FuJ3QgdXNlIG91ciBmdW5ueSBcImBpZmAgb25seSB3b3JrcyBoZXJlIGJlY2F1c2UgaXQgZG9lc24ndCBicmVhayB0aGUgcnVsZXMgb2YgaG9va3NcIiB0cmljayB0aGVuLlxuICovXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcDxGdW5jdGlvbiwgYm9vbGVhbj4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyBGdW5jdGlvbj4ob2JqOiBUKTogb2JqIGlzIFN0YWJsZTxUPiB7XG4gICAgcmV0dXJuIChtYXAuZ2V0KG9iaikgPz8gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2V0SXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4ob2JqOiBUKTogU3RhYmxlPFQ+IHtcbiAgICBtYXAuc2V0KG9iaiwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG4vKipcbiAqIEFsdGVybmF0ZSB1c2VDYWxsYmFjaygpIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lICh3cmFwcGVkKSBmdW5jdGlvbiByZWZlcmVuY2VcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXlzIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzLlxuICogXG4gKiBJbiBnZW5lcmFsLCBqdXN0IHBhc3MgdGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGJlIHN0YWJsZSAoYnV0IHlvdSBjYW4ndCB1c2UgaXQgZHVyaW5nIHJlbmRlcixcbiAqIHNvIGJlIGNhcmVmdWwhKS4gIEFsdGVybmF0aXZlbHksIGlmIHlvdSBuZWVkIGEgc3RhYmxlIGNhbGxiYWNrIHRoYXQgKipjYW4qKiBiZSB1c2VkXG4gKiBkdXJpbmcgcmVuZGVyLCBwYXNzIGFuIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgYW5kIGl0J2xsIGFjdCBsaWtlIGB1c2VDYWxsYmFja2Agd2l0aCBhblxuICogZW1wdHkgZGVwZW5kZW5jeSBhcnJheSwgYnV0IHdpdGggdGhlIGFzc29jaWF0ZWQgc3RhYmxlIHR5cGluZy4gSW4gdGhpcyBjYXNlLCB5b3UgKioqbXVzdCoqKiBlbnN1cmUgdGhhdCBpdFxuICogdHJ1bHkgaGFzIG5vIGRlcGVuZGVuY2llcy9vbmx5IHN0YWJsZSBkZXBlbmRlbmNpZXMhIVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzIEZ1bmN0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZD4oZm46IE5vbk51bGxhYmxlPFQ+LCBub0RlcHM/OiBbXSB8IG51bGwgfCB1bmRlZmluZWQpOiBTdGFibGU8Tm9uTnVsbGFibGU8VD4+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZVN0YWJsZUNhbGxiYWNrKTtcbiAgICBcbiAgICB0eXBlIFUgPSAoTm9uTnVsbGFibGU8VD4gJiAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlQ2FsbGJhY2tcIiwgbm9EZXBzID09IG51bGwsIG5vRGVwcz8ubGVuZ3RoLCBpc1N0YWJsZUdldHRlcjxVPihmbiBhcyBVKSk7XG4gICAgaWYgKGlzU3RhYmxlR2V0dGVyKGZuKSlcbiAgICAgICAgcmV0dXJuIGZuO1xuXG4gICAgaWYgKG5vRGVwcyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDYWxsYmFja0dldHRlciA9IHVzZVN0YWJsZUdldHRlcjxVPihmbik7XG4gICAgICAgIHJldHVybiBzZXRJc1N0YWJsZUdldHRlcih1c2VDYWxsYmFja05hdGl2ZTxVPigoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICAgICAgfSkgYXMgVSwgW10pKTtcblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQobm9EZXBzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIHJldHVybiBzZXRJc1N0YWJsZUdldHRlcih1c2VDYWxsYmFja05hdGl2ZTxVPihmbiwgW10pKTtcbiAgICB9XG59XG5cbiIsIlxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgRWxlbWVudFByb3BzLCBSZWYsIFJlZk9iamVjdCB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAocmVmIGFzIFJlZk9iamVjdDxUIHwgbnVsbD4pLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gKiBAcGFyYW0gbGhzIFxuICogQHBhcmFtIHJocyBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHJoczogRWxlbWVudFByb3BzPEU+W1wicmVmXCJdLCBsaHM6IEVsZW1lbnRQcm9wczxFPltcInJlZlwiXSkge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkUmVmcyk7XG4gICAgXG4gICAgLy8gVGhpcyAqbXVzdCogYmUgc3RhYmxlIGluIG9yZGVyIHRvIHByZXZlbnQgcmVwZWF0ZWQgcmVzZXQgYG51bGxgIGNhbGxzIGFmdGVyIGV2ZXJ5IHJlbmRlci5cbiAgICBjb25zdCBjb21iaW5lZCA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uIGNvbWJpbmVkKGN1cnJlbnQ6IEUgfCBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzITtcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocyE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ1NTUHJvcGVydGllcywgRWxlbWVudFByb3BzIH0gZnJvbSBcIi4uL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBDU1NQcm9wZXJ0aWVzIHtcbiAgICAvLyBUT0RPOiBUaGlzIHN1Y2tzIEQ6XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBDU1NQcm9wZXJ0aWVzO1xufVxuXG4vKipcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gKiBcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IEVsZW1lbnRQcm9wczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0pOiBFbGVtZW50UHJvcHM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkU3R5bGVzKTtcblxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cbiAgICAgICAgaWYgKGxocyAmJiAhcmhzKVxuICAgICAgICAgICAgcmV0dXJuIGxocztcbiAgICAgICAgaWYgKCFsaHMgJiYgcmhzKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXG4gICAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoc3R5bGVTdHJpbmdUb09iamVjdChsaHMgYXMgc3RyaW5nKSwgcmhzKSBhcyBDU1NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgc3R5bGVTdHJpbmdUb09iamVjdChyaHMgYXMgc3RyaW5nKSkgYXMgQ1NTUHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZ2ljPz8/XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihsaHMgPz8ge30pIGFzIENTU1Byb3BlcnRpZXMsXG4gICAgICAgIC4uLihyaHMgPz8ge30pIGFzIENTU1Byb3BlcnRpZXNcbiAgICB9IGFzIHVua25vd24gYXMgQ1NTUHJvcGVydGllc1xufVxuXG4iLCJpbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jaGlsZHJlbi5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlcy5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmcy5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkU3R5bGVzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1zdHlsZXMuanNcIjtcblxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XG4gICAgbG9nID0gbG9nMlxufVxuXG5cbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKiBcbiAqIFRoZSBob29rIGlzIGF3YXJlIG9mIGFuZCBjYW4gaW50ZWxsaWdlbnRseSBtZXJnZSBgY2xhc3NOYW1lYCwgYGNsYXNzYCwgYHN0eWxlYCwgYHJlZmAsIGFuZCBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0gbGhzMiBcbiAqIEBwYXJhbSByaHMyIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KC4uLmFsbFByb3BzOiBFbGVtZW50UHJvcHM8RT5bXSkge1xuICAgIG1vbml0b3JDYWxsQ291bnQodXNlTWVyZ2VkUHJvcHMpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogRWxlbWVudFByb3BzPEU+ID0ge307XG4gICAgZm9yIChsZXQgbmV4dFByb3BzIG9mIGFsbFByb3BzKSB7XG4gICAgICAgIHJldCA9IHVzZU1lcmdlZFByb3BzMjxFPihyZXQsIG5leHRQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY29uc3Qga25vd25zID0gbmV3IFNldDxzdHJpbmc+KFtcImNoaWxkcmVuXCIsIFwicmVmXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2xhc3NcIiwgXCJzdHlsZVwiXSlcblxuZnVuY3Rpb24gbWVyZ2VVbmtub3duKGtleTogc3RyaW5nLCBsaHNWYWx1ZTogdW5rbm93biwgcmhzVmFsdWU6IHVua25vd24pIHtcblxuICAgIGlmICh0eXBlb2YgbGhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cbiAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxuICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xuICAgICAgICByZXR1cm4gbWVyZ2VkIGFzIG5ldmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVWguLi53ZSdyZSBoZXJlIGJlY2F1c2Ugb25lIG9mIHRoZW0ncyBudWxsLCByaWdodD9cbiAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwgJiYgcmhzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJoc1ZhbHVlID09PSBudWxsICYmIGxoc1ZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBsaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgZWxzZSBpZiAocmhzVmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBsaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgZWxzZSBpZiAoKHJoc1ZhbHVlIGFzIGFueSkgPT0gbGhzVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEkgbWVhbiwgdGhleSdyZSB0aGUgc2FtZSB2YWx1ZSBhdCBsZWFzdFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE5vdCByZWFsbHkgaWRlYWwgdGhvdWdoLlxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVWdoLlxuICAgICAgICAgICAgLy8gTm8gZ29vZCBzdHJhdGVnaWVzIGhlcmUsIGp1c3QgbG9nIGl0IGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgbG9nPy4oYFRoZSBwcm9wIFwiJHtrZXl9XCIgY2Fubm90IHNpbXVsdGFuZW91c2x5IGJlIHRoZSB2YWx1ZXMgJHtsaHNWYWx1ZX0gYW5kICR7cmhzVmFsdWV9LiBPbmUgbXVzdCBiZSBjaG9zZW4gb3V0c2lkZSBvZiB1c2VNZXJnZWRQcm9wcy5gKTtcbiAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlclxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi5cbiAqIFxuICogVGhpcyBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9ubHkgY2FsbGVkIGZ1bmN0aW9ucyBpbiB0aGlzIGFuZCBjb25zdW1lciBsaWJyYXJpZXMsXG4gKiBzbyBpdCB0cmFkZXMgYSBiaXQgb2YgcmVhZGFiaWxpdHkgZm9yIHNwZWVkIChpLmUuIHdlIGRvbid0IGRlY29tcG9zZSBvYmplY3RzIGFuZCBqdXN0IGRvIHJlZ3VsYXIgcHJvcGVydHkgYWNjZXNzLCBpdGVyYXRlIHdpdGggYGZvci4uLmluYCwgaW5zdGVhZCBvZiBgT2JqZWN0LmVudHJpZXNgLCBldGMuKVxuICovXG5mdW5jdGlvbiB1c2VNZXJnZWRQcm9wczI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihsaHNBbGw6IEVsZW1lbnRQcm9wczxFPiwgcmhzQWxsOiBFbGVtZW50UHJvcHM8RT4pOiBFbGVtZW50UHJvcHM8RT4ge1xuXG4gICAgXG4gICAgY29uc3QgcmV0OiBFbGVtZW50UHJvcHM8RT4gPSB7XG4gICAgICAgIHJlZjogdXNlTWVyZ2VkUmVmczxFPihsaHNBbGwucmVmLCByaHNBbGwucmVmKSxcbiAgICAgICAgc3R5bGU6IHVzZU1lcmdlZFN0eWxlcyhsaHNBbGwuc3R5bGUsIHJoc0FsbC5zdHlsZSksXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGxbXCJjbGFzc1wiXSwgbGhzQWxsLmNsYXNzTmFtZSwgcmhzQWxsW1wiY2xhc3NcIl0sIHJoc0FsbC5jbGFzc05hbWUpLFxuICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzQWxsLmNoaWxkcmVuLCByaHNBbGwuY2hpbGRyZW4pLFxuICAgIH0gYXMgYW55O1xuXG4gICAgaWYgKHJldC5yZWYgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5yZWY7XG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xuICAgIGlmIChyZXRbXCJjbGFzc1wiXSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0W1wiY2xhc3NcIl07XG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xuXG4gICAgZm9yIChjb25zdCBsaHNLZXlVIGluIGxoc0FsbCkge1xuICAgICAgICBjb25zdCBsaHNLZXkgPSBsaHNLZXlVIGFzIGtleW9mIHR5cGVvZiBsaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKGxoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W2xoc0tleV0gPSBsaHNBbGxbbGhzS2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJoc0tleVUgaW4gcmhzQWxsKSB7XG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgdHlwZW9mIHJoc0FsbDtcbiAgICAgICAgaWYgKGtub3ducy5oYXMocmhzS2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXRbcmhzS2V5XSA9IG1lcmdlVW5rbm93bihyaHNLZXksIHJldFtyaHNLZXldLCByaHNBbGxbcmhzS2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gKHZvaWQgfCBQcm9taXNlPHZvaWQ+KSwgVSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gKHZvaWQgfCBQcm9taXNlPHZvaWQ+KT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKCFsaHMpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgaWYgKCFyaHMpXG4gICAgICAgIHJldHVybiBsaHM7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcbiAgICAgICAgY29uc3QgbHYgPSBsaHMoLi4uYXJncyk7XG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xuXG4gICAgICAgIGlmIChsdiBpbnN0YW5jZW9mIFByb21pc2UgfHwgcnYgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vdXRpbC9hc3NlcnQuanNcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIGRlYm91bmNlUmVuZGVyaW5nLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyLmpzXCI7XG5cbi8qKlxuICogUmVtaW5kZXIgb2Ygb3JkZXIgb2YgZXhlY3V0aW9uOlxuICogXG4gKiAqICh0cmVlIG1vdW50cylcbiAqICogUGFyZW50IHJlbmRlcnNcbiAqICogQ2hpbGRyZW4gcmVuZGVyXG4gKiAqIENoaWxkcmVuIHJlY2VpdmUgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBQYXJlbnQgcmVjZWl2ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZHJlbiBydW4gZWZmZWN0c1xuICogKiBQYXJlbnQgcnVucyBlZmZlY3RzXG4gKiBcbiAqICogKHRyZWUgdW5tb3VudHMpXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIFBhcmVudCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBDaGlsZCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqIFxuICogVHdvIHRoaW5ncyB0byBub3RlIGhlcmU6XG4gKiAqIFJlbmRlcmluZyBzdGFydHMgYXQgdGhlIHJvb3QsICBidXQgZWZmZWN0cyBhbmQgcmVmcyBzdGFydCBhdCB0aGUgbGVhdmVzLlxuICogKiByZWZzIGFyZSAqdXN1YWxseSogY2FsbGVkIGJlZm9yZSBlZmZlY3RzLCBidXQgb25seSB3aGVuIHRoYXQgSFRNTEVsZW1lbnQgcmVuZGVycy4gQmFzaWNhbGx5IGp1c3QgYSByZW1pbmRlciB0aGF0IGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIHdpdGhvdXQgaXQgZXhpc3RpbmcgaW4gdGhlIERPTS5cbiAqL1xuY29uc3QgX2NvbW1lbnRzID0gdm9pZCAoMCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLy9tYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl1cblxuICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogSW50ZXJuYWxDaGlsZEluZm88TT47XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0sIG1vdW50ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0pID0+ICgoKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogT3RoZXIgaG9va3Mgd2lsbCBpbmhlcml0IGZyb20gdGhpcyB0byBwcm92aWRlIG1vcmUgY29tcGxpY2F0ZWQgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiB7XG4gICAgaW5kZXg6IFQ7XG59XG5cblxuXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAgICAgKiBcbiAgICAgICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxuICAgICAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVE9ETzogVGhpcyBlbmRlZCB1cCBub3QgYmVpbmcgbmVlZGVkIGJ5IGFueXRoaW5nLiBJcyBpdCBuZWNlc3Nhcnk/IERvZXMgaXQgY29zdCBhbnl0aGluZz9cbiAgICAgICAgICovXG4gICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8TVtcImluZGV4XCJdPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPE1bXCJpbmRleFwiXT47XG5cbiAgICAgICAgb25DaGlsZHJlbkNvdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8ICgoY291bnQ6IG51bWJlcikgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBleGFjdCBkYXRhIHRoYXQncyBhdmFpbGFibGUgZnJvbSB0aGUgcGFyZW50L2VhY2ggc2libGluZyBlbGVtZW50IHZpYSBgZ2V0QXRgIG9yIHRoZSBvdGhlciBtZXRob2RzIG9uIGBNYW5hZ2VkQ2hpbGRyZW5gLlxuICAgICAqL1xuICAgIGluZm86IE07XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqICoqKlNUQUJMRSoqKlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgKipib3RoKiogYGdldENoaWxkcmVuYCBhbmQgdGhlIGBNYW5hZ2VkQ2hpbGRyZW5gIG9iamVjdCBpdCByZXR1cm5zIGFyZSBzdGFibGUhXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJlY2F1c2Ugd2hlbiBmdW5jdGlvbiBjYWxscyBoYXBwZW4gb3V0IG9mIG9yZGVyIGl0J3MgZWFzaWVyIHRvIGp1c3QgaGF2ZSBhbHdheXMgYmVlbiBwYXNzaW5nIGFuZCByZXR1cm4gZ2V0dGVycyBldmVyeXdoZXJlIFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG4gICAgfTtcblxuICAgIGNvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IE1bXCJpbmRleFwiXSk6IE0gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE0pID0+IHZvaWQpID0+IHZvaWQgfCBcImJyZWFrXCI7XG5cbiAgICAvKipcbiAgICAgKiAqKlVOU1RBQkxFKiosIFxuICAgICAqIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIFxuICAgICAqIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4sXG4gICAgICogb3IgYXQgbGVhc3QgcHJvcGVybHkgbmFtZSBpdC5cbiAgICAgKiBcbiAgICAgKiBXSEFUIFRISVMgRE9FUzpcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBjaGlsZHJlbiwgc2xpY2VzIHRoZSBhcnJheSBjb250YWluaW5nIHRoZW0sIFxuICAgICAqIGFuZCwgKmNydXRpYWxseSosIGZpbGxzIGluIGFueSBob2xlcyBpbiB0aGUgYXJyYXkgd2l0aCBhIHBzZXVkby1jaGlsZCB0aGF0IGp1c3QgY29udGFpbnMgYW4gaW5kZXguXG4gICAgICogXG4gICAgICogVGhpcyBiZWhhdmlvciwgdG8gYmUgY2xlYXIsIGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyBiZWNhdXNlXG4gICAgICogc29ydGluZyBhbmQgcmVhcnJhbmdpbmcgcmVxdWlyZSBrbm93aW5nIHBlcmZlY3RseSB3aGljaCBpbmRleCBtYXBzIHRvIHdoaWNoLlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IG90aGVyIG1pc3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IGJlc2lkZXMgdGhlIG1pc3NpbmcgaW5kZXguXG4gICAgICogKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VNYW5hZ2VkQ2hpbGRyZW4pO1xuXG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZHJlbkNvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRyZW5Db3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkcmVuQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+ICh2b2lkIHwgXCJicmVha1wiKSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZihjaGlsZCkgPT0gJ2JyZWFrJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGlmIChmKGNoaWxkKSA9PSAnYnJlYWsnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48TT5bXCJnZXRBdFwiXT4oKGluZGV4OiBJbmRleFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PEluZGV4VHlwZT4sIHVubW91bnRzOiBTZXQ8SW5kZXhUeXBlPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PEluZGV4VHlwZT4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvbkNoaWxkcmVuQ291bnRDaGFuZ2UgfHwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuQ291bnRDaGFuZ2U/LihnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlU3RhYmxlT2JqZWN0PE1hbmFnZWRDaGlsZHJlbjxNPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gZ2V0SGlnaGVzdEluZGV4KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbaV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0geyBpbmRleDogaSB9IGFzIE07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuLCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPj4oeyBjb250ZXh0LCBpbmZvIH06IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZU1hbmFnZWRDaGlsZCk7XG5cbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChjb250ZXh0ID8/IHsgbWFuYWdlZENoaWxkQ29udGV4dDoge30gfSk7XG4gICAgY29uc3QgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAvLyB0aGUgcGFyZW50IGlmIHRoZXkgbmVlZCBpdC5cbiAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbkFycmF5ID09IG51bGwgfHwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID09IG51bGwpIHJldHVybjtcblxuICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmFycltpbmRleCBhcyBudW1iZXJdID0geyAuLi5pbmZvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSA9IHsgLi4uaW5mbyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdGVVTEVDaGlsZENoYW5nZWQoaW5kZXggYXMgSW5kZXhUeXBlKTtcbiAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xuICAgIC8vIChldmVyeSBjaGlsZCBkb2VzIHRoaXMsIHNvIGV2ZXJ5dGhpbmcncyBjb29yZGluYXRlZCB0byBvbmx5IHF1ZXVlIGEgc2luZ2xlIG1pY3JvdGFzayBwZXIgdGljaylcbiAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcbiAgICAvLyBzbyB0aGF0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgaW5mbyBvbiBtb3VudC5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCBmYWxzZSk7XG4gICAgfSwgW2luZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHsgZ2V0Q2hpbGRyZW46IGdldENoaWxkcmVuISB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlOiBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8TVtcImluZGV4XCJdIHwgbnVsbCwgUj47XG5cbiAgICBzZXRBdChpbmRleDogTSwgdmFsdWU6IGJvb2xlYW4sIG5ld1NlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwsIHByZXZTZWxlY3RlZEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsKTogdm9pZDtcbiAgICBnZXRBdChpbmRleDogTSk6IGJvb2xlYW47XG4gICAgaXNWYWxpZChpbmRleDogTSk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG1vbml0b3JDYWxsQ291bnQgfSBmcm9tIFwiLi4vdXRpbC91c2UtY2FsbC1jb3VudC5qc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VTdGF0ZSk7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCJpbXBvcnQgdHlwZSB7IEpTWCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IEVsZW1lbnRQcm9wcyB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wcy5qc1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxuICogXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cbiAqIFxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cbiAqL1xudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xuXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XG5cblxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xuXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcblxuXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xuXG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICogXG4gKiBgXCJtb2RlXCJgIGNvbnRyb2xzIGlmIHRoZXJlJ3Mgb25lIGhhbmRsZXIgdGhhdCBjYWxscyBhbGwgeW91ciBmdW5jdGlvbnMgKGRlZmF1bHQpLCBvciBvbmUgaGFuZGxlciBhZGRlZCBwZXIgZnVuY3Rpb24gKGBcInNpbmdsZVwiYCkuIFxuICogXG4gKiBUaGUgZGVmYXVsdCwgYFwiZ3JvdXBlZFwiYCwgaXMgZmFzdGVyIHdoZW4geW91IGhhdmUsIHNheSwgYSBidXR0b24gY29tcG9uZW50LCB1c2VkIGh1bmRyZWRzIG9mIHRpbWVzIG9uIGEgcGFnZSwgdGhhdCBlYWNoIGluc3RhbGxzIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuXG4gKiBcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxuICogQHJldHVybnNcbiAqICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdLCBtb2RlPzogXCJncm91cGVkXCIgfCBcInNpbmdsZVwiKTogdm9pZCB7XG4gICAgbW9uaXRvckNhbGxDb3VudCh1c2VHbG9iYWxIYW5kbGVyKTtcbiAgICBtb2RlIHx8PSBcImdyb3VwZWRcIjtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VHbG9iYWxIYW5kbGVyXCIsIG1vZGUpO1xuXG4gICAgaWYgKG1vZGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXG4gICAgICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXG4gICAgICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXG4gICAgICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJHcm91cGVkPFQsIEV2ZW50VHlwZSwgSD4odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJTaW5nbGU8VCwgRXZlbnRUeXBlLCBIPih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxudHlwZSBHbG9iYWxIYW5kbGVySW5mbyA9IHsgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7IGxpc3RlbmVyczogU2V0PEV2ZW50TGlzdGVuZXI+OyB9O1xudHlwZSBNYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8c3RyaW5nLCBHbG9iYWxIYW5kbGVySW5mbz5cbnR5cGUgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8VHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RXZlbnRUYXJnZXQ+LCBNYXBPZk9wdGlvbnNUb0luZm8+O1xubGV0IG1hcFRoaW5nID0gbmV3IE1hcDxFdmVudFRhcmdldCwgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8+KCk7XG5cbmZ1bmN0aW9uIGRvTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4ob3A6IChpOiBHbG9iYWxIYW5kbGVySW5mbywgaDogRXZlbnRMaXN0ZW5lcikgPT4gdm9pZCwgdGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zOiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBpZiAoaGFuZGxlcikge1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnNLZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYnlUeXBlID0gbWFwVGhpbmcuZ2V0KHRhcmdldCkgfHwgKG5ldyBNYXAoKSBhcyBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbyk7XG4gICAgICAgIGNvbnN0IGJ5T3B0aW9ucyA9IChieVR5cGUuZ2V0KHR5cGUpIHx8IChuZXcgTWFwKCkgYXMgTWFwT2ZPcHRpb25zVG9JbmZvKSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBieU9wdGlvbnMuZ2V0KG9wdGlvbnNLZXkpIHx8IHsgbGlzdGVuZXI6IG51bGwhLCBsaXN0ZW5lcnM6IG5ldyBTZXQoKSB9O1xuXG4gICAgICAgIG9wKGluZm8sIGhhbmRsZXIpO1xuXG4gICAgICAgIGJ5T3B0aW9ucy5zZXQob3B0aW9uc0tleSwgaW5mbyk7XG4gICAgICAgIGJ5VHlwZS5zZXQodHlwZSwgYnlPcHRpb25zKTtcbiAgICAgICAgbWFwVGhpbmcuc2V0KHRhcmdldCwgYnlUeXBlKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWRkVG9NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM6IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuYWRkKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbU1hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuZGVsZXRlKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB3YXkgZmFzdGVyIGZvciBsYXJnZSBudW1iZXJzIG9mIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBGb3IgZXhhbXBsZSwgaWYgZXZlcnkgYnV0dG9uIGxpc3RlbnMgZm9yIGEgZ2xvYmFsIGNsaWNrLCBvciBzb21ldGhpbmcsXG4gKiBpdCB3b3VsZCBiZSBuaWNlIGlmIGl0IHdhcyBlZmZpY2llbnQgYXQgbGVhc3QuIFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGFkZFRvTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVGcm9tTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlclNpbmdsZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cbiAqIFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICogXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIGBgYFxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxKU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcblxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XG5cbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogRWxlbWVudFByb3BzPEVsZW1lbnRUeXBlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIEVsZW1lbnRQcm9wczxFbGVtZW50VHlwZT4sIHByb3BzKSBhcyBFbGVtZW50UHJvcHM8RWxlbWVudFR5cGU+O1xuICAgICAgICB9LCBbdHlwZV0pO1xuXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcblxuICAgIH0sIFtdKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHksIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgbW9uaXRvckNhbGxDb3VudCB9IGZyb20gXCIuLi91dGlsL3VzZS1jYWxsLWNvdW50LmpzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgcHJvcHNTdGFibGU6IEVsZW1lbnRQcm9wczxUPjtcblxuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xuICAgIC8qKlxuICAgICAqIEZvciB0aGUgc2FrZSBvZiBjb252ZW5pZW5jZSxcbiAgICAgKiB0aGlzIG9uZSBpcyBvcHRpb25hbCwgc2luY2UgdXNpbmcgdGhpcyBob29rIGlzIHNvIGNvbW1vbixcbiAgICAgKiBidXQgdXNpbmcgaXRzIHBhcmFtZXRlciBvcHRpb25zIGlzIHNvIHVuY29tbW9uLCBhbmQgaXQnc1xuICAgICAqIGFic2Vuc2UgaXNuJ3QgdXN1YWxseSBiZWNhdXNlIGl0IHdhcyBmb3Jnb3R0ZW4sIGl0J3MgYmVjYXVzZVxuICAgICAqIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAgICAqL1xuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzPzoge1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+O1xuICAgICAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnRQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IEVsZW1lbnRQcm9wczxFPltdKTogRWxlbWVudFByb3BzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZVJlZkVsZW1lbnQpO1xuXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MucmVmRWxlbWVudFBhcmFtZXRlcnMgfHwge30pO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xuXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj4+KChlLCBwcmV2VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XG4gICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcblxuICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcblxuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsLCBuZXZlcj4oaGFuZGxlciwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPEVsZW1lbnRQcm9wczxUPj4oeyByZWY6IHNldEVsZW1lbnQgfSk7XG5cbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnQsXG4gICAgICAgIFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWVcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0cmV0dXJuICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSBjIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gKiBAcGFyYW0geyhwcmV2OiBvYmplY3QsIG5leHQ6IG9iamVjdCkgPT4gYm9vbGVhbn0gW2NvbXBhcmVyXSBDdXN0b20gZXF1YWxpdHkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgcHJvcHMpO1xuXHR9XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KGNoaWxkcmVuKS5tYXAoZm4pKTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChub3JtYWxpemVkLmxlbmd0aCAhPT0gMSkgdGhyb3cgJ0NoaWxkcmVuLm9ubHknO1xuXHRcdHJldHVybiBub3JtYWxpemVkWzBdO1xuXHR9LFxuXHR0b0FycmF5OiB0b0NoaWxkQXJyYXlcbn07XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xub3B0aW9ucy5fY2F0Y2hFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHRpZiAoZXJyb3IudGhlbikge1xuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRcdGxldCBjb21wb25lbnQ7XG5cdFx0bGV0IHZub2RlID0gbmV3Vk5vZGU7XG5cblx0XHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZCkge1xuXHRcdFx0XHRpZiAobmV3Vk5vZGUuX2RvbSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERvbid0IGNhbGwgb2xkQ2F0Y2hFcnJvciBpZiB3ZSBmb3VuZCBhIFN1c3BlbnNlXG5cdFx0XHRcdHJldHVybiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZChlcnJvciwgbmV3Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRvbGRDYXRjaEVycm9yKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbyk7XG59O1xuXG5jb25zdCBvbGRVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xub3B0aW9ucy51bm1vdW50ID0gZnVuY3Rpb24odm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGNvbnN0IGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Ll9vblJlc29sdmUpIHtcblx0XHRjb21wb25lbnQuX29uUmVzb2x2ZSgpO1xuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBoeWRyYXRpbmdcblx0Ly8gbW9zdCBsaWtlbHkgaXQgaXMgYmVjYXVzZSB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZFxuXHQvLyB3ZSBzZXQgdGhlIHZub2RlLnR5cGUgYXMgYG51bGxgIHNvIHRoYXQgaXQgaXMgbm90IGEgdHlwZW9mIGZ1bmN0aW9uXG5cdC8vIHNvIHRoZSB1bm1vdW50IHdpbGwgcmVtb3ZlIHRoZSB2bm9kZS5fZG9tXG5cdGlmIChjb21wb25lbnQgJiYgdm5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZSkge1xuXHRcdHZub2RlLnR5cGUgPSBudWxsO1xuXHR9XG5cblx0aWYgKG9sZFVubW91bnQpIG9sZFVubW91bnQodm5vZGUpO1xufTtcblxuZnVuY3Rpb24gZGV0YWNoZWRDbG9uZSh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSkge1xuXHRpZiAodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAmJiB2bm9kZS5fY29tcG9uZW50Ll9faG9va3MpIHtcblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5mb3JFYWNoKGVmZmVjdCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZWZmZWN0Ll9jbGVhbnVwID09ICdmdW5jdGlvbicpIGVmZmVjdC5fY2xlYW51cCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBwYXJlbnREb20pIHtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gZGV0YWNoZWRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdGRldGFjaGVkQ2xvbmUoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pXG5cdFx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPcmlnaW5hbCh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdHZub2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRyZW1vdmVPcmlnaW5hbChjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KVxuXHRcdFx0KTtcblxuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBkZXRhY2hlZFBhcmVudCkge1xuXHRcdFx0XHRpZiAodm5vZGUuX2RvbSkge1xuXHRcdFx0XHRcdG9yaWdpbmFsUGFyZW50Lmluc2VydEJlZm9yZSh2bm9kZS5fZG9tLCB2bm9kZS5fbmV4dERvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBvcmlnaW5hbFBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbi8vIGhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXNcbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZSgpIHtcblx0Ly8gd2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZSB0byBnb2xmIHNvbWUgYnl0ZXMuLi5cblx0dGhpcy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCA9IDA7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBudWxsO1xuXHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xufVxuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSB0aHJvd24gcHJvbWlzZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZTxhbnksIGFueT59IHN1c3BlbmRpbmdWTm9kZSBUaGUgc3VzcGVuZGluZyBjb21wb25lbnRcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLl9jaGlsZERpZFN1c3BlbmQgPSBmdW5jdGlvbihwcm9taXNlLCBzdXNwZW5kaW5nVk5vZGUpIHtcblx0Y29uc3Qgc3VzcGVuZGluZ0NvbXBvbmVudCA9IHN1c3BlbmRpbmdWTm9kZS5fY29tcG9uZW50O1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9ICovXG5cdGNvbnN0IGMgPSB0aGlzO1xuXG5cdGlmIChjLl9zdXNwZW5kZXJzID09IG51bGwpIHtcblx0XHRjLl9zdXNwZW5kZXJzID0gW107XG5cdH1cblx0Yy5fc3VzcGVuZGVycy5wdXNoKHN1c3BlbmRpbmdDb21wb25lbnQpO1xuXG5cdGNvbnN0IHJlc29sdmUgPSBzdXNwZW5kZWQoYy5fdm5vZGUpO1xuXG5cdGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXHRjb25zdCBvblJlc29sdmVkID0gKCkgPT4ge1xuXHRcdGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuXG5cdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXHRcdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG51bGw7XG5cblx0XHRpZiAocmVzb2x2ZSkge1xuXHRcdFx0cmVzb2x2ZShvblN1c3BlbnNpb25Db21wbGV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uU3VzcGVuc2lvbkNvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG9uUmVzb2x2ZWQ7XG5cblx0Y29uc3Qgb25TdXNwZW5zaW9uQ29tcGxldGUgPSAoKSA9PiB7XG5cdFx0aWYgKCEtLWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQpIHtcblx0XHRcdC8vIElmIHRoZSBzdXNwZW5zaW9uIHdhcyBkdXJpbmcgaHlkcmF0aW9uIHdlIGRvbid0IG5lZWQgdG8gcmVzdG9yZSB0aGVcblx0XHRcdC8vIHN1c3BlbmRlZCBjaGlsZHJlbiBpbnRvIHRoZSBfY2hpbGRyZW4gYXJyYXlcblx0XHRcdGlmIChjLnN0YXRlLl9zdXNwZW5kZWQpIHtcblx0XHRcdFx0Y29uc3Qgc3VzcGVuZGVkVk5vZGUgPSBjLnN0YXRlLl9zdXNwZW5kZWQ7XG5cdFx0XHRcdGMuX3Zub2RlLl9jaGlsZHJlblswXSA9IHJlbW92ZU9yaWdpbmFsKFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX3BhcmVudERvbSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGwpIH0pO1xuXG5cdFx0XHRsZXQgc3VzcGVuZGVkO1xuXHRcdFx0d2hpbGUgKChzdXNwZW5kZWQgPSBjLl9zdXNwZW5kZXJzLnBvcCgpKSkge1xuXHRcdFx0XHRzdXNwZW5kZWQuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdlIGRvIG5vdCBzZXQgYHN1c3BlbmRlZDogdHJ1ZWAgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHdlIHdhbnQgdGhlIGFjdHVhbCBtYXJrdXBcblx0ICogdG8gcmVtYWluIG9uIHNjcmVlbiBhbmQgaHlkcmF0ZSBpdCB3aGVuIHRoZSBzdXNwZW5zZSBhY3R1YWxseSBnZXRzIHJlc29sdmVkLlxuXHQgKiBXaGlsZSBpbiBub24taHlkcmF0aW9uIGNhc2VzIHRoZSB1c3VhbCBmYWxsYmFjayAtPiBjb21wb25lbnQgZmxvdyB3b3VsZCBvY2NvdXIuXG5cdCAqL1xuXHRjb25zdCB3YXNIeWRyYXRpbmcgPSBzdXNwZW5kaW5nVk5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZTtcblx0aWYgKCFjLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KysgJiYgIXdhc0h5ZHJhdGluZykge1xuXHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gYy5fdm5vZGUuX2NoaWxkcmVuWzBdKSB9KTtcblx0fVxuXHRwcm9taXNlLnRoZW4ob25SZXNvbHZlZCwgb25SZXNvbHZlZCk7XG59O1xuXG5TdXNwZW5zZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fc3VzcGVuZGVycyA9IFtdO1xufTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50W1wicHJvcHNcIl19IHByb3BzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlU3RhdGV9IHN0YXRlXG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0aWYgKHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcikge1xuXHRcdC8vIFdoZW4gdGhlIFN1c3BlbnNlJ3MgX3Zub2RlIHdhcyBjcmVhdGVkIGJ5IGEgY2FsbCB0byBjcmVhdGVWTm9kZVxuXHRcdC8vIChpLmUuIGR1ZSB0byBhIHNldFN0YXRlIGZ1cnRoZXIgdXAgaW4gdGhlIHRyZWUpXG5cdFx0Ly8gaXQncyBfY2hpbGRyZW4gcHJvcCBpcyBudWxsLCBpbiB0aGlzIGNhc2Ugd2UgXCJmb3JnZXRcIiBhYm91dCB0aGUgcGFya2VkIHZub2RlcyB0byBkZXRhY2hcblx0XHRpZiAodGhpcy5fdm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBkZXRhY2hlZFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRDb21wb25lbnQgPSB0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0uX2NvbXBvbmVudDtcblx0XHRcdHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXSA9IGRldGFjaGVkQ2xvbmUoXG5cdFx0XHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcixcblx0XHRcdFx0ZGV0YWNoZWRQYXJlbnQsXG5cdFx0XHRcdChkZXRhY2hlZENvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb20gPSBkZXRhY2hlZENvbXBvbmVudC5fcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xuXHR9XG5cblx0Ly8gV3JhcCBmYWxsYmFjayB0cmVlIGluIGEgVk5vZGUgdGhhdCBwcmV2ZW50cyBpdHNlbGYgZnJvbSBiZWluZyBtYXJrZWQgYXMgYWJvcnRpbmcgbWlkLWh5ZHJhdGlvbjpcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gKi9cblx0Y29uc3QgZmFsbGJhY2sgPVxuXHRcdHN0YXRlLl9zdXNwZW5kZWQgJiYgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuZmFsbGJhY2spO1xuXHRpZiAoZmFsbGJhY2spIGZhbGxiYWNrLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdHJldHVybiBbXG5cdFx0Y3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgc3RhdGUuX3N1c3BlbmRlZCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbiksXG5cdFx0ZmFsbGJhY2tcblx0XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGFuZCBjYWxscyB0aGUgcGFyZW50IGNvbXBvbmVudCdzIF9zdXNwZW5kZWQgbWV0aG9kLCBwYXNzaW5nIGluIHRoZVxuICogc3VzcGVuZGVkIHZub2RlLiBUaGlzIGlzIGEgd2F5IGZvciBhIHBhcmVudCAoZS5nLiBTdXNwZW5zZUxpc3QpIHRvIGdldCBub3RpZmllZFxuICogdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIHN1c3BlbmRlZC5cbiAqXG4gKiBUaGUgcGFyZW50IE1BWSByZXR1cm4gYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogc3VzcGVuc2lvbiByZXNvbHZlcywgbm90aWZ5aW5nIHRoZSBwYXJlbnQgb2YgdGhlIGZhY3QuXG4gKiBNb3Jlb3ZlciwgdGhlIGNhbGxiYWNrIGdldHMgZnVuY3Rpb24gYHVuc3VzcGVuZGAgYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXNvbHZlZFxuICogY2hpbGQgZGVzY2VuZGFudCB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdW5zdXNwZW5kZWQgdW50aWwgYHVuc3VzcGVuZGAgZ2V0cyBjYWxsZWQuXG4gKiBUaGlzIGlzIGEgd2F5IGZvciB0aGUgcGFyZW50IHRvIGRlbGF5IHVuc3VzcGVuZGluZy5cbiAqXG4gKiBJZiB0aGUgcGFyZW50IGRvZXMgbm90IHJldHVybiBhIGNhbGxiYWNrIHRoZW4gdGhlIHJlc29sdmVkIHZub2RlXG4gKiBnZXRzIHVuc3VzcGVuZGVkIGltbWVkaWF0ZWx5IHdoZW4gaXQgcmVzb2x2ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHsoKHVuc3VzcGVuZDogKCkgPT4gdm9pZCkgPT4gdm9pZCk/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZGVkKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50ID0gdm5vZGUuX3BhcmVudC5fY29tcG9uZW50O1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkKHZub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenkobG9hZGVyKSB7XG5cdGxldCBwcm9tO1xuXHRsZXQgY29tcG9uZW50O1xuXHRsZXQgZXJyb3I7XG5cblx0ZnVuY3Rpb24gTGF6eShwcm9wcykge1xuXHRcdGlmICghcHJvbSkge1xuXHRcdFx0cHJvbSA9IGxvYWRlcigpO1xuXHRcdFx0cHJvbS50aGVuKFxuXHRcdFx0XHRleHBvcnRzID0+IHtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cztcblx0XHRcdFx0fSxcblx0XHRcdFx0ZSA9PiB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wb25lbnQpIHtcblx0XHRcdHRocm93IHByb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG5cdH1cblxuXHRMYXp5LmRpc3BsYXlOYW1lID0gJ0xhenknO1xuXHRMYXp5Ll9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTGF6eTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0Y29uc3QgbGlzdCA9IHRoaXM7XG5cdGNvbnN0IGRlbGVnYXRlZCA9IHN1c3BlbmRlZChsaXN0Ll92bm9kZSk7XG5cblx0bGV0IG5vZGUgPSBsaXN0Ll9tYXAuZ2V0KGNoaWxkKTtcblx0bm9kZVtTVVNQRU5ERURfQ09VTlRdKys7XG5cblx0cmV0dXJuIHVuc3VzcGVuZCA9PiB7XG5cdFx0Y29uc3Qgd3JhcHBlZFVuc3VzcGVuZCA9ICgpID0+IHtcblx0XHRcdGlmICghbGlzdC5wcm9wcy5yZXZlYWxPcmRlcikge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgdGhlIHVuZGVmaW5lZCAoZmFsc3kpIHJldmVhbE9yZGVyLCBhcyB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGNvb3JkaW5hdGUgYSBzcGVjaWZpYyBvcmRlciBvciB1bnN1c3BlbmRzLlxuXHRcdFx0XHR1bnN1c3BlbmQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucHVzaCh1bnN1c3BlbmQpO1xuXHRcdFx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdGRlbGVnYXRlZCh3cmFwcGVkVW5zdXNwZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d3JhcHBlZFVuc3VzcGVuZCgpO1xuXHRcdH1cblx0fTtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCBjaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cdGlmIChwcm9wcy5yZXZlYWxPcmRlciAmJiBwcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ2InKSB7XG5cdFx0Ly8gSWYgb3JkZXIgPT09ICdiYWNrd2FyZHMnIChvciwgd2VsbCwgYW55dGhpbmcgc3RhcnRpbmcgd2l0aCBhICdiJylcblx0XHQvLyB0aGVuIGZsaXAgdGhlIGNoaWxkIGxpc3QgYXJvdW5kIHNvIHRoYXQgdGhlIGxhc3QgY2hpbGQgd2lsbCBiZVxuXHRcdC8vIHRoZSBmaXJzdCBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdFx0Y2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHR9XG5cdC8vIEJ1aWxkIHRoZSBsaW5rZWQgbGlzdC4gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBpbiByZXZlcnNlIG9yZGVyXG5cdC8vIHNvIHRoYXQgYF9uZXh0YCBwb2ludHMgdG8gdGhlIGZpcnN0IGxpbmtlZCBsaXN0IG5vZGUgdG8gYmUgcmVzb2x2ZWQuXG5cdGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUgYXMgYW4gYXJyYXkgb2YgZm9ybTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGVdXG5cdFx0Ly8gd2hlcmUgc3VzcGVuZGVkX2NvdW50IGFuZCByZXNvbHZlZF9jb3VudCBhcmUgbnVtZXJpYyBjb3VudGVycyBmb3Jcblx0XHQvLyBrZWVwaW5nIHRyYWNrIGhvdyBtYW55IHRpbWVzIGEgbm9kZSBoYXMgYmVlbiBzdXNwZW5kZWQgYW5kIHJlc29sdmVkLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IHN1c3BlbmRlZF9jb3VudCBzdGFydHMgZnJvbSAxIGluc3RlYWQgb2YgMCwgc28gd2UgY2FuIGJsb2NrXG5cdFx0Ly8gcHJvY2Vzc2luZyBjYWxsYmFja3MgdW50aWwgY29tcG9uZW50RGlkTW91bnQgaGFzIGJlZW4gY2FsbGVkLiBJbiBhIHNlbnNlXG5cdFx0Ly8gbm9kZSBpcyBzdXNwZW5kZWQgYXQgbGVhc3QgdW50aWwgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQhXG5cdFx0Ly9cblx0XHQvLyBQZW5kaW5nIGNhbGxiYWNrcyBhcmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGUsIGNhbGxiYWNrXzAsIGNhbGxiYWNrXzEsIC4uLl1cblx0XHR0aGlzLl9tYXAuc2V0KGNoaWxkcmVuW2ldLCAodGhpcy5fbmV4dCA9IFsxLCAwLCB0aGlzLl9uZXh0XSkpO1xuXHR9XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBJdGVyYXRlIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFmdGVyIG1vdW50aW5nIGZvciB0d28gcmVhc29uczpcblx0Ly8gMS4gQXMgZWFjaCBub2RlW1NVU1BFTkRFRF9DT1VOVF0gc3RhcnRzIGZyb20gMSwgdGhpcyBpdGVyYXRpb24gaW5jcmVhc2VzXG5cdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdC8vICAgIFRoZSBub2RlcyBjYW4gbm93IGJlIGNvbXBsZXRlbHkgY29uc3VtZWQgZnJvbSB0aGUgbGlua2VkIGxpc3QuXG5cdC8vIDIuIEhhbmRsZSBub2RlcyB0aGF0IG1pZ2h0IGhhdmUgZ290dGVuIHJlc29sdmVkIGJldHdlZW4gcmVuZGVyIGFuZFxuXHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0dGhpcy5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZSh0aGlzLCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3NyYy9pbmRleCcpLlJlbmRlcmFibGVQcm9wczx7IGNvbnRleHQ6IGFueSB9Pn0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKHByb3BzKSB7XG5cdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gcHJvcHMuY29udGV4dDtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKlxuICogVE9ETzogdXNlIGNyZWF0ZVJvb3QoKSBpbnN0ZWFkIG9mIGZha2Ugcm9vdFxuICovXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuX2NvbnRhaW5lcjtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsImltcG9ydCB7XG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGh5ZHJhdGUgYXMgcHJlYWN0SHlkcmF0ZSxcblx0b3B0aW9ucyxcblx0dG9DaGlsZEFycmF5LFxuXHRDb21wb25lbnRcbn0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQweGVhYzc7XG5cbmNvbnN0IENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxkb21pbmFudHxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxpbWFnZXxsZXR0ZXJ8bGlnaHRpbmd8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHBvaW50ZXJ8c2hhcGV8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dHJhbnNmb3JtfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5jb25zdCBPTl9BTkkgPSAvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvO1xuY29uc3QgQ0FNRUxfUkVQTEFDRSA9IC9bQS1aMC05XS9nO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9cblx0XHQ6IC9maWx8Y2hlfHJhL1xuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzID0ge307XG5cblx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wc1tpXTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB8fFxuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHQoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jylcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBTa2lwIGFwcGx5aW5nIHZhbHVlIGlmIGl0IGlzIG51bGwvdW5kZWZpbmVkIGFuZCB3ZSBhbHJlYWR5IHNldFxuXHRcdFx0XHQvLyBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBsb3dlckNhc2VkID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKGkgPT09ICdkZWZhdWx0VmFsdWUnICYmICd2YWx1ZScgaW4gcHJvcHMgJiYgcHJvcHMudmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpcyB0cmVhdGVkIGFzIGEgZmFsbGJhY2sgYHZhbHVlYCB3aGVuIGEgdmFsdWUgcHJvcCBpcyBwcmVzZW50IGJ1dCBudWxsL3VuZGVmaW5lZC5cblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgZm9yIEVsZW1lbnRzIHdpdGggbm8gdmFsdWUgcHJvcCBpcyB0aGUgc2FtZSBhcyB0aGUgRE9NIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eS5cblx0XHRcdFx0aSA9ICd2YWx1ZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICdkb3dubG9hZCcgJiYgdmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gQ2FsbGluZyBgc2V0QXR0cmlidXRlYCB3aXRoIGEgdHJ1dGh5IHZhbHVlIHdpbGwgbGVhZCB0byBpdCBiZWluZ1xuXHRcdFx0XHQvLyBwYXNzZWQgYXMgYSBzdHJpbmdpZmllZCB2YWx1ZSwgZS5nLiBgZG93bmxvYWQ9XCJ0cnVlXCJgLiBSZWFjdFxuXHRcdFx0XHQvLyBjb252ZXJ0cyBpdCB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCwgb3RoZXJ3aXNlIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBmaWxlIG5hbWUgYW5kIHRoZSBmaWxlIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHRcdC8vIFwidHJ1ZVwiIHVwb24gZG93bmxvYWRpbmcgaXQuXG5cdFx0XHRcdHZhbHVlID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWQgPT09ICdvbmRvdWJsZWNsaWNrJykge1xuXHRcdFx0XHRpID0gJ29uZGJsY2xpY2snO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0bG93ZXJDYXNlZCA9PT0gJ29uY2hhbmdlJyAmJlxuXHRcdFx0XHQodHlwZSA9PT0gJ2lucHV0JyB8fCB0eXBlID09PSAndGV4dGFyZWEnKSAmJlxuXHRcdFx0XHQhb25DaGFuZ2VJbnB1dFR5cGUocHJvcHMudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRsb3dlckNhc2VkID0gaSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAobG93ZXJDYXNlZCA9PT0gJ29uZm9jdXMnKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAobG93ZXJDYXNlZCA9PT0gJ29uYmx1cicpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3Vzb3V0Jztcblx0XHRcdH0gZWxzZSBpZiAoT05fQU5JLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGxvd2VyQ2FzZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUuaW5kZXhPZignLScpID09PSAtMSAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoQ0FNRUxfUkVQTEFDRSwgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3VwcG9ydCBmb3Igb25JbnB1dCBhbmQgb25DaGFuZ2UsIHNlZSAjMzU2MVxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBhbiBvbmlucHV0IHByb3AgYWxyZWFkeSBjaGFuZ2UgaXQgdG8gb25pbnB1dENhcHR1cmVcblx0XHRcdGlmIChsb3dlckNhc2VkID09PSAnb25pbnB1dCcpIHtcblx0XHRcdFx0aSA9IGxvd2VyQ2FzZWQ7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0pIHtcblx0XHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCBtdWx0aXBsZSB2YWx1ZT17W119IC8+XG5cdFx0aWYgKFxuXHRcdFx0dHlwZSA9PSAnc2VsZWN0JyAmJlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLm11bHRpcGxlICYmXG5cdFx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0XHQpIHtcblx0XHRcdC8vIGZvckVhY2goKSBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHdoaWNoIHdlIGFidXNlIGhlcmUgdG8gdW5zZXQgdGhlIHZhbHVlIHByb3AuXG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkaW5nIHN1cHBvcnQgZm9yIGRlZmF1bHRWYWx1ZSBpbiBzZWxlY3QgdGFnXG5cdFx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcblxuXHRcdGlmIChwcm9wcy5jbGFzcyAhPSBwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIHByb3BzO1xuXHRcdFx0aWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSBub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsaXplZFByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXHR9XG5cblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0aWYgKG9sZFZOb2RlSG9vaykgb2xkVk5vZGVIb29rKHZub2RlKTtcbn07XG5cbi8vIE9ubHkgbmVlZGVkIGZvciByZWFjdC1yZWxheVxubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5jb25zdCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5vcHRpb25zLl9yZW5kZXIgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbmNvbnN0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuLyoqIEB0eXBlIHsodm5vZGU6IGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlKX0gKi9cbm9wdGlvbnMuZGlmZmVkID0gZnVuY3Rpb24odm5vZGUpIHtcblx0aWYgKG9sZERpZmZlZCkge1xuXHRcdG9sZERpZmZlZCh2bm9kZSk7XG5cdH1cblxuXHRjb25zdCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRjb25zdCBkb20gPSB2bm9kZS5fZG9tO1xuXHRpZiAoXG5cdFx0ZG9tICE9IG51bGwgJiZcblx0XHR2bm9kZS50eXBlID09PSAndGV4dGFyZWEnICYmXG5cdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdHByb3BzLnZhbHVlICE9PSBkb20udmFsdWVcblx0KSB7XG5cdFx0ZG9tLnZhbHVlID0gcHJvcHMudmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMudmFsdWU7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcbn07XG5cbi8vIFRoaXMgaXMgYSB2ZXJ5IHZlcnkgcHJpdmF0ZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgUmVhY3QgaXRcbi8vIGlzIHVzZWQgdG8gc29ydC1vZiBkbyBydW50aW1lIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbyBmYXJcbi8vIG9ubHkgYHJlYWN0LXJlbGF5YCBtYWtlcyB1c2Ugb2YgaXQuIEl0IHVzZXMgaXQgdG8gcmVhZCB0aGVcbi8vIGNvbnRleHQgdmFsdWUuXG5leHBvcnQgY29uc3QgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSB7XG5cdFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IHtcblx0XHRjdXJyZW50OiB7XG5cdFx0XHRyZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50Q29tcG9uZW50Ll9nbG9iYWxDb250ZXh0W2NvbnRleHQuX2lkXS5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCB0eXBlIEpTWCwgdHlwZSBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBDU1NQcm9wZXJ0aWVzLCBFbGVtZW50UHJvcHMsIFJlZiB9IGZyb20gXCIuLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wcy5qc1wiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnQuanNcIjtcblxuZXhwb3J0IHR5cGUgU2V0Q2hpbGRyZW4gPSAoKGNoaWxkcmVuOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIEdldENsYXNzID0gKGNsczogc3RyaW5nKSA9PiBib29sZWFuO1xuZXhwb3J0IHR5cGUgU2V0Q2xhc3MgPSAoY2xzOiBzdHJpbmcsIGVuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBTZXRTdHlsZSA9IDxUIGV4dGVuZHMgKGtleW9mIENTU1N0eWxlRGVjbGFyYXRpb24pICYgc3RyaW5nPihwcm9wOiBULCB2YWx1ZTogQ1NTUHJvcGVydGllc1tUXSB8IG51bGwpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBHZXRBdHRyaWJ1dGU8VCBleHRlbmRzIEVsZW1lbnQ+ID0gPEsgZXh0ZW5kcyBrZXlvZiBFbGVtZW50UHJvcHM8VD4+KHByb3A6IEspID0+IEVsZW1lbnRQcm9wczxUPltLXTtcbmV4cG9ydCB0eXBlIFNldEF0dHJpYnV0ZTxUIGV4dGVuZHMgRWxlbWVudD4gPSA8SyBleHRlbmRzIGtleW9mIEVsZW1lbnRQcm9wczxUPj4ocHJvcDogSywgdmFsdWU6IEVsZW1lbnRQcm9wczxUPltLXSB8IG51bGwpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBTZXRFdmVudEhhbmRsZXIgPSA8SyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50RXZlbnRNYXA+KHR5cGU6IEssIGxpc3RlbmVyOiBudWxsIHwgKCh0aGlzOiBIVE1MRWxlbWVudCwgZXY6IEhUTUxFbGVtZW50RXZlbnRNYXBbS10pID0+IHZvaWQpLCBvcHRpb25zOiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucykgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBJbXBlcmF0aXZlSGFuZGxlPFQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgaGFzQ2xhc3M6IEdldENsYXNzO1xuICAgIHNldENsYXNzOiBTZXRDbGFzcztcbiAgICBzZXRTdHlsZTogU2V0U3R5bGU7XG4gICAgZ2V0QXR0cmlidXRlOiBHZXRBdHRyaWJ1dGU8VD47XG4gICAgc2V0QXR0cmlidXRlOiBTZXRBdHRyaWJ1dGU8VD47XG4gICAgc2V0Q2hpbGRyZW46IFNldENoaWxkcmVuO1xuICAgIHNldEV2ZW50SGFuZGxlcjogU2V0RXZlbnRIYW5kbGVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUltcGVyYXRpdmVQcm9wc1BhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltcGVyYXRpdmVFbGVtZW50UHJvcHM8VCBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcD4gZXh0ZW5kcyBFbGVtZW50UHJvcHM8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPiB7XG4gICAgdGFnOiBUO1xuICAgIGhhbmRsZTogUmVmPEltcGVyYXRpdmVIYW5kbGU8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPj47XG59XG5cbi8qKlxuICogRWFzeSBhY2Nlc3MgdG8gYW4gSFRNTEVsZW1lbnQgdGhhdCBjYW4gYmUgY29udHJvbGxlZCBpbXBlcmF0aXZlbHkuXG4gKiBcbiAqIFRoZSBIVE1MRWxlbWVudCByZW5kZXJlZCBpcyBjb250cm9sbGVkIGJ5IHRoZSBgdGFnYCBwcm9wIChlLmcuIFwic3BhblwiLCBcImRpdlwiKS5cbiAqIFxuICogVGhlIGBoYW5kbGVgIHByb3Agc2hvdWxkIGJlIGUuZy4gYHVzZVJlZjxJbXBlcmF0aXZlSGFuZGxlPEhUTUxEaXZFbGVtZW50Pj4obnVsbClgXG4gKi9cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlRWxlbWVudCA9IG1lbW8oZm9yd2FyZFJlZihJbXBlcmF0aXZlRWxlbWVudFUpKSBhcyB0eXBlb2YgSW1wZXJhdGl2ZUVsZW1lbnRVO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCB9IH06IFVzZUltcGVyYXRpdmVQcm9wc1BhcmFtZXRlcnM8RT4pIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUltcGVyYXRpdmVQcm9wcyk7XG4gICAgXG4gICAgY29uc3QgY3VycmVudEltcGVyYXRpdmVQcm9wcyA9IHVzZVJlZjx7IGNsYXNzTmFtZTogU2V0PHN0cmluZz4sIHN0eWxlOiBDU1NQcm9wZXJ0aWVzLCBjaGlsZHJlbjogc3RyaW5nIHwgbnVsbCwgb3RoZXJzOiBFbGVtZW50UHJvcHM8RT4gfT4oeyBjbGFzc05hbWU6IG5ldyBTZXQoKSwgc3R5bGU6IHt9LCBjaGlsZHJlbjogbnVsbCwgb3RoZXJzOiB7fSB9KTtcblxuXG4gICAgY29uc3QgaGFzQ2xhc3MgPSB1c2VDYWxsYmFjazxHZXRDbGFzcz4oKGNsczogc3RyaW5nKSA9PiB7IHJldHVybiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lLmhhcyhjbHMpOyB9LCBbXSlcbiAgICBjb25zdCBzZXRDbGFzcyA9IHVzZUNhbGxiYWNrPFNldENsYXNzPigoY2xzLCBlbmFibGVkKSA9PiB7XG4gICAgICAgIGlmIChoYXNDbGFzcyhjbHMpID09ICFlbmFibGVkKSB7XG4gICAgICAgICAgICBnZXRFbGVtZW50KCk/LmNsYXNzTGlzdFtlbmFibGVkID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKGNscyk7XG4gICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lW2VuYWJsZWQgPyBcImFkZFwiIDogXCJkZWxldGVcIl0oY2xzKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldFN0eWxlID0gdXNlQ2FsbGJhY2s8U2V0U3R5bGU+KChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gKGdldEVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuc3R5bGVbcHJvcF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3AgYXMgc3RyaW5nKS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlID8/IChcIlwiIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2hpbGRyZW4gPSB1c2VDYWxsYmFjazxTZXRDaGlsZHJlbj4oKGNoaWxkcmVuOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIGxldCBlID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZSAmJiBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2hpbGRyZW4gIT0gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0QXR0cmlidXRlID0gdXNlQ2FsbGJhY2s8R2V0QXR0cmlidXRlPEU+PigocHJvcCkgPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRBdHRyaWJ1dGUgPSB1c2VDYWxsYmFjazxTZXRBdHRyaWJ1dGU8RT4+KChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgZ2V0RWxlbWVudCgpPy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbcHJvcF07XG4gICAgICAgICAgICBnZXRFbGVtZW50KCk/LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldEV2ZW50SGFuZGxlciA9IHVzZUNhbGxiYWNrPFNldEV2ZW50SGFuZGxlcj4oKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChnZXRFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG1hcHBlZEtleSA9IEV2ZW50TWFwcGluZ1t0eXBlXSBhcyBrZXlvZiBFbGVtZW50UHJvcHM8RT47XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQub3RoZXJzW21hcHBlZEtleV0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5vdGhlcnNbbWFwcGVkS2V5XSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1ttYXBwZWRLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlOiB1c2VSZWY8SW1wZXJhdGl2ZUhhbmRsZTxFPj4oe1xuICAgICAgICAgICAgaGFzQ2xhc3MsXG4gICAgICAgICAgICBzZXRDbGFzcyxcbiAgICAgICAgICAgIHNldFN0eWxlLFxuICAgICAgICAgICAgZ2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgc2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgc2V0RXZlbnRIYW5kbGVyLFxuICAgICAgICAgICAgc2V0Q2hpbGRyZW5cbiAgICAgICAgfSkuY3VycmVudCxcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzPEU+KFxuICAgICAgICAgICAgeyBjbGFzc05hbWU6IFsuLi5jdXJyZW50SW1wZXJhdGl2ZVByb3BzLmN1cnJlbnQuY2xhc3NOYW1lXS5qb2luKFwiIFwiKSwgc3R5bGU6IGN1cnJlbnRJbXBlcmF0aXZlUHJvcHMuY3VycmVudC5zdHlsZSB9LFxuICAgICAgICAgICAgY3VycmVudEltcGVyYXRpdmVQcm9wcy5jdXJyZW50Lm90aGVyc1xuICAgICAgICApXG5cbiAgICB9XG59XG5cbmZ1bmN0aW9uIEltcGVyYXRpdmVFbGVtZW50VTxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPih7IHRhZzogVGFnLCBoYW5kbGUsIC4uLnByb3BzIH06IFJlbmRlcmFibGVQcm9wczxJbXBlcmF0aXZlRWxlbWVudFByb3BzPFQ+PiwgcmVmOiBSZWY8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPikge1xuICAgIGNvbnN0IHsgcHJvcHNTdGFibGUsIHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuICAgIGNvbnN0IHsgcHJvcHM6IGlwcm9wcywgaW1wZXJhdGl2ZUhhbmRsZSB9ID0gdXNlSW1wZXJhdGl2ZVByb3BzPEhUTUxFbGVtZW50VGFnTmFtZU1hcFtUXT4oeyByZWZFbGVtZW50UmV0dXJuIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUoaGFuZGxlLCAoKSA9PiBpbXBlcmF0aXZlSGFuZGxlKTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFnLCB1c2VNZXJnZWRQcm9wcyhwcm9wc1N0YWJsZSwgaXByb3BzLCBwcm9wcywgeyByZWYgfSkpKTtcbn1cblxuXG5jb25zdCBFdmVudE1hcHBpbmc6IFBhcnRpYWw8eyBbSyBpbiBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwXTogKGtleW9mIEpTWC5JbnRyaW5zaWNFbGVtZW50c1tcImRpdlwiXSAmIGBvbiR7c3RyaW5nfWApIH0+ID0ge1xuICAgIGFib3J0OiBcIm9uQWJvcnRcIixcbiAgICBhbmltYXRpb25lbmQ6IFwib25BbmltYXRpb25FbmRcIixcbiAgICBhbmltYXRpb25zdGFydDogXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgYW5pbWF0aW9uaXRlcmF0aW9uOiBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIsXG4gICAgYmVmb3JlaW5wdXQ6IFwib25CZWZvcmVJbnB1dFwiLFxuICAgIGJsdXI6IFwib25CbHVyXCIsXG4gICAgY2FucGxheTogXCJvbkNhblBsYXlcIixcbiAgICBjYW5wbGF5dGhyb3VnaDogXCJvbkNhblBsYXlUaHJvdWdoXCIsXG4gICAgY2hhbmdlOiBcIm9uQ2hhbmdlXCIsXG4gICAgY2xpY2s6IFwib25DbGlja1wiLFxuICAgIGNvbXBvc2l0aW9uZW5kOiBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgICBjb21wb3NpdGlvbnN0YXJ0OiBcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuICAgIGNvbXBvc2l0aW9udXBkYXRlOiBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgICBjb250ZXh0bWVudTogXCJvbkNvbnRleHRNZW51XCIsXG4gICAgY3V0OiBcIm9uQ3V0XCIsXG4gICAgZGJsY2xpY2s6IFwib25EYmxDbGlja1wiLFxuICAgIGRyYWc6IFwib25EcmFnXCIsXG4gICAgZHJhZ2VuZDogXCJvbkRyYWdFbmRcIixcbiAgICBkcmFnZW50ZXI6IFwib25EcmFnRW50ZXJcIixcbiAgICBkcmFnbGVhdmU6IFwib25EcmFnTGVhdmVcIixcbiAgICBkcmFnb3ZlcjogXCJvbkRyYWdPdmVyXCIsXG4gICAgZHJhZ3N0YXJ0OiBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgZHJvcDogXCJvbkRyb3BcIixcbiAgICBkdXJhdGlvbmNoYW5nZTogXCJvbkR1cmF0aW9uQ2hhbmdlXCIsXG4gICAgZW1wdGllZDogXCJvbkVtcHRpZWRcIixcbiAgICBlbmRlZDogXCJvbkVuZGVkXCIsXG4gICAgZXJyb3I6IFwib25FcnJvclwiLFxuICAgIGZvY3VzOiBcIm9uRm9jdXNcIixcbiAgICBmb2N1c2luOiBcIm9uZm9jdXNpblwiLFxuICAgIGZvY3Vzb3V0OiBcIm9uZm9jdXNvdXRcIixcbiAgICBmb3JtZGF0YTogXCJvbkZvcm1EYXRhXCIsXG4gICAgZ290cG9pbnRlcmNhcHR1cmU6IFwib25Hb3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIGlucHV0OiBcIm9uSW5wdXRcIixcbiAgICBpbnZhbGlkOiBcIm9uSW52YWxpZFwiLFxuICAgIGtleWRvd246IFwib25LZXlEb3duXCIsXG4gICAga2V5cHJlc3M6IFwib25LZXlQcmVzc1wiLFxuICAgIGtleXVwOiBcIm9uS2V5VXBcIixcbiAgICBsb2FkOiBcIm9uTG9hZFwiLFxuICAgIGxvYWRlZGRhdGE6IFwib25Mb2FkZWREYXRhXCIsXG4gICAgbG9hZGVkbWV0YWRhdGE6IFwib25Mb2FkZWRNZXRhZGF0YVwiLFxuICAgIGxvYWRzdGFydDogXCJvbkxvYWRTdGFydFwiLFxuICAgIGxvc3Rwb2ludGVyY2FwdHVyZTogXCJvbkxvc3RQb2ludGVyQ2FwdHVyZVwiLFxuICAgIG1vdXNlZG93bjogXCJvbk1vdXNlRG93blwiLFxuICAgIG1vdXNlZW50ZXI6IFwib25Nb3VzZUVudGVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJvbk1vdXNlTGVhdmVcIixcbiAgICBtb3VzZW1vdmU6IFwib25Nb3VzZU1vdmVcIixcbiAgICBtb3VzZW91dDogXCJvbk1vdXNlT3V0XCIsXG4gICAgbW91c2VvdmVyOiBcIm9uTW91c2VPdmVyXCIsXG4gICAgbW91c2V1cDogXCJvbk1vdXNlVXBcIixcbiAgICBwYXN0ZTogXCJvblBhc3RlXCIsXG4gICAgcGF1c2U6IFwib25QYXVzZVwiLFxuICAgIHBsYXk6IFwib25QbGF5XCIsXG4gICAgcGxheWluZzogXCJvblBsYXlpbmdcIixcbiAgICBwb2ludGVyY2FuY2VsOiBcIm9uUG9pbnRlckNhbmNlbFwiLFxuICAgIHBvaW50ZXJkb3duOiBcIm9uUG9pbnRlckRvd25cIixcbiAgICBwb2ludGVyZW50ZXI6IFwib25Qb2ludGVyRW50ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwib25Qb2ludGVyTGVhdmVcIixcbiAgICBwb2ludGVybW92ZTogXCJvblBvaW50ZXJNb3ZlXCIsXG4gICAgcG9pbnRlcm91dDogXCJvblBvaW50ZXJPdXRcIixcbiAgICBwb2ludGVyb3ZlcjogXCJvblBvaW50ZXJPdmVyXCIsXG4gICAgcG9pbnRlcnVwOiBcIm9uUG9pbnRlclVwXCIsXG4gICAgcHJvZ3Jlc3M6IFwib25Qcm9ncmVzc1wiLFxuICAgIHJlc2V0OiBcIm9uUmVzZXRcIixcbiAgICBzY3JvbGw6IFwib25TY3JvbGxcIixcbiAgICBzZWVrZWQ6IFwib25TZWVrZWRcIixcbiAgICBzZWVraW5nOiBcIm9uU2Vla2luZ1wiLFxuICAgIHNlbGVjdDogXCJvblNlbGVjdFwiLFxuICAgIHN0YWxsZWQ6IFwib25TdGFsbGVkXCIsXG4gICAgc3VibWl0OiBcIm9uU3VibWl0XCIsXG4gICAgc3VzcGVuZDogXCJvblN1c3BlbmRcIixcbiAgICB0aW1ldXBkYXRlOiBcIm9uVGltZVVwZGF0ZVwiLFxuICAgIHRvZ2dsZTogXCJvblRvZ2dsZVwiLFxuICAgIHRvdWNoY2FuY2VsOiBcIm9uVG91Y2hDYW5jZWxcIixcbiAgICB0b3VjaGVuZDogXCJvblRvdWNoRW5kXCIsXG4gICAgdG91Y2htb3ZlOiBcIm9uVG91Y2hNb3ZlXCIsXG4gICAgdG91Y2hzdGFydDogXCJvblRvdWNoU3RhcnRcIixcbiAgICB0cmFuc2l0aW9uZW5kOiBcIm9uVHJhbnNpdGlvbkVuZFwiLFxuICAgIHZvbHVtZWNoYW5nZTogXCJvblZvbHVtZUNoYW5nZVwiLFxuICAgIHdhaXRpbmc6IFwib25XYWl0aW5nXCIsXG4gICAgd2hlZWw6IFwib25XaGVlbFwiXG59XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyBtb25pdG9yQ2FsbENvdW50IH0gZnJvbSBcIi4uL3V0aWwvdXNlLWNhbGwtY291bnQuanNcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG4vKipcbiAqIFdoZW4gYSBidW5jaCBvZiB1bnJlbGF0ZWQgY29tcG9uZW50cyBhbGwgdXNlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLFxuICogeWVzLCB0aGlzIGFjdHVhbGx5IGlzIGZhc3Rlci4gSSB3aXNoIGl0IHdhc24ndC4gSXQncyBsYW1lLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICBtb25pdG9yQ2FsbENvdW50KHVzZUFuaW1hdGlvbkZyYW1lKTtcbiAgICBcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gXCJsb2Rhc2gtZXNcIlxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgY29uc3QgcHJvY2VzczogeyBlbnY6IHsgTk9ERV9FTlY/OiBzdHJpbmcgfCB1bmRlZmluZWQgfSB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIHJldHVybiAncHJvZHVjdGlvbic7XG4gICAgfVxuICAgIGNhdGNoIChfZSkge1xuICAgICAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCI7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QnVpbGRNb2RlID0gbWVtb2l6ZShnZXRCdWlsZE1vZGVVbm1lbW9pemVkKSBhcyB0eXBlb2YgZ2V0QnVpbGRNb2RlVW5tZW1vaXplZDsiLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0QnVpbGRNb2RlIH0gZnJvbSBcIi4uL3V0aWwvbW9kZS5qc1wiO1xuXG4vKiogVGFrZXMgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgYSB2YWx1ZSwgdW5saWtlIGBPblBhc3NpdmVTdGF0ZUNoYW5nZWAgd2hpY2ggcmVhY3RzIHRvIHRob3NlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8UywgUj4gPSAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpIDogKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uOiBSKSA9PiB2b2lkKTtcbi8qKiBSZXNwb25kcyB0byBhIGNoYW5nZSBpbiBhIHZhbHVlLCB1bmxpa2UgYFBhc3NpdmVTdGF0ZVVwZGF0ZXJgIHdoaWNoIGNhdXNlcyB0aGUgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8UywgUj4gPSAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSkgOiAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbjogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuXG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIGlmIChnZXRCdWlsZE1vZGUoKSA9PSAncHJvZHVjdGlvbicpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZjxBcnJheTxUPj4oW10pO1xuICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWY8QXJyYXk8Ym9vbGVhbj4+KFtdKTtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCBhcyBhbnksIC0xKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFUgZXh0ZW5kcyBUPih2YWx1ZTogVSwgaTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSArIDE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpfS1pbmRleGVkIGFyZ3VtZW50ICgke2kgPj0gMD8gSlNPTi5zdHJpbmdpZnkodmFsdWVzW2ldKSA6IFwidGhlIG51bWJlciBvZiBzdXBwb3NlZGx5IHN0YWJsZSBlbGVtZW50c1wifSkuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gcXVldWVNaWNyb3Rhc2spKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHJlYXNvblJlZiA9IHVzZVJlZjxSIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QgPSB1c2VSZWY8VCB8ICh0eXBlb2YgVW5zZXQpPihVbnNldCk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQhKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+KChhcmc6IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMF0sIHJlYXNvbjogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlsxXSkgPT4ge1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9PT0gVW5zZXQgJiYgbmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZXF1ZXN0IHRvIGNoYW5nZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHksIHRoZW4gcXVldWUgdXAgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgdmFsdWUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGl0IGxhdGVyXG4gICAgICAgICAgICAvLyAoaWYgd2UgZmxpcCBiYWNrIHRvIHRoaXMgc3RhdGUsIHRoZW4gd2Ugd29uJ3Qgc2VuZCB0aGUgb25DaGFuZ2UgZnVuY3Rpb24pXG4gICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gdmFsdWVSZWYuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoaXMgaGVyZSAoYXMgd2VsbCBhcyBiZWxvdykgaW4gY2FzZSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBpbnZva2VzIHRoaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICByZWFzb25SZWYuY3VycmVudCA9IHJlYXNvbiBhcyBSO1xuXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgYWN0dWFsIGNoZWNrIGFuZCBpbnZvY2F0aW9uIG9mIG9uQ2hhbmdlIGxhdGVyIHRvIGxldCBlZmZlY3RzIHNldHRsZVxuICAgICAgICAgICAgKGN1c3RvbURlYm91bmNlUmVuZGVyaW5nID8/IGRlYm91bmNlUmVuZGVyaW5nKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFJlYXNvbiA9IHJlYXNvblJlZi5jdXJyZW50ISBhcyBSO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREZXAgPSB2YWx1ZVJlZi5jdXJyZW50ISBhcyBUO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEZXAgPSBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ICE9IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiBwcmV2RGVwLCBuZXh0UmVhc29uKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHREZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLCBzbyBtYXJrIHVzIGFzIGJlaW5nIG9uIGEgY2xlYW4gc2xhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IFVuc2V0O1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgcHJldkRlcCB0byBzZWUgaWYgd2Ugc2hvdWxkIGFjdHVhbGx5IGNhbGwgb25DaGFuZ2VcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH1cblxuLyoqIFxuICogQW4gYWx0ZXJuYXRpdmUgdG8gdXNlIGZvciBgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmdgIHRoYXQgY2F1c2VzIGB1c2VQYXNzaXZlU3RhdGVgIHRvIHJ1biBjaGFuZ2VzIHdpdGhvdXQgd2FpdGluZyBhIHRpY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7IGYoKTsgfSIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjayB8IG51bGwsIGlucHV0cz86IElucHV0cykge1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0pLCBbdmFsdWVdKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xufVxuXG5cbi8qKlxuICogTGlrZSBgdXNlU3RhYmxlR2V0dGVyYCwgYnV0ICoqKnJlcXVpcmVzKioqIHRoYXQgZXZlcnl0aGluZyBpbiB0aGUgb2JqZWN0IGlzIGFsc28gc3RhYmxlLFxuICogYW5kIGluIHR1cm4gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaXMgc3RhYmxlLlxuICogQHBhcmFtIHQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZU9iamVjdDxUIGV4dGVuZHMge30+KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModCk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlT2JqZWN0XCIsIGUubGVuZ3RoLCAuLi5lLm1hcCgoW19rLCB2XSkgPT4gdikpO1xuICAgIHJldHVybiB1c2VSZWYodCkuY3VycmVudDtcbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2tOYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbihsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdLCByaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xudHlwZSBDID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqIFxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxoc0NsYXNzOiBDLCBsaHNDbGFzc05hbWU6IEMsIHJoc0NsYXNzOiBDLCByaHNDbGFzc05hbWU6IEMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxuICogQHBhcmFtIGxocyBcbiAqIEBwYXJhbSByaHMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihyaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdLCBsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdKSB7XG4gICAgXG4gICAgLy8gVGhpcyAqbXVzdCogYmUgc3RhYmxlIGluIG9yZGVyIHRvIHByZXZlbnQgcmVwZWF0ZWQgcmVzZXQgYG51bGxgIGNhbGxzIGFmdGVyIGV2ZXJ5IHJlbmRlci5cbiAgICBjb25zdCBjb21iaW5lZCA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uIGNvbWJpbmVkKGN1cnJlbnQ6IEUgfCBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzITtcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocyE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcblxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cbiAgICAgICAgaWYgKGxocyAmJiAhcmhzKVxuICAgICAgICAgICAgcmV0dXJuIGxocztcbiAgICAgICAgaWYgKCFsaHMgJiYgcmhzKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXG4gICAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoc3R5bGVTdHJpbmdUb09iamVjdChsaHMgYXMgc3RyaW5nKSwgcmhzKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgc3R5bGVTdHJpbmdUb09iamVjdChyaHMgYXMgc3RyaW5nKSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZ2ljPz8/XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihsaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXG4gICAgICAgIC4uLihyaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW4uanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnMuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzLmpzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPiksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPik+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5LCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBzYWtlIG9mIGNvbnZlbmllbmNlLFxuICAgICAqIHRoaXMgb25lIGlzIG9wdGlvbmFsLCBzaW5jZSB1c2luZyB0aGlzIGhvb2sgaXMgc28gY29tbW9uLFxuICAgICAqIGJ1dCB1c2luZyBpdHMgcGFyYW1ldGVyIG9wdGlvbnMgaXMgc28gdW5jb21tb24sIGFuZCBpdCdzXG4gICAgICogYWJzZW5zZSBpc24ndCB1c3VhbGx5IGJlY2F1c2UgaXQgd2FzIGZvcmdvdHRlbiwgaXQncyBiZWNhdXNlXG4gICAgICogaXQgZG9lc24ndCBtYXR0ZXIuXG4gICAgICovXG4gICAgcmVmRWxlbWVudFBhcmFtZXRlcnM/OiB7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj47XG4gICAgICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICAgICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncy5yZWZFbGVtZW50UGFyYW1ldGVycyB8fCB7fSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XG5cbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xuXG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGwsIG5ldmVyPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgcHJvcHNTdGFibGUgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHsgcmVmOiBzZXRFbGVtZW50IH0pO1xuXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvL21hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxuXG4gICAgbWFuYWdlZENoaWxkQ29udGV4dDoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5OiBJbnRlcm5hbENoaWxkSW5mbzxNPjtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSwgbW91bnRlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSkgPT4gKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IHtcbiAgICBpbmRleDogVDtcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUT0RPOiBUaGlzIGVuZGVkIHVwIG5vdCBiZWluZyBuZWVkZWQgYnkgYW55dGhpbmcuIElzIGl0IG5lY2Vzc2FyeT8gRG9lcyBpdCBjb3N0IGFueXRoaW5nP1xuICAgICAgICAgKi9cbiAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxNW1wiaW5kZXhcIl0+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8TVtcImluZGV4XCJdPjtcblxuICAgICAgICBvbkNoaWxkQ291bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgKChjb3VudDogbnVtYmVyKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cbi8vIE1DU3ViSW5mbyBjb250YWlucyB0aGUgZW50aXJldHkgb2YgdGhlIHNhdmVkIGRhdGEgZm9yIHRoaXMgY2hpbGQuICBBbGwgb2YgaXQuIEV2ZW4gdHlwZXMgdGhlIHVzZXIgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHBhc3MgaW4gYmVjYXVzZSB0aGV5J3JlIGludGVybmFsbHkgZGVyaXZlZC5cbi8vIFN1YmJlc3RJbmZvIHJlZmVycyB0byB0aGUgYWN0dWFsIHBhcmFtZXRlcnMgdGhlIHVzZXIgcGFzc2VzIGluIHRoYXQgY291bGQgYmUgdG90YWxseSB1bnJlbGF0ZWQuIFxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5IHNoYXJlZCBhbW9uZyBhbGwgbWFuYWdlZCBjaGlsZHJlbi5cbiAgICAvLyBUZWNobmljYWxseSB0aGlzIGlzIHJlZHVuZGFudCB3aXRoIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGlzLi4uZWguIEJ1dCB0aGUgdHlwZXMgYXJlIGNsZWFyLlxuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8TSwgXCJpbmRleFwiPjtcblxuICAgIC8qKlxuICAgICAqIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkbid0IGJlIG51bGwsIGJ1dCBmb3IgY29udmVuaWVuY2UncyBzYWtlIHlvdSBhcmUgYWxsb3dlZCB0bywgd2hpY2ggZGlzYWJsZXMgYWxsIGJlaGF2aW9yLCBhbmQgYWxzbyBtZWFucyBgZ2V0Q2hpbGRyZW5gIHdpbGwgYmUgYHVuZGVmaW5lZGAhXG4gICAgICovXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPiB8IG51bGw7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqICoqKlNUQUJMRSoqKlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgKipib3RoKiogYGdldENoaWxkcmVuYCBhbmQgdGhlIGBNYW5hZ2VkQ2hpbGRyZW5gIG9iamVjdCBpdCByZXR1cm5zIGFyZSBzdGFibGUhXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJlY2F1c2Ugd2hlbiBmdW5jdGlvbiBjYWxscyBoYXBwZW4gb3V0IG9mIG9yZGVyIGl0J3MgZWFzaWVyIHRvIGp1c3QgaGF2ZSBhbHdheXMgYmVlbiBwYXNzaW5nIGFuZCByZXR1cm4gZ2V0dGVycyBldmVyeXdoZXJlIFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG4gICAgfTtcblxuICAgIGNvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IE1bXCJpbmRleFwiXSk6IE0gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE0pID0+IHZvaWQpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiAqKlVOU1RBQkxFKiosIFxuICAgICAqIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIFxuICAgICAqIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4sXG4gICAgICogb3IgYXQgbGVhc3QgcHJvcGVybHkgbmFtZSBpdC5cbiAgICAgKiBcbiAgICAgKiBXSEFUIFRISVMgRE9FUzpcbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBjaGlsZHJlbiwgc2xpY2VzIHRoZSBhcnJheSBjb250YWluaW5nIHRoZW0sIFxuICAgICAqIGFuZCwgKmNydXRpYWxseSosIGZpbGxzIGluIGFueSBob2xlcyBpbiB0aGUgYXJyYXkgd2l0aCBhIHBzZXVkby1jaGlsZCB0aGF0IGp1c3QgY29udGFpbnMgYW4gaW5kZXguXG4gICAgICogXG4gICAgICogVGhpcyBiZWhhdmlvciwgdG8gYmUgY2xlYXIsIGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBzb3J0aW5nIGFuZCByZWFycmFuZ2luZyBiZWNhdXNlXG4gICAgICogc29ydGluZyBhbmQgcmVhcnJhbmdpbmcgcmVxdWlyZSBrbm93aW5nIHBlcmZlY3RseSB3aGljaCBpbmRleCBtYXBzIHRvIHdoaWNoLlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IG90aGVyIG1pc3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IGJlc2lkZXMgdGhlIG1pc3NpbmcgaW5kZXguXG4gICAgICogKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRDb3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZENvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEhpZ2hlc3RJbmRleCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2ldID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IHsgaW5kZXg6IGkgfSBhcyBNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChpbmZvLmNvbnRleHQgPz8geyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuQXJyYXkgPT0gbnVsbCB8fCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4hIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbiwgbmV3U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCwgcHJldlNlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwpOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH0sIFtdKTtcblxuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbi8qKlxuICogV2hlbiBhIGJ1bmNoIG9mIHVucmVsYXRlZCBjb21wb25lbnRzIGFsbCB1c2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsXG4gKiB5ZXMsIHRoaXMgYWN0dWFsbHkgaXMgZmFzdGVyLiBJIHdpc2ggaXQgd2Fzbid0LiBJdCdzIGxhbWUuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29udGV4dCwgY3JlYXRlQ29udGV4dCwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFeGNsdXNpdmVDb250ZXh0VHlwZSwgU3dhcHBhYmxlQ29udGV4dFR5cGUsIFRyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZSB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IHN0cmluZyk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPjtcbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IG51bGwgfCB1bmRlZmluZWQpOiBudWxsO1xuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbihleGNsdXNpdml0eUtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPiB8IG51bGw7XG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogQ29udGV4dDxFeGNsdXNpdmVDb250ZXh0VHlwZSB8IG51bGw+IHwgbnVsbCB7XG4gICAgaWYgKGV4Y2x1c2l2aXR5S2V5ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjcmVhdGVDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG59XG5cbmV4cG9ydCBjb25zdCBTd2FwcGFibGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTd2FwcGFibGVDb250ZXh0VHlwZT4oeyBnZXRBbmltYXRlT25Nb3VudDogKCkgPT4gZmFsc2UgfSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCBmb3IgYSBnaXZlbiBgZXhjbHVzaXZpdHlLZXlgLCBjcmVhdGluZyBvbmUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICogXG4gKiBJZiBcbiAqL1xuZXhwb3J0IGNvbnN0IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0OiB0eXBlb2YgZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbiA9IG1lbW9pemUoZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbik7XG5cbmludGVyZmFjZSBDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcyB7XG4gICAgYmFzZTogc3RyaW5nO1xuICAgIGVudGVyOiBzdHJpbmc7XG4gICAgZXhpdDogc3RyaW5nO1xuICAgIG1lYXN1cmU6IHN0cmluZztcbiAgICBpbml0OiBzdHJpbmc7XG4gICAgdHJhbnNpdGlvbjogc3RyaW5nO1xuICAgIGZpbmFsaXplOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDc3NDbGFzc0NvbnRleHRUeXBlIHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IHN0cmluZztcbiAgICBHZXRFbnRlckNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0SW5pdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gc3RyaW5nO1xufVxuXG5jb25zdCBDc3NDbGFzc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PENzc0NsYXNzQ29udGV4dFR5cGU+KHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IFwicHRsXCIsXG4gICAgR2V0RW50ZXJDbGFzczogKCkgPT4gXCJuXCIsXG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBcInhcIixcbiAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IFwibVwiLFxuICAgIEdldEluaXRDbGFzczogKCkgPT4gXCJpXCIsXG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBcInRcIixcbiAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBcImZcIixcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBDc3NDbGFzc2VzUHJvdmlkZXIoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUsIGNoaWxkcmVuLCAuLi5yZXN0IH06IFJlbmRlcmFibGVQcm9wczxQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPj4pIHtcbiAgICBjb25zdCBjb250ZXh0T2JqZWN0ID0gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUgfSk7XG4gICAgcmV0dXJuICg8Q3NzQ2xhc3NDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0T2JqZWN0fSAgey4uLnJlc3R9IGNoaWxkcmVuPXtjaGlsZHJlbn0gLz4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDc3NDbGFzc2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgR2V0QmFzZUNsYXNzLFxuICAgICAgICBHZXRFbnRlckNsYXNzLFxuICAgICAgICBHZXRFeGl0Q2xhc3MsXG4gICAgICAgIEdldE1lYXN1cmVDbGFzcyxcbiAgICAgICAgR2V0SW5pdENsYXNzLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3MsXG4gICAgICAgIEdldEZpbmFsaXplQ2xhc3NcbiAgICB9ID0gdXNlQ29udGV4dChDc3NDbGFzc0NvbnRleHQpO1xuICAgIGNvbnN0IEdldERpcmVjdGlvbkNsYXNzID0gdXNlQ2FsbGJhY2soKGRpcmVjdGlvbjogVHJhbnNpdGlvbkRpcmVjdGlvbik6IHN0cmluZyA9PiB7IHN3aXRjaCAoZGlyZWN0aW9uKSB7IGNhc2UgXCJlbnRlclwiOiByZXR1cm4gR2V0RW50ZXJDbGFzcygpOyBjYXNlIFwiZXhpdFwiOiByZXR1cm4gR2V0RXhpdENsYXNzKCk7IH0gfSwgW10pO1xuICAgIGNvbnN0IEdldFBoYXNlQ2xhc3MgPSB1c2VDYWxsYmFjaygocGhhc2U6IFRyYW5zaXRpb25QaGFzZSk6IHN0cmluZyA9PiB7IHN3aXRjaCAocGhhc2UpIHsgY2FzZSBcIm1lYXN1cmVcIjogcmV0dXJuIEdldE1lYXN1cmVDbGFzcygpOyBjYXNlIFwiaW5pdFwiOiByZXR1cm4gR2V0SW5pdENsYXNzKCk7IGNhc2UgXCJ0cmFuc2l0aW9uXCI6IHJldHVybiBHZXRUcmFuc2l0aW9uQ2xhc3MoKTsgY2FzZSBcImZpbmFsaXplXCI6IHJldHVybiBHZXRGaW5hbGl6ZUNsYXNzKCk7IH0gfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIEdldEJhc2VDbGFzcyxcbiAgICAgICAgR2V0RW50ZXJDbGFzcyxcbiAgICAgICAgR2V0RXhpdENsYXNzLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3MsXG4gICAgICAgIEdldEluaXRDbGFzcyxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzLFxuICAgICAgICBHZXREaXJlY3Rpb25DbGFzcyxcbiAgICAgICAgR2V0UGhhc2VDbGFzc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUobmV3VmFsdWVzOiBQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPik6IENzc0NsYXNzQ29udGV4dFR5cGUge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHVzZUNvbnRleHQoQ3NzQ2xhc3NDb250ZXh0KTtcbiAgICBjb25zdCBiYXNlID0gKG5ld1ZhbHVlcz8uYmFzZSA/PyBvbGRWYWx1ZXMuR2V0QmFzZUNsYXNzKCkpO1xuICAgIGNvbnN0IGVudGVyID0gKG5ld1ZhbHVlcz8uZW50ZXIgPz8gb2xkVmFsdWVzLkdldEVudGVyQ2xhc3MoKSk7XG4gICAgY29uc3QgZXhpdCA9IChuZXdWYWx1ZXM/LmV4aXQgPz8gb2xkVmFsdWVzLkdldEV4aXRDbGFzcygpKTtcbiAgICBjb25zdCBtZWFzdXJlID0gKG5ld1ZhbHVlcz8ubWVhc3VyZSA/PyBvbGRWYWx1ZXMuR2V0TWVhc3VyZUNsYXNzKCkpO1xuICAgIGNvbnN0IGluaXQgPSAobmV3VmFsdWVzPy5pbml0ID8/IG9sZFZhbHVlcy5HZXRJbml0Q2xhc3MoKSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IChuZXdWYWx1ZXM/LnRyYW5zaXRpb24gPz8gb2xkVmFsdWVzLkdldFRyYW5zaXRpb25DbGFzcygpKTtcbiAgICBjb25zdCBmaW5hbGl6ZSA9IChuZXdWYWx1ZXM/LmZpbmFsaXplID8/IG9sZFZhbHVlcy5HZXRGaW5hbGl6ZUNsYXNzKCkpO1xuXG4gICAgcmV0dXJuIHVzZU1lbW88Q3NzQ2xhc3NDb250ZXh0VHlwZT4oKCkgPT4gKHtcbiAgICAgICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBiYXNlISxcbiAgICAgICAgR2V0RW50ZXJDbGFzczogKCkgPT4gZW50ZXIhLFxuICAgICAgICBHZXRFeGl0Q2xhc3M6ICgpID0+IGV4aXQhLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IG1lYXN1cmUhLFxuICAgICAgICBHZXRJbml0Q2xhc3M6ICgpID0+IGluaXQhLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3M6ICgpID0+IHRyYW5zaXRpb24hLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBmaW5hbGl6ZSEsXG4gICAgfSksIFtiYXNlLCBlbnRlciwgZXhpdCwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemVdKVxufVxuXG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgaCwgUmVuZGVyYWJsZVByb3BzLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuRmxhZywgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVPYmplY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgRXhjbHVzaXZlQ29udGV4dFR5cGUsIEV4Y2x1c2l2ZUluZm8sIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcblxuXG5cbmxldCBnbG9iYWxDb3VudCA9IC0xO1xuXG5leHBvcnQgZnVuY3Rpb24gRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyKHsgZXhjbHVzaXZpdHlLZXksIGNoaWxkcmVuIH06IFJlbmRlcmFibGVQcm9wczx7IGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB9Pikge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcIkV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlclwiLCBleGNsdXNpdml0eUtleSk7XG5cbiAgICBjb25zdCBbZ2V0TmV4dEluZGV4SW5MaW5lLCBzZXROZXh0SW5kZXhJbkxpbmVdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZyB8IG51bGwsIG5ldmVyPihudWxsKTtcblxuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuLCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPEV4Y2x1c2l2ZUluZm8+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgZ2V0Q3VycmVudEluZGV4IH0gPSB1c2VDaGlsZHJlbkZsYWc8RXhjbHVzaXZlSW5mbywgbmV2ZXI+KHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4sXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlLFxuICAgICAgICBpbml0aWFsSW5kZXg6IG51bGwsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIHNldEF0OiB1c2VDYWxsYmFjaygobSwgdikgPT4geyBtLnNldEV4Y2x1c2l2ZWx5T3Blbih2KTsgfSwgW10pLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKG0pID0+IG0uZ2V0RXhjbHVzaXZlbHlPcGVuKCksIFtdKSxcbiAgICAgICAgaXNWYWxpZDogdXNlQ2FsbGJhY2soKG0pID0+IHsgcmV0dXJuIHRydWUgfSwgW10pLFxuICAgIH0pXG5cbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgdmlzaWJsZTogXCJzaG93XCIgfCBcImhpZGRlblwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRJbkxpbmUgPSBnZXROZXh0SW5kZXhJbkxpbmUoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluTGluZSA9IGdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgICAgIGlmICh2aXNpYmxlID09IFwic2hvd1wiICYmIGluZGV4ICE9IGN1cnJlbnRJbkxpbmUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIGNoaWxkIHRyYW5zaXRpb24gc2hvd3MgaXRzZWxmIGluaXRpYWxseVxuICAgICAgICAgICAgICogKGkuZS4gcmVxdWVzdHMgaXRzZWxmIHRvIGJlIHRoZSBleGNsdXNpdmUgdHJhbnNpdGlvbilcbiAgICAgICAgICAgICAqIHdlIGVpdGhlciBsZXQgaXQgb3BlbiBpbW1lZGlhdGVseSBpZiB0aGVyZSdzIG5vIG9uZSBmaW5pc2hpbmcgdGhlaXIgZXhpdCxcbiAgICAgICAgICAgICAqIG9yIHdhaXQgdW50aWwgdGhhdCBhZm9yZW1lbnRpb25lZCBleGl0IGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbkxpbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuKCkuZ2V0QXQoY3VycmVudEluTGluZSk/LmZvcmNlQ2xvc2U/LigpO1xuICAgICAgICAgICAgICAgIHNldE5leHRJbmRleEluTGluZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlzaWJsZSA9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBjaGlsZCB0cmFuc2l0aW9uIGhhcyBmaW5pc2hlZCBpdHMgZXhpdCB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICogbWFrZSBzdXJlIHRoYXQgaWYgc29tZW9uZSByZXF1ZXN0ZWQgdG8gYmUgc2hvd24gaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgKiB0aGF0IHdlIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmV4dEluTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlSW5kZXgobmV4dEluTGluZSk7XG4gICAgICAgICAgICAgICAgc2V0TmV4dEluZGV4SW5MaW5lKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb250ZXh0MjogRXhjbHVzaXZlQ29udGV4dFR5cGUgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIGV4Y2x1c2l2aXR5S2V5LFxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgY29uc3QgRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQgPSBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dChleGNsdXNpdml0eUtleSk7XG5cbiAgICByZXR1cm4gKEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0ID09IG51bGwpID8gKChjaGlsZHJlbiBhcyBWTm9kZSkgPz8gbnVsbCkgOiA8RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHQyfT57Y2hpbGRyZW59PC9FeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlcj47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEV4Y2x1c2l2ZUluZm8+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIiB8IFwiY29udGV4dFwiPiB7XG4gICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IFBpY2s8VHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPGFueT4sIFwic2hvd1wiPjtcbiAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBmb3JjZUNsb3NlOiAoKSA9PiB2b2lkOyBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24oeyB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBzaG93IH0sIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGZvcmNlQ2xvc2UsIGV4Y2x1c2l2aXR5S2V5IH0gfTogVXNlRXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjID0gR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQoZXhjbHVzaXZpdHlLZXkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25cIiwgYyA9PSBudWxsKTtcbiAgICBjb25zdCBjb250ZXh0ID0gYz8gdXNlQ29udGV4dChjKSA6IG51bGw7XG5cbiAgICBjb25zdCBpbmRleCA9IHVzZU1lbW8oKCkgPT4geyBnbG9iYWxDb3VudCArPSAxOyByZXR1cm4gKGdsb2JhbENvdW50KS50b1N0cmluZygpIH0sIFtdKTtcbiAgICBjb25zdCBbZXhjbHVzaXZlbHlPcGVuLCBzZXRFeGNsdXNpdmVseU9wZW4sIGdldEV4Y2x1c2l2ZWx5T3Blbl0gPSB1c2VTdGF0ZTxib29sZWFuPighIXNob3cpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9ID0gdXNlTWFuYWdlZENoaWxkPEV4Y2x1c2l2ZUluZm8+KHsgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9IH0sIHsgaW5kZXgsIGdldEV4Y2x1c2l2ZWx5T3Blbiwgc2V0RXhjbHVzaXZlbHlPcGVuLCBmb3JjZUNsb3NlIH0pO1xuXG4gICAgY29uc3QgcGFyZW50T25WaXNDaGFuZ2UgPSBjb250ZXh0Py5leGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dC5vblZpc2liaWxpdHlDaGFuZ2U7XG5cbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8YW55PltcIm9uVmlzaWJpbGl0eUNoYW5nZVwiXT4+KCh2aXNpYmxlKSA9PiB7XG4gICAgICAgIHBhcmVudE9uVmlzQ2hhbmdlPy4oaW5kZXgsIHZpc2libGUgPT0gZmFsc2UgPyBcImhpZGRlblwiIDogXCJzaG93XCIpO1xuICAgIH0sIFtwYXJlbnRPblZpc0NoYW5nZSwgaW5kZXhdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG93KVxuICAgICAgICAgICAgcGFyZW50T25WaXNDaGFuZ2U/LihpbmRleCwgXCJzaG93XCIpO1xuICAgIH0sIFtzaG93LCBwYXJlbnRPblZpc0NoYW5nZSwgaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm46IHtcbiAgICAgICAgICAgIGlzRXhjbHVzaXZlOiAoY29udGV4dCAhPSBudWxsKSxcbiAgICAgICAgICAgIGV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIHNldEV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIGdldEV4Y2x1c2l2ZWx5T3BlbixcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4iLCJcclxuaW1wb3J0IHsgRnVuY3Rpb25hbENvbXBvbmVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxudHlwZSBGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50UHJvcHM8UCwgRT4gPSBPbWl0PFAsIFwicmVmXCI+ICYgeyByZWY/OiBSZWY8RT4gfVxyXG50eXBlIEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnQ8UCwgRT4gPSAocDogRm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+KSA9PiBWTm9kZTxGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50UHJvcHM8UCwgRT4+XHJcblxyXG50eXBlIEVsZW1lbnRGcm9tUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGluZmVyIEU+ID8gRSA6IEV2ZW50VGFyZ2V0O1xyXG50eXBlIFByb3BzRnJvbUNvbXBvbmVudDxDIGV4dGVuZHMgRnVuY3Rpb25hbENvbXBvbmVudDxhbnk+PiA9IEMgZXh0ZW5kcyBGdW5jdGlvbmFsQ29tcG9uZW50PGluZmVyIFA+ID8gUCA6IHVua25vd247XHJcblxyXG4vKipcclxuICogU2hvcnRjdXQgZm9yIHByZWFjdC9jb21wYXQncyBgZm9yd2FyZFJlZmAgdGhhdCBhdXRvLWFzc3VtZXMgc29tZSB0aGluZ3MgdGhhdCBhcmUgdXNlZnVsIGZvciBmb3J3YXJkaW5nIHJlZnMgdG8gYEhUTUxFbGVtZW50c2Agc3BlY2lmaWNhbGx5LlxyXG4gKiBOYW1lbHkgaXQgaW52b2x2ZXMgZGUtZ3Vua2luZyB0aGUgdHlwZSBzeXN0ZW0gYnkgbGV0dGluZyB1cyByZXR1cm4gKmdlbmVyaWMqIGZ1bmN0aW9uIGFuZCBwbGF5aW5nIG5pY2Ugd2l0aCBSZWFjdC4gSW4gYWxsIG90aGVyIHJlc3BlY3RzLCBpdCBhY3RzIGxpa2UgYGZvcndhcmRSZWZgLlxyXG4gKiBcclxuICogVE9ETzogU3RpbGwgbmVlZGVkP1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRFbGVtZW50UmVmPEMgZXh0ZW5kcyA8RSBleHRlbmRzIEhUTUxFbGVtZW50PihwOiBhbnksIHJlZjogUmVmPEU+KSA9PiAoVk5vZGU8YW55PiB8IG51bGwpPihDb21wb25lbnQ6IEMpIHtcclxuICAgIHR5cGUgUCA9IFByb3BzRnJvbUNvbXBvbmVudDxDPjtcclxuXHJcblxyXG4gICAgY29uc3QgRm9yd2FyZGVkQ29tcG9uZW50ID0gZm9yd2FyZFJlZihDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEZvcndhcmRlZENvbXBvbmVudCBhcyBDO1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZnVsIGluIHBhcnRpY3VsYXIgZm9yIFNsaWRlcyB3aXRoIGEgVGFiIFBhbmVsIC0tXHJcbiAqIGlmIHdlIGRvIE1hdGguc2lnbihjdXJyZW50SW5kZXggLSBzbGlkZUluZGV4KSwgaXRcclxuICogdHJhbnNpdGlvbnMgbmljZWx5IGluIHRoZSBleHBlY3RlZCBkaXJlY3Rpb24sXHJcbiAqIGJ1dCB3ZSBuZWVkIHRvIFwicmVtZW1iZXJcIiB3aGljaCBkaXJlY3Rpb24gdG8gdXNlXHJcbiAqIHdoZW4gaXQncyB0aGUgY3VycmVudCBwYW5lbCAoYW5kIHRoZSBkaWZmZXJlbmNlIGlzIDApXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGFzdE5vbk51bGxWYWx1ZTxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUIHwgbnVsbCB7XHJcbiAgICBjb25zdCBsYXN0Tm9uTnVsbFZhbHVlID0gdXNlUmVmPFQgfCBudWxsPihudWxsKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAgIGxhc3ROb25OdWxsVmFsdWUuY3VycmVudCA9IHZhbHVlO1xyXG4gICAgfSwgW3ZhbHVlXSk7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlID8/IGxhc3ROb25OdWxsVmFsdWUuY3VycmVudDtcclxufVxyXG4iLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBDb21wb25lbnRDaGlsZHJlbiwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlciB9IGZyb20gXCIuL2V4Y2x1c2l2ZS5qc1wiO1xyXG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0LCB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IE5vbkludHJ1c2l2ZUVsZW1lbnRBdHRyaWJ1dGVzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTd2FwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFBhcnRpYWw8Q3JlYXRlU3dhcHBhYmxlUHJvcHM+LCBOb25JbnRydXNpdmVFbGVtZW50QXR0cmlidXRlczxFPiB7XHJcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBlYWNoIGNoaWxkIHRyYW5zaXRpb25zIGluL291dCBhdCB0aGUgc2FtZSB0aW1lLCBpbiBzeW5jIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAqIFxyXG4gICAgICogSWYgeW91IHdhbnQgdG8gZ3VhcmFudGVlIHRoYXQsIG5vIG1hdHRlciB3aGF0LCBvbmx5IG9uZSBpcyBldmVyIHZpc2libGUgYXQgYWxsLFxyXG4gICAgICogcGFzcyBhIHN0cmluZyB0byBgZXhjbHVzaXZpdHlLZXlgLCBhbmQgYWxsIHRyYW5zaXRpb25zIHRoYXQgdXNlIHRoYXQgc2FtZVxyXG4gICAgICogYGV4Y2x1c2l2aXR5S2V5YCB3aWxsIGNvb3JkaW5hdGUgdGhpcyBiZWhhdmlvciBhbW9uZyB0aGVtc2VsdmVzLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIGlzIGFsc28gYXZhaWxhYmxlIGFzIGEgc2VwYXJhdGUgY29tcG9uZW50IChgRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyYClcclxuICAgICAqIGlmIHlvdSBuZWVkIHRoaXMgYmVoYXZpb3IgaW4gdW5yZWxhdGVkIGNpcmN1bXN0YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTd2FwcGFibGVQcm9wcyB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgaXMgaW5saW5lLWdyaWQgb3IgZ3JpZC4gXHJcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjaGlsZCBlbGVtZW50IGlzIGxvb2tlZCBhdC4gSWYgaXQncyBhIHNwYW4gb3Igb3RoZXIgaW5saW5lIGVsZW1lbnQsIGlubGluZSBpcyBhc3N1bWVkLiBcclxuICAgICAqIChBIHNpbXBseS1mb29sZWQgaGV1cmlzdGljLS1wcm92aWRlIHRoaXMgcHJvcCBpZiBuZWNlc3NhcnkpXHJcbiAgICAgKi9cclxuICAgIGlubGluZTogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBkZWZhdWx0IHZhbHVlcyB0byBgdXNlVHJhbnNpdGlvbmAncyBgYW5pbWF0ZU9uTW91bnRgLiBJZiBudWxsLCB0aGUgZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5LCB0aGVuIGB0cnVlYCBhZnRlciB0aGUgYFN3YXBwYWJsZWAgaXRzZWxmIGhhcyBtb3VudGVkLlxyXG4gICAgICovXHJcbiAgICBjaGlsZHJlbkFuaW1hdGVPbk1vdW50PzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgc3dhcCBjb250YWluZXIuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHM8UCBleHRlbmRzIHt9Pih7IGlubGluZSB9OiBDcmVhdGVTd2FwcGFibGVQcm9wcywgb3RoZXJQcm9wczogUCkge1xyXG4gICAgdHlwZSBFID0gUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGluZmVyIEU+ID8gRSA6IEhUTUxFbGVtZW50O1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGAke0dldEJhc2VDbGFzcygpfS1zd2FwLWNvbnRhaW5lcmAsIGlubGluZSAmJiBgJHtHZXRCYXNlQ2xhc3MoKX0tc3dhcC1jb250YWluZXItaW5saW5lYClcclxuICAgIH0sIG90aGVyUHJvcHMpO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGEgc2V0IG9mIGNoaWxkIDxUcmFuc2l0aW9uYWJsZT4gY29tcG9uZW50cyB0byBhbmltYXRlIGluICYgb3V0IGluLXBsYWNlLiBWZXJ5IHVzZWZ1bCBmb3IsIGUuZy4sIHRhYiBwYW5lbHMuXHJcbiAqIFxyXG4gKiBZb3UgbXVzdCBtYW5hZ2UgZWFjaCBjaGlsZCBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50J3MgYHNob3dgIHByb3AgLS0gdGhpcyBjb21wb25lbnQgKmRvZXMgbm90KiBtYW5hZ2UgYW55IHNvcnQgb2Ygc3RhdGUgaW4gdGhhdCByZWdhcmQuXHJcbiAqIFxyXG4gKiBJZiB5b3UgcGFzcyBhIHJlZ3VsYXIgZWxlbWVudCAobGlrZSBhIGRpdikgb3Igb3RoZXIgc2luZ2xlIGNvbXBvbmVudCwgdGhlbiB0aGVlIHByb3BzIGFuZCByZWYgd2lsbCBiZSBmb3J3YXJkZWQgb250byB0aGF0IGVsZW1lbnQuIE90aGVyd2lzZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIHdyYXBwZWQgaW4gYSBkaXYgb3Igc3BhbiBkZXBlbmRpbmcgb24gdGhlIGBpbmxpbmVgIHByb3AuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFN3YXBwYWJsZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU3dhcHBhYmxlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBjaGlsZHJlbjogYywgaW5saW5lLCBjaGlsZHJlbkFuaW1hdGVPbk1vdW50LCBleGNsdXNpdml0eUtleSwgLi4ucCB9OiBTd2FwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICBsZXQgY2hpbGRyZW4gPSBjIGFzIFZOb2RlO1xyXG4gICAgaWYgKCEoY2hpbGRyZW4gYXMgVk5vZGUpLnR5cGUpXHJcbiAgICAgICAgY2hpbGRyZW4gPSAoIWlubGluZSA/IDxkaXY+e2NoaWxkcmVufTwvZGl2PiA6IDxzcGFuPntjaGlsZHJlbn08L3NwYW4+KVxyXG4gICAgaW5saW5lID8/PSB0eXBlb2YgY2hpbGRyZW4udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBpbmxpbmVFbGVtZW50cy5oYXMoY2hpbGRyZW4udHlwZSk7XHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvblByb3BzID0gdXNlQ3JlYXRlU3dhcHBhYmxlUHJvcHMoeyBpbmxpbmUgfSwgeyAuLi5wLCByZWYgfSk7XHJcbiAgICBjb25zdCBtZXJnZWRXaXRoQ2hpbGRyZW4gPSB1c2VNZXJnZWRQcm9wczxFPih0cmFuc2l0aW9uUHJvcHMsIGNoaWxkcmVuLnByb3BzKTtcclxuXHJcbiAgICBjb25zdCBhbmltYXRlT25Nb3VudCA9IHVzZVJlZihjaGlsZHJlbkFuaW1hdGVPbk1vdW50ID8/IGZhbHNlKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgYW5pbWF0ZU9uTW91bnQuY3VycmVudCA9IHRydWU7XHJcbiAgICB9LCBbXSlcclxuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZVJlZih7IGdldEFuaW1hdGVPbk1vdW50OiAoKSA9PiB7IHJldHVybiBhbmltYXRlT25Nb3VudC5jdXJyZW50OyB9IH0pO1xyXG4gICAgbGV0IHJldCA9IGNsb25lRWxlbWVudChjaGlsZHJlbiwgbWVyZ2VkV2l0aENoaWxkcmVuIGFzIHR5cGVvZiB0cmFuc2l0aW9uUHJvcHMpO1xyXG4gICAgcmV0ID0gKDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWUuY3VycmVudH0+e3JldH08L1N3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXI+KVxyXG4gICAgaWYgKGV4Y2x1c2l2aXR5S2V5KSB7XHJcbiAgICAgICAgcmV0ID0gKDxFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIga2V5PXtleGNsdXNpdml0eUtleX0gZXhjbHVzaXZpdHlLZXk9e2V4Y2x1c2l2aXR5S2V5fT57cmV0fTwvRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyPilcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn0pKVxyXG5cclxuLy8gSWYgXCJpbmxpbmVcIiBpc24ndCBleHBsaWNpdGx5IHByb3ZpZGVkLCB3ZSB0cnkgdG8gaW1wbGljaXRseSBkbyBpdCBiYXNlZCBvbiB0aGUgY2hpbGQncyB0YWcuXHJcbi8vIE5vdCBwZXJmZWN0LCBidXQgaXQncyBub3Qgc3VwcG9zZWQgdG8gYmUuIGBpbmxpbmVgIGlzIGZvciBwZXJmZWN0LlxyXG5jb25zdCBpbmxpbmVFbGVtZW50cyA9IG5ldyBTZXQoW1xyXG4gICAgXCJhXCIsXHJcbiAgICBcImFiYnJcIixcclxuICAgIFwiYWNyb255bVwiLFxyXG4gICAgXCJhdWRpb1wiLFxyXG4gICAgXCJiXCIsXHJcbiAgICBcImJkaVwiLFxyXG4gICAgXCJiZG9cIixcclxuICAgIFwiYmlnXCIsXHJcbiAgICBcImJyXCIsXHJcbiAgICBcImJ1dHRvblwiLFxyXG4gICAgXCJjYW52YXNcIixcclxuICAgIFwiY2l0ZVwiLFxyXG4gICAgXCJjb2RlXCIsXHJcbiAgICBcImRhdGFcIixcclxuICAgIFwiZGF0YWxpc3RcIixcclxuICAgIFwiZGVsXCIsXHJcbiAgICBcImRmblwiLFxyXG4gICAgXCJlbVwiLFxyXG4gICAgXCJlbWJlZFwiLFxyXG4gICAgXCJpXCIsXHJcbiAgICBcImlmcmFtZVwiLFxyXG4gICAgXCJpbWdcIixcclxuICAgIFwiaW5wdXRcIixcclxuICAgIFwiaW5zXCIsXHJcbiAgICBcImtiZFwiLFxyXG4gICAgXCJsYWJlbFwiLFxyXG4gICAgXCJtYXBcIixcclxuICAgIFwibWFya1wiLFxyXG4gICAgXCJtZXRlclwiLFxyXG4gICAgXCJub3NjcmlwdFwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwib3V0cHV0XCIsXHJcbiAgICBcInBpY3R1cmVcIixcclxuICAgIFwicHJvZ3Jlc3NcIixcclxuICAgIFwicVwiLFxyXG4gICAgXCJydWJ5XCIsXHJcbiAgICBcInNcIixcclxuICAgIFwic2FtcFwiLFxyXG4gICAgXCJzY3JpcHRcIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcInNsb3RcIixcclxuICAgIFwic21hbGxcIixcclxuICAgIFwic3BhblwiLFxyXG4gICAgXCJzdHJvbmdcIixcclxuICAgIFwic3ViXCIsXHJcbiAgICBcInN1cFwiLFxyXG4gICAgXCJzdmdcIixcclxuICAgIFwidGVtcGxhdGVcIixcclxuICAgIFwidGV4dGFyZWFcIixcclxuICAgIFwidGltZVwiLFxyXG4gICAgXCJ1XCIsXHJcbiAgICBcInR0XCIsXHJcbiAgICBcInZhclwiLFxyXG4gICAgXCJ2aWRlb1wiLFxyXG4gICAgXCJ3YnJcIlxyXG5dKTtcclxuIiwiaW1wb3J0IHsgY2xvbmVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHJ1bkltbWVkaWF0ZWx5IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRXhjbHVzaXZlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2V4Y2x1c2l2ZS5qc1wiO1xuaW1wb3J0IHsgR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQsIHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IFN3YXBwYWJsZUNvbnRleHRUeXBlLCBUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2UsIFRyYW5zaXRpb25TdGF0ZSwgVXNlVHJhbnNpdGlvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0IH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5cblxuZnVuY3Rpb24gZ2V0VGltZW91dER1cmF0aW9uPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oZWxlbWVudDogRSB8IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZShgdHJhbnNpdGlvbi1kdXJhdGlvbmApKS5zcGxpdChcIixcIikubWFwKHN0ciA9PiB7XG4gICAgICAgIGlmIChzdHIuZW5kc1dpdGgoXCJtc1wiKSlcbiAgICAgICAgICAgIHJldHVybiArc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICAgIGlmIChzdHIuZW5kc1dpdGgoXCJzXCIpKVxuICAgICAgICAgICAgcmV0dXJuICgrc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSkpICogMTAwMDtcbiAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlKG5leHRTdGF0ZTogVHJhbnNpdGlvblN0YXRlKSB7XG4gICAgcmV0dXJuIG5leHRTdGF0ZS5zcGxpdChcIi1cIikgYXMgW1RyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZV07XG59XG5cbi8qKlxuICogUHJvdmlkZSBwcm9wcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFuaW1hdGUgYSB0cmFuc2l0aW9uLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0cmFuc2l0aW9uUGFyYW1ldGVyczogeyBwcm9wc0luY29taW5nOiB7IGNoaWxkcmVuLCAuLi5wIH0sIHNob3csIGFuaW1hdGVPbk1vdW50LCBtZWFzdXJlLCBleGl0VmlzaWJpbGl0eSwgZHVyYXRpb24sIGRlbGF5TW91bnRVbnRpbFNob3duLCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIG9uVmlzaWJpbGl0eUNoYW5nZSB9LCBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9IH06IFVzZVRyYW5zaXRpb25QYXJhbWV0ZXJzPEU+KTogVk5vZGU8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+IHwgbnVsbCB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlVHJhbnNpdGlvblwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuXG4gICAgY29uc3QgeyBnZXRBbmltYXRlT25Nb3VudCB9ID0gdXNlQ29udGV4dChTd2FwcGFibGVDb250ZXh0KTtcbiAgICBleGl0VmlzaWJpbGl0eSB8fD0gXCJoaWRkZW5cIlxuICAgIGFuaW1hdGVPbk1vdW50ID8/PSBnZXRBbmltYXRlT25Nb3VudCgpO1xuICAgIG1lYXN1cmUgPz89IGZhbHNlO1xuXG4gICAgY29uc3QgZ2V0RXhpdFZpc2liaWxpdHkgPSB1c2VTdGFibGVHZXR0ZXIoZXhpdFZpc2liaWxpdHkpO1xuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzLCBHZXRFbnRlckNsYXNzLCBHZXRFeGl0Q2xhc3MsIEdldE1lYXN1cmVDbGFzcywgR2V0SW5pdENsYXNzLCBHZXRUcmFuc2l0aW9uQ2xhc3MsIEdldEZpbmFsaXplQ2xhc3MsIEdldERpcmVjdGlvbkNsYXNzLCBHZXRQaGFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XG4gICAgY29uc3QgZ2V0TWVhc3VyZSA9IHVzZVN0YWJsZUdldHRlcihtZWFzdXJlKTtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm46IHsgZXhjbHVzaXZlbHlPcGVuLCBpc0V4Y2x1c2l2ZSwgb25WaXNpYmlsaXR5Q2hhbmdlOiBleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZSB9IH0gPSB1c2VFeGNsdXNpdmVUcmFuc2l0aW9uKHtcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgc2hvdyB9LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSwgZm9yY2VDbG9zZTogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBpbnRlcm5hbE9uU2hvd0NoYW5nZWQoZmFsc2UsIGdldE1lYXN1cmUoKSk7IH0pIH1cbiAgICB9KTtcblxuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBzaG93ID0gKHNob3cgJiYgZXhjbHVzaXZlbHlPcGVuKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCwgcHJvcHNTdGFibGUgfSB9ID0gdXNlUmVmRWxlbWVudDxFPih7fSlcbiAgICBjb25zdCBjc3NQcm9wZXJ0aWVzID0gdXNlUmVmPGguSlNYLkNTU1Byb3BlcnRpZXM+KHt9KTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdXNlUmVmKG5ldyBTZXQ8c3RyaW5nPihbXG4gICAgICAgIC8vIFRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBmaXJzdCByZW5kZXJcbiAgICAgICAgLy8gKGF0IGxlYXN0IG9uY2UgYHNob3dgIGlzIG5vbi1udWxsKVxuICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tcGVuZGluZ2AsXG4gICAgXSkpO1xuICAgIGNvbnN0IGhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCghIXN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBbZGlyZWN0aW9uLCBwaGFzZV0gPSBwYXJzZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChwaGFzZSA9PSBcInRyYW5zaXRpb25cIikge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKGAke2RpcmVjdGlvbn0tZmluYWxpemVgKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZS5jdXJyZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50Py4odGltZW91dEhhbmRsZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG4gICAgY29uc3Qgb3RoZXJQcm9wcyA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oe1xuICAgICAgICBvblRyYW5zaXRpb25FbmQ6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT0gZ2V0RWxlbWVudCgpICYmIGUuZWxhcHNlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUcmFuc2l0aW9uRmluaXNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBoYXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsZW1lbnQncyBDU1MgY2xhc3MgdG8gbWF0Y2ggdGhlIGdpdmVuIGRpcmVjdGlvbiBhbmQgcGhhc2UuXG4gICAgICovXG4gICAgY29uc3QgdXBkYXRlQ2xhc3NlcyA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCwgZGlyZWN0aW9uOiBUcmFuc2l0aW9uRGlyZWN0aW9uLCBwaGFzZT86IFRyYW5zaXRpb25QaGFzZSkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgY29uc3QgZXhpdFZpc2liaWxpdHkgPSBnZXRFeGl0VmlzaWJpbGl0eSgpO1xuXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXNUb1JlbW92ZSA9IFtcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldE1lYXN1cmVDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRJbml0Q2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0VHJhbnNpdGlvbkNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldEZpbmFsaXplQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0TWVhc3VyZUNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0SW5pdENsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0VHJhbnNpdGlvbkNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LSR7R2V0RmluYWxpemVDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcImluZXJ0XCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ldi0ke1wicmVtb3ZlZFwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcImhpZGRlblwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcInZpc2libGVcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LXBlbmRpbmdgLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXNUb0FkZCA9IFtcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXREaXJlY3Rpb25DbGFzcyhkaXJlY3Rpb24pfWAsXG4gICAgICAgICAgICBwaGFzZSA/IGAke0dldEJhc2VDbGFzcygpfS0ke0dldERpcmVjdGlvbkNsYXNzKGRpcmVjdGlvbil9LSR7R2V0UGhhc2VDbGFzcyhwaGFzZSl9YCA6IFwiXCIsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtleGl0VmlzaWJpbGl0eX1gXG4gICAgICAgIF07XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmFsbENsYXNzZXNUb1JlbW92ZSk7XG4gICAgICAgIGFsbENsYXNzZXNUb1JlbW92ZS5tYXAodiA9PiBjbGFzc05hbWVzLmN1cnJlbnQuZGVsZXRlKHYpKTtcblxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uYWxsQ2xhc3Nlc1RvQWRkKTtcbiAgICAgICAgYWxsQ2xhc3Nlc1RvQWRkLm1hcCh2ID0+IGNsYXNzTmFtZXMuY3VycmVudC5hZGQodikpO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHNpbmdsZSBcIm1lYXN1cmVcIiB2YXJpYWJsZSAob3IgcmVtb3ZlcyBpdClcbiAgICAgKi9cbiAgICBjb25zdCB1cGRhdGVTaXplUHJvcGVydHkgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSwgdmFyTmFtZTogKGtleW9mIGguSlNYLkNTU1Byb3BlcnRpZXMpICYgc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZX1weGA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFt2YXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSh2YXJOYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbdmFyTmFtZV07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBcIm1lYXN1cmVcIiB2YXJpdXBkYXRlQ2xhc3Nlc2FibGVzIHRvIHRoZSBlbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICBjb25zdCBtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIG1lYXN1cmU6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBzaXplOiBET01SZWN0UmVhZE9ubHkgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLXRvcGAsIHNpemU/LnRvcCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS1sZWZ0YCwgc2l6ZT8ubGVmdCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS13aWR0aGAsIHNpemU/LndpZHRoKTtcbiAgICAgICAgICAgIHVwZGF0ZVNpemVQcm9wZXJ0eShlbGVtZW50LCBgLS0ke0dldEJhc2VDbGFzcygpfS1tZWFzdXJlLWhlaWdodGAsIHNpemU/LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBXZSB1c2UgYm90aCB1c2VUaW1lb3V0IGFuZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIHRpbWluZyBjZXJ0YWluIHRoaW5ncyAtLVxuICAgIC8vIHJhZiBpcyB1c2VkIGZvciBjaGFuZ2luZyBmcm9tIGluaXQgdG8gdHJhbnNpdGlvbiAod291bGQgdXNlIHF1ZXVlTWljcm90YXNrIGJ1dCBpdCBjYW4ndCBiZSBjYW5jZWxsZWQpXG4gICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIGZvciBjaGFuZ2luZyBmcm9tIHRyYW5zaXRpb24gdG8gZmluYWxpemUgKGFzIGEgYmFja3VwIGluIGNhc2UgdHJhbnNpdGlvbmVuZCBkb2Vzbid0IGZpcmUpXG4gICAgLy9cbiAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBzdGFsZSBjYWxsYmFja3MgcnVubmluZyAoaS5lLiB3aGVuIHdlIHJhcGlkbHkgc3dpdGNoIGJldHdlZW4gdmlzaWJsZSBhbmQgbm90KVxuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFjY3VyYXRlbHkgY2FuY2VsIGFueXRoaW5nIHRoYXQgY2FuIGNoYW5nZSBvdXIgc3RhdGUgb24gYSBkZWxheS5cbiAgICAvL1xuICAgIC8vIEFsc28gb2Ygbm90ZSwgd2Ugc3RvcmUgXCIoZikgPT4gd2luZG93LmNsZWFyVGltZW91dChmKVwiIGluc3RlYWQgb2YganVzdCBcIndpbmRvdy5jbGVhclRpbWVvdXRcIiBiZWNhdXNlXG4gICAgLy8gb2YgdGhlIGltcGxpY2l0IHdpbmRvdyBvYmplY3QgLS0gcHJvYmxlbXMgd2l0aCBhIG1pc3NpbmcgYHRoaXNgIG9iamVjdCBhbmQgYWxsIHRoYXQgbm9uc2Vuc2UuXG4gICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHVzZVJlZjxudW1iZXI+KC0xKTtcbiAgICBjb25zdCB0aW1lb3V0Q2xlYXJGdW5jdGlvbiA9IHVzZVJlZjwodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lKSB8ICh0eXBlb2YgY2xlYXJUaW1lb3V0KSB8IG51bGw+KG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgdGhlIHN0YXRlIGNoYW5nZXMsIHRoZXJlJ3Mgc29tZSBsb2dpYyB3ZSBuZWVkIHRvIHJ1bjpcbiAgICAgKiBcbiAgICAgKiAqIElmIHdlJ3JlIGNoYW5naW5nIHRvIGFuIGBpbml0YCBwaGFzZSwgdXBkYXRlIHRoZSBjbGFzc2VzLCB0aGVuIHdhaXQgYSBtb21lbnQgYW5kIHRoZW4gY2hhbmdlIHRvIHRoZSBgdHJhbnNpdGlvbmAgcGhhc2UuXG4gICAgICogKiBJZiB3ZSdyZSBjaGFuZ2luZyB0byBhIGB0cmFuc2l0aW9uYCBwaGFzZSwgdXBkYXRlIHRoZSBjbGFzc2VzLCB0aGVuIHdhaXQgdW50aWwgdGhlIHRyYW5zaXRpb24gY29tcGxldGVzLCB0aGVuIGNoYW5nZSB0byB0aGUgYGZpbmFsaXplYCBwaGFzZS5cbiAgICAgKiBcbiAgICAgKiBBbnkgY2hhbmdlIGluIHN0YXRlIG9yIGNsYXNzZXMvc3R5bGVzIGRvZXMgbm90IGltcGxpY2l0bHkgY2F1c2UgYSByZS1yZW5kZXIuXG4gICAgICovXG4gICAgY29uc3Qgb25TdGF0ZUNoYW5nZSA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFRyYW5zaXRpb25TdGF0ZSB8IG51bGwsIHVuZGVmaW5lZD4+KChuZXh0U3RhdGUsIHByZXZTdGF0ZSwgcmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBbbmV4dERpcmVjdGlvbiwgbmV4dFBoYXNlXSA9IHBhcnNlU3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgbm8gc3RhbGUgY2hhbmdlIGNvZGUgZXZlciBydW5zXG4gICAgICAgIGlmICh0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPj0gMCAmJiB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50KVxuICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCh0aW1lb3V0SGFuZGxlLmN1cnJlbnQpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBpbmVydCBwcm9wcy9wcm9wZXJ0eVxuICAgICAgICBjb25zdCBleGl0VmlzaWJpbGl0eSA9IGdldEV4aXRWaXNpYmlsaXR5KCk7XG4gICAgICAgIGlmIChleGl0VmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgY29uc3QgaW5lcnQgPSAoZXhpdFZpc2liaWxpdHkgPT0gXCJpbmVydFwiICYmIChuZXh0RGlyZWN0aW9uID09IFwiZXhpdFwiICYmIG5leHRQaGFzZSA9PSBcImZpbmFsaXplXCIpID8gdHJ1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoaW5lcnQpXG4gICAgICAgICAgICAgICAgKG90aGVyUHJvcHMuY3VycmVudCBhcyBhbnkpLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgb3RoZXJQcm9wcy5jdXJyZW50W1wiaW5lcnRcIiBhcyBuZXZlcl07XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5lcnQgPSAoaW5lcnQgfHwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNCZWluZ1BhaW50ZWQgPSAobmV4dERpcmVjdGlvbiA9PSBcImVudGVyXCIgfHwgKG5leHREaXJlY3Rpb24gPT0gXCJleGl0XCIgJiYgbmV4dFBoYXNlICE9IFwiZmluYWxpemVcIikpO1xuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2U/Lihpc0JlaW5nUGFpbnRlZCk7XG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25WaXNpYmlsaXR5Q2hhbmdlPy4oaXNCZWluZ1BhaW50ZWQpO1xuXG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoZWxlbWVudCwgbmV4dERpcmVjdGlvbiwgbmV4dFBoYXNlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgKG5leHRQaGFzZSA9PSBcImluaXRcIiB8fCBuZXh0UGhhc2UgPT0gXCJ0cmFuc2l0aW9uXCIpKVxuICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG5cblxuXG4gICAgICAgIHN3aXRjaCAobmV4dFBoYXNlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVhc3VyZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50QW5kVXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvL3NldFN0YXRlKGAke25leHREaXJlY3Rpb259LWluaXRgKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDbGFzc2VzKGVsZW1lbnQsIG5leHREaXJlY3Rpb24sIFwiaW5pdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZWZsb3coZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyAhIUludGVudGlvbmFsIGZhbGwtdGhyb3VnaCEhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW5pdFwiOiB7XG4gICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgc2V0U3RhdGUoYCR7bmV4dERpcmVjdGlvbn0tdHJhbnNpdGlvbmApOyB9KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50ID0gKGY6IG51bWJlcikgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfSwgZ2V0VGltZW91dER1cmF0aW9uKGVsZW1lbnQpICogMS41KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q2xlYXJGdW5jdGlvbi5jdXJyZW50ID0gKGY6IG51bWJlcikgPT4gY2xlYXJUaW1lb3V0KGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVcIjoge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gb3Igc2NoZWR1bGUgb3IgYW55dGhpbmcgLS0gd2UganVzdCB1cGRhdGUgb3VyIGNsYXNzZXMgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IG51bGw7ICAgIC8vIERvZXMgdGhpcyBtYWtlIGl0IG1vcmUgb3IgbGVzcyBjbGVhcj9cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBJbnRlbnRpb25hbFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkIHN0YXRlIHVzZWQgaW4gdHJhbnNpdGlvbjogJHtuZXh0U3RhdGV9LiBQcmV2aW91cyBzdGF0ZSB3YXMgJHtwcmV2U3RhdGUgPz8gXCJudWxsXCJ9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cblxuICAgIGNvbnN0IFtnZXRTdGF0ZSwgc2V0U3RhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPFRyYW5zaXRpb25TdGF0ZSB8IG51bGwsIHVuZGVmaW5lZD4ob25TdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgYW5kIGV2ZXJ5IHRpbWUgdGhlcmVhZnRlciB0aGF0IGBzaG93YCBjaGFuZ2VzLFxuICAgIC8vIGNoYW5nZSBvdXIgY3VycmVudCBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhhdCBgc2hvd2AgdmFsdWUuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IGludGVybmFsT25TaG93Q2hhbmdlZChzaG93LCBtZWFzdXJlKSwgW21lYXN1cmUsIHNob3ddKTtcblxuXG4gICAgLy8gVGhpcyBoYXMgbm8gZGVwZW5kZW5jZXMgYW5kIGlzIHJlbGllZCBvbiBpbiB0d28gZGlmZmVyZW50IGFyZWFzXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxPblNob3dDaGFuZ2VkKHNob3c6IGJvb2xlYW4gfCBudWxsLCBtZWFzdXJlOiBib29sZWFuKSB7XG5cbiAgICAgICAgLy8gSWYgYHNob3dgIGlzIG51bGwsIHRoZW4gd2UgZG9uJ3QgY2hhbmdlIGFueXRoaW5nLlxuICAgICAgICBpZiAoc2hvdyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIChJZiBgc2hvd2AgaXMgdHJ1ZS9mYWxzZSwgd2UnbGwgcmVtb3ZlIHRoZSBDU1MgY2xhc3NlcyBkdXJpbmcgYG9uQ2hhbmdlYClcblxuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICBsZXQgbmV4dFBoYXNlOiBUcmFuc2l0aW9uUGhhc2UgPSBtZWFzdXJlID8gXCJtZWFzdXJlXCIgOiBcImluaXRcIjtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgW2N1cnJlbnREaXJlY3Rpb24sIGN1cnJlbnRQaGFzZV0gPSBwYXJzZVN0YXRlKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBoYXNlICE9IFwiZmluYWxpemVcIilcbiAgICAgICAgICAgICAgICBuZXh0UGhhc2UgPSBcInRyYW5zaXRpb25cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHRoZSBzZXRTdGF0ZSBjaGFuZ2UgaGFuZGxlciBydW5zIGltbWVkaWF0ZWx5IHdpdGggbm8gZGVib3VuY2UuXG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBpZiAoaGFzTW91bnRlZC5jdXJyZW50IHx8IGFuaW1hdGVPbk1vdW50KVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKGBlbnRlci0ke25leHRQaGFzZX1gKTtcblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKFwiZW50ZXItZmluYWxpemVcIik7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNNb3VudGVkLmN1cnJlbnQgfHwgYW5pbWF0ZU9uTW91bnQpXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoYGV4aXQtJHtuZXh0UGhhc2V9YCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoXCJleGl0LWZpbmFsaXplXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZHVyYXRpb24gIT0gbnVsbClcbiAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LWR1cmF0aW9uYF0gPSBkdXJhdGlvbiArIFwibXNcIjtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZHVyYXRpb25gXTtcblxuICAgIGVhc2luZ0luID8/PSBlYXNpbmc7XG4gICAgZWFzaW5nT3V0ID8/PSBlYXNpbmc7XG5cbiAgICBpZiAoZWFzaW5nT3V0ICE9IG51bGwpXG4gICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXSA9IGVhc2luZ091dDtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF07XG5cblxuICAgIGlmIChlYXNpbmdJbiAhPSBudWxsKVxuICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdID0gZWFzaW5nSW47XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXTtcblxuXG5cbiAgICAvLyBUT0RPXG4gICAgY29uc3QgaW5saW5lRGlyZWN0aW9uID0gbnVsbDtcbiAgICBjb25zdCBibG9ja0RpcmVjdGlvbiA9IG51bGw7XG5cblxuXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQgZGVsYXlNb3VudFVudGlsU2hvd24gaXMsXG4gICAgLy8gb25jZSB3ZSd2ZSByZW5kZXJlZCBvdXIgY2hpbGRyZW4gb25jZSwgXG4gICAgLy8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVtIGFnYWluIGFuZCB3YXN0ZSBhbGwgdGhhdCB3b3JrLlxuICAgIC8vIChJZiB5b3UgcmVhbGx5IG5lZWQgdGhpcyB5b3UgY2FuIGp1c3QgdW5tb3VudCB0aGUgZW50aXJlIHRyYW5zaXRpb24gaXRzZWxmKVxuICAgIGNvbnN0IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuID0gKHNob3cgfHwgIWRlbGF5TW91bnRVbnRpbFNob3duKTtcbiAgICBjb25zdCBoYXNSZW5kZXJlZENoaWxkcmVuID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCByZW5kZXJDaGlsZHJlbiA9IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuIHx8IGhhc1JlbmRlcmVkQ2hpbGRyZW4uY3VycmVudDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW4pXG4gICAgICAgICAgICBoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQgfHw9IHRydWU7XG4gICAgfSwgW2hhc1JlbmRlcmVkQ2hpbGRyZW4uY3VycmVudCA/IGZhbHNlIDogZGVmaW5pdGVseVNob3VsZE1vdW50Q2hpbGRyZW5dKTtcblxuXG4gICAgY29uc3QgY2hpbGRyZW5Jc1Zub2RlID0gKGNoaWxkcmVuICYmIChjaGlsZHJlbiBhcyBWTm9kZSkudHlwZSAmJiAoY2hpbGRyZW4gYXMgVk5vZGUpLnByb3BzKTtcbiAgICBjb25zdCBmaW5hbFByb3BzID0gdXNlTWVyZ2VkUHJvcHM8RT4ocCwgcHJvcHNTdGFibGUsIG90aGVyUHJvcHMuY3VycmVudCwge1xuICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgIC4uLmNsYXNzTmFtZXMuY3VycmVudCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtleGl0VmlzaWJpbGl0eX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWlubGluZS1kaXJlY3Rpb24tJHtpbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWJsb2NrLWRpcmVjdGlvbi0ke2Jsb2NrRGlyZWN0aW9uID8/IFwidHRiXCJ9YFxuICAgICAgICBdLmpvaW4oXCIgXCIpLFxuICAgICAgICBzdHlsZTogY3NzUHJvcGVydGllcy5jdXJyZW50XG4gICAgfSwgY2hpbGRyZW5Jc1Zub2RlID8geyByZWY6IChjaGlsZHJlbiBhcyBWTm9kZSkucmVmLCAuLi4oY2hpbGRyZW4gYXMgVk5vZGUpLnByb3BzIH0gOiB7fSk7XG5cblxuXG4gICAgY29uc3QgcmVzZXRDb250ZXh0ID0gdXNlUmVmPFN3YXBwYWJsZUNvbnRleHRUeXBlPih7IGdldEFuaW1hdGVPbk1vdW50OiByZXR1cm5GYWxzZSB9KS5jdXJyZW50O1xuXG4gICAgbGV0IG1vZGlmaWVkQ2hpbGRyZW46IFZOb2RlO1xuXG4gICAgaWYgKGNoaWxkcmVuSXNWbm9kZSkge1xuICAgICAgICBtb2RpZmllZENoaWxkcmVuID0gPFN3YXBwYWJsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3Jlc2V0Q29udGV4dH0+e2Nsb25lRWxlbWVudChjaGlsZHJlbiBhcyBWTm9kZSwgZmluYWxQcm9wcyl9PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW9kaWZpZWRDaGlsZHJlbiA9IDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyZXNldENvbnRleHR9PjxzcGFuIHsuLi5maW5hbFByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT59PntjaGlsZHJlbn08L3NwYW4+PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPlxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJDaGlsZHJlbiA/IG1vZGlmaWVkQ2hpbGRyZW4gOiBudWxsO1xufVxuXG5cblxuZnVuY3Rpb24gZm9yY2VSZWZsb3c8RSBleHRlbmRzIEhUTUxFbGVtZW50PihlOiBFKSB7XG5cbiAgICAvLyBUcnkgcmVhbGx5IGhhcmQgdG8gbWFrZSBzdXJlIHRoaXMgaXNuJ3Qgb3B0aW1pemVkIG91dCBieSBhbnl0aGluZy5cbiAgICAvLyBXZSBuZWVkIGl0IGZvciBpdHMgZG9jdW1lbnQgcmVmbG93IHNpZGUgZWZmZWN0LlxuICAgIGNvbnN0IHAgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLnN0eWxlLm9wYWNpdHk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9kdW1teSA9IHA7XG4gICAgcmV0dXJuIGU7XG59XG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBtaW5pbXVtIG9yIG1heGltdW0gb3BhY2l0eSB2YWx1ZXMgdG8gdXNlIGZvciB0aGUgZmFkZSBlZmZlY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIGZhZGVQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wYWNpdHkgdG8gdXNlIHdoZW4gZmFkZWQgb3V0LlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmYWRlTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3BhY2l0eSB0byB1c2Ugd2hlbiBmYWRlZCBpbi5cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmFkZU1heDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBGYWRlIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICogQmUgc3VyZSB0byBtZXJnZSB0aGVzZSByZXR1cm5lZCBwcm9wcyB3aXRoIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBpbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNGYWRlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNaW4sIGZhZGVNYXggfSB9OiBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tZmFkZWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZhZGUtbWluYF06IChmYWRlTWluID8/IDApLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmFkZS1tYXhgXTogKGZhZGVNYXggPz8gMSksXHJcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZhZGVQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGYWRlIGVmZmVjdC5cclxuICogXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc3NpYmxlIHRvIHdyYXAgYW5vdGhlciB0cmFuc2l0aW9uIHdpdGggYDxGYWRlPmAsXHJcbiAqIHRoZXJlIHdpbGwgYmUgc29tZSBkdXBsaWNhdGUgY29kZSBydW4gYXMgdHdvIGA8VHJhbnNpdGlvbmFibGU+YCBjb21wb25lbnRzIGVuZCB1cCBvcGVyYXRpbmcgb24gdGhlIHNhbWUgZWxlbWVudC5cclxuICogSXQncyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgdG8gZWl0aGVyIHVzZSB0aGUgY29tcG9uZW50cyB0aGF0IGluY2x1ZGUgYSBjb21iaW5lZCBmYWRlIGVmZmVjdCxcclxuICogb3IganVzdCBkaXJlY3RseSBhIGA8VHJhbnNpdGlvbmFibGU+YCBvbiB5b3VyIG93bi5cclxuICogXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPih7IHJlZiwgLi4ucmVzdCB9LCB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBjbGlwUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE9yaWdpbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBjbGlwIGFyb3VuZCAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE9yaWdpbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBNaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gY2xpcCB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE1pbkJsb2NrOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzQ2xpcDxFIGV4dGVuZHMgRWxlbWVudD4oeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluQmxvY2ssIGNsaXBNaW5JbmxpbmUsIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5CbG9jaywgY2xpcE9yaWdpbklubGluZSB9IH06IFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcGApLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtb3JpZ2luLWlubGluZWBdOiAoY2xpcE9yaWdpbklubGluZSA/PyBjbGlwT3JpZ2luID8/IDAuNSksXHJcbiAgICAgICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY2xpcC1vcmlnaW4tYmxvY2tgXTogKGNsaXBPcmlnaW5CbG9jayA/PyBjbGlwT3JpZ2luID8/IDApLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtbWluLWlubGluZWBdOiAoY2xpcE1pbklubGluZSA/PyBjbGlwTWluID8/IDEpLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtbWluLWJsb2NrYF06IChjbGlwTWluQmxvY2sgPz8gY2xpcE1pbiA/PyAwKSxcclxuICAgICAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIH1cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbGlwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RT4sIFwiY2xpcFBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDbGlwID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jaywgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDbGlwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcblxyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ2xpcCh7IGNsaXBQYXJhbWV0ZXJzOiB7IGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbklubGluZSwgY2xpcE9yaWdpbkJsb2NrIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSlcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNDbGlwLCBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVycyB9IGZyb20gXCIuL2NsaXAuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENsaXBGYWRlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RT4sIFwiY2xpcFBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IENsaXBGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBDbGlwRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZGVsYXlNb3VudFVudGlsU2hvd24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGR1cmF0aW9uLCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgY2xpcE1pbiwgY2xpcE1pbkJsb2NrLCBjbGlwTWluSW5saW5lLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBPcmlnaW5JbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ2xpcEZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NsaXAoeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jayB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuXHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29sbGFwc2UgZWZmZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG5cclxuICAgIGNvbGxhcHNlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHNtYWxsZXN0IHNpemUgdGhlIGNvbXBvbmVudCBjb2xsYXBzZXMgdG8uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBtaW5CbG9ja1NpemU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgWm9vbSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqIFxyXG4gKiBJTVBPUlRBTlQ6IElmIHVzZWQgb3V0c2lkZSBvZiBhIGA8Q29sbGFwc2UgLz5gLCB5b3UgbXVzdCBpbmNsdWRlIHRoZSBgbWVhc3VyZWAgcHJvcCBvbiB0aGUgYDxUcmFuc2l0aW9uYWJsZT5gIHRoYXQgeW91IHVzZS5cclxuICogXHJcbiAqIEBleGFtcGxlIDxUcmFuc2l0aW9uYWJsZSBtZWFzdXJlIHsuLi51c2VDcmVhdGVDb2xsYXBzZVByb3BzKC4uLil9IC8+XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzQ29sbGFwc2U8RSBleHRlbmRzIEVsZW1lbnQ+KHsgY29sbGFwc2VQYXJhbWV0ZXJzOiB7IG1pbkJsb2NrU2l6ZSB9IH06IFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tY29sbGFwc2VgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jb2xsYXBzZS1taW4tYmxvY2tgXTogbWluQmxvY2tTaXplID8/IDBcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbGxhcHNlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEU+LCBcImNvbGxhcHNlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuLyoqXHJcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBDb2xsYXBzZSBlZmZlY3QuXHJcbiAqIFxyXG4gKiAqSW1wb3J0YW50KjogVGhpcyBjb21wb25lbnQgaXMgKm5vdCogZWZmaWNpZW50IGZvciB0aGUgYnJvd3NlciB0byBhbmltYXRlISBcclxuICogTWFrZSBzdXJlIHlvdSBkbyB0ZXN0aW5nIG9uIGxvd2VyIHBvd2VyIGRldmljZXMsIG9yIHByZWZlciBhIGxpZ2h0ZXJcclxuICogYWx0ZXJuYXRpdmUsIGxpa2UgYDxDbGlwPmAuXHJcbiAqIFxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2U8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHNob3csIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGR1cmF0aW9uLCBkZWxheU1vdW50VW50aWxTaG93biwgbWluQmxvY2tTaXplLCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBDb2xsYXBzZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ29sbGFwc2UoeyBjb2xsYXBzZVBhcmFtZXRlcnM6IHsgbWluQmxvY2tTaXplIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0NvbGxhcHNlLCBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jb2xsYXBzZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2xsYXBzZUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEU+LCBcImNvbGxhcHNlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IENvbGxhcHNlRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ29sbGFwc2VGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzaG93LCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBmYWRlTWluLCBmYWRlTWF4LCBleGl0VmlzaWJpbGl0eSwgbWluQmxvY2tTaXplLCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ29sbGFwc2VGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDb2xsYXBzZSh7IGNvbGxhcHNlUGFyYW1ldGVyczogeyBtaW5CbG9ja1NpemUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmLCB1c2VMYXN0Tm9uTnVsbFZhbHVlIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XG5cbi8qKlxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgZGlyZWN0aW9uIGFuZCBleHRlbnQgb2YgdGhlIGZsaXAgZWZmZWN0LiBcbiAqIFZhbHVlcyBhcmUgcmVsYXRpdmUsIHdpdGggMSBvciAtMSBiZWluZyB0aGUgc2l6ZSBvZiB0aGUgY29tcG9uZW50IGluIHRoYXQgZGlyZWN0aW9uLlxuICogYDAuNWAsIGZvciBleGFtcGxlLCB3b3VsZCBmbGlwIHRvIHRoZSByaWdodCBieSA1MCUgb2YgdGhlIGVsZW1lbnQncyB3aWR0aC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNGbGlwUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XG4gICAgZmxpcFBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgYW5nbGUgKGluIGRlZ3JlZXMpIHRvIHJvdGF0ZSB0b3dhcmRzIG9uIHRoZSBpbmxpbmUgYXhpcyAoWCBheGlzIGZvciBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcEFuZ2xlSW5saW5lOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGFuZ2xlIChpbiBkZWdyZWVzKSB0byByb3RhdGUgdG93YXJkcyBvbiB0aGUgYmxvY2sgYXhpcyAoWCBheGlzIGZvciBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcEFuZ2xlQmxvY2s6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmNlIHRoaXMgaXMgYSAzRCBlZmZlY3QsIGEgcGVyc3BlY3RpdmUgdmFsdWUgaXMgbmVlZGVkLlxuICAgICAgICAgKiBAZGVmYXVsdCA4MDBweFxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcFBlcnNwZWN0aXZlOiBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBGbGlwIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0ZsaXA8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZmxpcFBhcmFtZXRlcnM6IHsgZmxpcEFuZ2xlQmxvY2ssIGZsaXBBbmdsZUlubGluZSwgZmxpcFBlcnNwZWN0aXZlIH0gfTogVXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RT4pIHtcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWZsaXBgLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZsaXAtYW5nbGUtaW5saW5lYF06IGAkeyh1c2VMYXN0Tm9uTnVsbFZhbHVlKGZsaXBBbmdsZUlubGluZSkgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mbGlwLWFuZ2xlLWJsb2NrYF06IGAkeyh1c2VMYXN0Tm9uTnVsbFZhbHVlKGZsaXBBbmdsZUJsb2NrKSA/PyAwKX1kZWdgLFxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXBlcnNwZWN0aXZlYF06IGAkeyhmbGlwUGVyc3BlY3RpdmUgPz8gODAwKX1weGBcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZsaXBQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGbGlwUGFyYW1ldGVyczxFPiwgXCJmbGlwUGFyYW1ldGVyc1wiPj4geyB9O1xuXG4vKipcbiAqIFdyYXBzIGEgZGl2IChldGMuKSBhbmQgYWxsb3dzIGl0IHRvIHRyYW5zaXRpb24gaW4vb3V0IHNtb290aGx5IHdpdGggYSBGbGlwIGVmZmVjdC5cbiAqIFxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYGZsaXBJbmxpbmVgIGFuZCBgZmxpcEJsb2NrYCxcbiAqIHdpdGggYDFgIGJlaW5nIGAxMDAlYCBvZiB0aGUgZWxlbWVudCdzIHdpZHRoIG9yIGhlaWdodC5cbiAqIFxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcbiAqIGV4Y2x1c2l2aXR5S2V5IGFsbG93cyBmb3IgY29udmVuaWVudCBzZXR1cHMgaW5zaWRlIG9mIGEgYFN3YXBDb250YWluZXJgIFxuICogKGBmbGlwSW5saW5lPXtpbmRleCAtIHNlbGVjdGVkSW5kZXh9YCBvciBzaW1pbGFyLikgXG4gKiBcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxuICovXG5leHBvcnQgY29uc3QgRmxpcCA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gRmxpcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBBbmdsZUJsb2NrLCBmbGlwUGVyc3BlY3RpdmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IEZsaXBQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3csXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGVhc2luZ0luLFxuICAgICAgICAgICAgZWFzaW5nT3V0LFxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmxpcCh7IGZsaXBQYXJhbWV0ZXJzOiB7IGZsaXBBbmdsZUJsb2NrLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBQZXJzcGVjdGl2ZSB9IH0pLFxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXG4gICAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cbiAgICB9KTtcbn0pKTtcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiwgdXNlTGFzdE5vbk51bGxWYWx1ZSB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBhbmQgZXh0ZW50IG9mIHRoZSBzbGlkZSBlZmZlY3QuIFxyXG4gKiBWYWx1ZXMgYXJlIHJlbGF0aXZlLCB3aXRoIDEgb3IgLTEgYmVpbmcgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGF0IGRpcmVjdGlvbi5cclxuICogYDAuNWAsIGZvciBleGFtcGxlLCB3b3VsZCBzbGlkZSB0byB0aGUgcmlnaHQgYnkgNTAlIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBzbGlkZVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHNsaWRlIHRvL2Zyb20gKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2xpZGVUYXJnZXRJbmxpbmU6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gc2xpZGUgdG8vZnJvbSAoWSBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzbGlkZVRhcmdldEJsb2NrOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFNsaWRlIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNTbGlkZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2sgfSB9OiBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIHNsaWRlVGFyZ2V0SW5saW5lID0gdXNlTGFzdE5vbk51bGxWYWx1ZShzbGlkZVRhcmdldElubGluZSk7XHJcbiAgICBzbGlkZVRhcmdldEJsb2NrID0gdXNlTGFzdE5vbk51bGxWYWx1ZShzbGlkZVRhcmdldEJsb2NrKTtcclxuXHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1zbGlkZWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXNsaWRlLXRhcmdldC1pbmxpbmVgXTogYCR7KHNsaWRlVGFyZ2V0SW5saW5lID8/IDApfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1zbGlkZS10YXJnZXQtYmxvY2tgXTogYCR7KHNsaWRlVGFyZ2V0QmxvY2sgPz8gMCl9YFxyXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgU2xpZGUgZWZmZWN0LlxyXG4gKiBcclxuICogUHJvdmlkZSB0aGUgZGlyZWN0aW9uIHRoZSBlbGVtZW50IHdpbGwgdHJhdmVsIGluIHdpdGggYHNsaWRlSW5saW5lYCBhbmQgYHNsaWRlQmxvY2tgLFxyXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXHJcbiAqIFxyXG4gKiBBIHZhbHVlIG9mIGAwYCBpcyBoYW5kbGVkIHNwZWNpYWxseSwgZWZmZWN0aXZlbHkgbWVhbmluZyBcInVzZSB0aGUgbGFzdCBub24temVybyB2YWx1ZVwiLFxyXG4gKiB3aGljaCBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYCBcclxuICogKGBzbGlkZUlubGluZT17aW5kZXggLSBzZWxlY3RlZEluZGV4fWAgb3Igc2ltaWxhci4pIFxyXG4gKiBcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU2xpZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgb25WaXNpYmlsaXR5Q2hhbmdlLCBzbGlkZVRhcmdldElubGluZSwgc2xpZGVUYXJnZXRCbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBkZWxheU1vdW50VW50aWxTaG93biwgLi4ucmVzdCB9OiBTbGlkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1NsaWRlLCBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9zbGlkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IHVzZUNzc0NsYXNzZXMgfSBmcm9tIFwiLi91dGlsL2NvbnRleHQuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UsIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIG9yaWdpbiwgbWluaW11bSBzaXplLCBhbmQgZGlyZWN0aW9uIG9mIHRoZSB6b29tIGVmZmVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgem9vbVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gb3V0IG9mL2ludG8gKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU9yaWdpbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvIChYIGNvbXBvbmVudClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tT3JpZ2luSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHpvb20gb3V0IG9mL2ludG8gKFkgY29tcG9uZW50KVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21PcmlnaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKHdpdGggWCAmIFkgY29tcG9uZW50cyBpZGVudGljYWwpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tTWluOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIHNocmluayB0by9mcm9tLCBmcm9tIDAgdG8gMSAoWCBjb21wb25lbnQgaW4gaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU1pbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21NaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBab29tIHRyYW5zaXRpb24uIExpa2UgYWxsIGB1c2VDcmVhdGUqUHJvcHNgIGhvb2tzLCBtdXN0IGJlIHVzZWQgaW4gdGFtZGVtIHdpdGggYSBgVHJhbnNpdGlvbmFibGVgIGNvbXBvbmVudCAob3IgYHVzZUNyZWF0ZVRyYW5zaXRpb25hYmxlUHJvcHNgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNab29tPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21PcmlnaW4sIHpvb21PcmlnaW5JbmxpbmUsIHpvb21PcmlnaW5CbG9jaywgem9vbU1pbiwgem9vbU1pbklubGluZSwgem9vbU1pbkJsb2NrIH0gfTogVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS16b29tYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1vcmlnaW4taW5saW5lYF06IGAkeyh6b29tT3JpZ2luSW5saW5lID8/IHpvb21PcmlnaW4gPz8gMC41KX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1vcmlnaW4tYmxvY2tgXTogYCR7KHpvb21PcmlnaW5CbG9jayA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tbWluLWlubGluZWBdOiBgJHsoem9vbU1pbklubGluZSA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW1pbi1ibG9ja2BdOiBgJHsoem9vbU1pbkJsb2NrID8/IHpvb21NaW4gPz8gMCl9YCxcclxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBab29tUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgWm9vbSBlZmZlY3QuXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYCBgWm9vbUZhZGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgWm9vbSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogWm9vbVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG59KSk7XHJcblxyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1NsaWRlLCBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9zbGlkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc1pvb20sIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vem9vbS5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVpvb21Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNsaWRlWm9vbSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogU2xpZGVab29tUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVab29tRmFkZVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZVpvb21GYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZVpvb21GYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgem9vbU1pbiwgem9vbU1pbkJsb2NrLCB6b29tTWluSW5saW5lLCB6b29tT3JpZ2luLCB6b29tT3JpZ2luQmxvY2ssIHpvb21PcmlnaW5JbmxpbmUsIHNob3csIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUsIGZhZGVNYXgsIGZhZGVNaW4sIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogU2xpZGVab29tRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSxcclxuICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9vbUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnM8RT4sIFwiem9vbVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBab29tRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gWm9vbUZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBmYWRlTWluLCBmYWRlTWF4LCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFpvb21GYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzWm9vbSh7IHpvb21QYXJhbWV0ZXJzOiB7IHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IG9wdGlvbnMsIEZyYWdtZW50LCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdERldlRvb2xzKCkge1xuXHRpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19QUkVBQ1RfREVWVE9PTFNfXykge1xuXHRcdHdpbmRvdy5fX1BSRUFDVF9ERVZUT09MU19fLmF0dGFjaFByZWFjdCgnMTAuMTMuMScsIG9wdGlvbnMsIHtcblx0XHRcdEZyYWdtZW50LFxuXHRcdFx0Q29tcG9uZW50XG5cdFx0fSk7XG5cdH1cbn1cbiIsImNvbnN0IFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubGV0IGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBoaXN0b3J5IG9mIHdoaWNoIHByb3AgdHlwZSB3YXJuaW5ncyBoYXZlIGJlZW4gbG9nZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRQcm9wV2FybmluZ3MoKSB7XG5cdGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcHJvcC10eXBlcy9ibG9iL21hc3Rlci9jaGVja1Byb3BUeXBlcy5qc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMoXG5cdHR5cGVTcGVjcyxcblx0dmFsdWVzLFxuXHRsb2NhdGlvbixcblx0Y29tcG9uZW50TmFtZSxcblx0Z2V0U3RhY2tcbikge1xuXHRPYmplY3Qua2V5cyh0eXBlU3BlY3MpLmZvckVhY2godHlwZVNwZWNOYW1lID0+IHtcblx0XHRsZXQgZXJyb3I7XG5cdFx0dHJ5IHtcblx0XHRcdGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0oXG5cdFx0XHRcdHZhbHVlcyxcblx0XHRcdFx0dHlwZVNwZWNOYW1lLFxuXHRcdFx0XHRjb21wb25lbnROYW1lLFxuXHRcdFx0XHRsb2NhdGlvbixcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0UmVhY3RQcm9wVHlwZXNTZWNyZXRcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZXJyb3IgPSBlO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0XHRcdGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRgRmFpbGVkICR7bG9jYXRpb259IHR5cGU6ICR7ZXJyb3IubWVzc2FnZX0keyhnZXRTdGFjayAmJlxuXHRcdFx0XHRcdGBcXG4ke2dldFN0YWNrKCl9YCkgfHxcblx0XHRcdFx0XHQnJ31gXG5cdFx0XHQpO1xuXHRcdH1cblx0fSk7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogR2V0IGh1bWFuIHJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC9kb20gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUodm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG5cdFx0cmV0dXJuICdGcmFnbWVudCc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiB2bm9kZS50eXBlLmRpc3BsYXlOYW1lIHx8IHZub2RlLnR5cGUubmFtZTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB2bm9kZS50eXBlO1xuXHR9XG5cblx0cmV0dXJuICcjdGV4dCc7XG59XG5cbi8qKlxuICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgYHZub2RlYCBhbmQgcHJpbnQgaXRcbiAqIGluIGRlYnVnIG1lc3NhZ2VzLlxuICovXG5sZXQgcmVuZGVyU3RhY2sgPSBbXTtcblxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVycy4gQW4gb3duZXIgZGVzY3JpYmVzIGEgY29tcG9uZW50XG4gKiB3aGljaCB3YXMgcmVzcG9uc2libGUgdG8gcmVuZGVyIGEgc3BlY2lmaWMgYHZub2RlYC4gVGhpcyBleGNsdWRlXG4gKiBjaGlsZHJlbiB0aGF0IGFyZSBwYXNzZWQgdmlhIGBwcm9wcy5jaGlsZHJlbmAsIGJlY2F1c2UgdGhleSBiZWxvbmdcbiAqIHRvIHRoZSBwYXJlbnQgb3duZXIuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBGb28gPSBwcm9wcyA9PiA8ZGl2Pntwcm9wcy5jaGlsZHJlbn08L2Rpdj4gLy8gZGl2J3Mgb3duZXIgaXMgRm9vXG4gKiBjb25zdCBCYXIgPSBwcm9wcyA9PiB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvbz48c3BhbiAvPjwvRm9vPiAvLyBGb28ncyBvd25lciBpcyBCYXIsIHNwYW4ncyBvd25lciBpcyBCYXJcbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogTm90ZTogQSBgdm5vZGVgIG1heSBiZSBob2lzdGVkIHRvIHRoZSByb290IHNjb3BlIGR1ZSB0byBjb21waWxlclxuICogb3B0aW1penRpb25zLiBJbiB0aGVzZSBjYXNlcyB0aGUgYF9vd25lcmAgd2lsbCBiZSBkaWZmZXJlbnQuXG4gKi9cbmxldCBvd25lclN0YWNrID0gW107XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgYHZub2RlYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRWTm9kZSgpIHtcblx0cmV0dXJuIHJlbmRlclN0YWNrLmxlbmd0aCA+IDAgPyByZW5kZXJTdGFja1tyZW5kZXJTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG59XG5cbi8qKlxuICogSWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIGBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gtc291cmNlYFxuICogc29tZXdoZXJlIGluIGhpcyB0b29sIGNoYWluIHdlIGNhbid0IHByaW50IHRoZSBmaWxlbmFtZSBhbmQgc291cmNlXG4gKiBsb2NhdGlvbiBvZiBhIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIGp1c3Qgb21pdCB0aGF0LCBidXQgd2UnbGxcbiAqIHByaW50IGEgaGVscGZ1bCBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLCBub3RpZnlpbmcgdGhlIHVzZXIgb2YgaXQuXG4gKi9cbmxldCBoYXNCYWJlbFBsdWdpbiA9IGZhbHNlO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYHZub2RlYCBpcyBhIHBvc3NpYmxlIG93bmVyLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gaXNQb3NzaWJsZU93bmVyKHZub2RlKSB7XG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmIHZub2RlLnR5cGUgIT0gRnJhZ21lbnQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb21wb25lbnQgc3RhY2sgdGhhdCB3YXMgY2FwdHVyZWQgdXAgdG8gdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJTdGFjayh2bm9kZSkge1xuXHRjb25zdCBzdGFjayA9IFt2bm9kZV07XG5cdGxldCBuZXh0ID0gdm5vZGU7XG5cdHdoaWxlIChuZXh0Ll9vd25lciAhPSBudWxsKSB7XG5cdFx0c3RhY2sucHVzaChuZXh0Ll9vd25lcik7XG5cdFx0bmV4dCA9IG5leHQuX293bmVyO1xuXHR9XG5cblx0cmV0dXJuIHN0YWNrLnJlZHVjZSgoYWNjLCBvd25lcikgPT4ge1xuXHRcdGFjYyArPSBgICBpbiAke2dldERpc3BsYXlOYW1lKG93bmVyKX1gO1xuXG5cdFx0Y29uc3Qgc291cmNlID0gb3duZXIuX19zb3VyY2U7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0YWNjICs9IGAgKGF0ICR7c291cmNlLmZpbGVOYW1lfToke3NvdXJjZS5saW5lTnVtYmVyfSlgO1xuXHRcdH0gZWxzZSBpZiAoIWhhc0JhYmVsUGx1Z2luKSB7XG5cdFx0XHRoYXNCYWJlbFBsdWdpbiA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdBZGQgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcmVhY3QtanN4LXNvdXJjZSB0byBnZXQgYSBtb3JlIGRldGFpbGVkIGNvbXBvbmVudCBzdGFjay4gTm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IGFkZCBpdCB0byBwcm9kdWN0aW9uIGJ1aWxkcyBvZiB5b3VyIEFwcCBmb3IgYnVuZGxlIHNpemUgcmVhc29ucy4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoYWNjICs9ICdcXG4nKTtcblx0fSwgJycpO1xufVxuXG4vKipcbiAqIFNldHVwIGNvZGUgdG8gY2FwdHVyZSB0aGUgY29tcG9uZW50IHRyYWNlIHdoaWxlIHJlbmRlcmluZy4gTm90ZSB0aGF0XG4gKiB3ZSBjYW5ub3Qgc2ltcGx5IHRyYXZlcnNlIGB2bm9kZS5fcGFyZW50YCB1cHdhcmRzLCBiZWNhdXNlIHdlIGhhdmUgc29tZVxuICogZGVidWcgbWVzc2FnZXMgZm9yIGB0aGlzLnNldFN0YXRlYCB3aGVyZSB0aGUgYHZub2RlYCBpcyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQ29tcG9uZW50U3RhY2soKSB7XG5cdGxldCBvbGREaWZmID0gb3B0aW9ucy5fZGlmZjtcblx0bGV0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuXHRsZXQgb2xkUm9vdCA9IG9wdGlvbnMuX3Jvb3Q7XG5cdGxldCBvbGRWTm9kZSA9IG9wdGlvbnMudm5vZGU7XG5cdGxldCBvbGRSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5cblx0b3B0aW9ucy5kaWZmZWQgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdG93bmVyU3RhY2sucG9wKCk7XG5cdFx0fVxuXHRcdHJlbmRlclN0YWNrLnBvcCgpO1xuXHRcdGlmIChvbGREaWZmZWQpIG9sZERpZmZlZCh2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0XHRpZiAoaXNQb3NzaWJsZU93bmVyKHZub2RlKSkge1xuXHRcdFx0cmVuZGVyU3RhY2sucHVzaCh2bm9kZSk7XG5cdFx0fVxuXHRcdGlmIChvbGREaWZmKSBvbGREaWZmKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9yb290ID0gKHZub2RlLCBwYXJlbnQpID0+IHtcblx0XHRvd25lclN0YWNrID0gW107XG5cdFx0aWYgKG9sZFJvb3QpIG9sZFJvb3Qodm5vZGUsIHBhcmVudCk7XG5cdH07XG5cblx0b3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0XHR2bm9kZS5fb3duZXIgPVxuXHRcdFx0b3duZXJTdGFjay5sZW5ndGggPiAwID8gb3duZXJTdGFja1tvd25lclN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcblx0XHRpZiAob2xkVk5vZGUpIG9sZFZOb2RlKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdG93bmVyU3RhY2sucHVzaCh2bm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFJlbmRlcikgb2xkUmVuZGVyKHZub2RlKTtcblx0fTtcbn1cbiIsImltcG9ydCB7IGNoZWNrUHJvcFR5cGVzIH0gZnJvbSAnLi9jaGVjay1wcm9wcyc7XG5pbXBvcnQgeyBvcHRpb25zLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcblx0RUxFTUVOVF9OT0RFLFxuXHRET0NVTUVOVF9OT0RFLFxuXHRET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdGdldE93bmVyU3RhY2ssXG5cdHNldHVwQ29tcG9uZW50U3RhY2ssXG5cdGdldEN1cnJlbnRWTm9kZSxcblx0Z2V0RGlzcGxheU5hbWVcbn0gZnJvbSAnLi9jb21wb25lbnQtc3RhY2snO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgaXNXZWFrTWFwU3VwcG9ydGVkID0gdHlwZW9mIFdlYWtNYXAgPT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQocGFyZW50KSB7XG5cdGlmICghcGFyZW50KSByZXR1cm4ge307XG5cdGlmICh0eXBlb2YgcGFyZW50LnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBnZXRDbG9zZXN0RG9tTm9kZVBhcmVudChwYXJlbnQuX3BhcmVudCk7XG5cdH1cblx0cmV0dXJuIHBhcmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXREZWJ1ZygpIHtcblx0c2V0dXBDb21wb25lbnRTdGFjaygpO1xuXG5cdGxldCBob29rc0FsbG93ZWQgPSBmYWxzZTtcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdGxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcblx0bGV0IG9sZERpZmZlZCA9IG9wdGlvbnMuZGlmZmVkO1xuXHRsZXQgb2xkVm5vZGUgPSBvcHRpb25zLnZub2RlO1xuXHRsZXQgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5cdGxldCBvbGRSb290ID0gb3B0aW9ucy5fcm9vdDtcblx0bGV0IG9sZEhvb2sgPSBvcHRpb25zLl9ob29rO1xuXHRjb25zdCB3YXJuZWRDb21wb25lbnRzID0gIWlzV2Vha01hcFN1cHBvcnRlZFxuXHRcdD8gbnVsbFxuXHRcdDoge1xuXHRcdFx0XHR1c2VFZmZlY3Q6IG5ldyBXZWFrTWFwKCksXG5cdFx0XHRcdHVzZUxheW91dEVmZmVjdDogbmV3IFdlYWtNYXAoKSxcblx0XHRcdFx0bGF6eVByb3BUeXBlczogbmV3IFdlYWtNYXAoKVxuXHRcdCAgfTtcblx0Y29uc3QgZGVwcmVjYXRpb25zID0gW107XG5cblx0b3B0aW9ucy5fY2F0Y2hFcnJvciA9IChlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pID0+IHtcblx0XHRsZXQgY29tcG9uZW50ID0gdm5vZGUgJiYgdm5vZGUuX2NvbXBvbmVudDtcblx0XHRpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBlcnJvci50aGVuID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnN0IHByb21pc2UgPSBlcnJvcjtcblx0XHRcdGVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRgTWlzc2luZyBTdXNwZW5zZS4gVGhlIHRocm93aW5nIGNvbXBvbmVudCB3YXM6ICR7Z2V0RGlzcGxheU5hbWUodm5vZGUpfWBcblx0XHRcdCk7XG5cblx0XHRcdGxldCBwYXJlbnQgPSB2bm9kZTtcblx0XHRcdGZvciAoOyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQuX2NvbXBvbmVudCAmJiBwYXJlbnQuX2NvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBwcm9taXNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGhhdmVuJ3QgcmVjb3ZlcmVkIGFuZCB3ZSBrbm93IGF0IHRoaXMgcG9pbnQgdGhhdCB0aGVyZSBpcyBub1xuXHRcdFx0Ly8gU3VzcGVuc2UgY29tcG9uZW50IGhpZ2hlciB1cCBpbiB0aGUgdHJlZVxuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGVycm9ySW5mbyA9IGVycm9ySW5mbyB8fCB7fTtcblx0XHRcdGVycm9ySW5mby5jb21wb25lbnRTdGFjayA9IGdldE93bmVyU3RhY2sodm5vZGUpO1xuXHRcdFx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xuXG5cdFx0XHQvLyB3aGVuIGFuIGVycm9yIHdhcyBoYW5kbGVkIGJ5IGFuIEVycm9yQm91bmRhcnkgd2Ugd2lsbCBub25ldGhlbGVzcyBlbWl0IGFuIGVycm9yXG5cdFx0XHQvLyBldmVudCBvbiB0aGUgd2luZG93IG9iamVjdC4gVGhpcyBpcyB0byBtYWtlIHVwIGZvciByZWFjdCBjb21wYXRpYmlsaXR5IGluIGRldiBtb2RlXG5cdFx0XHQvLyBhbmQgdGh1cyBtYWtlIHRoZSBOZXh0LmpzIGRldiBvdmVybGF5IHdvcmsuXG5cdFx0XHRpZiAodHlwZW9mIGVycm9yLnRoZW4gIT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH07XG5cblx0b3B0aW9ucy5fcm9vdCA9ICh2bm9kZSwgcGFyZW50Tm9kZSkgPT4ge1xuXHRcdGlmICghcGFyZW50Tm9kZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnVW5kZWZpbmVkIHBhcmVudCBwYXNzZWQgdG8gcmVuZGVyKCksIHRoaXMgaXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG4nICtcblx0XHRcdFx0XHQnQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYXZhaWxhYmxlIGluIHRoZSBET00vaGFzIHRoZSBjb3JyZWN0IGlkLidcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGlzVmFsaWQ7XG5cdFx0c3dpdGNoIChwYXJlbnROb2RlLm5vZGVUeXBlKSB7XG5cdFx0XHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHRcdGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcblx0XHRcdGNhc2UgRE9DVU1FTlRfTk9ERTpcblx0XHRcdFx0aXNWYWxpZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghaXNWYWxpZCkge1xuXHRcdFx0bGV0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZSh2bm9kZSk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBFeHBlY3RlZCBhIHZhbGlkIEhUTUwgbm9kZSBhcyBhIHNlY29uZCBhcmd1bWVudCB0byByZW5kZXIuXHRSZWNlaXZlZCAke3BhcmVudE5vZGV9IGluc3RlYWQ6IHJlbmRlcig8JHtjb21wb25lbnROYW1lfSAvPiwgJHtwYXJlbnROb2RlfSk7YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkUm9vdCkgb2xkUm9vdCh2bm9kZSwgcGFyZW50Tm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0XHRsZXQgeyB0eXBlLCBfcGFyZW50OiBwYXJlbnQgfSA9IHZub2RlO1xuXHRcdGxldCBwYXJlbnRWTm9kZSA9IGdldENsb3Nlc3REb21Ob2RlUGFyZW50KHBhcmVudCk7XG5cblx0XHRob29rc0FsbG93ZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnVW5kZWZpbmVkIGNvbXBvbmVudCBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCgpXFxuXFxuJyArXG5cdFx0XHRcdFx0J1lvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBvciBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMnICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICh0eXBlLl9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHR5cGUuX2RvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRgSW52YWxpZCB0eXBlIHBhc3NlZCB0byBjcmVhdGVFbGVtZW50KCk6ICR7dHlwZX1cXG5cXG5gICtcblx0XHRcdFx0XHRcdCdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgSlNYIGxpdGVyYWwgYXMgSlNYIHR3aWNlP1xcblxcbicgK1xuXHRcdFx0XHRcdFx0YCAgbGV0IE15JHtnZXREaXNwbGF5TmFtZSh2bm9kZSl9ID0gJHtzZXJpYWxpemVWTm9kZSh0eXBlKX07XFxuYCArXG5cdFx0XHRcdFx0XHRgICBsZXQgdm5vZGUgPSA8TXkke2dldERpc3BsYXlOYW1lKHZub2RlKX0gLz47XFxuXFxuYCArXG5cdFx0XHRcdFx0XHQnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiB5b3UgZXhwb3J0IGEgSlNYIGxpdGVyYWwgYW5kIG5vdCB0aGUgY29tcG9uZW50LicgK1xuXHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdJbnZhbGlkIHR5cGUgcGFzc2VkIHRvIGNyZWF0ZUVsZW1lbnQoKTogJyArXG5cdFx0XHRcdFx0KEFycmF5LmlzQXJyYXkodHlwZSkgPyAnYXJyYXknIDogdHlwZSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0KHR5cGUgPT09ICd0aGVhZCcgfHwgdHlwZSA9PT0gJ3Rmb290JyB8fCB0eXBlID09PSAndGJvZHknKSAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RhYmxlJ1xuXHRcdCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRoZWFkL3Rib2R5L3Rmb290PiBzaG91bGQgaGF2ZSBhIDx0YWJsZT4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dHlwZSA9PT0gJ3RyJyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RoZWFkJyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3Rmb290JyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3Rib2R5JyAmJlxuXHRcdFx0cGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RhYmxlJ1xuXHRcdCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRyPiBzaG91bGQgaGF2ZSBhIDx0aGVhZC90Ym9keS90Zm9vdC90YWJsZT4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZCcgJiYgcGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RyJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRkPiBzaG91bGQgaGF2ZSBhIDx0cj4gcGFyZW50LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0aCcgJiYgcGFyZW50Vk5vZGUudHlwZSAhPT0gJ3RyJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0J0ltcHJvcGVyIG5lc3Rpbmcgb2YgdGFibGUuIFlvdXIgPHRoPiBzaG91bGQgaGF2ZSBhIDx0cj4uJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdHZub2RlLnJlZiAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHR0eXBlb2Ygdm5vZGUucmVmICE9ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiB2bm9kZS5yZWYgIT0gJ29iamVjdCcgJiZcblx0XHRcdCEoJyQkdHlwZW9mJyBpbiB2bm9kZSkgLy8gYWxsb3cgc3RyaW5nIHJlZnMgd2hlbiBwcmVhY3QtY29tcGF0IGlzIGluc3RhbGxlZFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgQ29tcG9uZW50J3MgXCJyZWZcIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IGNyZWF0ZWQgYCArXG5cdFx0XHRcdFx0YGJ5IGNyZWF0ZVJlZigpLCBidXQgZ290IFske3R5cGVvZiB2bm9kZS5yZWZ9XSBpbnN0ZWFkXFxuYCArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdm5vZGUucHJvcHMpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGtleVswXSA9PT0gJ28nICYmXG5cdFx0XHRcdFx0a2V5WzFdID09PSAnbicgJiZcblx0XHRcdFx0XHR0eXBlb2Ygdm5vZGUucHJvcHNba2V5XSAhPSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdFx0dm5vZGUucHJvcHNba2V5XSAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdGBDb21wb25lbnQncyBcIiR7a2V5fVwiIHByb3BlcnR5IHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBgICtcblx0XHRcdFx0XHRcdFx0YGJ1dCBnb3QgWyR7dHlwZW9mIHZub2RlLnByb3BzW2tleV19XSBpbnN0ZWFkXFxuYCArXG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgcHJvcC10eXBlcyBpZiBhdmFpbGFibGVcblx0XHRpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB2bm9kZS50eXBlLnByb3BUeXBlcykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR2bm9kZS50eXBlLmRpc3BsYXlOYW1lID09PSAnTGF6eScgJiZcblx0XHRcdFx0d2FybmVkQ29tcG9uZW50cyAmJlxuXHRcdFx0XHQhd2FybmVkQ29tcG9uZW50cy5sYXp5UHJvcFR5cGVzLmhhcyh2bm9kZS50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IG0gPVxuXHRcdFx0XHRcdCdQcm9wVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gbGF6eSgpLiBVc2UgcHJvcFR5cGVzIG9uIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpdHNlbGYuICc7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgbGF6eVZOb2RlID0gdm5vZGUudHlwZSgpO1xuXHRcdFx0XHRcdHdhcm5lZENvbXBvbmVudHMubGF6eVByb3BUeXBlcy5zZXQodm5vZGUudHlwZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0bSArIGBDb21wb25lbnQgd3JhcHBlZCBpbiBsYXp5KCkgaXMgJHtnZXREaXNwbGF5TmFtZShsYXp5Vk5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGNhdGNoIChwcm9taXNlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdFx0bSArIFwiV2Ugd2lsbCBsb2cgdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgbmFtZSBvbmNlIGl0IGlzIGxvYWRlZC5cIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHZhbHVlcyA9IHZub2RlLnByb3BzO1xuXHRcdFx0aWYgKHZub2RlLnR5cGUuX2ZvcndhcmRlZCkge1xuXHRcdFx0XHR2YWx1ZXMgPSBhc3NpZ24oe30sIHZhbHVlcyk7XG5cdFx0XHRcdGRlbGV0ZSB2YWx1ZXMucmVmO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja1Byb3BUeXBlcyhcblx0XHRcdFx0dm5vZGUudHlwZS5wcm9wVHlwZXMsXG5cdFx0XHRcdHZhbHVlcyxcblx0XHRcdFx0J3Byb3AnLFxuXHRcdFx0XHRnZXREaXNwbGF5TmFtZSh2bm9kZSksXG5cdFx0XHRcdCgpID0+IGdldE93bmVyU3RhY2sodm5vZGUpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLl9ob29rID0gKGNvbXAsIGluZGV4LCB0eXBlKSA9PiB7XG5cdFx0aWYgKCFjb21wIHx8ICFob29rc0FsbG93ZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSG9vayBjYW4gb25seSBiZSBpbnZva2VkIGZyb20gcmVuZGVyIG1ldGhvZHMuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZEhvb2spIG9sZEhvb2soY29tcCwgaW5kZXgsIHR5cGUpO1xuXHR9O1xuXG5cdC8vIElkZWFsbHkgd2UnZCB3YW50IHRvIHByaW50IGEgd2FybmluZyBvbmNlIHBlciBjb21wb25lbnQsIGJ1dCB3ZVxuXHQvLyBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgdm5vZGUgdGhhdCB0cmlnZ2VyZWQgaXQgaGVyZS4gQXMgYVxuXHQvLyBjb21wcm9taXNlIGFuZCB0byBhdm9pZCBmbG9vZGluZyB0aGUgY29uc29sZSB3aXRoIHdhcm5pbmdzIHdlXG5cdC8vIHByaW50IGVhY2ggZGVwcmVjYXRpb24gd2FybmluZyBvbmx5IG9uY2UuXG5cdGNvbnN0IHdhcm4gPSAocHJvcGVydHksIG1lc3NhZ2UpID0+ICh7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qga2V5ID0gJ2dldCcgKyBwcm9wZXJ0eSArIG1lc3NhZ2U7XG5cdFx0XHRpZiAoZGVwcmVjYXRpb25zICYmIGRlcHJlY2F0aW9ucy5pbmRleE9mKGtleSkgPCAwKSB7XG5cdFx0XHRcdGRlcHJlY2F0aW9ucy5wdXNoKGtleSk7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgZ2V0dGluZyB2bm9kZS4ke3Byb3BlcnR5fSBpcyBkZXByZWNhdGVkLCAke21lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXQoKSB7XG5cdFx0XHRjb25zdCBrZXkgPSAnc2V0JyArIHByb3BlcnR5ICsgbWVzc2FnZTtcblx0XHRcdGlmIChkZXByZWNhdGlvbnMgJiYgZGVwcmVjYXRpb25zLmluZGV4T2Yoa2V5KSA8IDApIHtcblx0XHRcdFx0ZGVwcmVjYXRpb25zLnB1c2goa2V5KTtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBzZXR0aW5nIHZub2RlLiR7cHJvcGVydHl9IGlzIG5vdCBhbGxvd2VkLCAke21lc3NhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRjb25zdCBkZXByZWNhdGVkQXR0cmlidXRlcyA9IHtcblx0XHRub2RlTmFtZTogd2Fybignbm9kZU5hbWUnLCAndXNlIHZub2RlLnR5cGUnKSxcblx0XHRhdHRyaWJ1dGVzOiB3YXJuKCdhdHRyaWJ1dGVzJywgJ3VzZSB2bm9kZS5wcm9wcycpLFxuXHRcdGNoaWxkcmVuOiB3YXJuKCdjaGlsZHJlbicsICd1c2Ugdm5vZGUucHJvcHMuY2hpbGRyZW4nKVxuXHR9O1xuXG5cdGNvbnN0IGRlcHJlY2F0ZWRQcm90byA9IE9iamVjdC5jcmVhdGUoe30sIGRlcHJlY2F0ZWRBdHRyaWJ1dGVzKTtcblxuXHRvcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRcdGNvbnN0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdFx0aWYgKFxuXHRcdFx0dm5vZGUudHlwZSAhPT0gbnVsbCAmJlxuXHRcdFx0cHJvcHMgIT0gbnVsbCAmJlxuXHRcdFx0KCdfX3NvdXJjZScgaW4gcHJvcHMgfHwgJ19fc2VsZicgaW4gcHJvcHMpXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBuZXdQcm9wcyA9ICh2bm9kZS5wcm9wcyA9IHt9KTtcblx0XHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdFx0Y29uc3QgdiA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAoaSA9PT0gJ19fc291cmNlJykgdm5vZGUuX19zb3VyY2UgPSB2O1xuXHRcdFx0XHRlbHNlIGlmIChpID09PSAnX19zZWxmJykgdm5vZGUuX19zZWxmID0gdjtcblx0XHRcdFx0ZWxzZSBuZXdQcm9wc1tpXSA9IHY7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdFx0dm5vZGUuX19wcm90b19fID0gZGVwcmVjYXRlZFByb3RvO1xuXHRcdGlmIChvbGRWbm9kZSkgb2xkVm5vZGUodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRcdC8vIENoZWNrIGlmIHRoZSB1c2VyIHBhc3NlZCBwbGFpbiBvYmplY3RzIGFzIGNoaWxkcmVuLiBOb3RlIHRoYXQgd2UgY2Fubm90XG5cdFx0Ly8gbW92ZSB0aGlzIGNoZWNrIGludG8gYG9wdGlvbnMudm5vZGVgIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gcmVjZWl2ZVxuXHRcdC8vIGNoaWxkcmVuIGluIGFueSBzaGFwZSB0aGV5IHdhbnQgKGUuZy5cblx0XHQvLyBgPE15SlNPTkZvcm1hdHRlcj57eyBmb286IDEyMywgYmFyOiBcImFiY1wiIH19PC9NeUpTT05Gb3JtYXR0ZXI+YCkuXG5cdFx0Ly8gUHV0dGluZyB0aGlzIGNoZWNrIGluIGBvcHRpb25zLmRpZmZlZGAgZW5zdXJlcyB0aGF0XG5cdFx0Ly8gYHZub2RlLl9jaGlsZHJlbmAgaXMgc2V0IGFuZCB0aGF0IHdlIG9ubHkgdmFsaWRhdGUgdGhlIGNoaWxkcmVuXG5cdFx0Ly8gdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHRcdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQgJiYgY2hpbGQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkKS5qb2luKCcsJyk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0YE9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIGNoaWxkLiBFbmNvdW50ZXJlZCBhbiBvYmplY3Qgd2l0aCB0aGUga2V5cyB7JHtrZXlzfX0uYCArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRob29rc0FsbG93ZWQgPSBmYWxzZTtcblxuXHRcdGlmIChvbGREaWZmZWQpIG9sZERpZmZlZCh2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2NoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGNvbnN0IGtleXMgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoIWNoaWxkIHx8IGNoaWxkLmtleSA9PSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG5cdFx0XHRcdGlmIChrZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcdFx0J0ZvbGxvd2luZyBjb21wb25lbnQgaGFzIHR3byBvciBtb3JlIGNoaWxkcmVuIHdpdGggdGhlICcgK1xuXHRcdFx0XHRcdFx0XHRgc2FtZSBrZXkgYXR0cmlidXRlOiBcIiR7a2V5fVwiLiBUaGlzIG1heSBjYXVzZSBnbGl0Y2hlcyBhbmQgbWlzYmVoYXZpb3IgYCArXG5cdFx0XHRcdFx0XHRcdCdpbiByZW5kZXJpbmcgcHJvY2Vzcy4gQ29tcG9uZW50OiBcXG5cXG4nICtcblx0XHRcdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBCcmVhayBlYXJseSB0byBub3Qgc3BhbSB0aGUgY29uc29sZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBzZXRTdGF0ZSA9IENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGU7XG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUgPT0gbnVsbCkge1xuXHRcdC8vIGB0aGlzLl92bm9kZWAgd2lsbCBiZSBgbnVsbGAgZHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudC4gQnV0IGl0XG5cdFx0Ly8gaXMgcGVyZmVjdGx5IHZhbGlkIHRvIGNhbGwgYHNldFN0YXRlYCBkdXJpbmcgY1dNLiBTbyB3ZVxuXHRcdC8vIG5lZWQgYW4gYWRkaXRpb25hbCBjaGVjayB0byB2ZXJpZnkgdGhhdCB3ZSBhcmUgZGVhbGluZyB3aXRoIGFcblx0XHQvLyBjYWxsIGluc2lkZSBjb25zdHJ1Y3Rvci5cblx0XHRpZiAodGhpcy5zdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdGBDYWxsaW5nIFwidGhpcy5zZXRTdGF0ZVwiIGluc2lkZSB0aGUgY29uc3RydWN0b3Igb2YgYSBjb21wb25lbnQgaXMgYSBgICtcblx0XHRcdFx0XHRgbm8tb3AgYW5kIG1pZ2h0IGJlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIHNldCBgICtcblx0XHRcdFx0XHRgXCJ0aGlzLnN0YXRlID0ge31cIiBkaXJlY3RseS5cXG5cXG4ke2dldE93bmVyU3RhY2soZ2V0Q3VycmVudFZOb2RlKCkpfWBcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNldFN0YXRlLmNhbGwodGhpcywgdXBkYXRlLCBjYWxsYmFjayk7XG59O1xuXG5jb25zdCBmb3JjZVVwZGF0ZSA9IENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGU7XG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlID09IG51bGwpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgQ2FsbGluZyBcInRoaXMuZm9yY2VVcGRhdGVcIiBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGEgY29tcG9uZW50IGlzIGEgYCArXG5cdFx0XHRcdGBuby1vcCBhbmQgbWlnaHQgYmUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi5cXG5cXG4ke2dldE93bmVyU3RhY2soXG5cdFx0XHRcdFx0Z2V0Q3VycmVudFZOb2RlKClcblx0XHRcdFx0KX1gXG5cdFx0KTtcblx0fSBlbHNlIGlmICh0aGlzLl9wYXJlbnREb20gPT0gbnVsbCkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGBDYW4ndCBjYWxsIFwidGhpcy5mb3JjZVVwZGF0ZVwiIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcCwgYCArXG5cdFx0XHRcdGBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gZml4LCBjYW5jZWwgYWxsIGAgK1xuXHRcdFx0XHRgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuYCArXG5cdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodGhpcy5fdm5vZGUpfWBcblx0XHQpO1xuXHR9XG5cdHJldHVybiBmb3JjZVVwZGF0ZS5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgdm5vZGUgdHJlZSB0byBhIHN0cmluZ1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVWTm9kZSh2bm9kZSkge1xuXHRsZXQgeyBwcm9wcyB9ID0gdm5vZGU7XG5cdGxldCBuYW1lID0gZ2V0RGlzcGxheU5hbWUodm5vZGUpO1xuXG5cdGxldCBhdHRycyA9ICcnO1xuXHRmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG5cdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdjaGlsZHJlbicpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG5cdFx0XHQvLyBJZiBpdCBpcyBhbiBvYmplY3QgYnV0IGRvZXNuJ3QgaGF2ZSB0b1N0cmluZygpLCB1c2UgT2JqZWN0LnRvU3RyaW5nXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSBgZnVuY3Rpb24gJHt2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lfSgpIHt9YDtcblx0XHRcdH1cblxuXHRcdFx0dmFsdWUgPVxuXHRcdFx0XHRPYmplY3QodmFsdWUpID09PSB2YWx1ZSAmJiAhdmFsdWUudG9TdHJpbmdcblx0XHRcdFx0XHQ/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHZhbHVlICsgJyc7XG5cblx0XHRcdGF0dHJzICs9IGAgJHtwcm9wfT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuXHRcdH1cblx0fVxuXG5cdGxldCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXHRyZXR1cm4gYDwke25hbWV9JHthdHRyc30ke1xuXHRcdGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/ICc+Li48LycgKyBuYW1lICsgJz4nIDogJyAvPidcblx0fWA7XG59XG4iLCJleHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gOTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG4iLCJpbXBvcnQgeyBpbml0RGVidWcgfSBmcm9tICcuL2RlYnVnJztcbmltcG9ydCAncHJlYWN0L2RldnRvb2xzJztcblxuaW5pdERlYnVnKCk7XG5cbmV4cG9ydCB7IHJlc2V0UHJvcFdhcm5pbmdzIH0gZnJvbSAnLi9jaGVjay1wcm9wcyc7XG4iLCJpbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFJlbGF0aXZlbHkgbG93LWxldmVsIGhvb2sgdGhhdCBhbGxvd3MgeW91IHRvIGluc3BlY3RcbiAqIHdoZW4gdGhlIGVudGlyZSBVUkwgY2hhbmdlcywgZWl0aGVyIGJlY2F1c2UgdGhlIGhhc2ggY2hhbmdlZCxcbiAqIG9yIGJlY2F1c2UgdGhlIEJhY2svRm9yd2FyZCBicm93c2VyIGJ1dHRvbnMgd2VyZSBwcmVzc2VkLlxuICogXG4gKiAoQ2hhbmdpbmcgcXVlcnkgcGFyYW1ldGVycyByZWxvYWRzIHRoZSBwYWdlIGFuZCBzbyBpc24ndFxuICogdHJhY2tlZCwgdW5sZXNzIG9mIGNvdXJzZSBpdCdzIGJlY2F1c2Ugb2YgdGhlIGJyb3dzZXJcbiAqIG5hdmlnYXRpbmcgYmFjay9mb3J3YXJkcykuXG4gKiBcbiAqIEluIGdlbmVyYWwsIHlvdSdsbCB3YW50IHRvIGluc3BlY3QgYSBzcGVjaWZpYyBkaXJlY3Rvcnkgb2ZcbiAqIGEgcGF0aCwgb3IgYSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXIgdmFsdWUsIG5vdCB0aGVcbiAqIGVudGlyZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcmwob25VcmxDaGFuZ2U6ICh1cmw6IHN0cmluZykgPT4gdm9pZCkge1xuXG4gICAgY29uc3QgW2dldFVybCwgc2V0VXJsXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhvblVybENoYW5nZSksIHVzZUNhbGxiYWNrKCgpID0+IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLCBbXSkpO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCBlID0+IHtcbiAgICAgICAgc2V0VXJsKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInBvcHN0YXRlXCIsIChlOiBQb3BTdGF0ZUV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvcG9wc3RhdGVfZXZlbnQjdGhlX2hpc3Rvcnlfc3RhY2tcbiAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBhc3NlcnQgbmV2ZXIgZmlyZXMsIGl0J3MgKnByb2JhYmx5KiBmaW5lPz9cbiAgICAgICAgY29uc29sZS5hc3NlcnQod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkgPT09IGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICBzZXRVcmwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtnZXRVcmwsIHNldFVybF0gYXMgY29uc3Q7XG59XG5cblxuIiwiaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5cblxuLy9leHBvcnQgY29uc3QgUm91dGVyTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gdHJpbSB0aGUgY3J1c3RzIG9mZiBvZiBhIGhhc2ggcGF0aC5cbiAqIEBwYXJhbSBoYXNoIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltSGFzaChoYXNoOiBzdHJpbmcpIHtcbiAgICBpZiAoaGFzaC5zdGFydHNXaXRoKFwiI1wiKSlcbiAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDEpO1xuICAgIGlmIChoYXNoLnN0YXJ0c1dpdGgoXCIvXCIpKVxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMSk7XG4gICAgaWYgKGhhc2guZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMCwgaGFzaC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gaGFzaDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUhhc2hUb1BhdGgoaGFzaDogc3RyaW5nKSB7XG4gICAgaGFzaCA9IHRyaW1IYXNoKGhhc2gpO1xuICAgIHJldHVybiBoYXNoLnNwbGl0KFwiL1wiKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeXBlTWFwIHtcbiAgICBcImJpZ2ludFwiOiBiaWdpbnQ7XG4gICAgXCJudW1iZXJcIjogbnVtYmVyO1xuICAgIFwic3RyaW5nXCI6IHN0cmluZztcbiAgICBcImJvb2xlYW5cIjogYm9vbGVhbjtcbiAgICBcInVua25vd25cIjogdW5rbm93bjtcbn1cblxuLy8gTm90IHB1YmxpYyAtLSBqdXN0IGNvbnRhaW5zIHNoYXJlZCBjb2RlIGZvciBoaXN0b3J5IG1vZGlmaWNhdGlvbi5cbi8vIFRoaXMgaXMgd2hhdCBhY3R1YWxseSBjaGFuZ2VzIEhpc3RvcnkgYW5kIHVwZGF0ZXMgdGhlIHdpbmRvdydzIFVSTC5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnRpcmVIYXNoKGhhc2g6IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSB7XG4gICAgYWN0aW9uID8/PSBcInB1c2hcIjtcbiAgICBoYXNoID0gdHJpbUhhc2goaGFzaCk7XG4gICAgbGV0IG9sZFVSTCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgIGxldCBuZXh0VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgbmV4dFVybC5oYXNoID0gYCMke2hhc2h9YDtcblxuICAgIGhpc3RvcnlbYCR7YWN0aW9ufVN0YXRlYF0oe30sIGRvY3VtZW50LnRpdGxlLCBuZXh0VXJsKTtcblxuICAgIC8vIE1vZGlmeWluZyBoaXN0b3J5IGRvZXNuJ3QgYWN0dWFsbHkgY2F1c2UgYSBoYXNoY2hhbmdlIGV2ZW50LlxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBIYXNoQ2hhbmdlRXZlbnQoJ2hhc2hjaGFuZ2UnLCB7IG9sZFVSTCwgbmV3VVJMOiBuZXh0VXJsLnRvU3RyaW5nKCkgfSkpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBnaXZlbiBTZWFyY2ggUGFyYW1zIG9iamVjdCB0byBoYXZlIGl0cyBrZXkgYmUgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIFxuICogU3BlY2lmaWNhbGx5IGZvciBib29sZWFuIHR5cGVzIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBwYXJhbSBpcyBzaW1wbHkgZXhpc3RhbnQvbm9uLWV4aXN0YW50LFxuICogYnV0IGZvciBvdGhlciB0eXBlcyB0aGlzIGlzIHByZXR0eSBzdHJhaWdodGZvcndhcmQuXG4gKiBAcGFyYW0gcGFyYW1zIFxuICogQHBhcmFtIGtleSBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEBwYXJhbSB0eXBlIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYXJzZVBhcmFtPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4ocGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMsIGtleTogc3RyaW5nLCB2YWx1ZTogVHlwZU1hcFtUXSwgdHlwZTogVCkge1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoa2V5LCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIGAke3ZhbHVlfWApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlcXVlc3RlZCBTZWFyY2ggUGFyYW0gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcGFyc2VkIHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYm9vbGVhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW08VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPih1cmw6IFVSTCwga2V5OiBzdHJpbmcsIHR5cGU6IFQpOiBUeXBlTWFwW1RdIHwgbnVsbCB7XG4gICAgbGV0IHZhbHVlID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGFzIFR5cGVNYXBbVF0pID8/IG51bGw7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCkgYXMgVHlwZU1hcFtUXTtcblxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBwYXJzZWQ6IG51bWJlciA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShwYXJzZWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQgYXMgVHlwZU1hcFtUXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKSBhcyBUeXBlTWFwW1RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGFzIFR5cGVNYXBbVF0gPz8gbnVsbDtcbn1cblxuXG5leHBvcnQgdHlwZSBSb3V0ZXJQYXRoVHlwZSA9IG51bGwgfCBzdHJpbmcgfCBSZWdFeHAgfCAoKGxvY2FsUGF0aDogc3RyaW5nKSA9PiBib29sZWFuKTtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250cm9scyB7XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byBgZGlyYC5cbiAgICAgKiBcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkLiAgXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBmYXJ0aGVyIGZyb20gdGhlIHJvb3QgYXJlIGRlbGV0ZWQgdW5sZXNzIHJlcXVlc3RlZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2V0TG9jYWxQYXRoKGRpcjogc3RyaW5nLCBhY3Rpb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEdvIG9uZSBsZXZlbCBkZWVwZXIgaW50byB0aGlzIGRpcmVjdG9yeSBieSBhcHBlbmRpbmcgYC9kaXJgIHRvIGl0LlxuICAgICAqIFxuICAgICAqICogVGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIG5vdCBhZmZlY3RlZFxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgY2xvc2VyIHRvIHRoZSByb290IGFyZSBub3QgYWZmZWN0ZWQuICBcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGZhcnRoZXIgZnJvbSB0aGUgcm9vdCBhcmUgZGVsZXRlZCB1bmxlc3MgcmVxdWVzdGVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdXNoTG9jYWxQYXRoKGRpcjogc3RyaW5nLCBhY3Rpb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiLCBrZWVwVHJhaWxpbmc/OiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEdvIGJhY2sgb25lIGxldmVsIGJ5IHNldHRpbmcgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHRvIGVtcHR5IGFuZCwgb3B0aW9uYWxseSwgY2hhbmdpbmcgdGhlIHBhcmVudCBkaXJlY3RvcnkgdG8gYGRpcmAgYXMgd2VsbC5cbiAgICAgKiBcbiAgICAgKiAqIFRoZSBjdXJyZW50IGRpcmVjdG9yeSBpcyBzZXQgdG8gZW1wdHlcbiAgICAgKiAqIEFsbCBkaXJlY3RvcmllcyBhZnRlciB0aGUgY3VycmVudCBkaXJlY3RvcnksIGlmIGFueSwgYXJlIGVtcHRpZWQuXG4gICAgICogKiBJZiBwcm92aWRlZCwgdGhlIHBhcmVudCBkaXJlY3RvcnkgdG8gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHNldCB0byBgZGlyYC5cbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkXG4gICAgICovXG4gICAgcG9wTG9jYWxQYXRoKGRpcj86IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIik6IHZvaWQ7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZz4ge1xuICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyhhbnlNYXRjaGVzOiBib29sZWFuKTogdm9pZDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRleHRUeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICByb3V0ZXJDb250ZXh0OiB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGxldmVsIHRoZSBjaGlsZCBzaG91bGQgY29uc2lkZXIgaXRzZWxmIGFzLS1cbiAgICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0aGlzIHRvIGtub3cgd2hhdCBwYXJ0IG9mIHRoZSBVUkwgdG8gcGFyc2VcbiAgICAgICAgLy8gYW5kIGFsc28gdG8gaW5mb3JtICp0aGVpciogY2hpbGRyZW4gd2hhdCBsZXZlbCB0aGV5IGFyZVxuICAgICAgICBsZXZlbDogbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGluIG9yZGVyIHRvIGZhY2lsaXRhdGUgc2hvd2luZyB0aGUgZGVmYXVsdCBjaGlsZCB3aGVuIG5vIG5vbi1kZWZhdWx0IGNoaWxkcmVuIGFyZSBiZWluZyBzaG93bi5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCBcbiAgICAgICAgICogQHBhcmFtIG1hdGNoZXMgXG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleDogc3RyaW5nLCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbCk6IHZvaWQ7XG4gICAgfTtcbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nPiB7XG4vLyAgICBub3RpZnlPZlNpYmxpbmdzSGF2ZU5vTWF0Y2hlcyhub01hdGNoZXM6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8vcGF0aDogUm91dGVyUGF0aFR5cGUgfCBudWxsO1xuLy8gICAgbWF0Y2hlczogYm9vbGVhbiB8IG51bGw7XG4vL31cbiIsImltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZU1hbmFnZWRDaGlsZCwgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIFJvdXRlckNoaWxkSW5mbywgUm91dGVyUGF0aFR5cGUsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9jYWxQYXRoUGFyYW1ldGVycyB7XG4gICAgY29uc3VtZVJvdXRlclJldHVybjogUGljazxVc2VDb25zdW1lUm91dGVyUmV0dXJuW1wiY29uc3VtZVJvdXRlclJldHVyblwiXSwgXCJsZXZlbFwiPjtcbiAgICBsb2NhbFJvdXRlUGFyYW1ldGVyczoge1xuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTogT25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nLCBuZXZlcj47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNvbnRleHRUeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICByb3V0ZXJDb250ZXh0OiB7XG4gICAgICAgIGxldmVsOiBudW1iZXI7XG4gICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4OiBzdHJpbmcsIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsKTogdm9pZDtcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdXRlckNvbnN1bWVyQXJndW1lbnRzIHtcbiAgICByb3V0ZXJDb25zdW1lclBhcmFtZXRlcnM6IHsgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZSB8IG51bGw7IH1cbn1cblxuLyoqXG4gKiBUaGUgXCJjaGlsZFwiIHBhcnQgb2YgYSByb3V0ZXIuXG4gKiBcbiAqIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIG9ic2VydmluZyB0aGUgY3VycmVudCBkaXJlY3RvcnkgaW4gdGhlIGhhc2gsXG4gKiBhbmQgbm90aWZ5aW5nIHRoZSBwYXJlbnQgYW55IHRpbWUgaXQgYmVjb21lcyB2YWxpZC9pbnZhbGlkLCBiZWNhdXNlXG4gKiBpZiB0aGlzIHBhdGggYW5kIGFsbCBpdHMgc2libGluZ3MgYXJlIGludmFsaWQgYXQgdGhlIHNhbWUgdGltZSxcbiAqIHRoZSBkZWZhdWx0IHBhdGggaXMgYWxsb3dlZCB0byBiZSBzaG93bi5cbiAqL1xuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICBjb250ZXh0OiBSb3V0ZXJDb250ZXh0VHlwZTtcbiAgICBjb25zdW1lUm91dGVyUGFyYW1ldGVyczoge1xuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcbiAgICAgICAgbG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29uc3VtZVJvdXRlclJldHVybiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgY29uc3VtZVJvdXRlclJldHVybjoge1xuICAgICAgICBsZXZlbDogbnVtYmVyO1xuICAgICAgICBtYXRjaGVzOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgZ2V0TG9jYWxQYXRoOiAoKSA9PiBzdHJpbmc7XG4gICAgICAgIHNldExvY2FsUGF0aDogKHBhdGg6IHN0cmluZykgPT4gdm9pZDtcbiAgICAgICAgcGF0aFdoZW5NYXRjaGluZzogc3RyaW5nIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb25zdW1lUm91dGVyKHsgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LCBjb25zdW1lUm91dGVyUGFyYW1ldGVyczogeyBvbkxvY2FsUGF0aENoYW5nZSwgbG9jYWxQYXRoOiB3YW50ZWRMb2NhbFBhdGggfSB9OiBVc2VDb25zdW1lUm91dGVyUGFyYW1ldGVycyk6IFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4ge1xuICAgIGNvbnN0IHsgcm91dGVyQ29udGV4dDogeyBsZXZlbCwgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQgfSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBbYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3NdID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgYm9vbGVhbik7XG5cbiAgICBjb25zdCBbcGF0aFdoZW5NYXRjaGluZywgc2V0UGF0aFdoZW5NYXRjaGluZ10gPSB1c2VTdGF0ZShudWxsIGFzIG51bGwgfCBzdHJpbmcpO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxSb3V0ZXJDaGlsZEluZm8+KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyc1xuICAgIH0sIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nczogdXNlU3RhYmxlQ2FsbGJhY2soKGFueU1hdGNoZXMpID0+IHtcbiAgICAgICAgICAgIHNldEFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyhhbnlNYXRjaGVzKTtcbiAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlMih3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXMsIGdldExvY2FsUGF0aCgpKTtcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlMih3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncywgZ2V0TG9jYWxQYXRoKCkpO1xuICAgIH0sIFt3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5nc10pXG5cblxuICAgIGNvbnN0IG9uTG9jYWxQYXRoQ2hhbmdlMiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uICh3YW50ZWRMb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3M6IGJvb2xlYW4gfCBudWxsLCBwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhdGhDb21wYXJlKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcbiAgICAgICAgc2V0TWF0Y2hlcyhtYXRjaGVzKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7aW5kZXh9OiBvbkxvY2FsUGF0aENoYW5nZTIod2xwOiAkeyh3YW50ZWRMb2NhbFBhdGggPz8gXCJudWxsXCIpLnRvU3RyaW5nKCl9LCBhbWFuZHM6ICR7KGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncyA/PyBcIm51bGxcIikudG9TdHJpbmcoKX0sIHA6ICR7cGF0aH0pOiAkeyhtYXRjaGVzID8/IFwibnVsbFwiKS50b1N0cmluZygpfWApXG4gICAgICAgIGlmIChtYXRjaGVzKVxuICAgICAgICAgICAgc2V0UGF0aFdoZW5NYXRjaGluZyhwYXRoKTtcblxuICAgICAgICBpZiAod2FudGVkTG9jYWxQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4LCBtYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkKGluZGV4LCBudWxsKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgW21hdGNoZXMsIHNldE1hdGNoZXNdID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgYm9vbGVhbik7XG4gICAgY29uc3QgW2dldExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSA9IHVzZUxvY2FsUGF0aCh7XG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHsgbGV2ZWwgfSxcbiAgICAgICAgbG9jYWxSb3V0ZVBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygocGF0aCwgcHJldiwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2UyKHdhbnRlZExvY2FsUGF0aCwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZT8uKHBhdGgsIHByZXYsIHJlYXNvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHtcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGdldExvY2FsUGF0aCxcbiAgICAgICAgICAgIHNldExvY2FsUGF0aCxcbiAgICAgICAgICAgIHBhdGhXaGVuTWF0Y2hpbmdcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiB1c2VMb2NhbFBhdGgoeyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsIH0sIGxvY2FsUm91dGVQYXJhbWV0ZXJzOiB7IG9uTG9jYWxQYXRoQ2hhbmdlIH0gfTogVXNlTG9jYWxQYXRoUGFyYW1ldGVycykge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9jYWxQYXRoXCIsIGxldmVsKTtcblxuICAgIGNvbnN0IHVybFRvUGF0aCA9IHVzZUNhbGxiYWNrKCh1cmw6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh1cmwpLmhhc2gpKTtcbiAgICAgICAgcmV0dXJuIG9sZEhhc2hQYXRoW2xldmVsXTtcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gPSB1c2VQYXNzaXZlU3RhdGU8c3RyaW5nLCBuZXZlcj4odXNlU3RhYmxlQ2FsbGJhY2sob25Mb2NhbFBhdGhDaGFuZ2UpLCB1c2VDYWxsYmFjaygoKSA9PiB7IFxuICAgICAgICByZXR1cm4gdXJsVG9QYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9LCBbdXJsVG9QYXRoXSkpO1xuXG5cbiAgICAvLyBBbnkgdGltZSB0aGUgVVJMIGNoYW5nZXMsIGluc3BlY3QgdGhlIGhhc2hcbiAgICAvLyBhdCBvdXIgY3VycmVudCBsZXZlbCwgYW5kIGNoYW5nZSBvdXIgbG9jYWwgY29weSBvZiBvdXIgcGF0aFxuICAgIC8vIGluIG91ciBwYXNzaXZlIHN0YXRlLiBUaGlzIHdpbGwgdHJpZ2dlciBvdXIgY2FsbGJhY2sgaWYgdGhleSdyZSBkaWZmZXJlbnQuXG4gICAgdXNlVXJsKHVybCA9PiB7IHNldExvY2FsUGF0aCh1cmxUb1BhdGgodXJsKSk7IH0pO1xuXG4gICAgcmV0dXJuIFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gYXMgY29uc3Q7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhDb21wYXJlKHJlcXVlc3RlZExvY2FsSGFzaDogbnVsbCB8IHN0cmluZyB8IFJlZ0V4cCB8ICgobG9jYWxIYXNoOiBzdHJpbmcpID0+IGJvb2xlYW4pLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3M6IGJvb2xlYW4gfCBudWxsLCBsb2NhbFBhdGg6IHN0cmluZyB8IG51bGwpIHtcbiAgICBsZXQgbWF0Y2hlczogYm9vbGVhbiB8IG51bGw7XG4gICAgbG9jYWxQYXRoID8/PSBcIlwiO1xuXG4gICAgaWYgKHJlcXVlc3RlZExvY2FsSGFzaCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2gudGVzdChsb2NhbFBhdGgpKTtcbiAgICBlbHNlIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2gobG9jYWxQYXRoKSk7XG5cbiAgICBlbHNlIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggPT0gbnVsbClcbiAgICAgICAgbWF0Y2hlcyA9IChhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MgPT0gbnVsbD8gbnVsbCA6ICFhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MpO1xuICAgIGVsc2VcbiAgICAgICAgbWF0Y2hlcyA9IChyZXF1ZXN0ZWRMb2NhbEhhc2ggPT09IGxvY2FsUGF0aCk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbn1cbiIsIlxuLyoqXG4gKiBFcnJvciBjbGFzcyB1c2VkIHdoZW4gYXR0ZW1wcyB0byBtb2RpZnkgdGhlIHJvb3QgZGlyZWN0b3J5IG9jY3VyLlxuICovXG5leHBvcnQgY2xhc3MgUm9vdFJvdXRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgVGhlIHJvb3QgUm91dGVyJ3MgcGF0aCBjYW4gb25seSBiZSBwdXNoZWQgdG8gYW5kIGNhbm5vdCBiZSBzZXQgb3IgcG9wcGVkIGZyb20uYCk7XG4gICAgfVxufSAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFJvb3RSb3V0ZXJFcnJvciB9IGZyb20gXCIuL3Jvb3Qtcm91dGVyLWVycm9yLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBzZXRFbnRpcmVIYXNoLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkaXJlY3RvcnkgYXQgdGhlIGN1cnJlbnQgbGV2ZWwsIGVmZmVjdGl2ZWx5IHJldHVybmluZ1xuICogdG8gdGhlIHByZXZpb3VzIGxldmVsLiAgWW91IGNhbiBhbHNvIHN3aXRjaCB0byBhIGRpZmZlcmVudFxuICogcHJldmlvdXMgbGV2ZWwgaWYgeW91IHdvdWxkIGxpa2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGRpcj86IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiID0gXCJwdXNoXCIpIHtcbiAgICAgICAgc2V0RW50aXJlSGFzaChwb3BMb2NhbFBhdGgobGV2ZWwsIGRpciksIGFjdGlvbik7XG4gICAgfSwgW2xldmVsXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BMb2NhbFBhdGgobGV2ZWw6IG51bWJlciwgZGlyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAobGV2ZWwgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUm9vdFJvdXRlckVycm9yKCk7XG4gICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcbiAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBsZXZlbCkubWFwKHMgPT4gKHMgPz8gXCJcIikpO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgZGlyID0gdHJpbUhhc2goZGlyKTtcbiAgICAgICAgbmV3SGFzaFBhdGhbbmV3SGFzaFBhdGgubGVuZ3RoIC0gMV0gPSBkaXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0hhc2hQYXRoLmpvaW4oXCIvXCIpO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBzZXRFbnRpcmVIYXNoLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuLyoqXG4gKiBBZGRzIGEgZGlyZWN0b3J5IGF0IG9uZSBsZXZlbCBkZWVwZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQdXNoTG9jYWxQYXRoKGxldmVsOiBudW1iZXIpIHtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiBwdXNoTG9jYWxIYXNoKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xuICAgICAgICBkaXIgPSB0cmltSGFzaChkaXIpO1xuICAgICAgICBjb25zdCBvbGRIYXNoUGF0aCA9IG5vcm1hbGl6ZUhhc2hUb1BhdGgodHJpbUhhc2gobmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkuaGFzaCkpO1xuICAgICAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBrZWVwVHJhaWxpbmcgPyB1bmRlZmluZWQgOiBsZXZlbCArIDEpLm1hcChzID0+IChzID8/IFwiXCIpKTtcbiAgICAgICAgbmV3SGFzaFBhdGguc3BsaWNlKGxldmVsICsgMSwgMSwgZGlyKTtcbiAgICAgICAgc2V0RW50aXJlSGFzaChuZXdIYXNoUGF0aC5qb2luKFwiL1wiKSwgYWN0aW9uKTtcbiAgICB9LCBbbGV2ZWxdKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUm9vdFJvdXRlckVycm9yIH0gZnJvbSBcIi4vcm9vdC1yb3V0ZXItZXJyb3IuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUhhc2hUb1BhdGgsIHNldEVudGlyZUhhc2gsIHRyaW1IYXNoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBkaXJlY3RvcnkgYXQgdGhlIGN1cnJlbnQgbGV2ZWwgd2l0aCBhIG5ldyBvbmUuIFlvdSBjYW5cbiAqIGNob29zZSB3aGV0aGVyIG9yIG5vdCBhbnkgdHJhaWxpbmcgcGF0aHMgYXJlIGtlcHQgLS0gYnkgZGVmYXVsdCB0aGlzIGlzIGZhbHNlLlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNldExvY2FsUGF0aChsZXZlbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGRpcjogc3RyaW5nLCBhY3Rpb246IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgPSBcInB1c2hcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbikge1xuICAgICAgICBzZXRFbnRpcmVIYXNoKHNldExvY2FsUGF0aChsZXZlbCwgZGlyLCBrZWVwVHJhaWxpbmcgfHwgZmFsc2UpLCBhY3Rpb24pO1xuICAgIH0sIFtsZXZlbF0pO1xufVxuXG5mdW5jdGlvbiBzZXRMb2NhbFBhdGgobGV2ZWw6IG51bWJlciwgZGlyOiBzdHJpbmcsIGtlZXBUcmFpbGluZzogYm9vbGVhbikge1xuICAgIGlmIChsZXZlbCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSb290Um91dGVyRXJyb3IoKTtcblxuICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XG4gICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcbiAgICBsZXQgbmV3SGFzaFBhdGggPSBvbGRIYXNoUGF0aC5zbGljZSgwLCBrZWVwVHJhaWxpbmcgPyB1bmRlZmluZWQgOiBsZXZlbCArIDEpLm1hcChzID0+IChzID8/IFwiXCIpKTtcbiAgICBuZXdIYXNoUGF0aC5zcGxpY2UobGV2ZWwsIDEsIGRpcik7XG4gICAgcmV0dXJuIG5ld0hhc2hQYXRoLmpvaW4oXCIvXCIpO1xufVxuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVBvcExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1wb3AtbG9jYWwtcGF0aC5qc1wiO1xuaW1wb3J0IHsgdXNlUHVzaExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1wdXNoLWxvY2FsLXBhdGguanNcIjtcbmltcG9ydCB7IHVzZVNldExvY2FsUGF0aCB9IGZyb20gXCIuL3VzZS1zZXQtbG9jYWwtcGF0aC5qc1wiO1xuaW1wb3J0IHsgUm91dGVyQ29udHJvbHMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cblxuLyoqXG4gKiBBbGxvd3MgZWFzeSBhY2Nlc3MgdG8gdGhlIGNvbnRyb2xzIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICogXG4gKiBZb3UgY2FuIGFsc28gZ2V0IHRoaXMgaW5mb3JtYXRpb24gZnJvbSBhIGNoaWxkIDxSb3V0ZXIgLz5cbiAqIGJ5IHBhc3NpbmcgaW4gYSByZWYgKGUuZy4gPFJvdXRlciByZWY9e3NldENvbnRyb2xzfSAvPikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXJDb250cm9scyhsZXZlbDogbnVtYmVyKTogUm91dGVyQ29udHJvbHMge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggYXQgdGhpcyBsZXZlbCBzcGVjaWZpY2FsbHksIFxuICAgIC8vIHNvIGl0IGNvbnRhaW5zIG5vIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxuICAgIGNvbnN0IHBvcExvY2FsUGF0aCA9IHVzZVBvcExvY2FsUGF0aChsZXZlbCk7XG4gICAgY29uc3QgcHVzaExvY2FsUGF0aCA9IHVzZVB1c2hMb2NhbFBhdGgobGV2ZWwpO1xuICAgIGNvbnN0IHNldExvY2FsUGF0aCA9IHVzZVNldExvY2FsUGF0aChsZXZlbCk7XG5cbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBwb3BMb2NhbFBhdGgsXG4gICAgICAgIHB1c2hMb2NhbFBhdGgsXG4gICAgICAgIHNldExvY2FsUGF0aCxcbiAgICB9KSwgW3BvcExvY2FsUGF0aCwgcHVzaExvY2FsUGF0aCwgc2V0TG9jYWxQYXRoXSk7XG59XG5cblxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFJvdXRlckNoaWxkSW5mbywgUm91dGVyQ29udGV4dFR5cGUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFJvdXRlckNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVByb3ZpZGVSb3V0ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxSb3V0ZXJDaGlsZEluZm8+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVByb3ZpZGVSb3V0ZXJSZXR1cm5UeXBlIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxSb3V0ZXJDaGlsZEluZm8+IHtcbiAgICBjb250ZXh0OiBSb3V0ZXJDb250ZXh0VHlwZTtcbn1cblxuLy9jb25zdCBSb3V0ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxSb3V0ZXJDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG4vKipcbiAqIFRoZSBcInBhcmVudFwiIHBhcnQgb2YgYSByb3V0ZXIuXG4gKiBcbiAqIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIGNvb3JkaW5hdGluZywgYW1vbmcgYWxsIGNoaWxkcmVuLCB3aGljaCByb3V0ZSB0byBzaG93LlxuICogVGhpcyBjb29yZGluYXRpb24gaXMgcmVhbGx5IG9ubHkgbmVlZGVkIGZvciB0aGUgXCJkZWZhdWx0XCIgcGF0aHdheSwgd2hpY2hcbiAqIG5lZWRzIHRvIGtub3cgYXMgcGFpbmxlc3NseSBhcyBwb3NzaWJsZSB3aGV0aGVyIGFueSBvZiBpdHMgc2libGluZ3MgYXJlIGN1cnJlbnRseSB2YWxpZC5cbiAqIFxuICogSXQgYWxzbyBpbmNyZWFzZXMgdGhlIGRlcHRoIGJ5IG9uZSwgc3RhcnRpbmcgYXQgZGVwdGg9LTEgZm9yIHRoZSByb290IHJvdXRlciBpcyAqanVzdCogYSBwYXJlbnQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByb3ZpZGVSb3V0ZXIoeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH06IFVzZVByb3ZpZGVSb3V0ZXJQYXJhbWV0ZXJzKTogVXNlUHJvdmlkZVJvdXRlclJldHVyblR5cGUge1xuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48Um91dGVyQ2hpbGRJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByb3V0ZXJDb250ZXh0OiB7IGxldmVsIH0gfSA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dCkgPz8geyByb3V0ZXJDb250ZXh0OiB7IGxldmVsOiAtMSB9IH1cblxuICAgIGNvbnN0IG1hdGNoaW5nSW5kaWNlcyA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKTtcbiAgICBjb25zdCBbZ2V0U2hvd2luZ0RlZmF1bHQsIHNldFNob3dpbmdEZWZhdWx0XSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuIHwgbnVsbCwgbmV2ZXI+KHVzZVN0YWJsZUNhbGxiYWNrKHNob3dpbmdEZWZhdWx0ID0+IHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoIXNob3dpbmdEZWZhdWx0KTtcbiAgICAgICAgfSlcbiAgICB9KSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3Qgb25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgbWF0Y2hlczogYm9vbGVhbiB8IG51bGwpID0+IHtcbiAgICAgICAgbWF0Y2hpbmdJbmRpY2VzLmN1cnJlbnRbbWF0Y2hlcyA/IFwiYWRkXCIgOiBcImRlbGV0ZVwiXShpbmRleCk7XG4gICAgICAgIHNldFNob3dpbmdEZWZhdWx0KG1hdGNoaW5nSW5kaWNlcy5jdXJyZW50LnNpemUgPT0gMCk7XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgcm91dGVyQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxuICAgICAgICAgICAgICAgIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkOiBvbk5vbkRlZmF1bHRDaGlsZE1hdGNoQ2hhbmdlZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVyblxuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUNvbnN1bWVSb3V0ZXIsIFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4gfSBmcm9tIFwiLi91c2Utcm91dGVyLWNvbnN1bWVyLmpzXCI7XG5pbXBvcnQgeyB1c2VSb3V0ZXJDb250cm9scyB9IGZyb20gXCIuL3VzZS1yb3V0ZXItY29udHJvbHMuanNcIjtcbmltcG9ydCB7IFJvdXRlckNvbnRleHQsIHVzZVByb3ZpZGVSb3V0ZXIgfSBmcm9tIFwiLi91c2Utcm91dGVyLXByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBSb3V0ZXJDb250cm9scywgUm91dGVyUGF0aFR5cGUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjaGlsZHJlbiB0byBkaXNwbGF5LCBnaXZlbiB0aGUgY3VycmVudCBsb2NhbCBwYXRoLCBpZiBvbmUgbWF0Y2hlcy5cbiAgICAgKiBcbiAgICAgKiBgbnVsbGAgd2lsbCBiZSBwYXNzZWQgd2hlbiB5b3Ugc2hvdWxkIGhpZGUgdGhlIGNvbnRlbnRzLCBhbmQgdGhlIHN0cmluZyB0aGF0IG1hdGNoZWQgd2lsbCBiZSBwYXNzZWQgb3RoZXJ3aXNlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBwYXRoV2hlbk1hdGNoaW5nIFdoZW4gYG51bGxgLCBkb24ndCBzaG93LCBiZWNhdXNlIHRoZSBVUkwgaXNuJ3Qgb24gdGhpcyBwYXRoLiBBbnkgb3RoZXIgc3RyaW5nIHZhbHVlIGlzIHRoZSBjdXJyZW50IHBhdGggdGhhdCB0aGlzIGBSb3V0ZXJgIG1hdGNoZXMuXG4gICAgICogQHJldHVybnMgV2hhdCB5b3Ugd2FudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgY2hpbGRyZW46IChwYXRoV2hlbk1hdGNoaW5nOiBzdHJpbmcgfCBudWxsLCBjb250cm9sczogUm91dGVyQ29udHJvbHMpID0+IENvbXBvbmVudENoaWxkcmVuO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBwYXRoIG9yIHBhdGhzIHRoaXMgYFJvdXRlcmAgc2hvdWxkIHNob3cgaXRzZWxmIG9uLlxuICAgICAqIFxuICAgICAqIENhbiBiZSBhIHN0cmluZywgUmVnRXhwLCBvciBgKHA6IHN0cmluZykgPT4gYm9vbGVhbmAuIE9yIGBudWxsYCB0byBiZSBhIFwiZGVmYXVsdFwiIGBSb3V0ZXJgLlxuICAgICAqIFxuICAgICAqIFwiRGVmYXVsdFwiIGBSb3V0ZXJgcyAoYGxvY2FwUGF0aD17bnVsbH1gKSBhcmUgc2hvd24gd2hlbiBubyBvdGhlciBgUm91dGVyYCBhdCB0aGUgc2FtZSBsZXZlbCBtYXRjaGVzLlxuICAgICAqL1xuICAgIGxvY2FsUGF0aDogUm91dGVyUGF0aFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gSWYgeW91IHdvdWxkIGxpa2UgdG8ga25vdyB3aGF0IHRoZSBjdXJyZW50IHBhdGggaXMgZXZlbiB3aGVuIG5vdCBjdXJyZW50bHkgYmVpbmcgc2hvd24sIHlvdSBjYW4gZ2V0IHRoYXQgaW5mb3JtYXRpb24gaGVyZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBwYXNzIGEgbm9ybWFsIGBzZXRTdGF0ZWAgZnVuY3Rpb24gaGVyZS5cbiAgICAgKi9cbiAgICBvbkxvY2FsUGF0aENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZywgbmV2ZXI+O1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gY29uZGl0aW9uYWxseSBoaWRlL3Nob3cgY29udGVudCBiYXNlZCBvbiBhIHBhdGggaW4gdGhlIGhhc2ggY29tcG9uZW50IG9mIHRoZSBVUkwuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcGFyYW0gcmVmIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoeyBsb2NhbFBhdGgsIG9uTG9jYWxQYXRoQ2hhbmdlLCBjaGlsZHJlbiB9OiBSb3V0ZXJQcm9wcywgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KTtcblxuICAgIGNvbnN0IHsgY29udGV4dDogY29udGV4dEZyb21QYXJlbnQsIG1hbmFnZWRDaGlsZHJlblJldHVybiB9ID0gdXNlUHJvdmlkZVJvdXRlcih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IGluZGV4ID0gdXNlTWVtbygoKSA9PiAoKGxvY2FsUGF0aCA/PyBcIjxkZWZhdWx0PlwiKSArIGAtJHtNYXRoLnJhbmRvbSgpfWApLCBbbG9jYWxQYXRoXSk7XG4gICAgbGV0IGNvbnN1bWVSb3V0ZXJSZXR1cm46IFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4gfCBudWxsID0gbnVsbDtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJSb3V0ZXJcIiwgISFjb250ZXh0KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm4gPSB1c2VDb25zdW1lUm91dGVyKHsgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHsgbG9jYWxQYXRoLCBvbkxvY2FsUGF0aENoYW5nZSB9LCBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsLCBtYXRjaGVzLCBwYXRoV2hlbk1hdGNoaW5nIH0gfSA9IGNvbnN1bWVSb3V0ZXJSZXR1cm4gPz8geyBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsOiAtMSwgbWF0Y2hlczogbnVsbCwgcGF0aFdoZW5NYXRjaGluZzogbnVsbCB9IH1cblxuICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlUm91dGVyQ29udHJvbHMobGV2ZWwpO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiAoe1xuICAgICAgICBsZXZlbCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGF0aFdoZW5NYXRjaGluZyxcbiAgICAgICAgLi4uY29udHJvbHNcbiAgICB9KSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0RnJvbVBhcmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW4obGV2ZWwgPT0gLTEgPyBcIi9cIiA6IG1hdGNoZXMgPyBwYXRoV2hlbk1hdGNoaW5nIDogbnVsbCwgdXNlUm91dGVyQ29udHJvbHMobGV2ZWwpKX1cbiAgICAgICAgPC9Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuIiwiXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVVybCB9IGZyb20gXCIuL3VzZS11cmwuanNcIjtcbmltcG9ydCB7IHBhcnNlUGFyYW0sIFR5cGVNYXAsIHVucGFyc2VQYXJhbSB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZXhwb3J0IHR5cGUgT25QYXJhbVZhbHVlQ2hhbmdlZDxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+ID0gT25QYXNzaXZlU3RhdGVDaGFuZ2U8VHlwZU1hcFtUXSB8IG51bGwsIG5ldmVyPjsgLy8odmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsLCByZWFzb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgU2V0UGFyYW1XaXRoSGlzdG9yeTxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+ID0gKHZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCB8ICgocHJldlZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCkgPT4gKFR5cGVNYXBbVF0gfCBudWxsKSksIHJlYXNvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpID0+IHZvaWQ7XG5cbi8qKlxuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtJ3MgdmFsdWVcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgbGlrZSB1c2VQYXNzaXZlU3RhdGUgKGl0c2VsZiBsaWtlIHVzZVN0YXRlIGFuZCB1c2VFZmZlY3QgY29tYmluZWQpLFxuICogdGhlIGBzZXRTdGF0ZWAgcmV0dXJuIGZ1bmN0aW9uIGlzLCBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9ucywgbm90IHN5bmNyb25vdXMsIGJ1dCB0aGF0J3NcbiAqIGxpa2UgbW9zdCBjYWxscyB0byBgc2V0U3RhdGVgIGFueXdheSBJIGd1ZXNzP1xuICogXG4gKiBAcGFyYW0gcGFyYW1LZXkgVGhlIG5hbWUgb2YgdGhlIFVSTCBzZWFyY2ggcGFyYW1ldGVyIHRvIHJlZmVyZW5jZSBcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGRhdGEgZW5jb2RlL2RlY29kZSAoYFwic3RyaW5nXCJgIHwgYFwiYm9vbGVhblwiYCB8IGBcIm51bWJlclwiYCB8IGBcImJpZ2ludFwiYClcbiAqIEBwYXJhbSBvblBhcmFtVmFsdWVDaGFuZ2VkIFdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtZXRlcidzIHZhbHVlIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXM8VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPihwYXJhbUtleTogc3RyaW5nLCB0eXBlOiBULCBvblBhcmFtVmFsdWVDaGFuZ2VkPzogT25QYXJhbVZhbHVlQ2hhbmdlZDxUPikge1xuXG4gICAgLy8gV2Uga2VlcCBhIGxvY2FsIGNvcHkgb2Ygb3VyIGN1cnJlbnQgU2VhcmNoIFBhcmFtIHZhbHVlXG4gICAgLy8gYmVjYXVzZSBjaGFuZ2luZyBpdCBpcyBhY3R1YWxseSBhbiBhc3luY3Jvbm91cyBvcGVyYXRpb25cbiAgICAvLyBhbmQgd2UgY2FuJ3Qga25vdyB3aGVuIGl0IGVuZHMgYXNpZGUgZnJvbSBqdXN0IFwiZGlkIHRoZSBVUkwgY2hhbmdlIG9yIG5vdFwiXG4gICAgLy8gc28gd2UgbWlnaHQgYXMgd2VsbCBrZWVwIHRoaXMgc3RhdGUgYXJvdW5kIGxvY2FsbHkgdG8gY29tcGVuc2F0ZS5cbiAgICBjb25zdCBbZ2V0U2F2ZWRQYXJhbVZhbHVlLCBzZXRTYXZlZFBhcmFtVmFsdWVdID0gdXNlUGFzc2l2ZVN0YXRlPFR5cGVNYXBbVF0gfCBudWxsLCBuZXZlcj4ob25QYXJhbVZhbHVlQ2hhbmdlZCwgdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKSwgcGFyYW1LZXksIHR5cGUpO1xuICAgIH0sIFtdKSk7XG4gICAgY29uc3Qgc2V0UGFyYW1XaXRoSGlzdG9yeSA9IHVzZVN0YWJsZUNhbGxiYWNrPFNldFBhcmFtV2l0aEhpc3Rvcnk8VD4+KChuZXdWYWx1ZU9yVXBkYXRlciwgcmVhc29uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikgPT4ge1xuXG4gICAgICAgIGxldCBwcmV2VmFsdWUgPSBwYXJzZVBhcmFtKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLCBwYXJhbUtleSwgdHlwZSk7XG4gICAgICAgIGxldCBuZXh0VmFsdWU6IFR5cGVNYXBbVF0gfCBudWxsID0gKHR5cGVvZiBuZXdWYWx1ZU9yVXBkYXRlciA9PSBcImZ1bmN0aW9uXCI/IG5ld1ZhbHVlT3JVcGRhdGVyKHByZXZWYWx1ZSkgOiBuZXdWYWx1ZU9yVXBkYXRlcik7XG5cbiAgICAgICAgbGV0IG5ld1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLnNlYXJjaFBhcmFtcykpO1xuICAgICAgICB1bnBhcnNlUGFyYW0obmV3UGFyYW1zLCBwYXJhbUtleSwgbmV4dFZhbHVlIGFzIFR5cGVNYXBbVF0sIHR5cGUpO1xuICAgICAgICBsZXQgbmV4dFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICBuZXh0VXJsLnNlYXJjaCA9IHByZXR0eVByaW50UGFyYW1zKG5ld1BhcmFtcyk7XG4gICAgICAgIGhpc3RvcnlbYCR7cmVhc29uID8/IFwicmVwbGFjZVwifVN0YXRlYF0oe30sIGRvY3VtZW50LnRpdGxlLCBuZXh0VXJsKTtcbiAgICAgICAgc2V0U2F2ZWRQYXJhbVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIEFueSB0aW1lIHRoZSBVUkwgY2hhbmdlcywgaXQgbWVhbnMgdGhlIFNlYXJjaCBQYXJhbSB3ZSBjYXJlIGFib3V0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgICAvLyBQYXJzZSBpdCBvdXQgYW5kIHNhdmUgaXQuXG4gICAgdXNlVXJsKHVzZVN0YWJsZUNhbGxiYWNrKHVybCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtID0gcGFyc2VQYXJhbShuZXcgVVJMKHVybCksIHBhcmFtS2V5LCB0eXBlKTtcbiAgICAgICAgc2V0U2F2ZWRQYXJhbVZhbHVlKG5ld1BhcmFtKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gW2dldFNhdmVkUGFyYW1WYWx1ZSwgc2V0UGFyYW1XaXRoSGlzdG9yeV0gYXMgY29uc3Q7XG59XG5cbmZ1bmN0aW9uIHByZXR0eVByaW50UGFyYW1zKHBhcmFtczogVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1BcnJheSA9IFsuLi5wYXJhbXMuZW50cmllcygpXS5maWx0ZXIoKGtleSwgdmFsdWUpID0+IHZhbHVlICE9IG51bGwpO1xuICAgIGlmIChwYXJhbUFycmF5Lmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gXCJcIjtcblxuXG4gICAgbGV0IHF1ZXJ5U3RyaW5nID0gcGFyYW1BcnJheS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIgfHwgKHZhbHVlIGFzIGFueSkgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9YDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcblxuICAgIHJldHVybiBgPyR7cXVlcnlTdHJpbmd9YDtcblxufVxuIixudWxsXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJkZWZlciIsImRlcHRoU29ydCIsImkiLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJhc3NpZ24iLCJvYmoiLCJwcm9wcyIsInJlbW92ZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJjaGlsZHJlbiIsImtleSIsInJlZiIsIm5vcm1hbGl6ZWRQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZSIsIm9yaWdpbmFsIiwidm5vZGUiLCJfX2siLCJfXyIsIl9fYiIsIl9fZSIsIl9fZCIsIl9fYyIsIl9faCIsImNvbnN0cnVjdG9yIiwiX192IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwidGhpcyIsImdldERvbVNpYmxpbmciLCJjaGlsZEluZGV4IiwiaW5kZXhPZiIsInNpYmxpbmciLCJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsImNoaWxkIiwiYmFzZSIsImVucXVldWVSZW5kZXIiLCJjIiwicHVzaCIsInByb2Nlc3MiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsInckMiIsInJlbmRlclF1ZXVlTGVuZ3RoIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsInNvcnQiLCJzaGlmdCIsIl9fUCIsImRpZmYiLCJfX24iLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJnZXRMYXN0RG9tIiwibmV4dFNpYmxpbmciLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJzb21lIiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJsYXN0RG9tIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIlByb21pc2UiLCJ0aGVuIiwiYmluZCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZiQyIiwiYSIsImIiLCJpc1N0YXRpY0NoaWxkcmVuIiwiX19zb3VyY2UiLCJfX3NlbGYiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldmlvdXNDb21wb25lbnQiLCJwcmV2UmFmIiwiY3VycmVudEhvb2siLCJhZnRlclBhaW50RWZmZWN0cyIsIkVNUFRZIiwib2xkQmVmb3JlRGlmZiIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJnZXRIb29rU3RhdGUiLCJpbmRleCIsImhvb2tzIiwiX19IIiwiX19WIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiaW52b2tlT3JSZXR1cm4iLCJyZWR1Y2VyIiwiaW5pdCIsImhvb2tTdGF0ZSIsIl9yZWR1Y2VyIiwiYWN0aW9uIiwiY3VycmVudFZhbHVlIiwiX19OIiwibmV4dFZhbHVlIiwiX2hhc1NjdUZyb21Ib29rcyIsInVwZGF0ZUhvb2tTdGF0ZSIsImYiLCJwIiwic3RhdGVIb29rcyIsImZpbHRlciIsIngiLCJldmVyeSIsInByZXZTY3UiLCJzaG91bGRVcGRhdGUiLCJob29rSXRlbSIsInByZXZDV1UiLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUhhbmRsZSIsImNvbmNhdCIsImZhY3RvcnkiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwiaW52b2tlQ2xlYW51cCIsImludm9rZUVmZmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFmdGVyTmV4dEZyYW1lIiwiaGFzRXJyb3JlZCIsIkhBU19SQUYiLCJyYWYiLCJkb25lIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaG9vayIsImNvbXAiLCJjbGVhbnVwIiwib2xkQXJncyIsIm5ld0FyZ3MiLCJhcmciLCJnZXRCdWlsZE1vZGVVbm1lbW9pemVkIiwiZ2V0QnVpbGRNb2RlVW5tZW1vaXplZCQxIiwiZW52IiwiTk9ERV9FTlYiLCJfZSIsImdldEJ1aWxkTW9kZSIsIm5vb3AiLCJ0aW1lb3V0SGFuZGxlIiwiY2FsbENvdW50VSIsIl93aW5kb3ciLCJfd2luZG93JF9ob29rQ2FsbENvdW4iLCJfd2luZG93JF9ob29rQ2FsbENvdW4yIiwiX3dpbmRvdyRfaG9va0NhbGxDb3VuMyIsImZpbHRlcnMiLCJoYXMiLCJjb25zb2xlIiwiYXNzZXJ0Iiwid2luZG93IiwiX2hvb2tDYWxsQ291bnQiLCJjYWxsQ291bnRzIiwibW9tZW50IiwidG90YWwiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIl9yZWYiLCJjb3VudHMiLCJIb29rIiwiTm93IiwiVG90YWwiLCJfcmVmMiIsIl9yZWYzIiwiX3JlZjQiLCJsaHNNIiwicmhzTSIsIkluZmluaXR5IiwidGFibGUiLCJfcmVmNSIsIlNldCIsIm1vbml0b3JDYWxsQ291bnQiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJ1c2VFbnN1cmVTdGFiaWxpdHkkMSIsInBhcmVudEhvb2tOYW1lIiwiX2xlbiIsInZhbHVlcyIsIl9rZXkiLCJoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSIsInNob3duRXJyb3IiLCJ1c2VIZWxwZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVib3VuY2VSZW5kZXJpbmckMSIsIl9sJDIkZGVib3VuY2VSZW5kZXJpbiIsInF1ZXVlTWljcm90YXNrIiwidXNlUGFzc2l2ZVN0YXRlIiwidXNlUGFzc2l2ZVN0YXRlJDEiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiX29uQ2hhbmdlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm4iLCJzZXRWYWx1ZSIsInJlYXNvbiIsIkZ1bmN0aW9uIiwibmV4dFJlYXNvbiIsIm5leHREZXAiLCJwcmV2RGVwIiwiX29uQ2hhbmdlMiIsIlN5bWJvbCIsInJldHVybk51bGwiLCJyZXR1cm5OdWxsJDEiLCJydW5JbW1lZGlhdGVseSIsInJ1bkltbWVkaWF0ZWx5JDEiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsInVzZU1lcmdlZENoaWxkcmVuJDEiLCJsaHMiLCJyaHMiLCJyJDEiLCJ0IiwibiIsImNsc3giLCJjbHN4JDEiLCJ1c2VNZXJnZWRDbGFzc2VzIiwidXNlTWVyZ2VkQ2xhc3NlcyQxIiwibGhzQ2xhc3MiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiZnJvbSIsImpvaW4iLCJUYWJsZSIsImJhc2U2NCIsImJhc2U2NCQxIiwicmFuZG9tNkJpdHMiLCJyYW5kb202Qml0cyQxIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tNjRCaXRzIiwicmFuZG9tNjRCaXRzJDEiLCJnZW5lcmF0ZVJhbmRvbUlkIiwiZ2VuZXJhdGVSYW5kb21JZCQxIiwicHJlZml4IiwidG9SdW4iLCJNYXAiLCJjb21taXROYW1lIiwibmV3Q29tbWl0IiwibmV3Q29tbWl0JDEiLCJpZCIsImVmZmVjdEluZm8iLCJvbGRJbnB1dHMiLCJwcmV2SW5wdXRzIiwiaW5wdXRzIiwiX2VmZmVjdEluZm8kY2xlYW51cCIsImVmZmVjdCIsImNsZWFyIiwiX2xlbjIiLCJfa2V5MiIsIm9yaWdpbmFsQ29tbWl0IiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0JDEiLCJzZXQiLCJkZWxldGUiLCJhcmdzQ2hhbmdlZCQxIiwidXNlU3RhYmxlR2V0dGVyIiwidXNlU3RhYmxlR2V0dGVyJDEiLCJFcnJvciIsInVzZVN0YWJsZU9iamVjdCIsInVzZVN0YWJsZU9iamVjdCQxIiwiX3JlZjYiLCJfayIsInYiLCJXZWFrTWFwIiwiaXNTdGFibGVHZXR0ZXIiLCJpc1N0YWJsZUdldHRlciQxIiwiX21hcCQxJGdldCIsImdldCIsInNldElzU3RhYmxlR2V0dGVyIiwic2V0SXNTdGFibGVHZXR0ZXIkMSIsInVzZVN0YWJsZUNhbGxiYWNrIiwidXNlU3RhYmxlQ2FsbGJhY2skMSIsImZuIiwibm9EZXBzIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwidXNlQ2FsbGJhY2tOYXRpdmUiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1JlZiQxIiwiaW5zdGFuY2UiLCJ1c2VNZXJnZWRSZWZzIiwidXNlTWVyZ2VkUmVmcyQxIiwiY29tYmluZWQiLCJzdHlsZVN0cmluZ1RvT2JqZWN0Iiwic3R5bGVTdHJpbmdUb09iamVjdCQxIiwiZnJvbUVudHJpZXMiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJ1c2VNZXJnZWRTdHlsZXMkMSIsImxvZyIsInVzZU1lcmdlZFByb3BzIiwidXNlTWVyZ2VkUHJvcHMkMSIsIl9sZW4zIiwiYWxsUHJvcHMiLCJfa2V5MyIsInJldCIsIm5leHRQcm9wcyIsInVzZU1lcmdlZFByb3BzMiIsImtub3ducyIsIm1lcmdlVW5rbm93biIsIm1lcmdlVW5rbm93biQxIiwibGhzVmFsdWUiLCJyaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwidXNlTWVyZ2VkUHJvcHMyJDEiLCJsaHNBbGwiLCJyaHNBbGwiLCJjbGFzc05hbWUiLCJsaHNLZXlVIiwibGhzS2V5IiwicmhzS2V5VSIsInJoc0tleSIsIm1lcmdlRnVuY3Rpb25zJDEiLCJsdiIsInJ2IiwiYWxsIiwidXNlTWFuYWdlZENoaWxkcmVuIiwidXNlTWFuYWdlZENoaWxkcmVuJDEiLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsIm9uQ2hpbGRyZW5Db3VudENoYW5nZSIsInJlc3QiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZmllbGQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInNpemUiLCJhZGQiLCJyZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJtb3VudGVkIiwibW91bnRzIiwidW5tb3VudHMiLCJnZXRDaGlsZHJlbiIsIm1heCIsInNoYXZlIiwibWFuYWdlZENoaWxkcmVuIiwiXyIsImdldEF0IiwiYXJyYXlTbGljZSIsIm1hbmFnZWRDaGlsZENvbnRleHQiLCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4iLCJ1c2VNYW5hZ2VkQ2hpbGQiLCJ1c2VNYW5hZ2VkQ2hpbGQkMSIsIl9yZWY3IiwiaW5mbyIsImZsYXQiLCJtYW5hZ2VkQ2hpbGRSZXR1cm4iLCJ1c2VTdGF0ZSQxIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwicHJldlZhbHVlIiwiZ2V0U3RhdGUiLCJ1c2VHbG9iYWxIYW5kbGVyIiwidGFyZ2V0IiwiaGFuZGxlciIsIm1vZGUiLCJ1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZCIsInVzZUdsb2JhbEhhbmRsZXJTaW5nbGUiLCJtYXBUaGluZyIsImRvTWFwVGhpbmciLCJvcCIsIm9wdGlvbnNLZXkiLCJieVR5cGUiLCJieU9wdGlvbnMiLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsImFkZFRvTWFwVGhpbmciLCJoIiwicmVtb3ZlRnJvbU1hcFRoaW5nIiwic3RhYmxlSGFuZGxlciIsInVzZVJlZkVsZW1lbnQiLCJ1c2VSZWZFbGVtZW50JDEiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwicmVmRWxlbWVudFBhcmFtZXRlcnMiLCJnZXRFbGVtZW50Iiwic2V0RWxlbWVudCIsInByb3BzU3RhYmxlIiwicmVmRWxlbWVudFJldHVybiIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsIl90b3BDaGFuZ2VkIiwiX3N3YXBJbmVydGVkU2libGluZyIsIl9pbmVydFNpYmxpbmdzIiwiX3Jlc3RvcmVJbmVydGVkU2libGluZ3MiLCJfZ2V0UGFyZW50cyIsIl9nZXREaXN0cmlidXRlZENoaWxkcmVuIiwiX2lzSW5lcnRhYmxlIiwiX2hhbmRsZU11dGF0aW9ucyIsIkJsb2NraW5nRWxlbWVudHNJbXBsIiwiX2EiLCJfYiIsIl9jIiwiZGVzdHJ1Y3RvciIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJlbGVtZW50IiwicmVtb3ZlIiwicG9wIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsImJvZHkiLCJ0b1NraXAiLCJvbGRJbmVydCIsIm5ld0luZXJ0Iiwic2libGluZ3NUb1Jlc3RvcmUiLCJpbmVydCIsImVsZW1lbnRzIiwibW8iLCJkaXNjb25uZWN0Iiwic2libGluZ3MiLCJwYXJlbnQiLCJpbmVydGVkU2libGluZ3MiLCJNdXRhdGlvbk9ic2VydmVyIiwicGFyZW50VG9PYnNlcnZlIiwibWF5YmVTaGFkeVJvb3QiLCJfX3NoYWR5IiwiaG9zdCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJyZW1vdmVkTm9kZXMiLCJhZGRlZE5vZGVzIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImFzc2lnbmVkU2xvdCIsInNoYWRvd1Jvb3QiLCJyZXN1bHQiLCJub2RlcyIsInNsb3RzIiwicXVlcnlTZWxlY3RvckFsbCIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiJGJsb2NraW5nRWxlbWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NDYWxsQ2hlY2skMSIsIlR5cGVFcnJvciIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiX29uTXV0YXRpb24iLCJzdWJ0cmVlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJ0YWJJbmRleCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsIl9vbkRvY3VtZW50TG9hZGVkIiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJpbmVydEVsZW1lbnQiLCJfdGhpcyIsInVuc2hpZnQiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJfaSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsIkhUTUxFbGVtZW50IiwiaGFzT3duUHJvcGVydHkiLCJzaGFsbG93RGlmZmVycyIsIlB1cmVDb21wb25lbnQiLCJtZW1vIiwiY29tcGFyZXIiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX2YiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiUkVBQ1RfRk9SV0FSRF9TWU1CT0wiLCJmb3IiLCJmb3J3YXJkUmVmIiwiRm9yd2FyZGVkIiwiY2xvbmUiLCIkJHR5cGVvZiIsIm9sZENhdGNoRXJyb3IiLCJvbGRVbm1vdW50IiwiZGV0YWNoZWRDbG9uZSIsImRldGFjaGVkUGFyZW50IiwicmVtb3ZlT3JpZ2luYWwiLCJvcmlnaW5hbFBhcmVudCIsIlN1c3BlbnNlIiwiX191IiwiX3N1c3BlbmRlcnMiLCJzdXNwZW5kZWQiLCJfX2EiLCJTdXNwZW5zZUxpc3QiLCJfbmV4dCIsIl9tYXAiLCJfX1IiLCJwcm9taXNlIiwic3VzcGVuZGluZ1ZOb2RlIiwic3VzcGVuZGluZ0NvbXBvbmVudCIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsIl9fTyIsImZhbGxiYWNrIiwiVyIsImxpc3QiLCJyZXZlYWxPcmRlciIsImRlbGVnYXRlZCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJyZXZlcnNlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiQ0FNRUxfUFJPUFMiLCJPTl9BTkkiLCJDQU1FTF9SRVBMQUNFIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJxIiwib2xkRXZlbnRIb29rIiwiZW1wdHkiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsIm5uIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsImxvd2VyQ2FzZWQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwib2xkRGlmZmVkIiwiSW1wZXJhdGl2ZUVsZW1lbnRVIiwidXNlSW1wZXJhdGl2ZVByb3BzIiwiX3JlZjgiLCJjdXJyZW50SW1wZXJhdGl2ZVByb3BzIiwib3RoZXJzIiwiaGFzQ2xhc3MiLCJjbHMiLCJzZXRDbGFzcyIsImVuYWJsZWQiLCJfZ2V0RWxlbWVudCIsImNsYXNzTGlzdCIsInByb3AiLCJzdGFydHNXaXRoIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRDaGlsZHJlbiIsIl9nZXRFbGVtZW50MiIsIl9nZXRFbGVtZW50MyIsInNldEV2ZW50SGFuZGxlciIsIm1hcHBlZEtleSIsIkV2ZW50TWFwcGluZyIsImltcGVyYXRpdmVIYW5kbGUiLCJfcmVmOSIsInRhZyIsIlRhZyIsImhhbmRsZSIsImlwcm9wcyIsImFib3J0IiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uc3RhcnQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJiZWZvcmVpbnB1dCIsImNhbnBsYXkiLCJjYW5wbGF5dGhyb3VnaCIsImNoYW5nZSIsImNsaWNrIiwiY29tcG9zaXRpb25lbmQiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJjb250ZXh0bWVudSIsImN1dCIsImRibGNsaWNrIiwiZHJhZyIsImRyYWdlbmQiLCJkcmFnZW50ZXIiLCJkcmFnbGVhdmUiLCJkcmFnb3ZlciIsImRyYWdzdGFydCIsImRyb3AiLCJkdXJhdGlvbmNoYW5nZSIsImVtcHRpZWQiLCJlbmRlZCIsImZvY3VzaW4iLCJmb2N1c291dCIsImZvcm1kYXRhIiwiZ290cG9pbnRlcmNhcHR1cmUiLCJpbnB1dCIsImludmFsaWQiLCJrZXlkb3duIiwia2V5cHJlc3MiLCJrZXl1cCIsImxvYWQiLCJsb2FkZWRkYXRhIiwibG9hZGVkbWV0YWRhdGEiLCJsb2Fkc3RhcnQiLCJsb3N0cG9pbnRlcmNhcHR1cmUiLCJtb3VzZWRvd24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm1vdXNlbW92ZSIsIm1vdXNlb3V0IiwibW91c2VvdmVyIiwibW91c2V1cCIsInBhc3RlIiwicGF1c2UiLCJwbGF5IiwicGxheWluZyIsInBvaW50ZXJjYW5jZWwiLCJwb2ludGVyZG93biIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcm91dCIsInBvaW50ZXJvdmVyIiwicG9pbnRlcnVwIiwicHJvZ3Jlc3MiLCJyZXNldCIsInNjcm9sbCIsInNlZWtlZCIsInNlZWtpbmciLCJzZWxlY3QiLCJzdGFsbGVkIiwic3VibWl0Iiwic3VzcGVuZCIsInRpbWV1cGRhdGUiLCJ0b2dnbGUiLCJ0b3VjaGNhbmNlbCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hzdGFydCIsInRyYW5zaXRpb25lbmQiLCJ2b2x1bWVjaGFuZ2UiLCJ3YWl0aW5nIiwid2hlZWwiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZUdsb2JhbCQxIiwiZnJlZVNlbGYiLCJyb290JDEiLCJTeW1ib2wkMiIsIm9iamVjdFByb3RvIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInVubWFza2VkIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsImNvcmVKc0RhdGEkMSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwia2V5cyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsIm9iamVjdCIsImdldE5hdGl2ZSIsImVxIiwib3RoZXIiLCJuYXRpdmVDcmVhdGUiLCJuYXRpdmVDcmVhdGUkMSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsImVudHJ5IiwibGlzdENhY2hlQ2xlYXIiLCJhc3NvY0luZGV4T2YiLCJhcnJheSIsImFycmF5UHJvdG8iLCJsaXN0Q2FjaGVEZWxldGUiLCJsYXN0SW5kZXgiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJNYXAkMiIsIm1hcENhY2hlQ2xlYXIiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemUiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiYXBwbHkiLCJjYWNoZSIsIkNhY2hlIiwiX3Byb2Nlc3MiLCJfcHJvY2VzcyRlbnYiLCJfbGVuNCIsIl9rZXk0IiwiX2wkMiRkZWJvdW5jZVJlbmRlcmluMiIsIl9vbkNoYW5nZTMiLCJfb25DaGFuZ2U0IiwicmV0dXJuRmFsc2UiLCJwcmV2aW91c0lucHV0cyIsIl9lZmZlY3RJbmZvJGNsZWFudXAyIiwiX2xlbjUiLCJfa2V5NSIsIl9yZWYxMCIsIl9tYXAkZ2V0IiwiX2xlbjYiLCJfa2V5NiIsIm9uQ2hpbGRDb3VudENoYW5nZSIsIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMiLCJfaW5mbyRjb250ZXh0IiwidXNlQ2hpbGRyZW5GbGFnIiwiX3JlZjExIiwiaW5pdGlhbEluZGV4IiwiY2xvc2VzdEZpdCIsIm9uSW5kZXhDaGFuZ2UiLCJzZXRBdCIsImlzVmFsaWQiLCJnZXRDdXJyZW50SW5kZXgiLCJzZXRDdXJyZW50SW5kZXgiLCJnZXRSZXF1ZXN0ZWRJbmRleCIsInNldFJlcXVlc3RlZEluZGV4IiwiZ2V0Q2xvc2VzdEZpdCIsInJlcXVlc3RlZEluZGV4IiwiY2xvc2VzdERpc3RhbmNlIiwiY2xvc2VzdEluZGV4IiwibmV3RGlzdGFuY2UiLCJhYnMiLCJyZWV2YWx1YXRlQ2xvc2VzdEZpdCIsImN1cnJlbnRDaGlsZCIsImNsb3Nlc3RGaXRJbmRleCIsImNsb3Nlc3RGaXRDaGlsZCIsImNoYW5nZUluZGV4IiwibmV3TWF0Y2hpbmdDaGlsZCIsIm9sZE1hdGNoaW5nQ2hpbGQiLCJjaGlsZElzVmFsaWQiLCJnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uIiwiZXhjbHVzaXZpdHlLZXkiLCJTd2FwcGFibGVDb250ZXh0IiwiZ2V0QW5pbWF0ZU9uTW91bnQiLCJHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIkNzc0NsYXNzQ29udGV4dCIsIkdldEJhc2VDbGFzcyIsIkdldEVudGVyQ2xhc3MiLCJHZXRFeGl0Q2xhc3MiLCJHZXRNZWFzdXJlQ2xhc3MiLCJHZXRJbml0Q2xhc3MiLCJHZXRUcmFuc2l0aW9uQ2xhc3MiLCJHZXRGaW5hbGl6ZUNsYXNzIiwidXNlQ3NzQ2xhc3NlcyIsIkdldERpcmVjdGlvbkNsYXNzIiwiZGlyZWN0aW9uIiwiR2V0UGhhc2VDbGFzcyIsInBoYXNlIiwiZ2xvYmFsQ291bnQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIiLCJfcmVmMTIiLCJnZXROZXh0SW5kZXhJbkxpbmUiLCJzZXROZXh0SW5kZXhJbkxpbmUiLCJtIiwic2V0RXhjbHVzaXZlbHlPcGVuIiwiZ2V0RXhjbHVzaXZlbHlPcGVuIiwib25WaXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJsZSIsIm5leHRJbkxpbmUiLCJjdXJyZW50SW5MaW5lIiwiX2dldENoaWxkcmVuJGdldEF0IiwiX2dldENoaWxkcmVuJGdldEF0JGZvIiwiZm9yY2VDbG9zZSIsImNvbnRleHQyIiwiZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIl9qc3giLCJ1c2VFeGNsdXNpdmVUcmFuc2l0aW9uIiwiX3JlZjEzIiwidHJhbnNpdGlvblBhcmFtZXRlcnMiLCJzaG93IiwiZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMiLCJleGNsdXNpdmVseU9wZW4iLCJwYXJlbnRPblZpc0NoYW5nZSIsImV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm4iLCJpc0V4Y2x1c2l2ZSIsImZvcndhcmRFbGVtZW50UmVmIiwiRm9yd2FyZGVkQ29tcG9uZW50IiwidXNlTGFzdE5vbk51bGxWYWx1ZSIsImxhc3ROb25OdWxsVmFsdWUiLCJ1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyIsIl9yZWYxNCIsIm90aGVyUHJvcHMiLCJpbmxpbmUiLCJTd2FwcGFibGUiLCJfcmVmMTUiLCJfaW5saW5lIiwiY2hpbGRyZW5BbmltYXRlT25Nb3VudCIsImlubGluZUVsZW1lbnRzIiwidHJhbnNpdGlvblByb3BzIiwibWVyZ2VkV2l0aENoaWxkcmVuIiwiYW5pbWF0ZU9uTW91bnQiLCJnZXRUaW1lb3V0RHVyYXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInN0ciIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwicGFyc2VTdGF0ZSIsIm5leHRTdGF0ZSIsInVzZVRyYW5zaXRpb24iLCJfcmVmMTYiLCJfYW5pbWF0ZU9uTW91bnQiLCJfbWVhc3VyZSIsIl9lYXNpbmdJbiIsIl9lYXNpbmdPdXQiLCJwcm9wc0luY29taW5nIiwibWVhc3VyZSIsImV4aXRWaXNpYmlsaXR5IiwiZHVyYXRpb24iLCJkZWxheU1vdW50VW50aWxTaG93biIsImVhc2luZyIsImVhc2luZ0luIiwiZWFzaW5nT3V0IiwiZ2V0RXhpdFZpc2liaWxpdHkiLCJnZXRNZWFzdXJlIiwiZXhjbHVzaXZlVHJhbnNpdGlvblZpc2liaWxpdHlDaGFuZ2UiLCJpbnRlcm5hbE9uU2hvd0NoYW5nZWQiLCJjc3NQcm9wZXJ0aWVzIiwiY2xhc3NOYW1lcyIsImhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCIsIl90aW1lb3V0Q2xlYXJGdW5jdGlvbiIsInRpbWVvdXRDbGVhckZ1bmN0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwiZWxhcHNlZFRpbWUiLCJoYXNNb3VudGVkIiwidXBkYXRlQ2xhc3NlcyIsImFsbENsYXNzZXNUb1JlbW92ZSIsImFsbENsYXNzZXNUb0FkZCIsInVwZGF0ZVNpemVQcm9wZXJ0eSIsInZhck5hbWUiLCJtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMiLCJfc2l6ZSIsIl9zaXplMiIsIl9zaXplMyIsIl9zaXplNCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsIm9uU3RhdGVDaGFuZ2UiLCJwcmV2U3RhdGUiLCJuZXh0RGlyZWN0aW9uIiwibmV4dFBoYXNlIiwiaXNCZWluZ1BhaW50ZWQiLCJmb3JjZVJlZmxvdyIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50UGhhc2UiLCJkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiIsImhhc1JlbmRlcmVkQ2hpbGRyZW4iLCJyZW5kZXJDaGlsZHJlbiIsImNoaWxkcmVuSXNWbm9kZSIsImZpbmFsUHJvcHMiLCJyZXNldENvbnRleHQiLCJtb2RpZmllZENoaWxkcmVuIiwiZ2xvYmFsVGhpcyIsIl9kdW1teSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJ1c2VCYXNlUHJvcHNGYWRlIiwiX3JlZjE3IiwiZmFkZVBhcmFtZXRlcnMiLCJmYWRlTWluIiwiZmFkZU1heCIsIkZhZGUiLCJfcmVmMTgiLCJ1c2VCYXNlUHJvcHNDbGlwIiwiX3JlZjE5IiwiX3JlZjIwIiwiX3JlZjIxIiwiX3JlZjIyIiwiX3JlZjIzIiwiY2xpcFBhcmFtZXRlcnMiLCJjbGlwTWluIiwiY2xpcE1pbkJsb2NrIiwiY2xpcE1pbklubGluZSIsImNsaXBPcmlnaW4iLCJjbGlwT3JpZ2luQmxvY2siLCJjbGlwT3JpZ2luSW5saW5lIiwiQ2xpcCIsIl9yZWYyNCIsIkNsaXBGYWRlIiwiX3JlZjI1IiwidXNlQmFzZVByb3BzQ29sbGFwc2UiLCJfcmVmMjYiLCJjb2xsYXBzZVBhcmFtZXRlcnMiLCJtaW5CbG9ja1NpemUiLCJDb2xsYXBzZSIsIl9yZWYyNyIsIkNvbGxhcHNlRmFkZSIsIl9yZWYyOCIsInVzZUJhc2VQcm9wc0ZsaXAiLCJfcmVmMjkiLCJfdXNlTGFzdE5vbk51bGxWYWx1ZSIsIl91c2VMYXN0Tm9uTnVsbFZhbHVlMiIsImZsaXBQYXJhbWV0ZXJzIiwiZmxpcEFuZ2xlQmxvY2siLCJmbGlwQW5nbGVJbmxpbmUiLCJmbGlwUGVyc3BlY3RpdmUiLCJGbGlwIiwiX3JlZjMwIiwidXNlQmFzZVByb3BzU2xpZGUiLCJfcmVmMzEiLCJfc2xpZGVUYXJnZXRJbmxpbmUiLCJfc2xpZGVUYXJnZXRCbG9jayIsInNsaWRlUGFyYW1ldGVycyIsInNsaWRlVGFyZ2V0SW5saW5lIiwic2xpZGVUYXJnZXRCbG9jayIsIlNsaWRlIiwiX3JlZjMyIiwiU2xpZGVGYWRlIiwiX3JlZjMzIiwidXNlQmFzZVByb3BzWm9vbSIsIl9yZWYzNCIsIl9yZWYzNSIsIl9yZWYzNiIsIl9yZWYzNyIsIl9yZWYzOCIsInpvb21QYXJhbWV0ZXJzIiwiem9vbU9yaWdpbiIsInpvb21PcmlnaW5JbmxpbmUiLCJ6b29tT3JpZ2luQmxvY2siLCJ6b29tTWluIiwiem9vbU1pbklubGluZSIsInpvb21NaW5CbG9jayIsIlpvb20iLCJfcmVmMzkiLCJTbGlkZVpvb20iLCJfcmVmNDAiLCJTbGlkZVpvb21GYWRlIiwiX3JlZjQxIiwiWm9vbUZhZGUiLCJfcmVmNDIiLCJfX1BSRUFDVF9ERVZUT09MU19fIiwiYXR0YWNoUHJlYWN0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwicmVzZXRQcm9wV2FybmluZ3MiLCJnZXREaXNwbGF5TmFtZSIsInJlbmRlclN0YWNrIiwib3duZXJTdGFjayIsImdldEN1cnJlbnRWTm9kZSIsImhhc0JhYmVsUGx1Z2luIiwiaXNQb3NzaWJsZU93bmVyIiwiZ2V0T3duZXJTdGFjayIsInN0YWNrIiwibmV4dCIsIl9fbyIsInJlZHVjZSIsImFjYyIsIm93bmVyIiwic291cmNlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiaXNXZWFrTWFwU3VwcG9ydGVkIiwiZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQiLCJzZXJpYWxpemVWTm9kZSIsImF0dHJzIiwib2xkRGlmZiIsIm9sZFJvb3QiLCJvbGRSZW5kZXIiLCJzZXR1cENvbXBvbmVudFN0YWNrIiwiaG9va3NBbGxvd2VkIiwib2xkVm5vZGUiLCJvbGRIb29rIiwid2FybmVkQ29tcG9uZW50cyIsImxhenlQcm9wVHlwZXMiLCJkZXByZWNhdGlvbnMiLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudE5hbWUiLCJwcm9wVHlwZXMiLCJsYXp5Vk5vZGUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJtZXNzYWdlIiwidyIsInByb3BlcnR5IiwiZGVwcmVjYXRlZEF0dHJpYnV0ZXMiLCJub2RlTmFtZSIsImRlcHJlY2F0ZWRQcm90byIsImNyZWF0ZSIsIl9fcHJvdG9fXyIsImluaXREZWJ1ZyIsInVzZVVybCIsIm9uVXJsQ2hhbmdlIiwiZ2V0VXJsIiwic2V0VXJsIiwidHJpbUhhc2giLCJoYXNoIiwic3Vic3RyIiwibm9ybWFsaXplSGFzaFRvUGF0aCIsInNldEVudGlyZUhhc2giLCJfYWN0aW9uIiwib2xkVVJMIiwibmV4dFVybCIsIlVSTCIsImhpc3RvcnkiLCJ0aXRsZSIsImRpc3BhdGNoRXZlbnQiLCJIYXNoQ2hhbmdlRXZlbnQiLCJuZXdVUkwiLCJ1bnBhcnNlUGFyYW0iLCJwYXJhbXMiLCJwYXJzZVBhcmFtIiwidXJsIiwic2VhcmNoUGFyYW1zIiwicGFyc2VkIiwiaXNGaW5pdGUiLCJCaWdJbnQiLCJ1c2VDb25zdW1lUm91dGVyIiwiX3JlZjQzIiwiY29uc3VtZVJvdXRlclBhcmFtZXRlcnMiLCJvbkxvY2FsUGF0aENoYW5nZSIsImxvY2FsUGF0aCIsIndhbnRlZExvY2FsUGF0aCIsInJvdXRlckNvbnRleHQiLCJsZXZlbCIsIm5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkIiwiYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzIiwic2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzIiwicGF0aFdoZW5NYXRjaGluZyIsInNldFBhdGhXaGVuTWF0Y2hpbmciLCJhbnlNYXRjaGVzIiwib25Mb2NhbFBhdGhDaGFuZ2UyIiwiZ2V0TG9jYWxQYXRoIiwicGF0aCIsInBhdGhDb21wYXJlIiwic2V0TWF0Y2hlcyIsInNldExvY2FsUGF0aCIsInVzZUxvY2FsUGF0aCIsImNvbnN1bWVSb3V0ZXJSZXR1cm4iLCJsb2NhbFJvdXRlUGFyYW1ldGVycyIsInByZXYiLCJfcmVmNDQiLCJ1cmxUb1BhdGgiLCJvbGRIYXNoUGF0aCIsImhyZWYiLCJyZXF1ZXN0ZWRMb2NhbEhhc2giLCJfbG9jYWxQYXRoIiwiUm9vdFJvdXRlckVycm9yIiwidXNlUG9wTG9jYWxQYXRoIiwiZGlyIiwicG9wTG9jYWxQYXRoIiwibmV3SGFzaFBhdGgiLCJ1c2VQdXNoTG9jYWxQYXRoIiwicHVzaExvY2FsSGFzaCIsImtlZXBUcmFpbGluZyIsInVzZVNldExvY2FsUGF0aCIsInVzZVJvdXRlckNvbnRyb2xzIiwicHVzaExvY2FsUGF0aCIsIlJvdXRlckNvbnRleHQiLCJ1c2VQcm92aWRlUm91dGVyIiwiX3JlZjQ1IiwiX3EkIiwibWF0Y2hpbmdJbmRpY2VzIiwiZ2V0U2hvd2luZ0RlZmF1bHQiLCJzZXRTaG93aW5nRGVmYXVsdCIsInNob3dpbmdEZWZhdWx0Iiwib25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWQiLCJSb3V0ZXIiLCJfcmVmNDYiLCJfY29uc3VtZVJvdXRlclJldHVybiIsImNvbnRleHRGcm9tUGFyZW50IiwiY29udHJvbHMiLCJ1c2VTZWFyY2hQYXJhbXMiLCJwYXJhbUtleSIsIm9uUGFyYW1WYWx1ZUNoYW5nZWQiLCJnZXRTYXZlZFBhcmFtVmFsdWUiLCJzZXRTYXZlZFBhcmFtVmFsdWUiLCJzZXRQYXJhbVdpdGhIaXN0b3J5IiwibmV3VmFsdWVPclVwZGF0ZXIiLCJuZXdQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJwcmV0dHlQcmludFBhcmFtcyIsIm5ld1BhcmFtIiwicGFyYW1BcnJheSIsInF1ZXJ5U3RyaW5nIiwiX3JlZjQ3IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXhhbXBsZSIsInNldEV4YW1wbGVMb2NhbCIsImdldEV4YW1wbGUiLCJzZXRFeGFtcGxlIiwiX3JlZjQ4IiwiX2pzeHMiLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJvbklucHV0IiwiY3VycmVudFRhcmdldCIsInZhbHVlQXNOdW1iZXIiLCJMZXZlbDEiLCJfRnJhZ21lbnQiLCJfcmVmNDkiLCJnZXRFbGVtZW50QnlJZCJdLCJtYXBwaW5ncyI6Ijs7O0VBMEJhQSxJQUFBQSxDQUFBQTtJQ2ZQQyxHQ1JGQztJQUFBQSxHQUFBQTtJQ3lLQUMsR0FBQUE7SUFXQUM7SUFFRUMsR0EwQkFDO0lBQUFBLEdBQUFBO0lDak5LQyxHQ0ZFQztJQUFBQSxHQUFBQSxHQUFZLENBQUEsQ0FDWkM7SUFBQUEsR0FBQUEsR0FBWSxFQUNaQztJQUFBQSxHQUFBQSxHQUFxQixtRUFBQTtFTE9sQkMsU0FBQUEsR0FBQUEsQ0FBT0MsQ0FBS0MsRUFBQUEsQ0FBQUEsRUFBQUE7SUFFM0IsS0FBSyxJQUFJTixDQUFBQSxJQUFLTSxDQUFP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
