(function () {
  'use strict';

  var n,
    l$2,
    u$2,
    t$1,
    r$2,
    o$3,
    f$2,
    e$1 = {},
    c$2 = [],
    s$2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function a$2(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function h$2(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function v$2(l, u, i) {
    var t,
      r,
      o,
      f = {};
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);
    return y$2(l, f, t, r, null);
  }
  function y$2(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$2 : o
    };
    return null == o && null != l$2.vnode && l$2.vnode(f), f;
  }
  function d$2(n) {
    return n.children;
  }
  function _$2(n, l) {
    this.props = n, this.context = l;
  }
  function k$2(n, l) {
    if (null == l) return n.__ ? k$2(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? k$2(n) : null;
  }
  function b$1(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return b$1(n);
    }
  }
  function g$2(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !m$1.__r++ || r$2 !== l$2.debounceRendering) && ((r$2 = l$2.debounceRendering) || o$3)(m$1);
  }
  function m$1() {
    var n, l, u, i, r, o, f, e;
    for (t$1.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }); n = t$1.shift();) n.__d && (l = t$1.length, i = void 0, r = void 0, f = (o = (u = n).__v).__e, (e = u.__P) && (i = [], (r = a$2({}, o)).__v = o.__v + 1, z$2(e, o, r, u.__n, void 0 !== e.ownerSVGElement, null != o.__h ? [f] : null, i, null == f ? k$2(o) : f, o.__h), L$1(i, o), o.__e != f && b$1(o)), t$1.length > l && t$1.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }));
    m$1.__r = 0;
  }
  function w$2(n, l, u, i, t, r, o, f, s, a) {
    var h,
      v,
      p,
      _,
      b,
      g,
      m,
      w = i && i.__k || c$2,
      A = w.length;
    for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$2(null, _, null, null, _) : Array.isArray(_) ? y$2(d$2, {
      children: _
    }, null, null, null) : _.__b > 0 ? y$2(_.type, _.props, _.key, _.ref ? _.ref : null, _.__v) : _)) {
      if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
        if ((p = w[v]) && _.key == p.key && _.type === p.type) {
          w[v] = void 0;
          break;
        }
        p = null;
      }
      z$2(n, _, p = p || e$1, t, r, o, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (m || (m = []), p.ref && m.push(p.ref, null, _), m.push(v, _.__c || b, _)), null != b ? (null == g && (g = b), "function" == typeof _.type && _.__k === p.__k ? _.__d = s = x$1(_, s, n) : s = P(n, _, p, w, b, s), "function" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k$2(p));
    }
    for (u.__e = g, h = A; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = C$1(i).nextSibling), O(w[h], w[h]));
    if (m) for (h = 0; h < m.length; h++) N$1(m[h], m[++h], m[++h]);
  }
  function x$1(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? x$1(i, l, u) : P(u, i, i, t, i.__e, l));
    return l;
  }
  function A$1(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      A$1(n, l);
    }) : l.push(n)), l;
  }
  function P(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1) if (f == t) break n;
      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }
  function C$1(n) {
    var l, u, i;
    if (null == n.type || "string" == typeof n.type) return n.__e;
    if (n.__k) for (l = n.__k.length - 1; l >= 0; l--) if ((u = n.__k[l]) && (i = C$1(u))) return i;
    return null;
  }
  function $(n, l, u, i, t) {
    var r;
    for (r in u) "children" === r || "key" === r || r in l || I$1(n, r, null, u[r], i);
    for (r in l) t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || I$1(n, r, l[r], u[r], i);
  }
  function H$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || s$2.test(l) ? u : u + "px";
  }
  function I$1(n, l, u, i, t) {
    var r;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || H$1(n.style, l, "");
        if (u) for (l in u) i && u[l] === i[l] || H$1(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? j$1 : T$2, r) : n.removeEventListener(l, r ? j$1 : T$2, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function T$2(n) {
    return this.l[n.type + !1](l$2.event ? l$2.event(n) : n);
  }
  function j$1(n) {
    return this.l[n.type + !0](l$2.event ? l$2.event(n) : n);
  }
  function z$2(n, u, i, t, r, o, f, e, c) {
    var s,
      h,
      v,
      y,
      p,
      k,
      b,
      g,
      m,
      x,
      A,
      P,
      C,
      $,
      H,
      I = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$2.__b) && s(u);
    try {
      n: if ("function" == typeof I) {
        if (g = u.props, m = (s = I.contextType) && t[s.__c], x = s ? m ? m.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in I && I.prototype.render ? u.__c = h = new I(g, x) : (u.__c = h = new _$2(g, x), h.constructor = I, h.render = S), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != I.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$2({}, h.__s)), a$2(h.__s, I.getDerivedStateFromProps(g, h.__s))), y = h.props, p = h.state, h.__v = u, v) null == I.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
          if (null == I.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
            for (u.__v !== i.__v && (h.props = g, h.state = h.__s, h.__d = !1), h.__e = !1, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < h._sb.length; A++) h.__h.push(h._sb[A]);
            h._sb = [], h.__h.length && f.push(h);
            break n;
          }
          null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
            h.componentDidUpdate(y, p, k);
          });
        }
        if (h.context = x, h.props = g, h.__P = n, P = l$2.__r, C = 0, "prototype" in I && I.prototype.render) {
          for (h.state = h.__s, h.__d = !1, P && P(u), s = h.render(h.props, h.state, h.context), $ = 0; $ < h._sb.length; $++) h.__h.push(h._sb[$]);
          h._sb = [];
        } else do {
          h.__d = !1, P && P(u), s = h.render(h.props, h.state, h.context), h.state = h.__s;
        } while (h.__d && ++C < 25);
        h.state = h.__s, null != h.getChildContext && (t = a$2(a$2({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), H = null != s && s.type === d$2 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(H) ? H : [H], u, i, t, r, o, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = M(i.__e, u, i, t, r, o, f, c);
      (s = l$2.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$2.__e(n, u, i);
    }
  }
  function L$1(n, u) {
    l$2.__c && l$2.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$2.__e(n, u.__v);
      }
    });
  }
  function M(l, u, i, t, r, o, f, c) {
    var s,
      a,
      v,
      y = i.props,
      p = u.props,
      d = u.type,
      _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
      l = s, o[_] = null;
      break;
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
        (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
      }
      if ($(l, p, y, r, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && k$2(i, 0), c), null != o) for (_ = o.length; _--;) null != o[_] && h$2(o[_]);
      c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && I$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && I$1(l, "checked", _, y.checked, !1));
    }
    return l;
  }
  function N$1(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$2.__e(n, i);
    }
  }
  function O(n, u, i) {
    var t, r;
    if (l$2.unmount && l$2.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || N$1(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$2.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && O(t[r], u, i || "function" != typeof n.type);
    i || null == n.__e || h$2(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function S(n, l, u) {
    return this.constructor(n, u);
  }
  function q$1(u, i, t) {
    var r, o, f;
    l$2.__ && l$2.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], z$2(i, u = (!r && t || i).__k = v$2(d$2, null, [u]), o || e$1, e$1, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), L$1(f, u);
  }
  function D$1(l, u, i) {
    var t,
      r,
      o,
      f = a$2({}, l.props);
    for (o in u) "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$2(l.type, f, t || l.key, r || l.ref, null);
  }
  function E(n, l) {
    var u = {
      __c: l = "__cC" + f$2++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(function (n) {
            n.__e = !0, g$2(n);
          });
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = c$2.slice, l$2 = {
    __e: function (n, l, u, i) {
      for (var t, r, o; l = l.__;) if ((t = l.__c) && !t.__) try {
        if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$2 = 0, _$2.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$2({}, this.state), "function" == typeof n && (n = n(a$2({}, u), this.props)), n && a$2(u, n), null != n && this.__v && (l && this._sb.push(l), g$2(this));
  }, _$2.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), g$2(this));
  }, _$2.prototype.render = d$2, t$1 = [], o$3 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, m$1.__r = 0, f$2 = 0;
  var _$1 = 0;
  function o$2(o, e, n, t, f, l) {
    var s,
      u,
      a = {};
    for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
    var i = {
      type: o,
      props: a,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: l
    };
    if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
    return l$2.vnode && l$2.vnode(i), i;
  }
  var t,
    r$1,
    u$1,
    i$1,
    o$1 = 0,
    f$1 = [],
    c$1 = [],
    e = l$2.__b,
    a$1 = l$2.__r,
    v$1 = l$2.diffed,
    l$1 = l$2.__c,
    m = l$2.unmount;
  function d$1(t, u) {
    l$2.__h && l$2.__h(r$1, t, o$1 || u), o$1 = 0;
    var i = r$1.__H || (r$1.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c$1
    }), i.__[t];
  }
  function p$1(n) {
    return o$1 = 1, y$1(B$1, n);
  }
  function y$1(n, u, i) {
    var o = d$1(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$1, !r$1.u)) {
      r$1.u = !0;
      var f = r$1.shouldComponentUpdate;
      r$1.shouldComponentUpdate = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !f || f.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
      };
    }
    return o.__N || o.__;
  }
  function h$1(u, i) {
    var o = d$1(t++, 3);
    !l$2.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
  }
  function s$1(u, i) {
    var o = d$1(t++, 4);
    !l$2.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
  }
  function _(n) {
    return o$1 = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o$1 = 6, s$1(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d$1(t++, 7);
    return z$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o$1 = 8, F$1(function () {
      return n;
    }, t);
  }
  function q(n) {
    var u = r$1.context[n.__c],
      i = d$1(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
  }
  function b() {
    for (var t; t = f$1.shift();) if (t.__P && t.__H) try {
      t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
    } catch (r) {
      t.__H.__h = [], l$2.__e(r, t.__v);
    }
  }
  l$2.__b = function (n) {
    r$1 = null, e && e(n);
  }, l$2.__r = function (n) {
    a$1 && a$1(n), t = 0;
    var i = (r$1 = n.__c).__H;
    i && (u$1 === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c$1, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u$1 = r$1;
  }, l$2.diffed = function (t) {
    v$1 && v$1(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f$1.push(o) && i$1 === l$2.requestAnimationFrame || ((i$1 = l$2.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c$1 && (n.__ = n.__V), n.i = void 0, n.__V = c$1;
    })), u$1 = r$1 = null;
  }, l$2.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$2.__e(u, t.__v);
      }
    }), l$1 && l$1(t, r);
  }, l$2.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$2.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$1,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
  }
  function w$1(n) {
    var t = r$1;
    n.__c = n.__(), r$1 = t;
  }
  function z$1(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$2 = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$3 = freeGlobal$2;

  /** Detect free variable `self`. */
  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$2 = freeGlobal$3 || freeSelf$1 || Function('return this')();
  var root$3 = root$2;

  /** Built-in value references. */
  var Symbol$3 = root$3.Symbol;
  var Symbol$4 = Symbol$3;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$3 = objectProto$9.toString;

  /** Built-in value references. */
  var symToStringTag$3 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$7.call(value, symToStringTag$3),
      tag = value[symToStringTag$3];
    try {
      value[symToStringTag$3] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$3.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$3] = tag;
      } else {
        delete value[symToStringTag$3];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$2 = objectProto$8.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString$2.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag$1 = '[object Null]',
    undefinedTag$1 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$2 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$1 : nullTag$1;
    }
    return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag$1 = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag$1 = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$1(value);
    return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData$2 = root$3['__core-js_shared__'];
  var coreJsData$3 = coreJsData$2;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey$1 = function () {
    var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey$1 && maskSrcKey$1 in func;
  }

  /** Used for built-in method references. */
  var funcProto$3 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$3 = funcProto$3.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$3.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
    objectProto$7 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative$1 = RegExp('^' + funcToString$2.call(hasOwnProperty$6).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$1(value) || isMasked$1(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
    return pattern.test(toSource$1(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$1(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative$1(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$1(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate$2 = getNative$1(Object, 'create');
  var nativeCreate$3 = nativeCreate$2;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$3) {
      var result = data[key];
      return result === HASH_UNDEFINED$3 ? undefined : result;
    }
    return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$3 ? data[key] !== undefined : hasOwnProperty$4.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$3 && value === undefined ? HASH_UNDEFINED$2 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear$1;
  Hash$1.prototype['delete'] = hashDelete$1;
  Hash$1.prototype.get = hashGet$1;
  Hash$1.prototype.has = hashHas$1;
  Hash$1.prototype.set = hashSet$1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$1(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto$1 = Array.prototype;

  /** Built-in value references. */
  var splice$1 = arrayProto$1.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice$1.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
      index = assocIndexOf$1(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$1.prototype.clear = listCacheClear$1;
  ListCache$1.prototype['delete'] = listCacheDelete$1;
  ListCache$1.prototype.get = listCacheGet$1;
  ListCache$1.prototype.has = listCacheHas$1;
  ListCache$1.prototype.set = listCacheSet$1;

  /* Built-in method references that are verified to be native. */
  var Map$3 = getNative$1(root$3, 'Map');
  var Map$4 = Map$3;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash$1(),
      'map': new (Map$4 || ListCache$1)(),
      'string': new Hash$1()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable$1(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$1(map, key) {
    var data = map.__data__;
    return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$1(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$1(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData$1(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$1.prototype.clear = mapCacheClear$1;
  MapCache$1.prototype['delete'] = mapCacheDelete$1;
  MapCache$1.prototype.get = mapCacheGet$1;
  MapCache$1.prototype.has = mapCacheHas$1;
  MapCache$1.prototype.set = mapCacheSet$1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache$1)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache$1;
  function getBuildModeUnmemoized$1() {
    try {
      var _process, _process$env;
      if (((_process = process) === null || _process === void 0 ? void 0 : (_process$env = _process.env) === null || _process$env === void 0 ? void 0 : _process$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode$1 = memoize$1(getBuildModeUnmemoized$1);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability$1(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    if (getBuildMode$1() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering$1(f) {
    var _l$2$debounceRenderin;
    ((_l$2$debounceRenderin = l$2.debounceRendering) !== null && _l$2$debounceRenderin !== void 0 ? _l$2$debounceRenderin : setTimeout)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState$1(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$3);
    const reasonRef = _(Unset$3);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$3);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability$1("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$3 && getInitialValue != undefined) {
        try {
          var _onChange;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$3) tryEnsureValue();
      return valueRef.current === Unset$3 ? undefined : valueRef.current;
    }, []);
    s$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$3 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$3 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering$1)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$3 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$3;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$3 = Symbol();
  function returnNull$1() {
    return null;
  }
  const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64$1(value) {
    return Table$1[value];
  }
  function random6Bits$1() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits$1() {
    return [random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1(), random6Bits$1()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId$1(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits$1().map(n => base64$1(n)).join(""));
  }
  const previousInputs$1 = new Map();
  const toRun$1 = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName$1 = "diffed";
  const originalCommit$1 = l$2[commitName$1];
  const newCommit$1 = function () {
    for (const [id, effectInfo] of toRun$1) {
      const oldInputs = previousInputs$1.get(id);
      if (argsChanged$1(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs$1.set(id, effectInfo.inputs);
      }
    }
    toRun$1.clear();
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    originalCommit$1 === null || originalCommit$1 === void 0 ? void 0 : originalCommit$1(...args);
  };
  l$2[commitName$1] = newCommit$1;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect$1(effect, inputs) {
    /*(() => {
        const cleanup = useRef<void | (() => void) | null>(null);
        const prevArgsRef = useRef<Inputs>(null!);
        if (argsChanged(inputs, prevArgsRef.current)) {
            prevArgsRef.current = inputs!;
            if (cleanup.current)
                cleanup.current();
            cleanup.current = effect();
        }
    })();*/
    const [id] = p$1(() => generateRandomId$1());
    if (effect) toRun$1.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun$1.delete(id);
    h$1(() => {
      return () => {
        toRun$1.delete(id);
        previousInputs$1.delete(id);
      };
    }, [id]);
  }
  function argsChanged$1(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset$2 = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter$1(value) {
    const ref = _(Unset$2);
    useBeforeLayoutEffect$1(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset$2) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject$1(t) {
    const e = Object.entries(t);
    useEnsureStability$1("useStableObject", e.length, ...e.map(_ref => {
      let [_k, v] = _ref;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map$1 = new WeakMap();
  function isStableGetter$1(obj) {
    var _map$1$get;
    return (_map$1$get = map$1.get(obj)) !== null && _map$1$get !== void 0 ? _map$1$get : false;
  }
  function setIsStableGetter$1(obj) {
    map$1.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback$1(fn, noDeps) {
    useEnsureStability$1("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter$1(fn));
    if (isStableGetter$1(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter$1(fn);
      return setIsStableGetter$1(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter$1(T$1(fn, []));
    }
  }

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * Due to typing limitations, this function must be called like this:
   *
   * `useEventHandler(element, "input")<InputEvent>(e => {})`
   *
   * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
   *
   * There is a separate version that attaches event handlers to a set of props.
   * It takes different event string types (onEvent vs onevent).
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options, mode) {
    mode || (mode = "grouped");
    useEnsureStability$1("useGlobalHandler", mode);
    if (mode === "grouped") {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      useGlobalHandlerGrouped(target, type, handler, options);
    } else {
      useGlobalHandlerSingle(target, type, handler, options);
    }
  }
  let mapThing = new Map();
  function doMapThing(op, target, type, handler, options) {
    if (handler) {
      const optionsKey = JSON.stringify(options);
      const byType = mapThing.get(target) || new Map();
      const byOptions = byType.get(type) || new Map();
      const info = byOptions.get(optionsKey) || {
        listener: null,
        listeners: new Set()
      };
      op(info, handler);
      byOptions.set(optionsKey, info);
      byType.set(type, byOptions);
      mapThing.set(target, byType);
    }
  }
  function addToMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.add(h);
      if (info.listener == null) target.addEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  function removeFromMapThing(target, type, handler, options) {
    doMapThing((info, h) => {
      info.listeners.delete(h);
      if (info.listener == null) target.removeEventListener(type, info.listener = e => info.listeners.forEach(fn => fn(e)), options);
    }, target, type, handler, options);
  }
  /**
   * This is way faster for large numbers of event handlers.
   *
   * For example, if every button listens for a global click, or something,
   * it would be nice if it was efficient at least.
   */
  function useGlobalHandlerGrouped(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h$1(() => {
      if (stableHandler) {
        addToMapThing(target, type, stableHandler, options);
        return () => removeFromMapThing(target, type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }
  function useGlobalHandlerSingle(target, type, handler, options) {
    let stableHandler = useStableCallback$1(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h$1(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck$1(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass$1(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck$1(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass$1(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck$1(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass$1(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren$1(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability$1("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering$1(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering$1(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject$1({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        return managedChildrenArray.current.arr.slice();
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject$1({
        managedChildContext: useStableObject$1({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild$1(info, managedChildParameters) {
    var _info$context;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context = info.context) !== null && _info$context !== void 0 ? _info$context : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState$1(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = p$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = () => {
      return ref.current;
    };
    console.assert(ref.current === state || typeof state === "number" && isNaN(state));
    return [state, setState, getState];
  }
  function g(n, t) {
    for (var e in t) n[e] = t[e];
    return n;
  }
  function C(n, t) {
    for (var e in n) if ("__source" !== e && !(e in t)) return !0;
    for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function x(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, v$2(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new _$2()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var R = l$2.__b;
  l$2.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$2.__e;
  l$2.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    T(n, t, e, r);
  };
  var I = l$2.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$2.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new _$2()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && v$2(d$2, null, n.fallback);
    return i && (i.__h = null), [v$2(d$2, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) e.pop()();
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  (V.prototype = new _$2()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = A$1(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var z = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    H = "undefined" != typeof document,
    Z = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };
  _$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(_$2.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var G = l$2.event;
  function J() {}
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l$2.event = function (n) {
    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;
  };
  var nn = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    tn = l$2.vnode;
  l$2.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      var o = -1 === t.indexOf("-");
      for (var i in u = {}, e) {
        var l = e[i];
        H && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = A$1(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = A$1(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (nn.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", nn));
    }
    n.$$typeof = z, tn && tn(n);
  };
  var en = l$2.__r;
  l$2.__r = function (n) {
    en && en(n), n.__c;
  };
  var rn = l$2.diffed;
  l$2.diffed = function (n) {
    rn && rn(n);
    var t = n.props,
      e = n.__e;
    null != e && "textarea" === n.type && "value" in t && t.value !== e.value && (e.value = null == t.value ? "" : t.value);
  };
  E(null);
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();
  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$4.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$3.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];
  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');
  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');
  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;
  function getBuildModeUnmemoized() {
    try {
      var _process2, _process2$env;
      if (((_process2 = process) === null || _process2 === void 0 ? void 0 : (_process2$env = _process2.env) === null || _process2$env === void 0 ? void 0 : _process2$env.NODE_ENV) === 'development') return 'development';
      return 'production';
    } catch (_e) {
      return "production";
    }
  }
  const getBuildMode = memoize(getBuildModeUnmemoized);

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      values[_key3 - 1] = arguments[_key3];
    }
    if (getBuildMode() == 'production') return;
    const helperToEnsureStability = _([]);
    const shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      const index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$2$debounceRenderin2;
    ((_l$2$debounceRenderin2 = l$2.debounceRendering) !== null && _l$2$debounceRenderin2 !== void 0 ? _l$2$debounceRenderin2 : setTimeout)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    const valueRef = _(Unset$1);
    const reasonRef = _(Unset$1);
    const warningRef = _(false);
    const dependencyToCompareAgainst = _(Unset$1);
    const cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    const onShouldCleanUp = T$1(() => {
      const cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    const tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange3;
          const initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange3 = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange3 !== void 0 ? _onChange3 : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    const getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    s$1(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    const setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          const nextReason = reasonRef.current;
          const nextDep = valueRef.current;
          const prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange4;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange4 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange4 !== void 0 ? _onChange4 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  const Unset$1 = Symbol();
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }
  const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  const previousInputs = new Map();
  const toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  const commitName = "diffed";
  const originalCommit = l$2[commitName];
  const newCommit = function () {
    for (const [id, effectInfo] of toRun) {
      const oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup2;
        (_effectInfo$cleanup2 = effectInfo.cleanup) === null || _effectInfo$cleanup2 === void 0 ? void 0 : _effectInfo$cleanup2.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$2[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    /*(() => {
        const cleanup = useRef<void | (() => void) | null>(null);
        const prevArgsRef = useRef<Inputs>(null!);
        if (argsChanged(inputs, prevArgsRef.current)) {
            prevArgsRef.current = inputs!;
            if (cleanup.current)
                cleanup.current();
            cleanup.current = effect();
        }
    })();*/
    const [id] = p$1(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    h$1(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  const Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    const ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    const e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref2 => {
      let [_k, v] = _ref2;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  const map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      const currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return v$2(d$2, {}, lhs, rhs);
    }
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
    function combined(current) {
      processRef(current, lhs);
      processRef(current, rhs);
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return {
      ...(lhs !== null && lhs !== void 0 ? lhs : {}),
      ...(rhs !== null && rhs !== void 0 ? rhs : {})
    };
  }
  let log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len5 = arguments.length, allProps = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      allProps[_key5] = arguments[_key5];
    }
    useEnsureStability("useMergedProps", allProps.length);
    let ret = {};
    for (let nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  const knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      const merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) {
        // I mean, they're the same value at least
        // so we don't need to do anything.
        // Not really ideal though.
        return rhsValue;
      } else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    const ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (const lhsKeyU in lhsAll) {
      const lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (const rhsKeyU in rhsAll) {
      const rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      const lv = lhs(...arguments);
      const rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    const {
      onElementChange,
      onMount,
      onUnmount
    } = args.refElementParameters || {};
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    const handler = T$1((e, prevValue) => {
      const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    const propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    const _blockingElements = Symbol();
    const _alreadyInertElements = Symbol();
    const _topElParents = Symbol();
    const _siblingsToRestore = Symbol();
    const _parentMO = Symbol();
    /* Symbols for private static methods */
    const _topChanged = Symbol();
    const _swapInertedSibling = Symbol();
    const _inertSiblings = Symbol();
    const _restoreInertedSiblings = Symbol();
    const _getParents = Symbol();
    const _getDistributedChildren = Symbol();
    const _isInertable = Symbol();
    const _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        const nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        const elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        const i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        const top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        const toKeepInert = this[_alreadyInertElements];
        const oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        const newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        const toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        let i = oldParents.length - 1;
        let j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        const siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (const element of elements) {
          const mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          const siblings = element[_siblingsToRestore];
          for (const sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (const element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          const parent = element.parentNode;
          const children = parent.children;
          const inertedSiblings = new Set();
          for (let j = 0; j < children.length; j++) {
            const sibling = children[j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          const mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          let parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          const maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        const parents = this[_topElParents];
        const toKeepInert = this[_alreadyInertElements];
        for (const mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          const target = mutation.target.host || mutation.target;
          const idx = target === document.body ? parents.length : parents.indexOf(target);
          const inertedChild = parents[idx - 1];
          const inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            const sibling = mutation.removedNodes[i];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const sibling = mutation.addedNodes[i];
            if (!this[_isInertable](sibling)) {
              continue;
            }
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        const parents = [];
        let current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        const shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        const result = new Set();
        let i;
        let j;
        let nodes;
        const slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /**
   * This work is licensed under the W3C Software and Document License
   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
   */

  (function () {
    // Return early if we're not running inside of the browser.
    if (typeof window === 'undefined') {
      return;
    }

    // Convenience function for converting NodeLists.
    /** @type {typeof Array.prototype.slice} */
    var slice = Array.prototype.slice;

    /**
     * IE has a non-standard name for "matches".
     * @type {typeof Element.prototype.matches}
     */
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    /** @type {string} */
    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    /**
     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
     * attribute.
     *
     * Its main functions are:
     *
     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
     *   instance exists for each focusable node which has at least one inert root as an ancestor.
     *
     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
     *   attribute is removed from the root node). This is handled in the destructor, which calls the
     *   `deregister` method on `InertManager` for each managed inert node.
     */

    var InertRoot = function () {
      /**
       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
       * @param {!InertManager} inertManager The global singleton InertManager object.
       */
      function InertRoot(rootElement, inertManager) {
        _classCallCheck(this, InertRoot);

        /** @type {!InertManager} */
        this._inertManager = inertManager;

        /** @type {!HTMLElement} */
        this._rootElement = rootElement;

        /**
         * @type {!Set<!InertNode>}
         * All managed focusable nodes in this InertRoot's subtree.
         */
        this._managedNodes = new Set();

        // Make the subtree hidden from assistive technology
        if (this._rootElement.hasAttribute('aria-hidden')) {
          /** @type {?string} */
          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
        } else {
          this._savedAriaHidden = null;
        }
        this._rootElement.setAttribute('aria-hidden', 'true');

        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
        this._makeSubtreeUnfocusable(this._rootElement);

        // Watch for:
        // - any additions in the subtree: make them unfocusable too
        // - any removals from the subtree: remove them from this inert root's managed nodes
        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
        //   element, make that node a managed node.
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(this._rootElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      /**
       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
       * stored in this object and updates the state of all of the managed nodes.
       */

      _createClass(InertRoot, [{
        key: 'destructor',
        value: function destructor() {
          this._observer.disconnect();
          if (this._rootElement) {
            if (this._savedAriaHidden !== null) {
              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
            } else {
              this._rootElement.removeAttribute('aria-hidden');
            }
          }
          this._managedNodes.forEach(function (inertNode) {
            this._unmanageNode(inertNode.node);
          }, this);

          // Note we cast the nulls to the ANY type here because:
          // 1) We want the class properties to be declared as non-null, or else we
          //    need even more casts throughout this code. All bets are off if an
          //    instance has been destroyed and a method is called.
          // 2) We don't want to cast "this", because we want type-aware optimizations
          //    to know which properties we're setting.
          this._observer = /** @type {?} */null;
          this._rootElement = /** @type {?} */null;
          this._managedNodes = /** @type {?} */null;
          this._inertManager = /** @type {?} */null;
        }

        /**
         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
         */
      }, {
        key: '_makeSubtreeUnfocusable',
        /**
         * @param {!Node} startNode
         */
        value: function _makeSubtreeUnfocusable(startNode) {
          var _this2 = this;
          composedTreeWalk(startNode, function (node) {
            return _this2._visitNode(node);
          });
          var activeElement = document.activeElement;
          if (!document.body.contains(startNode)) {
            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
            var node = startNode;
            /** @type {!ShadowRoot|undefined} */
            var root = undefined;
            while (node) {
              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                root = /** @type {!ShadowRoot} */node;
                break;
              }
              node = node.parentNode;
            }
            if (root) {
              activeElement = root.activeElement;
            }
          }
          if (startNode.contains(activeElement)) {
            activeElement.blur();
            // In IE11, if an element is already focused, and then set to tabindex=-1
            // calling blur() will not actually move the focus.
            // To work around this we call focus() on the body instead.
            if (activeElement === document.activeElement) {
              document.body.focus();
            }
          }
        }

        /**
         * @param {!Node} node
         */
      }, {
        key: '_visitNode',
        value: function _visitNode(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */node;

          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
          if (element !== this._rootElement && element.hasAttribute('inert')) {
            this._adoptInertRoot(element);
          }
          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
            this._manageNode(element);
          }
        }

        /**
         * Register the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_manageNode',
        value: function _manageNode(node) {
          var inertNode = this._inertManager.register(node, this);
          this._managedNodes.add(inertNode);
        }

        /**
         * Unregister the given node with this InertRoot and with InertManager.
         * @param {!Node} node
         */
      }, {
        key: '_unmanageNode',
        value: function _unmanageNode(node) {
          var inertNode = this._inertManager.deregister(node, this);
          if (inertNode) {
            this._managedNodes['delete'](inertNode);
          }
        }

        /**
         * Unregister the entire subtree starting at `startNode`.
         * @param {!Node} startNode
         */
      }, {
        key: '_unmanageSubtree',
        value: function _unmanageSubtree(startNode) {
          var _this3 = this;
          composedTreeWalk(startNode, function (node) {
            return _this3._unmanageNode(node);
          });
        }

        /**
         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
         * @param {!HTMLElement} node
         */
      }, {
        key: '_adoptInertRoot',
        value: function _adoptInertRoot(node) {
          var inertSubroot = this._inertManager.getInertRoot(node);

          // During initialisation this inert root may not have been registered yet,
          // so register it now if need be.
          if (!inertSubroot) {
            this._inertManager.setInert(node, true);
            inertSubroot = this._inertManager.getInertRoot(node);
          }
          inertSubroot.managedNodes.forEach(function (savedInertNode) {
            this._manageNode(savedInertNode.node);
          }, this);
        }

        /**
         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_onMutation',
        value: function _onMutation(records, self) {
          records.forEach(function (record) {
            var target = /** @type {!HTMLElement} */record.target;
            if (record.type === 'childList') {
              // Manage added nodes
              slice.call(record.addedNodes).forEach(function (node) {
                this._makeSubtreeUnfocusable(node);
              }, this);

              // Un-manage removed nodes
              slice.call(record.removedNodes).forEach(function (node) {
                this._unmanageSubtree(node);
              }, this);
            } else if (record.type === 'attributes') {
              if (record.attributeName === 'tabindex') {
                // Re-initialise inert node if tabindex changes
                this._manageNode(target);
              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                // already managed nodes from this inert subroot.
                this._adoptInertRoot(target);
                var inertSubroot = this._inertManager.getInertRoot(target);
                this._managedNodes.forEach(function (managedNode) {
                  if (target.contains(managedNode.node)) {
                    inertSubroot._manageNode(managedNode.node);
                  }
                });
              }
            }
          }, this);
        }
      }, {
        key: 'managedNodes',
        get: function get() {
          return new Set(this._managedNodes);
        }

        /** @return {boolean} */
      }, {
        key: 'hasSavedAriaHidden',
        get: function get() {
          return this._savedAriaHidden !== null;
        }

        /** @param {?string} ariaHidden */
      }, {
        key: 'savedAriaHidden',
        set: function set(ariaHidden) {
          this._savedAriaHidden = ariaHidden;
        }

        /** @return {?string} */,

        get: function get() {
          return this._savedAriaHidden;
        }
      }]);
      return InertRoot;
    }();

    /**
     * `InertNode` initialises and manages a single inert node.
     * A node is inert if it is a descendant of one or more inert root elements.
     *
     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
     * is intrinsically focusable or not.
     *
     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
     * or removes the `tabindex` attribute if the element is intrinsically focusable.
     */

    var InertNode = function () {
      /**
       * @param {!Node} node A focusable element to be made inert.
       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
       */
      function InertNode(node, inertRoot) {
        _classCallCheck(this, InertNode);

        /** @type {!Node} */
        this._node = node;

        /** @type {boolean} */
        this._overrodeFocusMethod = false;

        /**
         * @type {!Set<!InertRoot>} The set of descendant inert roots.
         *    If and only if this set becomes empty, this node is no longer inert.
         */
        this._inertRoots = new Set([inertRoot]);

        /** @type {?number} */
        this._savedTabIndex = null;

        /** @type {boolean} */
        this._destroyed = false;

        // Save any prior tabindex info and make this node untabbable
        this.ensureUntabbable();
      }

      /**
       * Call this whenever this object is about to become obsolete.
       * This makes the managed node focusable again and deletes all of the previously stored state.
       */

      _createClass(InertNode, [{
        key: 'destructor',
        value: function destructor() {
          this._throwIfDestroyed();
          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */this._node;
            if (this._savedTabIndex !== null) {
              element.setAttribute('tabindex', this._savedTabIndex);
            } else {
              element.removeAttribute('tabindex');
            }

            // Use `delete` to restore native focus method.
            if (this._overrodeFocusMethod) {
              delete element.focus;
            }
          }

          // See note in InertRoot.destructor for why we cast these nulls to ANY.
          this._node = /** @type {?} */null;
          this._inertRoots = /** @type {?} */null;
          this._destroyed = true;
        }

        /**
         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
         * If the object has been destroyed, any attempt to access it will cause an exception.
         */
      }, {
        key: '_throwIfDestroyed',
        /**
         * Throw if user tries to access destroyed InertNode.
         */
        value: function _throwIfDestroyed() {
          if (this.destroyed) {
            throw new Error('Trying to access destroyed InertNode');
          }
        }

        /** @return {boolean} */
      }, {
        key: 'ensureUntabbable',
        /** Save the existing tabindex value and make the node untabbable and unfocusable */
        value: function ensureUntabbable() {
          if (this.node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          var element = /** @type {!HTMLElement} */this.node;
          if (matches.call(element, _focusableElementsString)) {
            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
              return;
            }
            if (element.hasAttribute('tabindex')) {
              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            }
            element.setAttribute('tabindex', '-1');
            if (element.nodeType === Node.ELEMENT_NODE) {
              element.focus = function () {};
              this._overrodeFocusMethod = true;
            }
          } else if (element.hasAttribute('tabindex')) {
            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
            element.removeAttribute('tabindex');
          }
        }

        /**
         * Add another inert root to this inert node's set of managing inert roots.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'addInertRoot',
        value: function addInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots.add(inertRoot);
        }

        /**
         * Remove the given inert root from this inert node's set of managing inert roots.
         * If the set of managing inert roots becomes empty, this node is no longer inert,
         * so the object should be destroyed.
         * @param {!InertRoot} inertRoot
         */
      }, {
        key: 'removeInertRoot',
        value: function removeInertRoot(inertRoot) {
          this._throwIfDestroyed();
          this._inertRoots['delete'](inertRoot);
          if (this._inertRoots.size === 0) {
            this.destructor();
          }
        }
      }, {
        key: 'destroyed',
        get: function get() {
          return (/** @type {!InertNode} */this._destroyed
          );
        }
      }, {
        key: 'hasSavedTabIndex',
        get: function get() {
          return this._savedTabIndex !== null;
        }

        /** @return {!Node} */
      }, {
        key: 'node',
        get: function get() {
          this._throwIfDestroyed();
          return this._node;
        }

        /** @param {?number} tabIndex */
      }, {
        key: 'savedTabIndex',
        set: function set(tabIndex) {
          this._throwIfDestroyed();
          this._savedTabIndex = tabIndex;
        }

        /** @return {?number} */,

        get: function get() {
          this._throwIfDestroyed();
          return this._savedTabIndex;
        }
      }]);
      return InertNode;
    }();

    /**
     * InertManager is a per-document singleton object which manages all inert roots and nodes.
     *
     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
     * is created for each such node, via the `_managedNodes` map.
     */

    var InertManager = function () {
      /**
       * @param {!Document} document
       */
      function InertManager(document) {
        _classCallCheck(this, InertManager);
        if (!document) {
          throw new Error('Missing required argument; InertManager needs to wrap a document.');
        }

        /** @type {!Document} */
        this._document = document;

        /**
         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertNode>}
         */
        this._managedNodes = new Map();

        /**
         * All inert roots known to this InertManager. In a map to allow looking up by Node.
         * @type {!Map<!Node, !InertRoot>}
         */
        this._inertRoots = new Map();

        /**
         * Observer for mutations on `document.body`.
         * @type {!MutationObserver}
         */
        this._observer = new MutationObserver(this._watchForInert.bind(this));

        // Add inert style.
        addInertStyle(document.head || document.body || document.documentElement);

        // Wait for document to be loaded.
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
        } else {
          this._onDocumentLoaded();
        }
      }

      /**
       * Set whether the given element should be an inert root or not.
       * @param {!HTMLElement} root
       * @param {boolean} inert
       */

      _createClass(InertManager, [{
        key: 'setInert',
        value: function setInert(root, inert) {
          if (inert) {
            if (this._inertRoots.has(root)) {
              // element is already inert
              return;
            }
            var inertRoot = new InertRoot(root, this);
            root.setAttribute('inert', '');
            this._inertRoots.set(root, inertRoot);
            // If not contained in the document, it must be in a shadowRoot.
            // Ensure inert styles are added there.
            if (!this._document.body.contains(root)) {
              var parent = root.parentNode;
              while (parent) {
                if (parent.nodeType === 11) {
                  addInertStyle(parent);
                }
                parent = parent.parentNode;
              }
            }
          } else {
            if (!this._inertRoots.has(root)) {
              // element is already non-inert
              return;
            }
            var _inertRoot = this._inertRoots.get(root);
            _inertRoot.destructor();
            this._inertRoots['delete'](root);
            root.removeAttribute('inert');
          }
        }

        /**
         * Get the InertRoot object corresponding to the given inert root element, if any.
         * @param {!Node} element
         * @return {!InertRoot|undefined}
         */
      }, {
        key: 'getInertRoot',
        value: function getInertRoot(element) {
          return this._inertRoots.get(element);
        }

        /**
         * Register the given InertRoot as managing the given node.
         * In the case where the node has a previously existing inert root, this inert root will
         * be added to its set of inert roots.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {!InertNode} inertNode
         */
      }, {
        key: 'register',
        value: function register(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (inertNode !== undefined) {
            // node was already in an inert subtree
            inertNode.addInertRoot(inertRoot);
          } else {
            inertNode = new InertNode(node, inertRoot);
          }
          this._managedNodes.set(node, inertNode);
          return inertNode;
        }

        /**
         * De-register the given InertRoot as managing the given inert node.
         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
         * node from the InertManager's set of managed nodes if it is destroyed.
         * If the node is not currently managed, this is essentially a no-op.
         * @param {!Node} node
         * @param {!InertRoot} inertRoot
         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
         */
      }, {
        key: 'deregister',
        value: function deregister(node, inertRoot) {
          var inertNode = this._managedNodes.get(node);
          if (!inertNode) {
            return null;
          }
          inertNode.removeInertRoot(inertRoot);
          if (inertNode.destroyed) {
            this._managedNodes['delete'](node);
          }
          return inertNode;
        }

        /**
         * Callback used when document has finished loading.
         */
      }, {
        key: '_onDocumentLoaded',
        value: function _onDocumentLoaded() {
          // Find all inert roots in document and make them actually inert.
          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
          inertElements.forEach(function (inertElement) {
            this.setInert(inertElement, true);
          }, this);

          // Comment this out to use programmatic API only.
          this._observer.observe(this._document.body || this._document.documentElement, {
            attributes: true,
            subtree: true,
            childList: true
          });
        }

        /**
         * Callback used when mutation observer detects attribute changes.
         * @param {!Array<!MutationRecord>} records
         * @param {!MutationObserver} self
         */
      }, {
        key: '_watchForInert',
        value: function _watchForInert(records, self) {
          var _this = this;
          records.forEach(function (record) {
            switch (record.type) {
              case 'childList':
                slice.call(record.addedNodes).forEach(function (node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) {
                    return;
                  }
                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
                  if (matches.call(node, '[inert]')) {
                    inertElements.unshift(node);
                  }
                  inertElements.forEach(function (inertElement) {
                    this.setInert(inertElement, true);
                  }, _this);
                }, _this);
                break;
              case 'attributes':
                if (record.attributeName !== 'inert') {
                  return;
                }
                var target = /** @type {!HTMLElement} */record.target;
                var inert = target.hasAttribute('inert');
                _this.setInert(target, inert);
                break;
            }
          }, this);
        }
      }]);
      return InertManager;
    }();

    /**
     * Recursively walk the composed tree from |node|.
     * @param {!Node} node
     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
     *     before descending into child nodes.
     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
     */

    function composedTreeWalk(node, callback, shadowRootAncestor) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        var element = /** @type {!HTMLElement} */node;
        if (callback) {
          callback(element);
        }

        // Descend into node:
        // If it has a ShadowRoot, ignore all child elements - these will be picked
        // up by the <content> or <shadow> elements. Descend straight into the
        // ShadowRoot.
        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
        if (shadowRoot) {
          composedTreeWalk(shadowRoot, callback);
          return;
        }

        // If it is a <content> element, descend into distributed elements - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'content') {
          var content = /** @type {!HTMLContentElement} */element;
          // Verifies if ShadowDom v0 is supported.
          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
          for (var i = 0; i < distributedNodes.length; i++) {
            composedTreeWalk(distributedNodes[i], callback);
          }
          return;
        }

        // If it is a <slot> element, descend into assigned nodes - these
        // are elements from outside the shadow root which are rendered inside the
        // shadow DOM.
        if (element.localName == 'slot') {
          var slot = /** @type {!HTMLSlotElement} */element;
          // Verify if ShadowDom v1 is supported.
          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
            flatten: true
          }) : [];
          for (var _i = 0; _i < _distributedNodes.length; _i++) {
            composedTreeWalk(_distributedNodes[_i], callback);
          }
          return;
        }
      }

      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
      // element, nor a <shadow> element recurse normally.
      var child = node.firstChild;
      while (child != null) {
        composedTreeWalk(child, callback);
        child = child.nextSibling;
      }
    }

    /**
     * Adds a style element to the node containing the inert specific styles
     * @param {!Node} node
     */
    function addInertStyle(node) {
      if (node.querySelector('style#inert-style, link#inert-style')) {
        return;
      }
      var style = document.createElement('style');
      style.setAttribute('id', 'inert-style');
      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
      node.appendChild(style);
    }
    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
      /** @type {!InertManager} */
      var inertManager = new InertManager(document);
      Object.defineProperty(HTMLElement.prototype, 'inert', {
        enumerable: true,
        /** @this {!HTMLElement} */
        get: function get() {
          return this.hasAttribute('inert');
        },
        /** @this {!HTMLElement} */
        set: function set(inert) {
          inertManager.setInert(this, inert);
        }
      });
    }
  })();

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    const {
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onChildCountChange
      },
      ...rest
    } = parentParameters;
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange, onChildCountChange);
    //const [getMountCount, setMountCount] = usePassiveState(onChildCountChange, returnZero, runImmediately);
    const getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    const managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    const forEachChild = T$1(f => {
      for (const child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (const field in managedChildrenArray.current.rec) {
        const child = managedChildrenArray.current.rec[field];
        if (child) f(child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    const getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    const hasRemoteULEChildMounted = _(null);
    const remoteULEChildChangedCausers = _(new Set());
    const remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        if (onAfterChildLayoutEffect != null) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    const remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        if (onChildCountChange || onChildrenMountChange) {
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            onChildCountChange === null || onChildCountChange === void 0 ? void 0 : onChildCountChange(getChildren().getHighestIndex() + 1);
            hasRemoteULEChildMounted.current = null;
          });
        }
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          let shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    const managedChildren = useStableObject({
      ...{
        _: managedChildrenArray.current
      },
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        return managedChildrenArray.current.arr.slice();
      }, [])
    });
    const getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var _info$context2;
    const {
      managedChildContext: {
        getChildren,
        managedChildrenArray,
        remoteULEChildMounted,
        remoteULEChildChanged
      }
    } = (_info$context2 = info.context) !== null && _info$context2 !== void 0 ? _info$context2 : {
      managedChildContext: {}
    };
    const index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s$1(() => {
      if (managedChildrenArray == null || remoteULEChildChanged == null) return;
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = {
          ...managedChildParameters
        };
      } else {
        managedChildrenArray.rec[index] = {
          ...managedChildParameters
        };
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s$1(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren: getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref3) {
    let {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref3;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    const [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    // Shared between onChildrenMountChange and changeIndex, not public
    // Only called when `closestFit` is false, naturally.
    const getClosestFit = T$1(requestedIndex => {
      const children = getChildren();
      let closestDistance = Infinity;
      let closestIndex = null;
      children.forEach(child => {
        if (child != null && isValid(child)) {
          console.assert(typeof child.index == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    const reevaluateClosestFit = useStableCallback(() => {
      const children = getChildren();
      const requestedIndex = getRequestedIndex();
      const currentIndex = getCurrentIndex();
      const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
        const closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (currentChild) setAt(currentChild, false, closestFitIndex, currentIndex);
        if (closestFitIndex != null) {
          const closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true, closestFitIndex, currentIndex);
        }
      }
    });
    const changeIndex = T$1((arg, reason) => {
      const children = getChildren();
      const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      setRequestedIndex(requestedIndex, reason);
      const currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
        return null;
      } else {
        const childIsValid = newMatchingChild && isValid(newMatchingChild);
        if (childIsValid || !closestFit) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false, requestedIndex, currentIndex);
          if (newMatchingChild) setAt(newMatchingChild, true, requestedIndex, currentIndex);
          return requestedIndex;
        } else {
          console.assert(typeof requestedIndex == "number", "closestFit can only be used when each child has a numeric index, and cannot be used when children use string indices instead.");
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            setAt(newMatchingChild, true, closestFitIndex, currentIndex);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false, closestFitIndex, currentIndex);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    s$1(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    const [state, setStateP] = p$1(initialState);
    const ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    const setState = T$1(value => {
      if (typeof value === "function") {
        const callback = value;
        setStateP(prevValue => {
          const nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    const getState = () => {
      return ref.current;
    };
    console.assert(ref.current === state || typeof state === "number" && isNaN(state));
    return [state, setState, getState];
  }
  E(null);
  function getExclusiveTransitionContextPrememoization(exclusivityKey) {
    if (exclusivityKey == null) return null;
    return E(null);
  }
  const SwappableContext = E({
    getAnimateOnMount: () => false
  });
  /**
   * Returns the context for a given `exclusivityKey`, creating one if it doesn't already exist.
   *
   * If
   */
  const GetExclusiveTransitionContext = memoize(getExclusiveTransitionContextPrememoization);
  const CssClassContext = E({
    GetBaseClass: () => "ptl",
    GetEnterClass: () => "n",
    GetExitClass: () => "x",
    GetMeasureClass: () => "m",
    GetInitClass: () => "i",
    GetTransitionClass: () => "t",
    GetFinalizeClass: () => "f"
  });
  function useCssClasses() {
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass
    } = q(CssClassContext);
    const GetDirectionClass = T$1(direction => {
      switch (direction) {
        case "enter":
          return GetEnterClass();
        case "exit":
          return GetExitClass();
      }
    }, []);
    const GetPhaseClass = T$1(phase => {
      switch (phase) {
        case "measure":
          return GetMeasureClass();
        case "init":
          return GetInitClass();
        case "transition":
          return GetTransitionClass();
        case "finalize":
          return GetFinalizeClass();
      }
    }, []);
    return {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    };
  }
  let globalCount = -1;
  function ExclusiveTransitionProvider(_ref4) {
    let {
      exclusivityKey,
      children
    } = _ref4;
    useEnsureStability("ExclusiveTransitionProvider", exclusivityKey);
    const [getNextIndexInLine, setNextIndexInLine] = usePassiveState(null);
    const {
      context,
      managedChildrenReturn,
      managedChildrenReturn: {
        getChildren
      }
    } = useManagedChildren({
      managedChildrenParameters: {}
    });
    const {
      changeIndex,
      getCurrentIndex
    } = useChildrenFlag({
      getChildren,
      closestFit: false,
      initialIndex: null,
      onIndexChange: null,
      setAt: T$1((m, v) => {
        m.setExclusivelyOpen(v);
      }, []),
      getAt: T$1(m => m.getExclusivelyOpen(), []),
      isValid: T$1(m => {
        return true;
      }, [])
    });
    const onVisibilityChange = T$1((index, visible) => {
      debugger;
      const nextInLine = getNextIndexInLine();
      const currentInLine = getCurrentIndex();
      if (visible == "show" && index != currentInLine) {
        /**
         * When a child transition shows itself initially
         * (i.e. requests itself to be the exclusive transition)
         * we either let it open immediately if there's no one finishing their exit,
         * or wait until that aforementioned exit has finished.
         */
        if (currentInLine == null) {
          changeIndex(index);
        } else {
          var _getChildren$getAt, _getChildren$getAt$fo;
          (_getChildren$getAt = getChildren().getAt(currentInLine)) === null || _getChildren$getAt === void 0 ? void 0 : (_getChildren$getAt$fo = _getChildren$getAt.forceClose) === null || _getChildren$getAt$fo === void 0 ? void 0 : _getChildren$getAt$fo.call(_getChildren$getAt);
          setNextIndexInLine(index);
        }
      } else if (visible == "hidden") {
        /**
         * When a child transition has finished its exit transition,
         * make sure that if someone requested to be shown in the meantime
         * that we do so.
         */
        if (nextInLine != null) {
          changeIndex(nextInLine);
          setNextIndexInLine(null);
        }
      }
    }, []);
    const context2 = useStableObject({
      ...context,
      exclusiveTransitionContext: useStableObject({
        exclusivityKey,
        onVisibilityChange
      })
    });
    const ExclusiveTransitionContext = GetExclusiveTransitionContext(exclusivityKey);
    return ExclusiveTransitionContext == null ? children !== null && children !== void 0 ? children : null : o$2(ExclusiveTransitionContext.Provider, {
      value: context2,
      children: children
    });
  }
  function useExclusiveTransition(_ref5) {
    let {
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        forceClose,
        exclusivityKey
      }
    } = _ref5;
    const c = GetExclusiveTransitionContext(exclusivityKey);
    useEnsureStability("useExclusiveTransition", c == null);
    const context = c ? q(c) : null;
    //const index = useMemo(() => generateRandomId(), []);
    const index = F$1(() => {
      globalCount += 1;
      return globalCount.toString();
    }, []);
    const [exclusivelyOpen, setExclusivelyOpen, getExclusivelyOpen] = useState(!!show);
    useManagedChild({
      context,
      managedChildParameters: {
        index
      }
    }, {
      index,
      getExclusivelyOpen,
      setExclusivelyOpen,
      forceClose
    });
    const parentOnVisChange = context === null || context === void 0 ? void 0 : context.exclusiveTransitionContext.onVisibilityChange;
    const onVisibilityChange = T$1(visible => {
      parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, visible == false ? "hidden" : "show");
    }, [parentOnVisChange, index]);
    s$1(() => {
      if (show) parentOnVisChange === null || parentOnVisChange === void 0 ? void 0 : parentOnVisChange(index, "show");
    }, [show, parentOnVisChange, index]);
    return {
      exclusiveTransitionReturn: {
        isExclusive: context != null,
        exclusivelyOpen,
        setExclusivelyOpen,
        getExclusivelyOpen,
        onVisibilityChange
      }
    };
  }

  /**
   * Shortcut for preact/compat's `forwardRef` that auto-assumes some things that are useful for forwarding refs to `HTMLElements` specifically.
   * Namely it involves de-gunking the type system by letting us return *generic* function and playing nice with React. In all other respects, it acts like `forwardRef`.
   *
   * TODO: Still needed?
   */
  function forwardElementRef(Component) {
    const ForwardedComponent = k(Component);
    return ForwardedComponent;
  }
  /**
   * Useful in particular for Slides with a Tab Panel --
   * if we do Math.sign(currentIndex - slideIndex), it
   * transitions nicely in the expected direction,
   * but we need to "remember" which direction to use
   * when it's the current panel (and the difference is 0)
   */
  function useLastNonNullValue(value) {
    const lastNonNullValue = _(null);
    h$1(() => {
      if (value != null) lastNonNullValue.current = value;
    }, [value]);
    return value !== null && value !== void 0 ? value : lastNonNullValue.current;
  }

  /**
   * Creates a set of props that implement a swap container.
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useCreateSwappableProps(_ref6, otherProps) {
    let {
      inline
    } = _ref6;
    const {
      GetBaseClass
    } = useCssClasses();
    return useMergedProps({
      className: clsx("".concat(GetBaseClass(), "-swap-container"), inline && "".concat(GetBaseClass(), "-swap-container-inline"))
    }, otherProps);
  }
  /**
   * Allows a set of child <Transitionable> components to animate in & out in-place. Very useful for, e.g., tab panels.
   *
   * You must manage each child `<Transitionable>` component's `show` prop -- this component *does not* manage any sort of state in that regard.
   *
   * If you pass a regular element (like a div) or other single component, then thee props and ref will be forwarded onto that element. Otherwise, all the children will be wrapped in a div or span depending on the `inline` prop.
   * @param param0
   * @returns
   */
  const Swappable = x(forwardElementRef(function Swappable(_ref7, ref) {
    var _inline;
    let {
      children: c,
      inline,
      childrenAnimateOnMount,
      exclusivityKey,
      ...p
    } = _ref7;
    let children = c;
    if (!children.type) children = !inline ? o$2("div", {
      children: children
    }) : o$2("span", {
      children: children
    });
    (_inline = inline) !== null && _inline !== void 0 ? _inline : inline = typeof children.type === "string" && inlineElements.has(children.type);
    const transitionProps = useCreateSwappableProps({
      inline
    }, {
      ...p,
      ref
    });
    const mergedWithChildren = useMergedProps(transitionProps, children.props);
    const animateOnMount = _(childrenAnimateOnMount !== null && childrenAnimateOnMount !== void 0 ? childrenAnimateOnMount : false);
    h$1(() => {
      animateOnMount.current = true;
    }, []);
    const contextValue = _({
      getAnimateOnMount: () => {
        return animateOnMount.current;
      }
    });
    let ret = D$1(children, mergedWithChildren);
    ret = o$2(SwappableContext.Provider, {
      value: contextValue.current,
      children: ret
    });
    if (exclusivityKey) {
      ret = o$2(ExclusiveTransitionProvider, {
        exclusivityKey: exclusivityKey,
        children: ret
      }, exclusivityKey);
    }
    return ret;
  }));
  // If "inline" isn't explicitly provided, we try to implicitly do it based on the child's tag.
  // Not perfect, but it's not supposed to be. `inline` is for perfect.
  const inlineElements = new Set(["a", "abbr", "acronym", "audio", "b", "bdi", "bdo", "big", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "label", "map", "mark", "meter", "noscript", "object", "output", "picture", "progress", "q", "ruby", "s", "samp", "script", "select", "slot", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "tt", "var", "video", "wbr"]);
  function getTimeoutDuration(element) {
    return Math.max(...window.getComputedStyle(element || document.body).getPropertyValue("transition-duration").split(",").map(str => {
      if (str.endsWith("ms")) return +str.substring(0, str.length - 2);
      if (str.endsWith("s")) return +str.substring(0, str.length - 1) * 1000;
      return 1000;
    }));
  }
  function parseState(nextState) {
    return nextState.split("-");
  }
  /**
   * Provide props that can be used to animate a transition.
   *
   * @param param0
   * @returns
   */
  function useTransition(_ref8) {
    var _animateOnMount, _measure, _easingIn, _easingOut;
    let {
      transitionParameters: {
        propsIncoming: {
          children,
          ...p
        },
        show,
        animateOnMount,
        measure,
        exitVisibility,
        duration,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    } = _ref8;
    useEnsureStability("useTransition", onVisibilityChange);
    const {
      getAnimateOnMount
    } = q(SwappableContext);
    exitVisibility || (exitVisibility = "hidden");
    (_animateOnMount = animateOnMount) !== null && _animateOnMount !== void 0 ? _animateOnMount : animateOnMount = getAnimateOnMount();
    (_measure = measure) !== null && _measure !== void 0 ? _measure : measure = false;
    const getExitVisibility = useStableGetter(exitVisibility);
    const {
      GetBaseClass,
      GetEnterClass,
      GetExitClass,
      GetMeasureClass,
      GetInitClass,
      GetTransitionClass,
      GetFinalizeClass,
      GetDirectionClass,
      GetPhaseClass
    } = useCssClasses();
    const getMeasure = useStableGetter(measure);
    const {
      exclusiveTransitionReturn: {
        exclusivelyOpen,
        isExclusive,
        onVisibilityChange: exclusiveTransitionVisibilityChange
      }
    } = useExclusiveTransition({
      transitionParameters: {
        show
      },
      exclusiveTransitionParameters: {
        exclusivityKey,
        forceClose: useStableCallback(() => {
          internalOnShowChanged(false, getMeasure());
        })
      }
    });
    if (isExclusive) {
      show = show && exclusivelyOpen;
    }
    const {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({});
    const cssProperties = _({});
    const classNames = _(new Set([// This is removed during useLayoutEffect on the first render
    // (at least once `show` is non-null)
    "".concat(GetBaseClass(), "-pending")]));
    const handleTransitionFinished = T$1(() => {
      const state = getState();
      console.assert(!!state);
      if (state) {
        const [direction, phase] = parseState(state);
        if (phase == "transition") {
          setState("".concat(direction, "-finalize"));
          if (timeoutHandle.current > 0) {
            var _timeoutClearFunction;
            (_timeoutClearFunction = timeoutClearFunction.current) === null || _timeoutClearFunction === void 0 ? void 0 : _timeoutClearFunction.call(timeoutClearFunction, timeoutHandle.current);
            timeoutHandle.current = -1;
          }
        }
      }
    }, []);
    const otherProps = _({
      onTransitionEnd: e => {
        if (e.target == getElement() && e.elapsedTime) {
          handleTransitionFinished();
        }
      }
    });
    const hasMounted = _(false);
    /**
     * Sets the element's CSS class to match the given direction and phase.
     */
    const updateClasses = T$1((element, direction, phase) => {
      if (element == null) return;
      const exitVisibility = getExitVisibility();
      const allClassesToRemove = ["".concat(GetBaseClass(), "-").concat(GetEnterClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetMeasureClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetInitClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetTransitionClass()), "".concat(GetBaseClass(), "-").concat(GetExitClass(), "-").concat(GetFinalizeClass()), "".concat(GetBaseClass(), "-ev-", "inert"), "".concat(GetBaseClass(), "-ev-", "removed"), "".concat(GetBaseClass(), "-ev-", "hidden"), "".concat(GetBaseClass(), "-ev-", "visible"), "".concat(GetBaseClass(), "-pending")];
      const allClassesToAdd = ["".concat(GetBaseClass()), "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction)), phase ? "".concat(GetBaseClass(), "-").concat(GetDirectionClass(direction), "-").concat(GetPhaseClass(phase)) : "", "".concat(GetBaseClass(), "-ev-").concat(exitVisibility)];
      element.classList.remove(...allClassesToRemove);
      allClassesToRemove.map(v => classNames.current.delete(v));
      element.classList.add(...allClassesToAdd);
      allClassesToAdd.map(v => classNames.current.add(v));
    }, []);
    /**
     * Updates a single "measure" variable (or removes it)
     */
    const updateSizeProperty = T$1((element, varName, value) => {
      if (value != null) {
        value = "".concat(value, "px");
        element.style.setProperty(varName, value);
        cssProperties.current[varName] = value;
      } else {
        element.style.removeProperty(varName);
        delete cssProperties.current[varName];
      }
    }, []);
    /**
     * Adds the "measure" variupdateClassesables to the element if requested.
     */
    const measureElementAndUpdateProperties = T$1((element, measure) => {
      if (element) {
        var _size, _size2, _size3, _size4;
        let size = null;
        if (measure) {
          size = element.getBoundingClientRect();
        }
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-top"), (_size = size) === null || _size === void 0 ? void 0 : _size.top);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-left"), (_size2 = size) === null || _size2 === void 0 ? void 0 : _size2.left);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-width"), (_size3 = size) === null || _size3 === void 0 ? void 0 : _size3.width);
        updateSizeProperty(element, "--".concat(GetBaseClass(), "-measure-height"), (_size4 = size) === null || _size4 === void 0 ? void 0 : _size4.height);
      }
    }, []);
    // We use both useTimeout and requestAnimationFrame for timing certain things --
    // raf is used for changing from init to transition (would use queueMicrotask but it can't be cancelled)
    // setTimeout is used for changing from transition to finalize (as a backup in case transitionend doesn't fire)
    //
    // In order to avoid stale callbacks running (i.e. when we rapidly switch between visible and not)
    // we need to make sure we accurately cancel anything that can change our state on a delay.
    //
    // Also of note, we store "(f) => window.clearTimeout(f)" instead of just "window.clearTimeout" because
    // of the implicit window object -- problems with a missing `this` object and all that nonsense.
    const timeoutHandle = _(-1);
    const timeoutClearFunction = _(null);
    /**
     * Any time the state changes, there's some logic we need to run:
     *
     * * If we're changing to an `init` phase, update the classes, then wait a moment and then change to the `transition` phase.
     * * If we're changing to a `transition` phase, update the classes, then wait until the transition completes, then change to the `finalize` phase.
     *
     * Any change in state or classes/styles does not implicitly cause a re-render.
     */
    const onStateChange = T$1((nextState, prevState, reason) => {
      if (nextState == null) return;
      const [nextDirection, nextPhase] = parseState(nextState);
      const element = getElement();
      // Make sure no stale change code ever runs
      if (timeoutHandle.current >= 0 && timeoutClearFunction.current) timeoutClearFunction.current(timeoutHandle.current);
      // Handle inert props/property
      const exitVisibility = getExitVisibility();
      if (exitVisibility) {
        const inert = exitVisibility == "inert" && nextDirection == "exit" && nextPhase == "finalize" ? true : undefined;
        if (inert) otherProps.current.inert = true;else delete otherProps.current["inert"];
        if (element) element.inert = inert || false;
      }
      const isBeingPainted = nextDirection == "enter" || nextDirection == "exit" && nextPhase != "finalize";
      onVisibilityChange === null || onVisibilityChange === void 0 ? void 0 : onVisibilityChange(isBeingPainted);
      exclusiveTransitionVisibilityChange === null || exclusiveTransitionVisibilityChange === void 0 ? void 0 : exclusiveTransitionVisibilityChange(isBeingPainted);
      updateClasses(element, nextDirection, nextPhase);
      if (element && (nextPhase == "init" || nextPhase == "transition")) forceReflow(element);
      switch (nextPhase) {
        case "measure":
          {
            if (element) measureElementAndUpdateProperties(element, true);
            //setState(`${nextDirection}-init`);
            updateClasses(element, nextDirection, "init");
            if (element) forceReflow(element);
            // !!Intentional fall-through!!
          }

        case "init":
          {
            timeoutHandle.current = requestAnimationFrame(() => {
              setState("".concat(nextDirection, "-transition"));
            });
            timeoutClearFunction.current = f => cancelAnimationFrame(f);
            break;
          }
        case "transition":
          {
            timeoutHandle.current = setTimeout(() => {
              handleTransitionFinished();
            }, getTimeoutDuration(element) * 1.5);
            timeoutClearFunction.current = f => clearTimeout(f);
            break;
          }
        case "finalize":
          {
            // Nothing to do or schedule or anything -- we just update our classes and we're done.
            timeoutClearFunction.current = null; // Does this make it more or less clear?
            break;
          }
        default:
          {
            debugger; // Intentional
            console.log("Invalid state used in transition: ".concat(nextState, ". Previous state was ").concat(prevState !== null && prevState !== void 0 ? prevState : "null"));
            break;
          }
      }
    }, []);
    const [getState, setState] = usePassiveState(onStateChange, returnNull, runImmediately);
    // When we mount, and every time thereafter that `show` changes,
    // change our current state according to that `show` value.
    s$1(() => internalOnShowChanged(show, measure), [measure, show]);
    // This has no dependences and is relied on in two different areas
    function internalOnShowChanged(show, measure) {
      // If `show` is null, then we don't change anything.
      if (show == null) return;
      // (If `show` is true/false, we'll remove the CSS classes during `onChange`)
      const currentState = getState();
      let nextPhase = measure ? "measure" : "init";
      if (currentState) {
        const [currentDirection, currentPhase] = parseState(currentState);
        if (currentPhase != "finalize") nextPhase = "transition";
      }
      // Note: the setState change handler runs immediately with no debounce.
      if (show) {
        if (hasMounted.current || animateOnMount) setState("enter-".concat(nextPhase));else setState("enter-finalize");
      } else {
        if (hasMounted.current || animateOnMount) setState("exit-".concat(nextPhase));else setState("exit-finalize");
      }
      hasMounted.current = true;
    }
    if (duration != null) cssProperties.current["--".concat(GetBaseClass(), "-duration")] = duration + "ms";else delete cssProperties.current["--".concat(GetBaseClass(), "-duration")];
    (_easingIn = easingIn) !== null && _easingIn !== void 0 ? _easingIn : easingIn = easing;
    (_easingOut = easingOut) !== null && _easingOut !== void 0 ? _easingOut : easingOut = easing;
    if (easingOut != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")] = easingOut;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetExitClass(), "-timing-function")];
    if (easingIn != null) cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")] = easingIn;else delete cssProperties.current["--".concat(GetBaseClass(), "-").concat(GetEnterClass(), "-timing-function")];
    // No matter what delayMountUntilShown is,
    // once we've rendered our children once, 
    // ensure that we don't unmount them again and waste all that work.
    // (If you really need this you can just unmount the entire transition itself)
    const definitelyShouldMountChildren = show || !delayMountUntilShown;
    const hasRenderedChildren = _(false);
    const renderChildren = definitelyShouldMountChildren || hasRenderedChildren.current;
    h$1(() => {
      if (definitelyShouldMountChildren) hasRenderedChildren.current || (hasRenderedChildren.current = true);
    }, [hasRenderedChildren.current ? false : definitelyShouldMountChildren]);
    const childrenIsVnode = children && children.type && children.props;
    const finalProps = useMergedProps(p, propsStable, otherProps.current, {
      className: [...classNames.current, "".concat(GetBaseClass()), "".concat(GetBaseClass(), "-ev-").concat(exitVisibility), "".concat(GetBaseClass(), "-inline-direction-", "ltr"), "".concat(GetBaseClass(), "-block-direction-", "ttb")].join(" "),
      style: cssProperties.current
    }, childrenIsVnode ? {
      ref: children.ref,
      ...children.props
    } : {});
    const resetContext = _({
      getAnimateOnMount: returnFalse
    }).current;
    let modifiedChildren;
    if (childrenIsVnode) {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: D$1(children, finalProps)
      });
    } else {
      modifiedChildren = o$2(SwappableContext.Provider, {
        value: resetContext,
        children: o$2("span", {
          ...finalProps,
          children: children
        })
      });
    }
    return renderChildren ? modifiedChildren : null;
  }
  function forceReflow(e) {
    // Try really hard to make sure this isn't optimized out by anything.
    // We need it for its document reflow side effect.
    const p = globalThis._dummy;
    globalThis._dummy = e.getBoundingClientRect();
    globalThis._dummy = e.style.opacity;
    globalThis._dummy = e.style.transform;
    globalThis._dummy = p;
    return e;
  }

  /**
   * Creates a set of props that implement a Fade transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   */
  function useBasePropsFade(_ref9) {
    let {
      fadeParameters: {
        fadeMin,
        fadeMax
      }
    } = _ref9;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-fade"),
      style: {
        ["--".concat(GetBaseClass(), "-fade-min")]: fadeMin !== null && fadeMin !== void 0 ? fadeMin : 0,
        ["--".concat(GetBaseClass(), "-fade-max")]: fadeMax !== null && fadeMax !== void 0 ? fadeMax : 1
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Fade effect.
   *
   * Note that while it is absolutely possible to wrap another transition with `<Fade>`,
   * there will be some duplicate code run as two `<Transitionable>` components end up operating on the same element.
   * It's generally recommended to either use the components that include a combined fade effect,
   * or just directly a `<Transitionable>` on your own.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Fade(_ref10, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref10;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  function useBasePropsClip(_ref11) {
    var _ref12, _ref13, _ref14, _ref15;
    let {
      clipParameters: {
        clipMin,
        clipMinBlock,
        clipMinInline,
        clipOrigin,
        clipOriginBlock,
        clipOriginInline
      }
    } = _ref11;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: clsx("".concat(GetBaseClass(), "-clip")),
      style: {
        ["--".concat(GetBaseClass(), "-clip-origin-inline")]: (_ref12 = clipOriginInline !== null && clipOriginInline !== void 0 ? clipOriginInline : clipOrigin) !== null && _ref12 !== void 0 ? _ref12 : 0.5,
        ["--".concat(GetBaseClass(), "-clip-origin-block")]: (_ref13 = clipOriginBlock !== null && clipOriginBlock !== void 0 ? clipOriginBlock : clipOrigin) !== null && _ref13 !== void 0 ? _ref13 : 0,
        ["--".concat(GetBaseClass(), "-clip-min-inline")]: (_ref14 = clipMinInline !== null && clipMinInline !== void 0 ? clipMinInline : clipMin) !== null && _ref14 !== void 0 ? _ref14 : 1,
        ["--".concat(GetBaseClass(), "-clip-min-block")]: (_ref15 = clipMinBlock !== null && clipMinBlock !== void 0 ? clipMinBlock : clipMin) !== null && _ref15 !== void 0 ? _ref15 : 0
      }
    };
  }
  x(forwardElementRef(function Clip(_ref16, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      clipOrigin,
      clipOriginInline,
      clipOriginBlock,
      clipMin,
      clipMinInline,
      clipMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref16;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ClipFade(_ref17, ref) {
    let {
      delayMountUntilShown,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      clipMin,
      clipMinBlock,
      clipMinInline,
      clipOrigin,
      clipOriginBlock,
      clipOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref17;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsClip({
          clipParameters: {
            clipMin,
            clipMinInline,
            clipMinBlock,
            clipOrigin,
            clipOriginInline,
            clipOriginBlock
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   * Be sure to merge these returned props with whatever the user passed in.
   *
   * IMPORTANT: If used outside of a `<Collapse />`, you must include the `measure` prop on the `<Transitionable>` that you use.
   *
   * @example <Transitionable measure {...useCreateCollapseProps(...)} />
   */
  function useBasePropsCollapse(_ref18) {
    let {
      collapseParameters: {
        minBlockSize
      }
    } = _ref18;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-collapse"),
      style: {
        ["--".concat(GetBaseClass(), "-collapse-min-block")]: minBlockSize !== null && minBlockSize !== void 0 ? minBlockSize : 0
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Collapse effect.
   *
   * *Important*: This component is *not* efficient for the browser to animate!
   * Make sure you do testing on lower power devices, or prefer a lighter
   * alternative, like `<Clip>`.
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Collapse(_ref19, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      delayMountUntilShown,
      minBlockSize,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref19;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function CollapseFade(_ref20, ref) {
    let {
      show,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      duration,
      animateOnMount,
      delayMountUntilShown,
      fadeMin,
      fadeMax,
      exitVisibility,
      minBlockSize,
      onVisibilityChange,
      ...rest
    } = _ref20;
    return useTransition({
      transitionParameters: {
        measure: true,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsCollapse({
          collapseParameters: {
            minBlockSize
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Flip transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsFlip(_ref21) {
    var _useLastNonNullValue, _useLastNonNullValue2;
    let {
      flipParameters: {
        flipAngleBlock,
        flipAngleInline,
        flipPerspective
      }
    } = _ref21;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-flip"),
      style: {
        ["--".concat(GetBaseClass(), "-flip-angle-inline")]: "".concat((_useLastNonNullValue = useLastNonNullValue(flipAngleInline)) !== null && _useLastNonNullValue !== void 0 ? _useLastNonNullValue : 0, "deg"),
        ["--".concat(GetBaseClass(), "-flip-angle-block")]: "".concat((_useLastNonNullValue2 = useLastNonNullValue(flipAngleBlock)) !== null && _useLastNonNullValue2 !== void 0 ? _useLastNonNullValue2 : 0, "deg"),
        ["--".concat(GetBaseClass(), "-perspective")]: "".concat(flipPerspective !== null && flipPerspective !== void 0 ? flipPerspective : 800, "px")
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Flip effect.
   *
   * Provide the direction the element will travel in with `flipInline` and `flipBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * exclusivityKey allows for convenient setups inside of a `SwapContainer`
   * (`flipInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Flip(_ref22, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      flipAngleInline,
      flipAngleBlock,
      flipPerspective,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref22;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFlip({
          flipParameters: {
            flipAngleBlock,
            flipAngleInline,
            flipPerspective
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Slide transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsSlide(_ref23) {
    var _slideTargetInline, _slideTargetBlock;
    let {
      slideParameters: {
        slideTargetInline,
        slideTargetBlock
      }
    } = _ref23;
    slideTargetInline = useLastNonNullValue(slideTargetInline);
    slideTargetBlock = useLastNonNullValue(slideTargetBlock);
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-slide"),
      style: {
        ["--".concat(GetBaseClass(), "-slide-target-inline")]: "".concat((_slideTargetInline = slideTargetInline) !== null && _slideTargetInline !== void 0 ? _slideTargetInline : 0),
        ["--".concat(GetBaseClass(), "-slide-target-block")]: "".concat((_slideTargetBlock = slideTargetBlock) !== null && _slideTargetBlock !== void 0 ? _slideTargetBlock : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Slide effect.
   *
   * Provide the direction the element will travel in with `slideInline` and `slideBlock`,
   * with `1` being `100%` of the element's width or height.
   *
   * A value of `0` is handled specially, effectively meaning "use the last non-zero value",
   * which allows for convenient setups inside of a `SwapContainer`
   * (`slideInline={index - selectedIndex}` or similar.)
   *
   * @see `Transitionable`
   */
  x(forwardElementRef(function Slide(_ref24, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      onVisibilityChange,
      slideTargetInline,
      slideTargetBlock,
      show,
      animateOnMount,
      exitVisibility,
      delayMountUntilShown,
      ...rest
    } = _ref24;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        easing,
        easingIn,
        easingOut,
        onVisibilityChange,
        propsIncoming: useMergedProps(useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideFade(_ref25, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref25;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));

  /**
   * Creates a set of props that implement a Zoom transition. Like all `useCreate*Props` hooks, must be used in tamdem with a `Transitionable` component (or `useCreateTransitionableProps`).
   */
  function useBasePropsZoom(_ref26) {
    var _ref27, _ref28, _ref29, _ref30;
    let {
      zoomParameters: {
        zoomOrigin,
        zoomOriginInline,
        zoomOriginBlock,
        zoomMin,
        zoomMinInline,
        zoomMinBlock
      }
    } = _ref26;
    const {
      GetBaseClass
    } = useCssClasses();
    return {
      className: "".concat(GetBaseClass(), "-zoom"),
      style: {
        ["--".concat(GetBaseClass(), "-zoom-origin-inline")]: "".concat((_ref27 = zoomOriginInline !== null && zoomOriginInline !== void 0 ? zoomOriginInline : zoomOrigin) !== null && _ref27 !== void 0 ? _ref27 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-origin-block")]: "".concat((_ref28 = zoomOriginBlock !== null && zoomOriginBlock !== void 0 ? zoomOriginBlock : zoomOrigin) !== null && _ref28 !== void 0 ? _ref28 : 0.5),
        ["--".concat(GetBaseClass(), "-zoom-min-inline")]: "".concat((_ref29 = zoomMinInline !== null && zoomMinInline !== void 0 ? zoomMinInline : zoomMin) !== null && _ref29 !== void 0 ? _ref29 : 0),
        ["--".concat(GetBaseClass(), "-zoom-min-block")]: "".concat((_ref30 = zoomMinBlock !== null && zoomMinBlock !== void 0 ? zoomMinBlock : zoomMin) !== null && _ref30 !== void 0 ? _ref30 : 0)
      }
    };
  }
  /**
   * Wraps a div (etc.) and allows it to transition in/out smoothly with a Zoom effect.
   * @see `Transitionable` `ZoomFade`
   */
  x(forwardElementRef(function Zoom(_ref31, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      delayMountUntilShown,
      zoomOrigin,
      zoomOriginInline,
      zoomOriginBlock,
      zoomMin,
      zoomMinInline,
      zoomMinBlock,
      show,
      animateOnMount,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref31;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoom(_ref32, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref32;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps({
          ref,
          ...rest
        }, useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }))
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function SlideZoomFade(_ref33, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      show,
      animateOnMount,
      delayMountUntilShown,
      slideTargetBlock,
      slideTargetInline,
      fadeMax,
      fadeMin,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref33;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), useBasePropsSlide({
          slideParameters: {
            slideTargetBlock,
            slideTargetInline
          }
        }), useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  x(forwardElementRef(function ZoomFade(_ref34, ref) {
    let {
      duration,
      exclusivityKey,
      easing,
      easingIn,
      easingOut,
      fadeMin,
      fadeMax,
      show,
      animateOnMount,
      delayMountUntilShown,
      zoomMin,
      zoomMinBlock,
      zoomMinInline,
      zoomOrigin,
      zoomOriginBlock,
      zoomOriginInline,
      exitVisibility,
      onVisibilityChange,
      ...rest
    } = _ref34;
    return useTransition({
      transitionParameters: {
        measure: false,
        show,
        duration,
        animateOnMount,
        exitVisibility,
        delayMountUntilShown,
        onVisibilityChange,
        easing,
        easingIn,
        easingOut,
        propsIncoming: useMergedProps(useBasePropsFade({
          fadeParameters: {
            fadeMax,
            fadeMin
          }
        }), useBasePropsZoom({
          zoomParameters: {
            zoomMin,
            zoomMinBlock,
            zoomMinInline,
            zoomOrigin,
            zoomOriginBlock,
            zoomOriginInline
          }
        }), {
          ref,
          ...rest
        })
      },
      exclusiveTransitionParameters: {
        exclusivityKey
      }
    });
  }));
  "undefined" != typeof window && window.__PREACT_DEVTOOLS__ && window.__PREACT_DEVTOOLS__.attachPreact("10.12.1", l$2, {
    Fragment: d$2,
    Component: _$2
  });
  var o = {};
  function a(e) {
    return e.type === d$2 ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
  }
  var i = [],
    c = [];
  function s() {
    return i.length > 0 ? i[i.length - 1] : null;
  }
  var u = !1;
  function l(e) {
    return "function" == typeof e.type && e.type != d$2;
  }
  function f(n) {
    for (var e = [n], t = n; null != t.__o;) e.push(t.__o), t = t.__o;
    return e.reduce(function (n, e) {
      n += "  in " + a(e);
      var t = e.__source;
      return t ? n += " (at " + t.fileName + ":" + t.lineNumber + ")" : u || (u = !0, console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")), n + "\n";
    }, "");
  }
  var p = "function" == typeof WeakMap;
  function d(n) {
    return n ? "function" == typeof n.type ? d(n.__) : n : {};
  }
  var h = _$2.prototype.setState;
  _$2.prototype.setState = function (n, e) {
    return null == this.__v && null == this.state && console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n' + f(s())), h.call(this, n, e);
  };
  var y = _$2.prototype.forceUpdate;
  function v(n) {
    var e = n.props,
      t = a(n),
      o = "";
    for (var r in e) if (e.hasOwnProperty(r) && "children" !== r) {
      var i = e[r];
      "function" == typeof i && (i = "function " + (i.displayName || i.name) + "() {}"), i = Object(i) !== i || i.toString ? i + "" : Object.prototype.toString.call(i), o += " " + r + "=" + JSON.stringify(i);
    }
    var c = e.children;
    return "<" + t + o + (c && c.length ? ">..</" + t + ">" : " />");
  }
  _$2.prototype.forceUpdate = function (n) {
    return null == this.__v ? console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n' + f(s())) : null == this.__P && console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n' + f(this.__v)), y.call(this, n);
  }, function () {
    !function () {
      var n = l$2.__b,
        t = l$2.diffed,
        o = l$2.__,
        r = l$2.vnode,
        a = l$2.__r;
      l$2.diffed = function (n) {
        l(n) && c.pop(), i.pop(), t && t(n);
      }, l$2.__b = function (e) {
        l(e) && i.push(e), n && n(e);
      }, l$2.__ = function (n, e) {
        c = [], o && o(n, e);
      }, l$2.vnode = function (n) {
        n.__o = c.length > 0 ? c[c.length - 1] : null, r && r(n);
      }, l$2.__r = function (n) {
        l(n) && c.push(n), a && a(n);
      };
    }();
    var n = !1,
      t = l$2.__b,
      r = l$2.diffed,
      s = l$2.vnode,
      u = l$2.__e,
      h = l$2.__,
      y = l$2.__h,
      m = p ? {
        useEffect: new WeakMap(),
        useLayoutEffect: new WeakMap(),
        lazyPropTypes: new WeakMap()
      } : null,
      b = [];
    l$2.__e = function (n, e, t, o) {
      if (e && e.__c && "function" == typeof n.then) {
        var r = n;
        n = new Error("Missing Suspense. The throwing component was: " + a(e));
        for (var i = e; i; i = i.__) if (i.__c && i.__c.__c) {
          n = r;
          break;
        }
        if (n instanceof Error) throw n;
      }
      try {
        (o = o || {}).componentStack = f(e), u(n, e, t, o), "function" != typeof n.then && setTimeout(function () {
          throw n;
        });
      } catch (n) {
        throw n;
      }
    }, l$2.__ = function (n, e) {
      if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");
      var t;
      switch (e.nodeType) {
        case 1:
        case 11:
        case 9:
          t = !0;
          break;
        default:
          t = !1;
      }
      if (!t) {
        var o = a(n);
        throw new Error("Expected a valid HTML node as a second argument to render.\tReceived " + e + " instead: render(<" + o + " />, " + e + ");");
      }
      h && h(n, e);
    }, l$2.__b = function (e) {
      var r = e.type,
        i = d(e.__);
      if (n = !0, void 0 === r) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + v(e) + "\n\n" + f(e));
      if (null != r && "object" == typeof r) {
        if (void 0 !== r.__k && void 0 !== r.__e) throw new Error("Invalid type passed to createElement(): " + r + "\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My" + a(e) + " = " + v(r) + ";\n  let vnode = <My" + a(e) + " />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n" + f(e));
        throw new Error("Invalid type passed to createElement(): " + (Array.isArray(r) ? "array" : r));
      }
      if ("thead" !== r && "tfoot" !== r && "tbody" !== r || "table" === i.type ? "tr" === r && "thead" !== i.type && "tfoot" !== i.type && "tbody" !== i.type && "table" !== i.type ? console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent." + v(e) + "\n\n" + f(e)) : "td" === r && "tr" !== i.type ? console.error("Improper nesting of table. Your <td> should have a <tr> parent." + v(e) + "\n\n" + f(e)) : "th" === r && "tr" !== i.type && console.error("Improper nesting of table. Your <th> should have a <tr>." + v(e) + "\n\n" + f(e)) : console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent." + v(e) + "\n\n" + f(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("string" == typeof e.type) for (var c in e.props) if ("o" === c[0] && "n" === c[1] && "function" != typeof e.props[c] && null != e.props[c]) throw new Error("Component's \"" + c + '" property should be a function, but got [' + typeof e.props[c] + "] instead\n" + v(e) + "\n\n" + f(e));
      if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && m && !m.lazyPropTypes.has(e.type)) {
          var s = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";
          try {
            var u = e.type();
            m.lazyPropTypes.set(e.type, !0), console.warn(s + "Component wrapped in lazy() is " + a(u));
          } catch (n) {
            console.warn(s + "We will log the wrapped component's name once it is loaded.");
          }
        }
        var l = e.props;
        e.type.__f && delete (l = function (n, e) {
          for (var t in e) n[t] = e[t];
          return n;
        }({}, l)).ref, function (n, e, t, r, a) {
          Object.keys(n).forEach(function (t) {
            var i;
            try {
              i = n[t](e, t, r, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (n) {
              i = n;
            }
            i && !(i.message in o) && (o[i.message] = !0, console.error("Failed prop type: " + i.message + (a && "\n" + a() || "")));
          });
        }(e.type.propTypes, l, 0, a(e), function () {
          return f(e);
        });
      }
      t && t(e);
    }, l$2.__h = function (e, t, o) {
      if (!e || !n) throw new Error("Hook can only be invoked from render methods.");
      y && y(e, t, o);
    };
    var w = function (n, e) {
        return {
          get: function () {
            var t = "get" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("getting vnode." + n + " is deprecated, " + e));
          },
          set: function () {
            var t = "set" + n + e;
            b && b.indexOf(t) < 0 && (b.push(t), console.warn("setting vnode." + n + " is not allowed, " + e));
          }
        };
      },
      g = {
        nodeName: w("nodeName", "use vnode.type"),
        attributes: w("attributes", "use vnode.props"),
        children: w("children", "use vnode.props.children")
      },
      E = Object.create({}, g);
    l$2.vnode = function (n) {
      var e = n.props;
      if (null !== n.type && null != e && ("__source" in e || "__self" in e)) {
        var t = n.props = {};
        for (var o in e) {
          var r = e[o];
          "__source" === o ? n.__source = r : "__self" === o ? n.__self = r : t[o] = r;
        }
      }
      n.__proto__ = E, s && s(n);
    }, l$2.diffed = function (e) {
      if (e.__k && e.__k.forEach(function (n) {
        if ("object" == typeof n && n && void 0 === n.type) {
          var t = Object.keys(n).join(",");
          throw new Error("Objects are not valid as a child. Encountered an object with the keys {" + t + "}.\n\n" + f(e));
        }
      }), n = !1, r && r(e), null != e.__k) for (var t = [], o = 0; o < e.__k.length; o++) {
        var a = e.__k[o];
        if (a && null != a.key) {
          var i = a.key;
          if (-1 !== t.indexOf(i)) {
            console.error('Following component has two or more children with the same key attribute: "' + i + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + v(e) + "\n\n" + f(e));
            break;
          }
          t.push(i);
        }
      }
    };
  }();

  /**
   * Relatively low-level hook that allows you to inspect
   * when the entire URL changes, either because the hash changed,
   * or because the Back/Forward browser buttons were pressed.
   *
   * (Changing query parameters reloads the page and so isn't
   * tracked, unless of course it's because of the browser
   * navigating back/forwards).
   *
   * In general, you'll want to inspect a specific directory of
   * a path, or a specific query parameter value, not the
   * entire URL.
   */
  function useUrl(onUrlChange) {
    const [getUrl, setUrl] = usePassiveState$1(useStableCallback$1(onUrlChange), T$1(() => window.location.toString(), []));
    useGlobalHandler(window, "hashchange", e => {
      setUrl(window.location.toString());
    });
    useGlobalHandler(window, "popstate", e => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#the_history_stack
      // TODO: If this assert never fires, it's *probably* fine??
      console.assert(window.location.toString() === document.location.toString());
      setUrl(window.location.toString());
    });
    return [getUrl, setUrl];
  }

  //export const RouterLevelContext = createContext(0);
  /**
   * Internal helper to trim the crusts off of a hash path.
   * @param hash
   * @returns
   */
  function trimHash(hash) {
    if (hash.startsWith("#")) hash = hash.substr(1);
    if (hash.startsWith("/")) hash = hash.substr(1);
    if (hash.endsWith("/")) hash = hash.substr(0, hash.length - 1);
    return hash;
  }
  function normalizeHashToPath(hash) {
    hash = trimHash(hash);
    return hash.split("/");
  }
  // Not public -- just contains shared code for history modification.
  // This is what actually changes History and updates the window's URL.
  function setEntireHash(hash, action) {
    var _action;
    (_action = action) !== null && _action !== void 0 ? _action : action = "push";
    hash = trimHash(hash);
    let oldURL = window.location.toString();
    let nextUrl = new URL(window.location.toString());
    nextUrl.hash = "#".concat(hash);
    history["".concat(action, "State")]({}, document.title, nextUrl);
    // Modifying history doesn't actually cause a hashchange event.
    window.dispatchEvent(new HashChangeEvent('hashchange', {
      oldURL,
      newURL: nextUrl.toString()
    }));
  }
  /**
   * Modifies the given Search Params object to have its key be set to the given value.
   *
   * Specifically for boolean types this ensures that the param is simply existant/non-existant,
   * but for other types this is pretty straightforward.
   * @param params
   * @param key
   * @param value
   * @param type
   */
  function unparseParam(params, key, value, type) {
    if (type === "boolean") {
      if (value === true) {
        params.set(key, "");
      } else {
        params.delete(key);
      }
    } else {
      params.set(key, "".concat(value));
    }
  }
  /**
   * Parses the requested Search Param from the given URL.
   *
   * The type will be automatically parsed with special handling for booleans
   */
  function parseParam(url, key, type) {
    let value = url.searchParams.get(key);
    switch (type) {
      case "string":
        return value !== null && value !== void 0 ? value : null;
      case "boolean":
        return value != null;
      case "number":
        if (value == null) return null;
        let parsed = +value;
        if (isFinite(parsed)) return parsed;
        return null;
      case "bigint":
        if (value == null) return null;
        try {
          return BigInt(value);
        } catch (ex) {
          return null;
        }
    }
    return value !== null && value !== void 0 ? value : null;
  }
  //export interface RouterChildInfo extends ManagedChildInfo<string> {
  //    notifyOfSiblingsHaveNoMatches(noMatches: boolean): void;
  //path: RouterPathType | null;
  //    matches: boolean | null;
  //}

  function useConsumeRouter(_ref35) {
    let {
      context,
      managedChildParameters,
      managedChildParameters: {
        index
      },
      consumeRouterParameters: {
        onLocalPathChange,
        localPath: wantedLocalPath
      }
    } = _ref35;
    const {
      routerContext: {
        level,
        notifyParentThatNonDefaultMatchHasChanged
      }
    } = context;
    const [anyMatchesAmongNonDefaultSiblings, setAnyMatchesAmongNonDefaultSiblings] = useState$1(null);
    const [pathWhenMatching, setPathWhenMatching] = useState$1(null);
    const {
      managedChildReturn
    } = useManagedChild$1({
      context,
      managedChildParameters
    }, {
      index,
      setAnyMatchesAmongNonDefaultSiblings: useStableCallback$1(anyMatches => {
        setAnyMatchesAmongNonDefaultSiblings(anyMatches);
        onLocalPathChange2(wantedLocalPath, anyMatches, getLocalPath());
      })
    });
    s$1(() => {
      onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, getLocalPath());
    }, [wantedLocalPath, anyMatchesAmongNonDefaultSiblings]);
    const onLocalPathChange2 = useStableCallback$1(function (wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path) {
      const matches = pathCompare(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
      setMatches(matches);
      console.log("".concat(index, ": onLocalPathChange2(wlp: ").concat((wantedLocalPath !== null && wantedLocalPath !== void 0 ? wantedLocalPath : "null").toString(), ", amands: ").concat((anyMatchesAmongNonDefaultSiblings !== null && anyMatchesAmongNonDefaultSiblings !== void 0 ? anyMatchesAmongNonDefaultSiblings : "null").toString(), ", p: ").concat(path, "): ").concat((matches !== null && matches !== void 0 ? matches : "null").toString()));
      if (matches) setPathWhenMatching(path);
      if (wantedLocalPath != null) {
        notifyParentThatNonDefaultMatchHasChanged(index, matches);
      } else {
        notifyParentThatNonDefaultMatchHasChanged(index, null);
      }
    });
    const [matches, setMatches] = useState$1(null);
    const [getLocalPath, setLocalPath] = useLocalPath({
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange: useStableCallback$1((path, prev, reason) => {
          onLocalPathChange2(wantedLocalPath, anyMatchesAmongNonDefaultSiblings, path);
          onLocalPathChange === null || onLocalPathChange === void 0 ? void 0 : onLocalPathChange(path, prev, reason);
        })
      }
    });
    return {
      managedChildReturn,
      consumeRouterReturn: {
        level,
        matches,
        getLocalPath,
        setLocalPath,
        pathWhenMatching
      }
    };
  }
  function useLocalPath(_ref36) {
    let {
      consumeRouterReturn: {
        level
      },
      localRouteParameters: {
        onLocalPathChange
      }
    } = _ref36;
    useEnsureStability$1("useLocalPath", level);
    const urlToPath = T$1(url => {
      const oldHashPath = normalizeHashToPath(trimHash(new URL(url).hash));
      return oldHashPath[level];
    }, []);
    const [getLocalPath, setLocalPath] = usePassiveState$1(useStableCallback$1(onLocalPathChange), T$1(() => {
      return urlToPath(window.location.href);
    }, [urlToPath]));
    // Any time the URL changes, inspect the hash
    // at our current level, and change our local copy of our path
    // in our passive state. This will trigger our callback if they're different.
    useUrl(url => {
      setLocalPath(urlToPath(url));
    });
    return [getLocalPath, setLocalPath];
  }
  function pathCompare(requestedLocalHash, anyMatchesAmongNonDefaultSiblings, localPath) {
    var _localPath;
    let matches;
    (_localPath = localPath) !== null && _localPath !== void 0 ? _localPath : localPath = "";
    if (requestedLocalHash instanceof RegExp) matches = requestedLocalHash.test(localPath);else if (requestedLocalHash instanceof Function) matches = requestedLocalHash(localPath);else if (requestedLocalHash == null) matches = anyMatchesAmongNonDefaultSiblings == null ? null : !anyMatchesAmongNonDefaultSiblings;else matches = requestedLocalHash === localPath;
    return matches;
  }

  /**
   * Error class used when attemps to modify the root directory occur.
   */
  class RootRouterError extends Error {
    constructor() {
      super("The root Router's path can only be pushed to and cannot be set or popped from.");
    }
  }

  /**
   * Removes the directory at the current level, effectively returning
   * to the previous level.  You can also switch to a different
   * previous level if you would like.
   */
  function usePopLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      setEntireHash(popLocalPath(level, dir), action);
    }, [level]);
  }
  function popLocalPath(level, dir) {
    if (level < 0) throw new RootRouterError();
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, level).map(s => s !== null && s !== void 0 ? s : "");
    if (dir) {
      dir = trimHash(dir);
      newHashPath[newHashPath.length - 1] = dir;
    }
    return newHashPath.join("/");
  }

  /**
   * Adds a directory at one level deeper.
   */
  function usePushLocalPath(level) {
    return T$1(function pushLocalHash(dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      dir = trimHash(dir);
      const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
      let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
      newHashPath.splice(level + 1, 1, dir);
      setEntireHash(newHashPath.join("/"), action);
    }, [level]);
  }

  /**
   * Replaces the directory at the current level with a new one. You can
   * choose whether or not any trailing paths are kept -- by default this is false.
   * @returns
   */
  function useSetLocalPath(level) {
    return T$1(function (dir) {
      let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "push";
      let keepTrailing = arguments.length > 2 ? arguments[2] : undefined;
      setEntireHash(setLocalPath(level, dir, keepTrailing || false), action);
    }, [level]);
  }
  function setLocalPath(level, dir, keepTrailing) {
    if (level < 0) throw new RootRouterError();
    dir = trimHash(dir);
    const oldHashPath = normalizeHashToPath(trimHash(new URL(window.location.toString()).hash));
    let newHashPath = oldHashPath.slice(0, keepTrailing ? undefined : level + 1).map(s => s !== null && s !== void 0 ? s : "");
    newHashPath.splice(level, 1, dir);
    return newHashPath.join("/");
  }

  /**
   * Allows easy access to the controls at the current level.
   *
   * You can also get this information from a child <Router />
   * by passing in a ref (e.g. <Router ref={setControls} />).
   */
  function useRouterControls(level) {
    // This is the hash at this level specifically, 
    // so it contains no directory separators.
    const popLocalPath = usePopLocalPath(level);
    const pushLocalPath = usePushLocalPath(level);
    const setLocalPath = useSetLocalPath(level);
    return F$1(() => ({
      popLocalPath,
      pushLocalPath,
      setLocalPath
    }), [popLocalPath, pushLocalPath, setLocalPath]);
  }
  const RouterContext = E(null);
  //const RouterContext = createContext<RouterContextType | null>(null);
  /**
   * The "parent" part of a router.
   *
   * This is responsible for coordinating, among all children, which route to show.
   * This coordination is really only needed for the "default" pathway, which
   * needs to know as painlessly as possible whether any of its siblings are currently valid.
   *
   * It also increases the depth by one, starting at depth=-1 for the root router is *just* a parent.
   */
  function useProvideRouter(_ref37) {
    var _q;
    let {
      managedChildrenParameters
    } = _ref37;
    const {
      context,
      managedChildrenReturn
    } = useManagedChildren$1({
      managedChildrenParameters
    });
    const {
      routerContext: {
        level
      }
    } = (_q = q(RouterContext)) !== null && _q !== void 0 ? _q : {
      routerContext: {
        level: -1
      }
    };
    const matchingIndices = _(new Set());
    const [getShowingDefault, setShowingDefault] = usePassiveState$1(useStableCallback$1(showingDefault => {
      managedChildrenReturn.getChildren().forEach(child => {
        child.setAnyMatchesAmongNonDefaultSiblings(!showingDefault);
      });
    }), returnNull$1);
    const onNonDefaultChildMatchChanged = useStableCallback$1((index, matches) => {
      matchingIndices.current[matches ? "add" : "delete"](index);
      setShowingDefault(matchingIndices.current.size == 0);
    });
    return {
      context: useStableObject$1({
        ...context,
        routerContext: useStableObject$1({
          level: level + 1,
          notifyParentThatNonDefaultMatchHasChanged: onNonDefaultChildMatchChanged
        })
      }),
      managedChildrenReturn
    };
  }

  /**
   * Allows you to conditionally hide/show content based on a path in the hash component of the URL.
   *
   * @param param0
   * @param ref
   * @returns
   */
  function Router(_ref38, ref) {
    var _consumeRouterReturn;
    let {
      localPath,
      onLocalPathChange,
      children
    } = _ref38;
    const context = q(RouterContext);
    const {
      context: contextFromParent,
      managedChildrenReturn
    } = useProvideRouter({
      managedChildrenParameters: {}
    });
    const index = F$1(() => (localPath !== null && localPath !== void 0 ? localPath : "<default>") + "-".concat(Math.random()), [localPath]);
    let consumeRouterReturn = null;
    useEnsureStability$1("Router", !!context);
    if (context) {
      consumeRouterReturn = useConsumeRouter({
        consumeRouterParameters: {
          localPath,
          onLocalPathChange
        },
        context,
        managedChildParameters: {
          index
        }
      });
    }
    const {
      consumeRouterReturn: {
        level,
        matches,
        pathWhenMatching
      }
    } = (_consumeRouterReturn = consumeRouterReturn) !== null && _consumeRouterReturn !== void 0 ? _consumeRouterReturn : {
      consumeRouterReturn: {
        level: -1,
        matches: null,
        pathWhenMatching: null
      }
    };
    const controls = useRouterControls(level);
    A(ref, () => ({
      level,
      matches,
      pathWhenMatching,
      ...controls
    }));
    return o$2(RouterContext.Provider, {
      value: contextFromParent,
      children: children(level == -1 ? "/" : matches ? pathWhenMatching : null, useRouterControls(level))
    });
  }

  /**
   * Provides access to the requested Search Param's value
   *
   * Note that while this function is like usePassiveState (itself like useState and useEffect combined),
   * the `setState` return function is, due to browser limitations, not syncronous, but that's
   * like most calls to `setState` anyway I guess?
   *
   * @param paramKey The name of the URL search parameter to reference
   * @param type The type of data encode/decode (`"string"` | `"boolean"` | `"number"` | `"bigint"`)
   * @param onParamValueChanged Will be called any time the requested Search Parameter's value changes.
   */
  function useSearchParams(paramKey, type, onParamValueChanged) {
    // We keep a local copy of our current Search Param value
    // because changing it is actually an asyncronous operation
    // and we can't know when it ends aside from just "did the URL change or not"
    // so we might as well keep this state around locally to compensate.
    const [getSavedParamValue, setSavedParamValue] = usePassiveState$1(onParamValueChanged, T$1(() => {
      return parseParam(new URL(window.location.toString()), paramKey, type);
    }, []));
    const setParamWithHistory = useStableCallback$1((newValueOrUpdater, reason) => {
      let prevValue = parseParam(new URL(window.location.toString()), paramKey, type);
      let nextValue = typeof newValueOrUpdater == "function" ? newValueOrUpdater(prevValue) : newValueOrUpdater;
      let newParams = new URLSearchParams(new URL(window.location.toString()).searchParams);
      unparseParam(newParams, paramKey, nextValue, type);
      let nextUrl = new URL(window.location.toString());
      nextUrl.search = prettyPrintParams(newParams);
      history["".concat(reason !== null && reason !== void 0 ? reason : "replace", "State")]({}, document.title, nextUrl);
      setSavedParamValue(nextValue);
    });
    // Any time the URL changes, it means the Search Param we care about might have changed.
    // Parse it out and save it.
    useUrl(useStableCallback$1(url => {
      const newParam = parseParam(new URL(url), paramKey, type);
      setSavedParamValue(newParam);
    }));
    return [getSavedParamValue, setParamWithHistory];
  }
  function prettyPrintParams(params) {
    const paramArray = [...params.entries()].filter((key, value) => value != null);
    if (paramArray.length == 0) return "";
    let queryString = paramArray.map(_ref39 => {
      let [key, value] = _ref39;
      if (value === "" || value === true) return "".concat(encodeURIComponent(key));else return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
    }).join("&");
    return "?".concat(queryString);
  }
  const Component = () => {
    const [url, setUrl] = useState$1("");
    useUrl(setUrl);
    const [example, setExampleLocal] = useState$1(null);
    const [getExample, setExample] = useSearchParams("example", "number");
    return o$2(Router, {
      localPath: null,
      children: (path, _ref40) => {
        let {
          pushLocalPath,
          popLocalPath,
          setLocalPath
        } = _ref40;
        return path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is the current URL: ", o$2("code", {
              children: url
            }), "."]
          }), o$2("p", {
            children: "This is content in the root router. It is always displayed, no matter what."
          }), o$2("p", {
            children: ["The ", o$2("code", {
              children: "Router"
            }), " that's rendering this content cannot have path-related functions performed on it, since the path is always just implicitly ", o$2("code", {
              children: "/"
            }), "."]
          }), o$2("p", {
            children: "Just beneath me is a child component that reads the first path after the root."
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => {
                debugger;
                pushLocalPath("test1");
              },
              children: "Push \"test1\""
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => popLocalPath(),
              children: "Pop"
            })
          }), o$2("p", {
            children: o$2("button", {
              onClick: () => setLocalPath("test1"),
              children: "Set \"test1\""
            })
          }), o$2("p", {
            children: o$2("label", {
              children: ["Search param example: ", o$2("input", {
                value: example !== null && example !== void 0 ? example : undefined,
                type: "number",
                onInput: e => setExample(e.currentTarget.valueAsNumber)
              })]
            })
          }), o$2("hr", {}), o$2(Swappable, {
            children: o$2("div", {
              children: o$2(Level1, {})
            })
          })]
        });
      }
    });
  };
  function Level1() {
    //const [{ popLocalPath, pushLocalPath, setLocalPath }, setRouteControls] = useState<Partial<RouterControls>>({});
    return o$2(d$2, {
      children: [o$2(Router, {
        localPath: null,
        children: (path, _ref41) => {
          let {
            popLocalPath,
            pushLocalPath,
            setLocalPath
          } = _ref41;
          return path != null && o$2("div", {
            children: [o$2("p", {
              children: ["This is within the first-level child ", o$2("code", {
                children: "Router"
              }), " that displays ", o$2("em", {
                children: "default content"
              }), ". That is, if no other ", o$2("code", {
                children: "Router"
              }), " at this level matches (which is presumably true if you're reading this), then ", o$2("em", {
                children: "this"
              }), " ", o$2("code", {
                children: "Router"
              }), " will display."]
            }), o$2("p", {
              children: ["The current path is: ", o$2("code", {
                children: path
              })]
            }), o$2("p", {
              children: ["These buttons are hooked up to this ", o$2("code", {
                children: "Router"
              }), "'s ", o$2("code", {
                children: "ref"
              }), ", so they control this level in the path."]
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("");
              },
              children: "(empty string)"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test1");
              },
              children: "test1"
            }), o$2("button", {
              onClick: () => {
                debugger;
                setLocalPath === null || setLocalPath === void 0 ? void 0 : setLocalPath("test2");
              },
              children: "test2"
            })]
          });
        }
      }), o$2(Router, {
        localPath: "",
        children: path => path != null && o$2("div", {
          children: [o$2("p", {
            children: ["This is within the first-level child ", o$2("code", {
              children: "Router"
            }), " that displays when the path is empty (this is different from the default path, taken when there is no match from anyone at this level)."]
          }), o$2("p", {
            children: ["The current path is: ", o$2("code", {
              children: path
            })]
          })]
        })
      })]
    });
  }
  /*
  function Test1() {
        const [{ popLocalPath: popHash1, pushLocalPath: pushHash1, setLocalPath: setHash1 }, setRouteControls] = useState<Partial<RouterControls>>({});
       return (
          <>
              <p>This is within the first-level child <code>Router</code> that displays when the path is <code>test1</code>.<Test1 /></p>
              <p>Level 1, Test1
                  <button onClick={() => { debugger; pushHash1?.("testa") }}>testA</button>
                  <Router ref={setRouteControls} localPath="testa">
                      <div>A</div>
                  </Router>
              </p>
          </>
       )
  }
   function Test2() {
      const [route0Controls, setRoute0Controls] = useState<RouterRefType | null>(null);
      const [route1Controls, setRoute1Controls] = useState<RouterRefType | null>(null);
       const [param, setParam] = useSearchParams("param", "boolean");
      console.log(param == null ? "<null>" : param);
      return (<>
          Test2: "{param == null ? "<null>" : param}".
          <Swappable>
              <span>
                  <Router ref={setRoute1Controls} localPath="">
                      <div>
                          Test2
                          <button onClick={() => route1Controls?.setLocalPath?.("testa")}>testA</button>
                      </div>
                  </Router>
                  <Router ref={setRoute1Controls} localPath="testa">
                      <div>
                          <div>A</div>
                          <label><input checked={param ?? false} type="checkbox" onInput={e => { e.preventDefault(); setParam(e.currentTarget.checked) }} />Checkbox</label>
                      </div>
                  </Router>
              </span>
          </Swappable>
      </>
      )
  }*/
  requestAnimationFrame(() => {
    q$1(o$2(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9jYXRjaC1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tpbmctZWxlbWVudHNAMC4xLjEvbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS93aWNnLWluZXJ0QDMuMS4yL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLW1hbmFnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvUHVyZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9wb3J0YWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vY2xzeEAxLjIuMS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLWVzQDQuMTcuMjEvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9sb2Rhc2gtZXNANC4xNy4yMS9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2xvZGFzaC1lc0A0LjE3LjIxL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3V0aWwvbW9kZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLXJlZnMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC1wcm9wLWhlbHBlcnNAODY0NTg3OGFhMjhhZGUzMDhhODNlZDIxZTg1YWVlMzA4ZDM4YmExMl9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2NraW5nLWVsZW1lbnRzQDAuMS4xL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCJub2RlX21vZHVsZXMvLnBucG0vd2ljZy1pbmVydEAzLjEuMi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmVzbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1tYW5hZ2VkLWNoaWxkcmVuLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtcHJvcC1oZWxwZXJzQDg2NDU4NzhhYTI4YWRlMzA4YTgzZWQyMWU4NWFlZTMwOGQzOGJhMTJfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXByb3AtaGVscGVyc0A4NjQ1ODc4YWEyOGFkZTMwOGE4M2VkMjFlODVhZWUzMDhkMzhiYTEyX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy90aW1pbmcvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvY29udGV4dC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2V4Y2x1c2l2ZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3V0aWwvdXRpbC50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3N3YXBwYWJsZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb25hYmxlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvZmFkZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NsaXAudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jbGlwLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9jb2xsYXBzZS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL2NvbGxhcHNlLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9mbGlwLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvc2xpZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS1mYWRlLnRzeCIsIm5vZGVfbW9kdWxlcy8ucG5wbS9naXRodWIuY29tK213c3pla2VseStwcmVhY3QtdHJhbnNpdGlvbkBkMmQ0NGVjNTZmMDcwYjM3YzE2MTc0MTExOWU2ZjE1NGEzOGQ2MzEwX3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QtdHJhbnNpdGlvbi9zcmMvem9vbS50c3giLCJub2RlX21vZHVsZXMvLnBucG0vZ2l0aHViLmNvbSttd3N6ZWtlbHkrcHJlYWN0LXRyYW5zaXRpb25AZDJkNDRlYzU2ZjA3MGIzN2MxNjE3NDExMTllNmYxNTRhMzhkNjMxMF9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0LXRyYW5zaXRpb24vc3JjL3NsaWRlLXpvb20udHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy9zbGlkZS16b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL2dpdGh1Yi5jb20rbXdzemVrZWx5K3ByZWFjdC10cmFuc2l0aW9uQGQyZDQ0ZWM1NmYwNzBiMzdjMTYxNzQxMTE5ZTZmMTU0YTM4ZDYzMTBfcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC10cmFuc2l0aW9uL3NyYy96b29tLWZhZGUudHN4Iiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGV2dG9vbHMvc3JjL2RldnRvb2xzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NoZWNrLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3ByZWFjdEAxMC4xMy4wL25vZGVfbW9kdWxlcy9wcmVhY3QvZGVidWcvc3JjL2NvbXBvbmVudC1zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vcHJlYWN0QDEwLjEzLjAvbm9kZV9tb2R1bGVzL3ByZWFjdC9kZWJ1Zy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9wcmVhY3RAMTAuMTMuMC9ub2RlX21vZHVsZXMvcHJlYWN0L2RlYnVnL3NyYy9pbmRleC5qcyIsIi4uL3NyYy91c2UtdXJsLnRzeCIsIi4uL3NyYy91dGlsLnRzeCIsIi4uL3NyYy91c2Utcm91dGVyLWNvbnN1bWVyLnRzeCIsIi4uL3NyYy9yb290LXJvdXRlci1lcnJvci50cyIsIi4uL3NyYy91c2UtcG9wLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1wdXNoLWxvY2FsLXBhdGgudHN4IiwiLi4vc3JjL3VzZS1zZXQtbG9jYWwtcGF0aC50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1jb250cm9scy50c3giLCIuLi9zcmMvdXNlLXJvdXRlci1wcm92aWRlci50c3giLCIuLi9zcmMvcm91dGVyLnRzeCIsIi4uL3NyYy91c2Utc2VhcmNoLXBhcmFtcy50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHR3aGlsZSAoKGMgPSByZXJlbmRlclF1ZXVlLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKGMuX2RpcnR5KSB7XG5cdFx0XHRsZXQgcmVuZGVyUXVldWVMZW5ndGggPSByZXJlbmRlclF1ZXVlLmxlbmd0aDtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjKTtcblx0XHRcdGlmIChyZXJlbmRlclF1ZXVlLmxlbmd0aCA+IHJlbmRlclF1ZXVlTGVuZ3RoKSB7XG5cdFx0XHRcdC8vIFdoZW4gaS5lLiByZXJlbmRlcmluZyBhIHByb3ZpZGVyIGFkZGl0aW9uYWwgbmV3IGl0ZW1zIGNhbiBiZSBpbmplY3RlZCwgd2Ugd2FudCB0b1xuXHRcdFx0XHQvLyBrZWVwIHRoZSBvcmRlciBmcm9tIHRvcCB0byBib3R0b20gd2l0aCB0aG9zZSBuZXcgaXRlbXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtIGluIGFcblx0XHRcdFx0Ly8gc2luZ2xlIHBhc3Ncblx0XHRcdFx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbn1cblxucHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG4iLCJpbXBvcnQgeyBlbnF1ZXVlUmVuZGVyIH0gZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQgbGV0IGkgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNvbnRleHRJZCkge1xuXHRjb250ZXh0SWQgPSAnX19jQycgKyBpKys7XG5cblx0Y29uc3QgY29udGV4dCA9IHtcblx0XHRfaWQ6IGNvbnRleHRJZCxcblx0XHRfZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dFZhbHVlKSB7XG5cdFx0XHQvLyByZXR1cm4gcHJvcHMuY2hpbGRyZW4oXG5cdFx0XHQvLyBcdGNvbnRleHRbY29udGV4dElkXSA/IGNvbnRleHRbY29udGV4dElkXS5wcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZVxuXHRcdFx0Ly8gKTtcblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbihjb250ZXh0VmFsdWUpO1xuXHRcdH0sXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRQcm92aWRlcihwcm9wcykge1xuXHRcdFx0aWYgKCF0aGlzLmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudFtdfSAqL1xuXHRcdFx0XHRsZXQgc3VicyA9IFtdO1xuXHRcdFx0XHRsZXQgY3R4ID0ge307XG5cdFx0XHRcdGN0eFtjb250ZXh0SWRdID0gdGhpcztcblxuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IGN0eDtcblxuXHRcdFx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKF9wcm9wcykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBfcHJvcHMudmFsdWUpIHtcblx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhlIGZvcmNlZCB2YWx1ZSBwcm9wYWdhdGlvbiBoZXJlIHdhcyBvbmx5IG5lZWRlZCB3aGVuIGBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nYCB3YXMgYmVpbmcgYnlwYXNzZWQ6XG5cdFx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2NvbW1pdC80ZDMzOWZiODAzYmVhMDllOWYxOThhYmYzOGNhMWJmOGVhNGI3NzcxI2RpZmYtNTQ2ODJjZTM4MDkzNWE3MTdlNDFiOGJmYzU0NzM3ZjZSMzU4XG5cdFx0XHRcdFx0XHQvLyBJbiB0aG9zZSBjYXNlcyB0aG91Z2gsIGV2ZW4gd2l0aCB0aGUgdmFsdWUgY29ycmVjdGVkLCB3ZSdyZSBkb3VibGUtcmVuZGVyaW5nIGFsbCBub2Rlcy5cblx0XHRcdFx0XHRcdC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IHRlbGwgZm9sa3Mgbm90IHRvIHVzZSBmb3JjZS1zeW5jIG1vZGUuXG5cdFx0XHRcdFx0XHQvLyBDdXJyZW50bHksIHVzaW5nIGB1c2VDb250ZXh0KClgIGluIGEgY2xhc3MgY29tcG9uZW50IHdpbGwgb3ZlcndyaXRlIGl0cyBgdGhpcy5jb250ZXh0YCB2YWx1ZS5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0ID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0W2NvbnRleHRJZF0gPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0XHRcdHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdFx0Yy5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc3ViID0gYyA9PiB7XG5cdFx0XHRcdFx0c3Vicy5wdXNoKGMpO1xuXHRcdFx0XHRcdGxldCBvbGQgPSBjLmNvbXBvbmVudFdpbGxVbm1vdW50O1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKG9sZCkgb2xkLmNhbGwoYyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuXHRcdH1cblx0fTtcblxuXHQvLyBEZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHdoZW4gaXRcblx0Ly8gZW5jb3VudGVycyBhIFByb3ZpZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0XG5cdC8vIHNldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiB0aGUgY29udGV4dCBvYmplY3QgaW5zdGVhZFxuXHQvLyBvZiBvbiB0aGUgY29tcG9uZW50IGl0c2VsZi4gU2VlOlxuXHQvLyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sI2NvbnRleHRkaXNwbGF5bmFtZVxuXG5cdHJldHVybiAoY29udGV4dC5Qcm92aWRlci5fY29udGV4dFJlZiA9IGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5yZWYgPyBjaGlsZFZOb2RlLnJlZiA6IG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXRMYXN0RG9tKG9sZFBhcmVudFZOb2RlKS5uZXh0U2libGluZztcblx0XHRcdH1cblxuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKHBhcmVudERvbSwgdm5vZGUsIHZub2RlLCBjLCB2bm9kZS5fZG9tLCBvbGREb20pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAxXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGdldExhc3REb20odm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT0gbnVsbCB8fCB0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUuX2RvbTtcblx0fVxuXG5cdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRmb3IgKGxldCBpID0gdm5vZGUuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdFx0bGV0IGxhc3REb20gPSBnZXRMYXN0RG9tKGNoaWxkKTtcblx0XHRcdFx0aWYgKGxhc3REb20pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFzdERvbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnd2lkdGgnICYmXG5cdFx0XHRuYW1lICE9PSAnaGVpZ2h0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlICE9PSBmYWxzZSB8fCBuYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkpIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFByb3h5IGFuIGV2ZW50IHRvIGhvb2tlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGJyb3dzZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuXHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIGZhbHNlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkge1xuXHRcdFx0XHRcdFx0Ly8gV2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgYmFpbCBiZWNhdXNlIG9mIHNDVSB3ZSBoYXZlIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdFx0Ly8gdGhlIHByb3BzLCBzdGF0ZSBhbmQgZGlydHktc3RhdGUuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggc3RyaWN0LWVxdWFsaXR5IHdlIGRvbid0IGFzIHRoZSBjaGlsZCBjb3VsZCBzdGlsbFxuXHRcdFx0XHRcdFx0Ly8gYmUgZGlydGllZCBzZWUgIzM4ODNcblx0XHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEluIGNhc2VzIG9mIGJhaWxpbmcgZHVlIHRvIHN0cmljdC1lcXVhbGl0eSB3ZSBoYXZlIHRvIHJlc2V0IGZvcmNlIGFzIHdlbGxcblx0XHRcdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4uZm9yRWFjaCh2bm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUpIHZub2RlLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblxuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50V2lsbFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjLmNvbXBvbmVudERpZFVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0Yy5fcGFyZW50RG9tID0gcGFyZW50RG9tO1xuXG5cdFx0XHRsZXQgcmVuZGVySG9vayA9IG9wdGlvbnMuX3JlbmRlcixcblx0XHRcdFx0Y291bnQgPSAwO1xuXHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHR9IHdoaWxlIChjLl9kaXJ0eSAmJiArK2NvdW50IDwgMjUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09PSBGcmFnbWVudCAmJiB0bXAua2V5ID09IG51bGw7XG5cdFx0XHRsZXQgcmVuZGVyUmVzdWx0ID0gaXNUb3BMZXZlbEZyYWdtZW50ID8gdG1wLnByb3BzLmNoaWxkcmVuIDogdG1wO1xuXG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShyZW5kZXJSZXN1bHQpID8gcmVuZGVyUmVzdWx0IDogW3JlbmRlclJlc3VsdF0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0Ly8gV2Ugc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgVk5vZGUsIHVuc2V0IGFueSBzdG9yZWQgaHlkcmF0aW9uL2JhaWxvdXQgc3RhdGU6XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0Ly8gaWYgaHlkcmF0aW5nIG9yIGNyZWF0aW5nIGluaXRpYWwgdHJlZSwgYmFpbG91dCBwcmVzZXJ2ZXMgRE9NOlxuXHRcdGlmIChpc0h5ZHJhdGluZyB8fCBleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkRG9tO1xuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9ICEhaXNIeWRyYXRpbmc7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbltleGNlc3NEb21DaGlsZHJlbi5pbmRleE9mKG9sZERvbSldID0gbnVsbDtcblx0XHRcdC8vIF4gY291bGQgcG9zc2libHkgYmUgc2ltcGxpZmllZCB0bzpcblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBSZXVzZSB0aGUgY29tbWl0UXVldWUgdmFyaWFibGUgaGVyZSBzbyB0aGUgdHlwZSBjaGFuZ2VzXG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgU2VlIGFib3ZlIHRzLWlnbm9yZSBvbiBjb21taXRRdWV1ZVxuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cdGxldCBub2RlVHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cdGxldCBpID0gMDtcblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aWYgKG5vZGVUeXBlID09PSAnc3ZnJykgaXNTdmcgPSB0cnVlO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yICg7IGkgPCBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBleGNlc3NEb21DaGlsZHJlbltpXTtcblxuXHRcdFx0Ly8gaWYgbmV3Vk5vZGUgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuIG9yIHRoZSBgZG9tYFxuXHRcdFx0Ly8gYXJndW1lbnQgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuLCByZW1vdmUgaXQgZnJvbVxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4gc28gaXQgaXNuJ3QgbGF0ZXIgcmVtb3ZlZCBpbiBkaWZmQ2hpbGRyZW5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2hpbGQgJiZcblx0XHRcdFx0J3NldEF0dHJpYnV0ZScgaW4gY2hpbGQgPT09ICEhbm9kZVR5cGUgJiZcblx0XHRcdFx0KG5vZGVUeXBlID8gY2hpbGQubG9jYWxOYW1lID09PSBub2RlVHlwZSA6IGNoaWxkLm5vZGVUeXBlID09PSAzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRvbSA9IGNoaWxkO1xuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gPT0gbnVsbCkge1xuXHRcdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBjcmVhdGVUZXh0Tm9kZSByZXR1cm5zIFRleHQsIHdlIGV4cGVjdCBQcmVhY3RFbGVtZW50XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3UHJvcHMpO1xuXHRcdH1cblxuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuXHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlLFxuXHRcdFx0XHRuZXdQcm9wcy5pcyAmJiBuZXdQcm9wc1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHdlIHN0aWxsIGhhdmUgdG8gc3BsaXQgbWVyZ2VkIHRleHQgZnJvbSBTU1InZCBIVE1MLlxuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgKCFpc0h5ZHJhdGluZyB8fCBkb20uZGF0YSAhPT0gbmV3UHJvcHMpKSB7XG5cdFx0XHRkb20uZGF0YSA9IG5ld1Byb3BzO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBJZiBleGNlc3NEb21DaGlsZHJlbiB3YXMgbm90IG51bGwsIHJlcG9wdWxhdGUgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW46XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBleGNlc3NEb21DaGlsZHJlbiAmJiBzbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0Ly8gQnV0LCBpZiB3ZSBhcmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIHVzaW5nIGV4aXN0aW5nIERPTSAoZS5nLiByZXBsYWNlTm9kZSlcblx0XHRcdC8vIHdlIHNob3VsZCByZWFkIHRoZSBleGlzdGluZyBET00gYXR0cmlidXRlcyB0byBkaWZmIHRoZW1cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdG9sZFByb3BzID0ge307XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXdIdG1sIHx8XG5cdFx0XHRcdFx0KCghb2xkSHRtbCB8fCBuZXdIdG1sLl9faHRtbCAhPSBvbGRIdG1sLl9faHRtbCkgJiZcblx0XHRcdFx0XHRcdG5ld0h0bWwuX19odG1sICE9PSBkb20uaW5uZXJIVE1MKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2ZyAmJiBub2RlVHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuXG5cdFx0XHRcdFx0PyBleGNlc3NEb21DaGlsZHJlblswXVxuXHRcdFx0XHRcdDogb2xkVk5vZGUuX2NoaWxkcmVuICYmIGdldERvbVNpYmxpbmcob2xkVk5vZGUsIDApLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW5baV0gIT0gbnVsbCkgcmVtb3ZlTm9kZShleGNlc3NEb21DaGlsZHJlbltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyAjMjc1NiBGb3IgdGhlIDxwcm9ncmVzcz4tZWxlbWVudCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyAwLFxuXHRcdFx0XHQvLyBkZXNwaXRlIHRoZSBhdHRyaWJ1dGUgbm90IGJlaW5nIHByZXNlbnQuIFdoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBpcyBtaXNzaW5nIHRoZSBwcm9ncmVzcyBiYXIgaXMgdHJlYXRlZCBhcyBpbmRldGVybWluYXRlLlxuXHRcdFx0XHQvLyBUbyBmaXggdGhhdCB3ZSdsbCBhbHdheXMgdXBkYXRlIGl0IHdoZW4gaXQgaXMgMCBmb3IgcHJvZ3Jlc3MgZWxlbWVudHNcblx0XHRcdFx0KGkgIT09IGRvbS52YWx1ZSB8fFxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ3Byb2dyZXNzJyAmJiAhaSkgfHxcblx0XHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgZm9yIElFIDExIHRvIGZpeCA8c2VsZWN0PiB2YWx1ZSBub3QgYmVpbmcgdXBkYXRlZC5cblx0XHRcdFx0XHQvLyBUbyBhdm9pZCBhIHN0YWxlIHNlbGVjdCB2YWx1ZSB3ZSBuZWVkIHRvIHNldCB0aGUgb3B0aW9uLnZhbHVlXG5cdFx0XHRcdFx0Ly8gYWdhaW4sIHdoaWNoIHRyaWdnZXJzIElFMTEgdG8gcmUtZXZhbHVhdGUgdGhlIHNlbGVjdCB2YWx1ZVxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ29wdGlvbicgJiYgaSAhPT0gb2xkUHJvcHMudmFsdWUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ3ZhbHVlJywgaSwgb2xkUHJvcHMudmFsdWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0J2NoZWNrZWQnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMuY2hlY2tlZCkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20uY2hlY2tlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ2NoZWNrZWQnLCBpLCBvbGRQcm9wcy5jaGVja2VkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBJbnZva2Ugb3IgdXBkYXRlIGEgcmVmLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uIG9yIG9iamVjdCByZWYuXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcmVmXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSwgdm5vZGUpIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuXHRcdGVsc2UgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgdm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVW5tb3VudCBhIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCBhcHBseSBET00gY2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gdW5tb3VudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHBhcmVudFZOb2RlIFRoZSBwYXJlbnQgb2YgdGhlIFZOb2RlIHRoYXRcbiAqIGluaXRpYXRlZCB0aGUgdW5tb3VudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZV0gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGEgcGFyZW50IG5vZGUgb2YgdGhlXG4gKiBjdXJyZW50IGVsZW1lbnQgaXMgYWxyZWFkeSBkZXRhY2hlZCBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KHZub2RlLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSkge1xuXHRsZXQgcjtcblx0aWYgKG9wdGlvbnMudW5tb3VudCkgb3B0aW9ucy51bm1vdW50KHZub2RlKTtcblxuXHRpZiAoKHIgPSB2bm9kZS5yZWYpKSB7XG5cdFx0aWYgKCFyLmN1cnJlbnQgfHwgci5jdXJyZW50ID09PSB2bm9kZS5fZG9tKSB7XG5cdFx0XHRhcHBseVJlZihyLCBudWxsLCBwYXJlbnRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdFx0dm5vZGUuX2NvbXBvbmVudCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyW2ldKSB7XG5cdFx0XHRcdHVubW91bnQoXG5cdFx0XHRcdFx0cltpXSxcblx0XHRcdFx0XHRwYXJlbnRWTm9kZSxcblx0XHRcdFx0XHRza2lwUmVtb3ZlIHx8IHR5cGVvZiB2bm9kZS50eXBlICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFza2lwUmVtb3ZlICYmIHZub2RlLl9kb20gIT0gbnVsbCkge1xuXHRcdHJlbW92ZU5vZGUodm5vZGUuX2RvbSk7XG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCB0byBgdW5kZWZpbmVkYCB0byBwcm9wZXJseSBjbGVhbiB1cCBgX25leHREb21gXG5cdC8vIGZvciB3aGljaCBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZS4gU2VlIGNvbW1lbnQgaW4gYGNyZWF0ZS1lbGVtZW50LmpzYFxuXHR2bm9kZS5fcGFyZW50ID0gdm5vZGUuX2RvbSA9IHZub2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xufVxuXG4vKiogVGhlIGAucmVuZGVyKClgIG1ldGhvZCBmb3IgYSBQRkMgYmFja2luZyBpbnN0YW5jZS4gKi9cbmZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwiaW1wb3J0IHsgYXNzaWduLCBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBhc3NpZ24oe30sIHZub2RlLnByb3BzKSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUoXG5cdFx0dm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5IHx8IHZub2RlLmtleSxcblx0XHRyZWYgfHwgdm5vZGUucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cbiIsIi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gW29sZFZOb2RlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuRXJyb3JJbmZvfSBbZXJyb3JJbmZvXVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgY3RvciwgaGFuZGxlZDtcblxuXHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5fcHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRpZiAoY3RvciAmJiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyB8fCB7fSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVycm9yIGJvdW5kYXJ5LiBNYXJrIGl0IGFzIGhhdmluZyBiYWlsZWQgb3V0LCBhbmQgd2hldGhlciBpdCB3YXMgbWlkLWh5ZHJhdGlvbi5cblx0XHRcdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGNvbXBvbmVudC5fcGVuZGluZ0Vycm9yID0gY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdwcmVhY3QnKS5WTm9kZX0gVk5vZGUgKi9cblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgZmlsZSBleHBvcnRzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBCYWJlbCdzIFwiYXV0b21hdGljXCIgSlNYIHJ1bnRpbWUgQVBJOlxuICogLSBqc3godHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4cyh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgX19zb3VyY2UsIF9fc2VsZilcbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlVk5vZGUgaGVyZSBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLlxuICogQmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81ZjZiNTRhMGI0NjMyMTAwYTdkY2QyYjNcbiAqL1xuXG4vKipcbiAqIEpTWC5FbGVtZW50IGZhY3RvcnkgdXNlZCBieSBCYWJlbCdzIHtydW50aW1lOlwiYXV0b21hdGljXCJ9IEpTWCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Vk5vZGVbJ3R5cGUnXX0gdHlwZVxuICogQHBhcmFtIHtWTm9kZVsncHJvcHMnXX0gcHJvcHNcbiAqIEBwYXJhbSB7Vk5vZGVbJ2tleSddfSBba2V5XVxuICogQHBhcmFtIHt1bmtub3dufSBbaXNTdGF0aWNDaGlsZHJlbl1cbiAqIEBwYXJhbSB7dW5rbm93bn0gW19fc291cmNlXVxuICogQHBhcmFtIHt1bmtub3dufSBbX19zZWxmXVxuICovXG5mdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBfX3NvdXJjZSwgX19zZWxmKSB7XG5cdC8vIFdlJ2xsIHdhbnQgdG8gcHJlc2VydmUgYHJlZmAgaW4gcHJvcHMgdG8gZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3Jcblx0Ly8gZm9yd2FyZFJlZiBjb21wb25lbnRzIGluIHRoZSBmdXR1cmUsIGJ1dCB0aGF0IHNob3VsZCBoYXBwZW4gdmlhXG5cdC8vIGEgc2VwYXJhdGUgUFIuXG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ3JlZicpIHtcblx0XHRcdHJlZiA9IHByb3BzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzOiBub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogLS12bm9kZUlkLFxuXHRcdF9fc291cmNlLFxuXHRcdF9fc2VsZlxuXHR9O1xuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wcy5cblx0Ly8gTm90ZTogYHR5cGVgIGlzIG9mdGVuIGEgU3RyaW5nLCBhbmQgY2FuIGJlIGB1bmRlZmluZWRgIGluIGRldmVsb3BtZW50LlxuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgKHJlZiA9IHR5cGUuZGVmYXVsdFByb3BzKSkge1xuXHRcdGZvciAoaSBpbiByZWYpXG5cdFx0XHRpZiAodHlwZW9mIG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcmVmW2ldO1xuXHRcdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCB7XG5cdGNyZWF0ZVZOb2RlIGFzIGpzeCxcblx0Y3JlYXRlVk5vZGUgYXMganN4cyxcblx0Y3JlYXRlVk5vZGUgYXMganN4REVWLFxuXHRGcmFnbWVudFxufTtcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Yy5fX2hvb2tzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tTdGF0ZS5fbmV4dFZhbHVlXG5cdFx0XHRcdFx0PyBob29rU3RhdGUuX25leHRWYWx1ZVswXVxuXHRcdFx0XHRcdDogaG9va1N0YXRlLl92YWx1ZVswXTtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGN1cnJlbnRWYWx1ZSwgYWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX25leHRWYWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cblx0XHRpZiAoIWN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcykge1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHByZXZTY3UgPSBjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0Y3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaERlbGV0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hIYXM7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoU2V0O1xuIiwiaW1wb3J0IGhhc2hDbGVhciBmcm9tICcuL19oYXNoQ2xlYXIuanMnO1xuaW1wb3J0IGhhc2hEZWxldGUgZnJvbSAnLi9faGFzaERlbGV0ZS5qcyc7XG5pbXBvcnQgaGFzaEdldCBmcm9tICcuL19oYXNoR2V0LmpzJztcbmltcG9ydCBoYXNoSGFzIGZyb20gJy4vX2hhc2hIYXMuanMnO1xuaW1wb3J0IGhhc2hTZXQgZnJvbSAnLi9faGFzaFNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBjb25zdCBwcm9jZXNzOiB7IGVudjogeyBOT0RFX0VOVj86IHN0cmluZyB8IHVuZGVmaW5lZCB9IHwgdW5kZWZpbmVkIH0gfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICB9XG4gICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRCdWlsZE1vZGUgPSBtZW1vaXplKGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQpIGFzIHR5cGVvZiBnZXRCdWlsZE1vZGVVbm1lbW9pemVkOyIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXRCdWlsZE1vZGUgfSBmcm9tIFwiLi4vdXRpbC9tb2RlLmpzXCI7XG5cbi8qKiBUYWtlcyBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBhIHZhbHVlLCB1bmxpa2UgYE9uUGFzc2l2ZVN0YXRlQ2hhbmdlYCB3aGljaCByZWFjdHMgdG8gdGhvc2UgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTLCBSPiA9ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCkgOiAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb246IFIpID0+IHZvaWQpO1xuLyoqIFJlc3BvbmRzIHRvIGEgY2hhbmdlIGluIGEgdmFsdWUsIHVubGlrZSBgUGFzc2l2ZVN0YXRlVXBkYXRlcmAgd2hpY2ggY2F1c2VzIHRoZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxTLCBSPiA9ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKSA6ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uOiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG5cblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgaWYgKGdldEJ1aWxkTW9kZSgpID09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmPEFycmF5PFQ+PihbXSk7XG4gICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZjxBcnJheTxib29sZWFuPj4oW10pO1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoIGFzIGFueSwgLTEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VSBleHRlbmRzIFQ+KHZhbHVlOiBVLCBpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgMTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2l9LWluZGV4ZWQgYXJndW1lbnQgKCR7aSA+PSAwPyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbaV0pIDogXCJ0aGUgbnVtYmVyIG9mIHN1cHBvc2VkbHkgc3RhYmxlIGVsZW1lbnRzXCJ9KS5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxULCBSPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQsIFI+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzFdKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID09PSBVbnNldCAmJiBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJlYXNvblJlZi5jdXJyZW50ID0gcmVhc29uIGFzIFI7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVhc29uID0gcmVhc29uUmVmLmN1cnJlbnQhIGFzIFI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHByZXZEZXAsIG5leHRSZWFzb24pID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfVxuXG4vKiogXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byB1c2UgZm9yIGBjdXN0b21EZWJvdW5jZVJlbmRlcmluZ2AgdGhhdCBjYXVzZXMgYHVzZVBhc3NpdmVTdGF0ZWAgdG8gcnVuIGNoYW5nZXMgd2l0aG91dCB3YWl0aW5nIGEgdGljay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHsgZigpOyB9IiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuXG5cbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XG5cbmZ1bmN0aW9uIGJhc2U2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDBiMTAwMDAwMCk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTY0Qml0cygpIHtcbiAgICByZXR1cm4gW3JhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCldIGFzIGNvbnN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cbiAqIElEcyB0aGF0IGFyZSBub3QgdmFsaWQgdW5kZXIgSFRNTDQgbWF5IGJlIGdlbmVyYXRlZC4gT2ggbm8uXG4gKiBcbiAqIFxuICogKFRoaXMgaXMgaGVyZSwgaW4gdGhpcyBwYXJ0aWN1bGFyIGZpbGUsIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxuICogT25jZSB3ZSBjYW4gcmVtb3ZlIHRoaXMgaG9vaywgd2UgY2FuIHB1dCB0aGlzIGZ1bmN0aW9uIGJhY2sgd2l0aCB1c2VSYW5kb21JZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XG59XG5cbmNvbnN0IHByZXZpb3VzSW5wdXRzID0gbmV3IE1hcDxzdHJpbmcsIElucHV0cyB8IHVuZGVmaW5lZD4oKTtcbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV0gYXMgKHZub2RlOiBWTm9kZSwgY29tbWl0UXVldWU6IENvbXBvbmVudFtdKSA9PiB2b2lkO1xuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBlZmZlY3RJbmZvXSBvZiB0b1J1bikge1xuICAgICAgICBjb25zdCBvbGRJbnB1dHMgPSBwcmV2aW91c0lucHV0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKC4uLmFyZ3MpO1xufVxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrIHwgbnVsbCwgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgaWYgKGVmZmVjdClcbiAgICAgICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuICAgIGVsc2VcbiAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QuanNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCkge1xuXG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0pLCBbdmFsdWVdKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xufVxuXG5cbi8qKlxuICogTGlrZSBgdXNlU3RhYmxlR2V0dGVyYCwgYnV0ICoqKnJlcXVpcmVzKioqIHRoYXQgZXZlcnl0aGluZyBpbiB0aGUgb2JqZWN0IGlzIGFsc28gc3RhYmxlLFxuICogYW5kIGluIHR1cm4gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpdHNlbGYgaXMgc3RhYmxlLlxuICogQHBhcmFtIHQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZU9iamVjdDxUIGV4dGVuZHMge30+KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmVudHJpZXModCk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU3RhYmxlT2JqZWN0XCIsIGUubGVuZ3RoLCAuLi5lLm1hcCgoW19rLCB2XSkgPT4gdikpO1xuICAgIHJldHVybiB1c2VSZWYodCkuY3VycmVudDtcbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2tOYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuXG4vL2NvbnN0IF9JU19TVEFCTEVfR0VUVEVSID0gU3ltYm9sKFwiU1RBQkxFXCIpO1xuZXhwb3J0IHR5cGUgU3RhYmxlPFQ+ID0gVDsvLyAmIHsgW19TVEFCTEVdOiB0cnVlIH07XG5cbi8qKlxuICogV2Uga2VlcCB0cmFjayBvZiB3aGljaCBjYWxsYmFja3MgYXJlIHN0YWJsZSB3aXRoIGEgV2Vha01hcCBpbnN0ZWFkIG9mLCBzYXksIGEgc3ltYm9sIGJlY2F1c2VcbiAqIGB1c2VDYWxsYmFja2Agd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0J3Mgc3RhYmxlIGFjcm9zcyAqYWxsKiByZW5kZXJzLCBtZWFuaW5nXG4gKiB3ZSBjYW4ndCB1c2Ugb3VyIGZ1bm55IFwiYGlmYCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGJyZWFrIHRoZSBydWxlcyBvZiBob29rc1wiIHRyaWNrIHRoZW4uXG4gKi9cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPEZ1bmN0aW9uLCBib29sZWFuPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzIEZ1bmN0aW9uPihvYmo6IFQpOiBvYmogaXMgU3RhYmxlPFQ+IHtcbiAgICByZXR1cm4gKG1hcC5nZXQob2JqKSA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZXRJc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihvYmo6IFQpOiBTdGFibGU8VD4ge1xuICAgIG1hcC5zZXQob2JqLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIEluIGdlbmVyYWwsIGp1c3QgcGFzcyB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgc3RhYmxlIChidXQgeW91IGNhbid0IHVzZSBpdCBkdXJpbmcgcmVuZGVyLFxuICogc28gYmUgY2FyZWZ1bCEpLiAgQWx0ZXJuYXRpdmVseSwgaWYgeW91IG5lZWQgYSBzdGFibGUgY2FsbGJhY2sgdGhhdCAqKmNhbioqIGJlIHVzZWRcbiAqIGR1cmluZyByZW5kZXIsIHBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBhbmQgaXQnbGwgYWN0IGxpa2UgYHVzZUNhbGxiYWNrYCB3aXRoIGFuXG4gKiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5LCBidXQgd2l0aCB0aGUgYXNzb2NpYXRlZCBzdGFibGUgdHlwaW5nLiBJbiB0aGlzIGNhc2UsIHlvdSAqKiptdXN0KioqIGVuc3VyZSB0aGF0IGl0XG4gKiB0cnVseSBoYXMgbm8gZGVwZW5kZW5jaWVzL29ubHkgc3RhYmxlIGRlcGVuZGVuY2llcyEhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgaCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wcy5qc1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxuICogXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cbiAqIFxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cbiAqL1xudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xuXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XG5cblxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xuXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcblxuXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xuXG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICogXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcbiAqIFxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxuICogXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqIFxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuIFxuICogSXQgdGFrZXMgZGlmZmVyZW50IGV2ZW50IHN0cmluZyB0eXBlcyAob25FdmVudCB2cyBvbmV2ZW50KS5cbiAqIFxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICogKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0sIG1vZGU/OiBcImdyb3VwZWRcIiB8IFwic2luZ2xlXCIpOiB2b2lkIHtcbiAgICBtb2RlIHx8PSBcImdyb3VwZWRcIjtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VHbG9iYWxIYW5kbGVyXCIsIG1vZGUpO1xuXG4gICAgaWYgKG1vZGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXG4gICAgICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXG4gICAgICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXG4gICAgICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJHcm91cGVkPFQsIEV2ZW50VHlwZSwgSD4odGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXJTaW5nbGU8VCwgRXZlbnRUeXBlLCBIPih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxudHlwZSBHbG9iYWxIYW5kbGVySW5mbyA9IHsgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7IGxpc3RlbmVyczogU2V0PEV2ZW50TGlzdGVuZXI+OyB9O1xudHlwZSBNYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8c3RyaW5nLCBHbG9iYWxIYW5kbGVySW5mbz5cbnR5cGUgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8gPSBNYXA8VHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RXZlbnRUYXJnZXQ+LCBNYXBPZk9wdGlvbnNUb0luZm8+O1xubGV0IG1hcFRoaW5nID0gbmV3IE1hcDxFdmVudFRhcmdldCwgTWFwT2ZUeXBlVG9NYXBPZk9wdGlvbnNUb0luZm8+KCk7XG5cbmZ1bmN0aW9uIGRvTWFwVGhpbmc8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPj4ob3A6IChpOiBHbG9iYWxIYW5kbGVySW5mbywgaDogRXZlbnRMaXN0ZW5lcikgPT4gdm9pZCwgdGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCBFdmVudExpc3RlbmVyLCBvcHRpb25zOiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBpZiAoaGFuZGxlcikge1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnNLZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYnlUeXBlID0gbWFwVGhpbmcuZ2V0KHRhcmdldCkgfHwgKG5ldyBNYXAoKSBhcyBNYXBPZlR5cGVUb01hcE9mT3B0aW9uc1RvSW5mbyk7XG4gICAgICAgIGNvbnN0IGJ5T3B0aW9ucyA9IChieVR5cGUuZ2V0KHR5cGUpIHx8IChuZXcgTWFwKCkgYXMgTWFwT2ZPcHRpb25zVG9JbmZvKSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBieU9wdGlvbnMuZ2V0KG9wdGlvbnNLZXkpIHx8IHsgbGlzdGVuZXI6IG51bGwhLCBsaXN0ZW5lcnM6IG5ldyBTZXQoKSB9O1xuXG4gICAgICAgIG9wKGluZm8sIGhhbmRsZXIpO1xuXG4gICAgICAgIGJ5T3B0aW9ucy5zZXQob3B0aW9uc0tleSwgaW5mbyk7XG4gICAgICAgIGJ5VHlwZS5zZXQodHlwZSwgYnlPcHRpb25zKTtcbiAgICAgICAgbWFwVGhpbmcuc2V0KHRhcmdldCwgYnlUeXBlKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWRkVG9NYXBUaGluZzxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8IEV2ZW50TGlzdGVuZXIsIG9wdGlvbnM6IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuYWRkKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbU1hcFRoaW5nPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgRXZlbnRMaXN0ZW5lciwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuICAgIGRvTWFwVGhpbmcoKGluZm8sIGgpID0+IHtcbiAgICAgICAgaW5mby5saXN0ZW5lcnMuZGVsZXRlKGgpO1xuICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PSBudWxsKVxuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaW5mby5saXN0ZW5lciA9IGUgPT4gaW5mby5saXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbihlKSksIG9wdGlvbnMpO1xuICAgIH0sIHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB3YXkgZmFzdGVyIGZvciBsYXJnZSBudW1iZXJzIG9mIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBGb3IgZXhhbXBsZSwgaWYgZXZlcnkgYnV0dG9uIGxpc3RlbnMgZm9yIGEgZ2xvYmFsIGNsaWNrLCBvciBzb21ldGhpbmcsXG4gKiBpdCB3b3VsZCBiZSBuaWNlIGlmIGl0IHdhcyBlZmZpY2llbnQgYXQgbGVhc3QuIFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyR3JvdXBlZDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGFkZFRvTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVGcm9tTWFwVGhpbmcodGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlclNpbmdsZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cbiAqIFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICogXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIGBgYFxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xuXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcbiAgICAgICAgfSwgW3R5cGVdKTtcblxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XG5cbiAgICB9LCBbXSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3V0aWwvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFjay5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXIuanNcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvL21hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxuXG4gICAgbWFuYWdlZENoaWxkQ29udGV4dDoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5OiBJbnRlcm5hbENoaWxkSW5mbzxNPjtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSwgbW91bnRlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSkgPT4gKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IHtcbiAgICBpbmRleDogVDtcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUT0RPOiBUaGlzIGVuZGVkIHVwIG5vdCBiZWluZyBuZWVkZWQgYnkgYW55dGhpbmcuIElzIGl0IG5lY2Vzc2FyeT8gRG9lcyBpdCBjb3N0IGFueXRoaW5nP1xuICAgICAgICAgKi9cbiAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxNW1wiaW5kZXhcIl0+O1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPE1bXCJpbmRleFwiXT47XG4gICAgXG4gICAgICAgIG9uQ2hpbGRDb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNvdW50OiBudW1iZXIpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHkgc2hhcmVkIGFtb25nIGFsbCBtYW5hZ2VkIGNoaWxkcmVuLlxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgcmVkdW5kYW50IHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCwgd2hpY2ggaXMuLi5laC4gQnV0IHRoZSB0eXBlcyBhcmUgY2xlYXIuXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxNLCBcImluZGV4XCI+O1xuXG4gICAgLyoqXG4gICAgICogSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRuJ3QgYmUgbnVsbCwgYnV0IGZvciBjb252ZW5pZW5jZSdzIHNha2UgeW91IGFyZSBhbGxvd2VkIHRvLCB3aGljaCBkaXNhYmxlcyBhbGwgYmVoYXZpb3IsIGFuZCBhbHNvIG1lYW5zIGBnZXRDaGlsZHJlbmAgd2lsbCBiZSBgdW5kZWZpbmVkYCFcbiAgICAgKi9cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHwgbnVsbDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKioqU1RBQkxFKioqXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCAqKmJvdGgqKiBgZ2V0Q2hpbGRyZW5gIGFuZCB0aGUgYE1hbmFnZWRDaGlsZHJlbmAgb2JqZWN0IGl0IHJldHVybnMgYXJlIHN0YWJsZSFcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgaW5zdGVhZCBvZiBhbiBvYmplY3QgYmVjYXVzZSB3aGVuIGZ1bmN0aW9uIGNhbGxzIGhhcHBlbiBvdXQgb2Ygb3JkZXIgaXQncyBlYXNpZXIgdG8ganVzdCBoYXZlIGFsd2F5cyBiZWVuIHBhc3NpbmcgYW5kIHJldHVybiBnZXR0ZXJzIGV2ZXJ5d2hlcmUgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cbiAgICB9O1xuXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogTVtcImluZGV4XCJdKTogTSB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNW107XG59XG5cbmludGVyZmFjZSBJbnRlcm5hbENoaWxkSW5mbzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PiB7XG4gICAgYXJyOiBBcnJheTxNPjtcbiAgICByZWM6IFBhcnRpYWw8UmVjb3JkPE1bXCJpbmRleFwiXSwgTT4+O1xuICAgIGhpZ2hlc3RJbmRleDogbnVtYmVyO1xuICAgIGxvd2VzdEluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmcgfCBudW1iZXI+PihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPiB7XG4gICAgdHlwZSBJbmRleFR5cGUgPSBNW1wiaW5kZXhcIl07XG4gICAgdHlwZSBJbmZvID0gTTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uQ2hpbGRDb3VudENoYW5nZSk7XG5cbiAgICAvL2NvbnN0IFtnZXRNb3VudENvdW50LCBzZXRNb3VudENvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZShvbkNoaWxkQ291bnRDaGFuZ2UsIHJldHVyblplcm8sIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8SW50ZXJuYWxDaGlsZEluZm88TT4+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPE0+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGlmIChvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob25DaGlsZENvdW50Q2hhbmdlIHx8IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPy4oZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkQ29udGV4dDogeyBnZXRDaGlsZHJlbiwgbWFuYWdlZENoaWxkcmVuQXJyYXksIHJlbW90ZVVMRUNoaWxkTW91bnRlZCwgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIH0gfSA9IChpbmZvLmNvbnRleHQgPz8geyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuQXJyYXkgPT0gbnVsbCB8fCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4hIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbiwgbmV3U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCwgcHJldlNlbGVjdGVkSW5kZXg6IE1bXCJpbmRleFwiXSB8IG51bGwpOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBNYW51YWxseSBjaGFuZ2VzIHRoZSBjdXJyZW50IGluZGV4IHRoYXQgaXMgKGZvY3VzZWQvc2VsZWN0ZWQvdGFiYmFibGUvd2hhdGV2ZXIpLlxuICAgICAqIFxuICAgICAqIFRoZSBwYXJlbnQgY2FuIHVzZSB0aGlzIHRvIG5vdGlmeSBlYWNoIHJlbGV2YW50IGNoaWxkIG9mIHdoYXQgaXQgbXVzdCBkbyBpbiBvcmRlciB0byBtYWtlIHRoaXMgY2hhbmdlIGhhcHBlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgbmV3IGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLiBJZiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHdoYXQgeW91IHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPjtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBNW1wiaW5kZXhcIl0gfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXIgfCBzdHJpbmc+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8TSwgUj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBNW1wiaW5kZXhcIl0sIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4obnVsbCk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljXG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBgY2xvc2VzdEZpdGAgaXMgZmFsc2UsIG5hdHVyYWxseS5cbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiYgaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgY2hpbGQuaW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKChjaGlsZC5pbmRleCBhcyBudW1iZXIpIC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIChjaGlsZC5pbmRleCBhcyBudW1iZXIpIDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSAoY2hpbGQuaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIHNldEF0KGNsb3Nlc3RGaXRDaGlsZCwgdHJ1ZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXNWYWxpZCA9IChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSXNWYWxpZCB8fCAhY2xvc2VzdEZpdCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIHJlcXVlc3RlZEluZGV4LCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIHJlcXVlc3RlZEluZGV4ID09IFwibnVtYmVyXCIsIFwiY2xvc2VzdEZpdCBjYW4gb25seSBiZSB1c2VkIHdoZW4gZWFjaCBjaGlsZCBoYXMgYSBudW1lcmljIGluZGV4LCBhbmQgY2Fubm90IGJlIHVzZWQgd2hlbiBjaGlsZHJlbiB1c2Ugc3RyaW5nIGluZGljZXMgaW5zdGVhZC5cIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFJ1biBvbmNlLCBvbiBtb3VudFxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGluaXRpYWxJbmRleCA/PyBudWxsLCB1bmRlZmluZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBvYmplY3RzIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgIShpIGluIGIpKSByZXR1cm4gdHJ1ZTtcblx0Zm9yIChsZXQgaSBpbiBiKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiBhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHRyZXR1cm4gKHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBjbGFzcyB3aXRoIGEgcHJlZGVmaW5lZCBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwKSB7XG5cdHRoaXMucHJvcHMgPSBwO1xufVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG4vLyBTb21lIHRoaXJkLXBhcnR5IGxpYnJhcmllcyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IGlzIHByZXNlbnRcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwiaW1wb3J0IHsgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcblxuY29uc3QgbWFwRm4gPSAoY2hpbGRyZW4sIGZuKSA9PiB7XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIHRvQ2hpbGRBcnJheSh0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLm1hcChmbikpO1xufTtcblxuLy8gVGhpcyBBUEkgaXMgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmb3IgUHJlYWN0LCBzbyBpdCdzIGJhc2ljYWxseSBwYXNzdGhyb3VnaC5cbmV4cG9ydCBjb25zdCBDaGlsZHJlbiA9IHtcblx0bWFwOiBtYXBGbixcblx0Zm9yRWFjaDogbWFwRm4sXG5cdGNvdW50KGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuID8gdG9DaGlsZEFycmF5KGNoaWxkcmVuKS5sZW5ndGggOiAwO1xuXHR9LFxuXHRvbmx5KGNoaWxkcmVuKSB7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IHRvQ2hpbGRBcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKG5vcm1hbGl6ZWQubGVuZ3RoICE9PSAxKSB0aHJvdyAnQ2hpbGRyZW4ub25seSc7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWRbMF07XG5cdH0sXG5cdHRvQXJyYXk6IHRvQ2hpbGRBcnJheVxufTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc3JjL2luZGV4JykuUmVuZGVyYWJsZVByb3BzPHsgY29udGV4dDogYW55IH0+fSBwcm9wc1xuICovXG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcblx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBwcm9wcy5jb250ZXh0O1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogUG9ydGFsIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcHNcbiAqXG4gKiBUT0RPOiB1c2UgY3JlYXRlUm9vdCgpIGluc3RlYWQgb2YgZmFrZSByb290XG4gKi9cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuXHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdGxldCBjb250YWluZXIgPSBwcm9wcy5fY29udGFpbmVyO1xuXG5cdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVuZGVyKG51bGwsIF90aGlzLl90ZW1wKTtcblx0XHRfdGhpcy5fdGVtcCA9IG51bGw7XG5cdFx0X3RoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdH07XG5cblx0Ly8gV2hlbiB3ZSBjaGFuZ2UgY29udGFpbmVyIHdlIHNob3VsZCBjbGVhciBvdXIgb2xkIGNvbnRhaW5lciBhbmRcblx0Ly8gaW5kaWNhdGUgYSBuZXcgbW91bnQuXG5cdGlmIChfdGhpcy5fY29udGFpbmVyICYmIF90aGlzLl9jb250YWluZXIgIT09IGNvbnRhaW5lcikge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cblxuXHQvLyBXaGVuIHByb3BzLnZub2RlIGlzIHVuZGVmaW5lZC9mYWxzZS9udWxsIHdlIGFyZSBkZWFsaW5nIHdpdGggc29tZSBraW5kIG9mXG5cdC8vIGNvbmRpdGlvbmFsIHZub2RlLiBUaGlzIHNob3VsZCBub3QgdHJpZ2dlciBhIHJlbmRlci5cblx0aWYgKHByb3BzLl92bm9kZSkge1xuXHRcdGlmICghX3RoaXMuX3RlbXApIHtcblx0XHRcdF90aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGZha2UgRE9NIHBhcmVudCBub2RlIHRoYXQgbWFuYWdlcyBhIHN1YnNldCBvZiBgY29udGFpbmVyYCdzIGNoaWxkcmVuOlxuXHRcdFx0X3RoaXMuX3RlbXAgPSB7XG5cdFx0XHRcdG5vZGVUeXBlOiAxLFxuXHRcdFx0XHRwYXJlbnROb2RlOiBjb250YWluZXIsXG5cdFx0XHRcdGNoaWxkTm9kZXM6IFtdLFxuXHRcdFx0XHRhcHBlbmRDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmUpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCkgPj4+IDEsIDEpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJlbmRlciBvdXIgd3JhcHBpbmcgZWxlbWVudCBpbnRvIHRlbXAuXG5cdFx0cmVuZGVyKFxuXHRcdFx0Y3JlYXRlRWxlbWVudChDb250ZXh0UHJvdmlkZXIsIHsgY29udGV4dDogX3RoaXMuY29udGV4dCB9LCBwcm9wcy5fdm5vZGUpLFxuXHRcdFx0X3RoaXMuX3RlbXBcblx0XHQpO1xuXHR9XG5cdC8vIFdoZW4gd2UgY29tZSBmcm9tIGEgY29uZGl0aW9uYWwgcmVuZGVyLCBvbiBhIG1vdW50ZWRcblx0Ly8gcG9ydGFsIHdlIHNob3VsZCBjbGVhciB0aGUgRE9NLlxuXHRlbHNlIGlmIChfdGhpcy5fdGVtcCkge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgUG9ydGFsYCB0byBjb250aW51ZSByZW5kZXJpbmcgdGhlIHZub2RlIHRyZWUgYXQgYSBkaWZmZXJlbnQgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gY29udGFpbmVyIFRoZSBET00gbm9kZSB0byBjb250aW51ZSByZW5kZXJpbmcgaW4gdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQb3J0YWwodm5vZGUsIGNvbnRhaW5lcikge1xuXHRjb25zdCBlbCA9IGNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7IF92bm9kZTogdm5vZGUsIF9jb250YWluZXI6IGNvbnRhaW5lciB9KTtcblx0ZWwuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lcjtcblx0cmV0dXJuIGVsO1xufVxuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvaVxuXHRcdDogL2ZpbHxjaGV8cmEvaVxuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3Qgbm9uQ3VzdG9tRWxlbWVudCA9IHR5cGUuaW5kZXhPZignLScpID09PSAtMTtcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW2ldO1xuXG5cdFx0XHRpZiAoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jykge1xuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHRcdC8vIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGkgPT09ICdkZWZhdWx0VmFsdWUnICYmXG5cdFx0XHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRcdFx0cHJvcHMudmFsdWUgPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBmb3IgRWxlbWVudHMgd2l0aCBubyB2YWx1ZSBwcm9wIGlzIHRoZSBzYW1lIGFzIHRoZSBET00gZGVmYXVsdFZhbHVlIHByb3BlcnR5LlxuXHRcdFx0XHRpID0gJ3ZhbHVlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBDYWxsaW5nIGBzZXRBdHRyaWJ1dGVgIHdpdGggYSB0cnV0aHkgdmFsdWUgd2lsbCBsZWFkIHRvIGl0IGJlaW5nXG5cdFx0XHRcdC8vIHBhc3NlZCBhcyBhIHN0cmluZ2lmaWVkIHZhbHVlLCBlLmcuIGBkb3dubG9hZD1cInRydWVcImAuIFJlYWN0XG5cdFx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGZpbGUgd2lsbCBiZSBjYWxsZWRcblx0XHRcdFx0Ly8gXCJ0cnVlXCIgdXBvbiBkb3dubG9hZGluZyBpdC5cblx0XHRcdFx0dmFsdWUgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoL29uZG91YmxlY2xpY2svaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25kYmxjbGljayc7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHQvXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QoaSArIHR5cGUpICYmXG5cdFx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25mb2N1cyQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmJsdXIkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAobm9uQ3VzdG9tRWxlbWVudCAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoL1tBLVowLTldL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuY29uc3Qgb2xkRGlmZmVkID0gb3B0aW9ucy5kaWZmZWQ7XG4vKiogQHR5cGUgeyh2bm9kZTogaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGUpfSAqL1xub3B0aW9ucy5kaWZmZWQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkRGlmZmVkKSB7XG5cdFx0b2xkRGlmZmVkKHZub2RlKTtcblx0fVxuXG5cdGNvbnN0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGNvbnN0IGRvbSA9IHZub2RlLl9kb207XG5cdGlmIChcblx0XHRkb20gIT0gbnVsbCAmJlxuXHRcdHZub2RlLnR5cGUgPT09ICd0ZXh0YXJlYScgJiZcblx0XHQndmFsdWUnIGluIHByb3BzICYmXG5cdFx0cHJvcHMudmFsdWUgIT09IGRvbS52YWx1ZVxuXHQpIHtcblx0XHRkb20udmFsdWUgPSBwcm9wcy52YWx1ZSA9PSBudWxsID8gJycgOiBwcm9wcy52YWx1ZTtcblx0fVxuXG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2suanNcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NvY0luZGV4T2Y7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVHZXQ7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlU2V0O1xuIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBIYXNoIGZyb20gJy4vX0hhc2guanMnO1xuaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5YWJsZTtcbiIsImltcG9ydCBpc0tleWFibGUgZnJvbSAnLi9faXNLZXlhYmxlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXBEYXRhO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlR2V0O1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlSGFzO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVTZXQ7XG4iLCJpbXBvcnQgbWFwQ2FjaGVDbGVhciBmcm9tICcuL19tYXBDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBtYXBDYWNoZURlbGV0ZSBmcm9tICcuL19tYXBDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVHZXQgZnJvbSAnLi9fbWFwQ2FjaGVHZXQuanMnO1xuaW1wb3J0IG1hcENhY2hlSGFzIGZyb20gJy4vX21hcENhY2hlSGFzLmpzJztcbmltcG9ydCBtYXBDYWNoZVNldCBmcm9tICcuL19tYXBDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDYWNoZTtcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbiIsImltcG9ydCB7IG1lbW9pemUgfSBmcm9tIFwibG9kYXNoLWVzXCJcblxuZGVjbGFyZSBnbG9iYWwge1xuICAgIGNvbnN0IHByb2Nlc3M6IHsgZW52OiB7IE5PREVfRU5WPzogc3RyaW5nIHwgdW5kZWZpbmVkIH0gfCB1bmRlZmluZWQgfSB8IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0QnVpbGRNb2RlVW5tZW1vaXplZCgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAocHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEJ1aWxkTW9kZSA9IG1lbW9pemUoZ2V0QnVpbGRNb2RlVW5tZW1vaXplZCkgYXMgdHlwZW9mIGdldEJ1aWxkTW9kZVVubWVtb2l6ZWQ7IiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldEJ1aWxkTW9kZSB9IGZyb20gXCIuLi91dGlsL21vZGUuanNcIjtcblxuLyoqIFRha2VzIGEgbmV3IHZhbHVlIG9yIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIGEgdmFsdWUsIHVubGlrZSBgT25QYXNzaXZlU3RhdGVDaGFuZ2VgIHdoaWNoIHJlYWN0cyB0byB0aG9zZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBQYXNzaXZlU3RhdGVVcGRhdGVyPFMsIFI+ID0gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKSA6ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbjogUikgPT4gdm9pZCk7XG4vKiogUmVzcG9uZHMgdG8gYSBjaGFuZ2UgaW4gYSB2YWx1ZSwgdW5saWtlIGBQYXNzaXZlU3RhdGVVcGRhdGVyYCB3aGljaCBjYXVzZXMgdGhlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFMsIFI+ID0gKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb24/OiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb24/OiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpIDogKCh2YWx1ZTogUywgcHJldlZhbHVlOiBTIHwgdW5kZWZpbmVkLCByZWFzb246IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XG5cblxuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICBpZiAoZ2V0QnVpbGRNb2RlKCkgPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICByZXR1cm47XG4gICAgXG4gICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWY8QXJyYXk8VD4+KFtdKTtcbiAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmPEFycmF5PGJvb2xlYW4+PihbXSk7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGggYXMgYW55LCAtMSk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVIGV4dGVuZHMgVD4odmFsdWU6IFUsIGk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGkgKyAxO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aX0taW5kZXhlZCBhcmd1bWVudCAoJHtpID49IDA/IEpTT04uc3RyaW5naWZ5KHZhbHVlc1tpXSkgOiBcInRoZSBudW1iZXIgb2Ygc3VwcG9zZWRseSBzdGFibGUgZWxlbWVudHNcIn0pLmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VSZW5kZXJpbmcoZjogKCkgPT4gdm9pZCkge1xuICAgIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID8/IHNldFRpbWVvdXQpKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHJlYXNvblJlZiA9IHVzZVJlZjxSIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QgPSB1c2VSZWY8VCB8ICh0eXBlb2YgVW5zZXQpPihVbnNldCk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQhKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cblxuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMV0pID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0aGlzIGhlcmUgKGFzIHdlbGwgYXMgYmVsb3cpIGluIGNhc2UgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgaW52b2tlcyB0aGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmVhc29uUmVmLmN1cnJlbnQgPSByZWFzb24gYXMgUjtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWFzb24gPSByZWFzb25SZWYuY3VycmVudCEgYXMgUjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogcHJldkRlcCwgbmV4dFJlYXNvbikgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9XG5cbi8qKiBcbiAqIEFuIGFsdGVybmF0aXZlIHRvIHVzZSBmb3IgYGN1c3RvbURlYm91bmNlUmVuZGVyaW5nYCB0aGF0IGNhdXNlcyBgdXNlUGFzc2l2ZVN0YXRlYCB0byBydW4gY2hhbmdlcyB3aXRob3V0IHdhaXRpbmcgYSB0aWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuSW1tZWRpYXRlbHkoZjogKCkgPT4gdm9pZCkgeyBmKCk7IH0iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2sgfCBudWxsLCBpbnB1dHM/OiBJbnB1dHMpIHtcblxuICAgIC8qKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHVzZVJlZjx2b2lkIHwgKCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQoaW5wdXRzLCBwcmV2QXJnc1JlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgcHJldkFyZ3NSZWYuY3VycmVudCA9IGlucHV0cyE7XG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCgpO1xuICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50ID0gZWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICB9KSgpOyovXG5cbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcbiAgICBpZiAoZWZmZWN0KVxuICAgICAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG4gICAgZWxzZVxuICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC5qc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKSB7XG5cbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSksIFt2YWx1ZV0pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSk7XG59XG5cblxuLyoqXG4gKiBMaWtlIGB1c2VTdGFibGVHZXR0ZXJgLCBidXQgKioqcmVxdWlyZXMqKiogdGhhdCBldmVyeXRoaW5nIGluIHRoZSBvYmplY3QgaXMgYWxzbyBzdGFibGUsXG4gKiBhbmQgaW4gdHVybiByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGl0c2VsZiBpcyBzdGFibGUuXG4gKiBAcGFyYW0gdCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlT2JqZWN0PFQgZXh0ZW5kcyB7fT4odDogVCk6IFQge1xuICAgIGNvbnN0IGUgPSBPYmplY3QuZW50cmllcyh0KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVPYmplY3RcIiwgZS5sZW5ndGgsIC4uLmUubWFwKChbX2ssIHZdKSA9PiB2KSk7XG4gICAgcmV0dXJuIHVzZVJlZih0KS5jdXJyZW50O1xufVxuXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFja05hdGl2ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG5cbi8vY29uc3QgX0lTX1NUQUJMRV9HRVRURVIgPSBTeW1ib2woXCJTVEFCTEVcIik7XG5leHBvcnQgdHlwZSBTdGFibGU8VD4gPSBUOy8vICYgeyBbX1NUQUJMRV06IHRydWUgfTtcblxuLyoqXG4gKiBXZSBrZWVwIHRyYWNrIG9mIHdoaWNoIGNhbGxiYWNrcyBhcmUgc3RhYmxlIHdpdGggYSBXZWFrTWFwIGluc3RlYWQgb2YsIHNheSwgYSBzeW1ib2wgYmVjYXVzZVxuICogYHVzZUNhbGxiYWNrYCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQncyBzdGFibGUgYWNyb3NzICphbGwqIHJlbmRlcnMsIG1lYW5pbmdcbiAqIHdlIGNhbid0IHVzZSBvdXIgZnVubnkgXCJgaWZgIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYnJlYWsgdGhlIHJ1bGVzIG9mIGhvb2tzXCIgdHJpY2sgdGhlbi5cbiAqL1xuY29uc3QgbWFwID0gbmV3IFdlYWtNYXA8RnVuY3Rpb24sIGJvb2xlYW4+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgRnVuY3Rpb24+KG9iajogVCk6IG9iaiBpcyBTdGFibGU8VD4ge1xuICAgIHJldHVybiAobWFwLmdldChvYmopID8/IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNldElzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KG9iajogVCk6IFN0YWJsZTxUPiB7XG4gICAgbWFwLnNldChvYmosIHRydWUpO1xuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogSW4gZ2VuZXJhbCwganVzdCBwYXNzIHRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBiZSBzdGFibGUgKGJ1dCB5b3UgY2FuJ3QgdXNlIGl0IGR1cmluZyByZW5kZXIsXG4gKiBzbyBiZSBjYXJlZnVsISkuICBBbHRlcm5hdGl2ZWx5LCBpZiB5b3UgbmVlZCBhIHN0YWJsZSBjYWxsYmFjayB0aGF0ICoqY2FuKiogYmUgdXNlZFxuICogZHVyaW5nIHJlbmRlciwgcGFzcyBhbiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5IGFuZCBpdCdsbCBhY3QgbGlrZSBgdXNlQ2FsbGJhY2tgIHdpdGggYW5cbiAqIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXksIGJ1dCB3aXRoIHRoZSBhc3NvY2lhdGVkIHN0YWJsZSB0eXBpbmcuIEluIHRoaXMgY2FzZSwgeW91ICoqKm11c3QqKiogZW5zdXJlIHRoYXQgaXRcbiAqIHRydWx5IGhhcyBubyBkZXBlbmRlbmNpZXMvb25seSBzdGFibGUgZGVwZW5kZW5jaWVzISFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyBGdW5jdGlvbiB8IG51bGwgfCB1bmRlZmluZWQ+KGZuOiBOb25OdWxsYWJsZTxUPiwgbm9EZXBzPzogW10gfCBudWxsIHwgdW5kZWZpbmVkKTogU3RhYmxlPE5vbk51bGxhYmxlPFQ+PiB7XG4gICAgdHlwZSBVID0gKE5vbk51bGxhYmxlPFQ+ICYgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZUNhbGxiYWNrXCIsIG5vRGVwcyA9PSBudWxsLCBub0RlcHM/Lmxlbmd0aCwgaXNTdGFibGVHZXR0ZXI8VT4oZm4gYXMgVSkpO1xuICAgIGlmIChpc1N0YWJsZUdldHRlcihmbikpXG4gICAgICAgIHJldHVybiBmbjtcblxuICAgIGlmIChub0RlcHMgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VT4oZm4pO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgICAgIH0pIGFzIFUsIFtdKSk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5vRGVwcy5sZW5ndGggPT09IDApO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oZm4sIFtdKSk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0sIHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG50eXBlIEMgPSBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjbGFzc05hbWVcIl07XG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlaXIgYGNsYXNzYCBhbmQgYGNsYXNzTmFtZWAgcHJvcGVydGllcy5cbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxuICogXG4gKiBAcGFyYW0gbGhzIENsYXNzZXMgb2YgdGhlIGZpcnN0IGNvbXBvbmVudFxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXMobGhzQ2xhc3M6IEMsIGxoc0NsYXNzTmFtZTogQywgcmhzQ2xhc3M6IEMsIHJoc0NsYXNzTmFtZTogQyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG5cbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXG5cbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IHJoc0NsYXNzZXMgPSBjbHN4KHJoc0NsYXNzLCByaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFsbENsYXNzZXMpLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoLCBSZWYsIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcblxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAocmVmIGFzIFJlZk9iamVjdDxUIHwgbnVsbD4pLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gKiBAcGFyYW0gbGhzIFxuICogQHBhcmFtIHJocyBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXCJyZWZcIl0sIGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXCJyZWZcIl0pIHtcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHMhO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzITtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbWJpbmVkKGN1cnJlbnQ6IEUgfCBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBoLkpTWC5DU1NQcm9wZXJ0aWVzIHtcbiAgICAvLyBUT0RPOiBUaGlzIHN1Y2tzIEQ6XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xufVxuXG4vKipcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gKiBcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdLCByaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xuXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXG4gICAgaWYgKCFsaHMgJiYgIXJocylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgbGhzICE9IHR5cGVvZiByaHMpIHtcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxuICAgICAgICBpZiAobGhzICYmICFyaHMpXG4gICAgICAgICAgICByZXR1cm4gbGhzO1xuICAgICAgICBpZiAoIWxocyAmJiByaHMpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBub24tbnVsbCBidXQgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cbiAgICAgICAgaWYgKGxocyAmJiByaHMpIHtcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhzdHlsZVN0cmluZ1RvT2JqZWN0KGxocyBhcyBzdHJpbmcpLCByaHMpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMobGhzLCBzdHlsZVN0cmluZ1RvT2JqZWN0KHJocyBhcyBzdHJpbmcpKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9naWM/Pz9cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxuICAgIGlmICh0eXBlb2YgbGhzID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke2xoc307JHtyaHMgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xuICAgIH1cblxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGxocyA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcbiAgICAgICAgLi4uKHJocyA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllc1xuICAgIH0gYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGUuanNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jaGlsZHJlbi5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlcy5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmcy5qc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkU3R5bGVzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1zdHlsZXMuanNcIjtcblxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XG4gICAgbG9nID0gbG9nMlxufVxuXG5cbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKiBcbiAqIFRoZSBob29rIGlzIGF3YXJlIG9mIGFuZCBjYW4gaW50ZWxsaWdlbnRseSBtZXJnZSBgY2xhc3NOYW1lYCwgYGNsYXNzYCwgYHN0eWxlYCwgYHJlZmAsIGFuZCBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0gbGhzMiBcbiAqIEBwYXJhbSByaHMyIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KC4uLmFsbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKSB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVyZ2VkUHJvcHNcIiwgYWxsUHJvcHMubGVuZ3RoKTtcbiAgICBsZXQgcmV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHt9O1xuICAgIGZvciAobGV0IG5leHRQcm9wcyBvZiBhbGxQcm9wcykge1xuICAgICAgICByZXQgPSB1c2VNZXJnZWRQcm9wczI8RT4ocmV0LCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGtub3ducyA9IG5ldyBTZXQ8c3RyaW5nPihbXCJjaGlsZHJlblwiLCBcInJlZlwiLCBcImNsYXNzTmFtZVwiLCBcImNsYXNzXCIsIFwic3R5bGVcIl0pXG5cbmZ1bmN0aW9uIG1lcmdlVW5rbm93bihrZXk6IHN0cmluZywgbGhzVmFsdWU6IHVua25vd24sIHJoc1ZhbHVlOiB1bmtub3duKSB7XG5cbiAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXG4gICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZCBhcyBuZXZlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKChyaHNWYWx1ZSBhcyBhbnkpID09IGxoc1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJIG1lYW4sIHRoZXkncmUgdGhlIHNhbWUgdmFsdWUgYXQgbGVhc3RcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cbiAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVnaC5cbiAgICAgICAgICAgIC8vIE5vIGdvb2Qgc3RyYXRlZ2llcyBoZXJlLCBqdXN0IGxvZyBpdCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGxvZz8uKGBUaGUgcHJvcCBcIiR7a2V5fVwiIGNhbm5vdCBzaW11bHRhbmVvdXNseSBiZSB0aGUgdmFsdWVzICR7bGhzVmFsdWV9IGFuZCAke3Joc1ZhbHVlfS4gT25lIG11c3QgYmUgY2hvc2VuIG91dHNpZGUgb2YgdXNlTWVyZ2VkUHJvcHMuYCk7XG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uXG4gKiBcbiAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbmx5IGNhbGxlZCBmdW5jdGlvbnMgaW4gdGhpcyBhbmQgY29uc3VtZXIgbGlicmFyaWVzLFxuICogc28gaXQgdHJhZGVzIGEgYml0IG9mIHJlYWRhYmlsaXR5IGZvciBzcGVlZCAoaS5lLiB3ZSBkb24ndCBkZWNvbXBvc2Ugb2JqZWN0cyBhbmQganVzdCBkbyByZWd1bGFyIHByb3BlcnR5IGFjY2VzcywgaXRlcmF0ZSB3aXRoIGBmb3IuLi5pbmAsIGluc3RlYWQgb2YgYE9iamVjdC5lbnRyaWVzYCwgZXRjLilcbiAqL1xuZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHMyPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcblxuICAgIFxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XG4gICAgICAgIHJlZjogdXNlTWVyZ2VkUmVmczxFPihsaHNBbGwucmVmLCByaHNBbGwucmVmKSxcbiAgICAgICAgc3R5bGU6IHVzZU1lcmdlZFN0eWxlcyhsaHNBbGwuc3R5bGUsIHJoc0FsbC5zdHlsZSksXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGxbXCJjbGFzc1wiXSwgbGhzQWxsLmNsYXNzTmFtZSwgcmhzQWxsW1wiY2xhc3NcIl0sIHJoc0FsbC5jbGFzc05hbWUpLFxuICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzQWxsLmNoaWxkcmVuLCByaHNBbGwuY2hpbGRyZW4pLFxuICAgIH0gYXMgYW55O1xuXG4gICAgaWYgKHJldC5yZWYgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5yZWY7XG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xuICAgIGlmIChyZXRbXCJjbGFzc1wiXSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0W1wiY2xhc3NcIl07XG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xuXG4gICAgZm9yIChjb25zdCBsaHNLZXlVIGluIGxoc0FsbCkge1xuICAgICAgICBjb25zdCBsaHNLZXkgPSBsaHNLZXlVIGFzIGtleW9mIHR5cGVvZiBsaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKGxoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W2xoc0tleV0gPSBsaHNBbGxbbGhzS2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJoc0tleVUgaW4gcmhzQWxsKSB7XG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgdHlwZW9mIHJoc0FsbDtcbiAgICAgICAgaWYgKGtub3ducy5oYXMocmhzS2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXRbcmhzS2V5XSA9IG1lcmdlVW5rbm93bihyaHNLZXksIHJldFtyaHNLZXldLCByaHNBbGxbcmhzS2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gKHZvaWQgfCBQcm9taXNlPHZvaWQ+KSwgVSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gKHZvaWQgfCBQcm9taXNlPHZvaWQ+KT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKCFsaHMpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgaWYgKCFyaHMpXG4gICAgICAgIHJldHVybiBsaHM7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcbiAgICAgICAgY29uc3QgbHYgPSBsaHMoLi4uYXJncyk7XG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xuXG4gICAgICAgIGlmIChsdiBpbnN0YW5jZW9mIFByb21pc2UgfHwgcnYgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHksIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLmpzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgcmVmRWxlbWVudFJldHVybjoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xuICAgICAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHNha2Ugb2YgY29udmVuaWVuY2UsXG4gICAgICogdGhpcyBvbmUgaXMgb3B0aW9uYWwsIHNpbmNlIHVzaW5nIHRoaXMgaG9vayBpcyBzbyBjb21tb24sXG4gICAgICogYnV0IHVzaW5nIGl0cyBwYXJhbWV0ZXIgb3B0aW9ucyBpcyBzbyB1bmNvbW1vbiwgYW5kIGl0J3NcbiAgICAgKiBhYnNlbnNlIGlzbid0IHVzdWFsbHkgYmVjYXVzZSBpdCB3YXMgZm9yZ290dGVuLCBpdCdzIGJlY2F1c2VcbiAgICAgKiBpdCBkb2Vzbid0IG1hdHRlci5cbiAgICAgKi9cbiAgICByZWZFbGVtZW50UGFyYW1ldGVycz86IHtcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPjtcbiAgICAgICAgb25Nb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgICAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICB9XG59XG5cblxuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50UHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSB7XG4gICAgcmV0dXJuIFtyLnJlZkVsZW1lbnRSZXR1cm4ucHJvcHNTdGFibGUsIC4uLm90aGVyUHJvcHNdO1xufSovXG5cbi8qKlxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXG4gKiBcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxuICogXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGFyZ3M6IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4ge1xuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzLnJlZkVsZW1lbnRQYXJhbWV0ZXJzIHx8IHt9KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+PigoZSwgcHJldlZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xuICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XG5cbiAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XG5cbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbCwgbmV2ZXI+KGhhbmRsZXIsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4oeyByZWY6IHNldEVsZW1lbnQgfSk7XG5cbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjoge1xuICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBwcm9wc1N0YWJsZS5jdXJyZW50XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAqL1xuICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAvKipcbiAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAqIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICpcbiAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICpcbiAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgKi9cblxuICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydFJvb3Q7XG4gIH0oKTtcblxuICAvKipcbiAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgKlxuICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgKlxuICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAqL1xuXG5cbiAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdub2RlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnROb2RlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICpcbiAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICB9LFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KSgpO1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vdXRpbC9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGRlYm91bmNlUmVuZGVyaW5nLCBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgUGFzc2l2ZVN0YXRlVXBkYXRlciwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlci5qc1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8vbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdXG5cbiAgICBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7XG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IEludGVybmFsQ2hpbGRJbmZvPE0+O1xuICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ6IChpbmRleDogTVtcImluZGV4XCJdLCBtb3VudGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWQ6IChpbmRleDogTVtcImluZGV4XCJdKSA9PiAoKCkgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXG4gKiBcbiAqICogYGluZGV4YCByZWZlcnMgdG8gd2hpY2ggY2hpbGQgdGhpcyBpcy5cbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcbiAqICogYHN1YkluZm9gIGlzIGFueXRoaW5nIHVzZWQgYnkgYSBkZXJpdmVkIGhvb2suIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGZvciBleGFtcGxlLCBuZWVkcyB0byBrbm93IGhvdyB0byBmb2N1cyBhbiBhcmJpdHJhcnkgY2hpbGQsIHNvIHRoZSBjaGlsZCBwb3B1bGF0ZXMgYGluZm9gIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBtZXRob2QgY2FsbGVkIGBmb2N1c1NlbGZgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4ge1xuICAgIGluZGV4OiBUO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgICAgICogXG4gICAgICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRPRE86IFRoaXMgZW5kZWQgdXAgbm90IGJlaW5nIG5lZWRlZCBieSBhbnl0aGluZy4gSXMgaXQgbmVjZXNzYXJ5PyBEb2VzIGl0IGNvc3QgYW55dGhpbmc/XG4gICAgICAgICAqL1xuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PE1bXCJpbmRleFwiXT47XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8TVtcImluZGV4XCJdPjtcbiAgICBcbiAgICAgICAgb25DaGlsZENvdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8ICgoY291bnQ6IG51bWJlcikgPT4gdm9pZCk7XG4gICAgfVxufVxuXG4vLyBNQ1N1YkluZm8gY29udGFpbnMgdGhlIGVudGlyZXR5IG9mIHRoZSBzYXZlZCBkYXRhIGZvciB0aGlzIGNoaWxkLiAgQWxsIG9mIGl0LiBFdmVuIHR5cGVzIHRoZSB1c2VyIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBwYXNzIGluIGJlY2F1c2UgdGhleSdyZSBpbnRlcm5hbGx5IGRlcml2ZWQuXG4vLyBTdWJiZXN0SW5mbyByZWZlcnMgdG8gdGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHRoZSB1c2VyIHBhc3NlcyBpbiB0aGF0IGNvdWxkIGJlIHRvdGFsbHkgdW5yZWxhdGVkLiBcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSBwcm9wZXJ0eSBzaGFyZWQgYW1vbmcgYWxsIG1hbmFnZWQgY2hpbGRyZW4uXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyByZWR1bmRhbnQgd2l0aCB0aGUgc2Vjb25kIGFyZ3VtZW50LCB3aGljaCBpcy4uLmVoLiBCdXQgdGhlIHR5cGVzIGFyZSBjbGVhci5cbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPE0sIFwiaW5kZXhcIj47XG5cbiAgICAvKipcbiAgICAgKiBJbiBnZW5lcmFsLCB0aGlzIHNob3VsZG4ndCBiZSBudWxsLCBidXQgZm9yIGNvbnZlbmllbmNlJ3Mgc2FrZSB5b3UgYXJlIGFsbG93ZWQgdG8sIHdoaWNoIGRpc2FibGVzIGFsbCBiZWhhdmlvciwgYW5kIGFsc28gbWVhbnMgYGdldENoaWxkcmVuYCB3aWxsIGJlIGB1bmRlZmluZWRgIVxuICAgICAqL1xuICAgIGNvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4gfCBudWxsO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiAqKipTVEFCTEUqKipcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0ICoqYm90aCoqIGBnZXRDaGlsZHJlbmAgYW5kIHRoZSBgTWFuYWdlZENoaWxkcmVuYCBvYmplY3QgaXQgcmV0dXJucyBhcmUgc3RhYmxlIVxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBpcyBhIGdldHRlciBpbnN0ZWFkIG9mIGFuIG9iamVjdCBiZWNhdXNlIHdoZW4gZnVuY3Rpb24gY2FsbHMgaGFwcGVuIG91dCBvZiBvcmRlciBpdCdzIGVhc2llciB0byBqdXN0IGhhdmUgYWx3YXlzIGJlZW4gcGFzc2luZyBhbmQgcmV0dXJuIGdldHRlcnMgZXZlcnl3aGVyZSBcbiAgICAgICAgICovXG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuICAgIH07XG5cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgfVxufVxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEF0KGluZGV4OiBNW1wiaW5kZXhcIl0pOiBNIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNKSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1bXTtcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ2hpbGRJbmZvPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+IHtcbiAgICBhcnI6IEFycmF5PE0+O1xuICAgIHJlYzogUGFydGlhbDxSZWNvcmQ8TVtcImluZGV4XCJdLCBNPj47XG4gICAgaGlnaGVzdEluZGV4OiBudW1iZXI7XG4gICAgbG93ZXN0SW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcbiAgICB0eXBlIEluZm8gPSBNO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBvbkNoaWxkQ291bnRDaGFuZ2UgfSwgLi4ucmVzdCB9ID0gcGFyZW50UGFyYW1ldGVycztcbiAgICBhc3NlcnRFbXB0eU9iamVjdChyZXN0KTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25DaGlsZENvdW50Q2hhbmdlKTtcblxuICAgIC8vY29uc3QgW2dldE1vdW50Q291bnQsIHNldE1vdW50Q291bnRdID0gdXNlUGFzc2l2ZVN0YXRlKG9uQ2hpbGRDb3VudENoYW5nZSwgcmV0dXJuWmVybywgcnVuSW1tZWRpYXRlbHkpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjxJbnRlcm5hbENoaWxkSW5mbzxNPj4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkcyB0byBzZWFyY2ggYWxsIGNoaWxkcmVuIGZvciB0aGF0IGNsb3Nlc3QgZml0LlxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgZm9yRWFjaENoaWxkID0gdXNlQ2FsbGJhY2soKGY6IChjaGlsZDogSW5mbykgPT4gdm9pZCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8SW5kZXhUeXBlLCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48TT5bXCJnZXRBdFwiXT4oKGluZGV4OiBJbmRleFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PEluZGV4VHlwZT4sIHVubW91bnRzOiBTZXQ8SW5kZXhUeXBlPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PEluZGV4VHlwZT4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgaWYgKG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvbkNoaWxkQ291bnRDaGFuZ2UgfHwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICBvbkNoaWxkQ291bnRDaGFuZ2U/LihnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlU3RhYmxlT2JqZWN0PE1hbmFnZWRDaGlsZHJlbjxNPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuLCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPj4oaW5mbzogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNPiwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogTSk6IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TT4ge1xuICAgIHR5cGUgSW5kZXhUeXBlID0gTVtcImluZGV4XCJdO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7IGdldENoaWxkcmVuLCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSwgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLCByZW1vdGVVTEVDaGlsZENoYW5nZWQgfSB9ID0gKGluZm8uY29udGV4dCA/PyB7IG1hbmFnZWRDaGlsZENvbnRleHQ6IHt9IH0pO1xuICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleDtcbiAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9PSBudWxsIHx8IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgLi4ubWFuYWdlZENoaWxkUGFyYW1ldGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkucmVjW2luZGV4IGFzIEluZGV4VHlwZV0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZGV4IGFzIEluZGV4VHlwZSk7XG4gICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXG5cbiAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cbiAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgZmFsc2UpO1xuICAgIH0sIFtpbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbiEgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55PiwgUj4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcblxuICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+O1xuXG4gICAgc2V0QXQoaW5kZXg6IE0sIHZhbHVlOiBib29sZWFuLCBuZXdTZWxlY3RlZEluZGV4OiBNW1wiaW5kZXhcIl0gfCBudWxsLCBwcmV2U2VsZWN0ZWRJbmRleDogTVtcImluZGV4XCJdIHwgbnVsbCk6IHZvaWQ7XG4gICAgZ2V0QXQoaW5kZXg6IE0pOiBib29sZWFuO1xuICAgIGlzVmFsaWQoaW5kZXg6IE0pOiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIE1hbnVhbGx5IGNoYW5nZXMgdGhlIGN1cnJlbnQgaW5kZXggdGhhdCBpcyAoZm9jdXNlZC9zZWxlY3RlZC90YWJiYWJsZS93aGF0ZXZlcikuXG4gICAgICogXG4gICAgICogVGhlIHBhcmVudCBjYW4gdXNlIHRoaXMgdG8gbm90aWZ5IGVhY2ggcmVsZXZhbnQgY2hpbGQgb2Ygd2hhdCBpdCBtdXN0IGRvIGluIG9yZGVyIHRvIG1ha2UgdGhpcyBjaGFuZ2UgaGFwcGVuLlxuICAgICAqIFxuICAgICAqIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIHRoZSBuZXcgaW5kZXggdGhhdCB3aWxsIGJlIHVzZWQuIElmIGBjbG9zZXN0Rml0YCBpcyBmYWxzZSwgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgd2hhdCB5b3UgcGFzc2VkIGluLlxuICAgICAqL1xuICAgIGNoYW5nZUluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+O1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCBvciB3aGVuZXZlciBjYWxsaW5nIGEgY2hpbGQncyBpc1ZhbGlkKCkgd291bGQgY2hhbmdlXG4gICAgICogICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IE1bXCJpbmRleFwiXSB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB5b3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpcGxlIGZsYWdzIHdpdGggdGhlIHNhbWUgY2hpbGRyZW4sIHRoaXMgaG9vayAqZG9lcyBub3QqIHVzZSBgdXNlTWFuYWdlZENoaWxkcmVuYCFcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXG4gKiBcbiAqIEFsc28gYmVjYXVzZSBvZiB0aGF0LCB0aGUgdHlwZXMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgcmF0aGVyIG9kZC4gIEl0J3MgYmV0dGVyIHRvIHN0YXJ0IG9mZiB1c2luZyBhIGhvb2sgdGhhdCBhbHJlYWR5IHVzZXMgYSBmbGFnLCBzdWNoIGFzIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFzIGFuIGV4YW1wbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5GbGFnPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4sIFI+KHsgZ2V0Q2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwgZ2V0QXQsIHNldEF0LCBpc1ZhbGlkLCB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0sIFI+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxNLCBSPiB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQ2hpbGRyZW5GbGFnXCIsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCk7XG5cbiAgICAvLyBUT0RPIChtYXliZT8pOiBFdmVuIGlmIHRoZXJlIGlzIGFuIGluaXRpYWwgaW5kZXgsIGl0J3Mgbm90IHNldCB1bnRpbCBtb3VudC4gSXMgdGhhdCBmaW5lP1xuICAgIGNvbnN0IFtnZXRDdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IE1bXCJpbmRleFwiXSwgUj4ob25JbmRleENoYW5nZSk7XG5cbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgTVtcImluZGV4XCJdLCBSPihudWxsKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWNcbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGBjbG9zZXN0Rml0YCBpcyBmYWxzZSwgbmF0dXJhbGx5LlxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBpc1ZhbGlkKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBjaGlsZC5pbmRleCA9PSBcIm51bWJlclwiLCBcImNsb3Nlc3RGaXQgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGVhY2ggY2hpbGQgaGFzIGEgbnVtZXJpYyBpbmRleCwgYW5kIGNhbm5vdCBiZSB1c2VkIHdoZW4gY2hpbGRyZW4gdXNlIHN0cmluZyBpbmRpY2VzIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoKGNoaWxkLmluZGV4IGFzIG51bWJlcikgLSByZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlIHx8IChuZXdEaXN0YW5jZSA9PSBjbG9zZXN0RGlzdGFuY2UgJiYgKGNoaWxkLmluZGV4IGFzIG51bWJlcikgPCByZXF1ZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IChjaGlsZC5pbmRleCBhcyBudW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcblxuICAgIC8vIEFueSB0aW1lIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB0byBzZWUgaWYgdGhhdCBhZmZlY3RzIFxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXG4gICAgLy8gMi4gQSBjaGlsZCBtb3VudGVkLCBhbmQgaXQgbW91bnRzIHdpdGggdGhlIGluZGV4IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWlzVmFsaWQoY3VycmVudENoaWxkKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiByZXF1ZXN0ZWRJbmRleCA9PSBcIm51bWJlclwiLCBcImNsb3Nlc3RGaXQgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGVhY2ggY2hpbGQgaGFzIGEgbnVtZXJpYyBpbmRleCwgYW5kIGNhbm5vdCBiZSB1c2VkIHdoZW4gY2hpbGRyZW4gdXNlIHN0cmluZyBpbmRpY2VzIGluc3RlYWQuXCIpO1xuXG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4IGFzIG51bWJlcik7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4LCB1bmRlZmluZWQhKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hpbGQpXG4gICAgICAgICAgICAgICAgc2V0QXQoY3VycmVudENoaWxkLCBmYWxzZSwgY2xvc2VzdEZpdEluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgc2V0QXQoY2xvc2VzdEZpdENoaWxkLCB0cnVlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPE1bXCJpbmRleFwiXSB8IG51bGwsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8TVtcImluZGV4XCJdIHwgbnVsbCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxNW1wiaW5kZXhcIl0gfCBudWxsLCBSPj5bMV0pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZykgYXMgTVtcImluZGV4XCJdO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09IHJlcXVlc3RlZEluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuXG4gICAgICAgIGxldCBuZXdNYXRjaGluZ0NoaWxkID0gKHJlcXVlc3RlZEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQocmVxdWVzdGVkSW5kZXgpKTtcbiAgICAgICAgY29uc3Qgb2xkTWF0Y2hpbmdDaGlsZCA9IChjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVhc3kgY2FzZVxuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KG51bGwsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCByZXF1ZXN0ZWRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJc1ZhbGlkID0gKG5ld01hdGNoaW5nQ2hpbGQgJiYgaXNWYWxpZChuZXdNYXRjaGluZ0NoaWxkKSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRJc1ZhbGlkIHx8ICFjbG9zZXN0Rml0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KHJlcXVlc3RlZEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCByZXF1ZXN0ZWRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQobmV3TWF0Y2hpbmdDaGlsZCwgdHJ1ZSwgcmVxdWVzdGVkSW5kZXgsIGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgcmVxdWVzdGVkSW5kZXggPT0gXCJudW1iZXJcIiwgXCJjbG9zZXN0Rml0IGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBlYWNoIGNoaWxkIGhhcyBhIG51bWVyaWMgaW5kZXgsIGFuZCBjYW5ub3QgYmUgdXNlZCB3aGVuIGNoaWxkcmVuIHVzZSBzdHJpbmcgaW5kaWNlcyBpbnN0ZWFkLlwiKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlLCBjbG9zZXN0Rml0SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UsIGNsb3Nlc3RGaXRJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gUnVuIG9uY2UsIG9uIG1vdW50XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlSW5kZXgoaW5pdGlhbEluZGV4ID8/IG51bGwsIHVuZGVmaW5lZCk7XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xufVxuXG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGVQIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfTtcblxuXG4gICAgY29uc29sZS5hc3NlcnQocmVmLmN1cnJlbnQgPT09IHN0YXRlIHx8ICh0eXBlb2Ygc3RhdGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oc3RhdGUpKSk7XG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCJpbXBvcnQgeyBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLmpzXCI7XG5cbnR5cGUgUmFmQ2FsbGJhY2tUeXBlID0gKG1zU2luY2VMYXN0OiBudW1iZXIsIHRhZz86IGFueSkgPT4gdm9pZDtcblxuaW50ZXJmYWNlIENvbnRleHRUeXBlIHtcbiAgICBhZGRDYWxsYmFjazogKGNhbGxiYWNrOiBSYWZDYWxsYmFja1R5cGUsIHRhZz86IGFueSkgPT4gdm9pZDtcbiAgICByZW1vdmVDYWxsYmFjazogKGNhbGxiYWNrOiBSYWZDYWxsYmFja1R5cGUpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8bnVsbCB8IENvbnRleHRUeXBlPihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQ29udGV4dCwgY3JlYXRlQ29udGV4dCwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFeGNsdXNpdmVDb250ZXh0VHlwZSwgU3dhcHBhYmxlQ29udGV4dFR5cGUsIFRyYW5zaXRpb25EaXJlY3Rpb24sIFRyYW5zaXRpb25QaGFzZSB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IHN0cmluZyk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPjtcbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0UHJlbWVtb2l6YXRpb24oZXhjbHVzaXZpdHlLZXk6IG51bGwgfCB1bmRlZmluZWQpOiBudWxsO1xuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbihleGNsdXNpdml0eUtleTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IENvbnRleHQ8RXhjbHVzaXZlQ29udGV4dFR5cGUgfCBudWxsPiB8IG51bGw7XG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uKGV4Y2x1c2l2aXR5S2V5OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogQ29udGV4dDxFeGNsdXNpdmVDb250ZXh0VHlwZSB8IG51bGw+IHwgbnVsbCB7XG4gICAgaWYgKGV4Y2x1c2l2aXR5S2V5ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjcmVhdGVDb250ZXh0PEV4Y2x1c2l2ZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG59XG5cbmV4cG9ydCBjb25zdCBTd2FwcGFibGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTd2FwcGFibGVDb250ZXh0VHlwZT4oeyBnZXRBbmltYXRlT25Nb3VudDogKCkgPT4gZmFsc2UgfSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCBmb3IgYSBnaXZlbiBgZXhjbHVzaXZpdHlLZXlgLCBjcmVhdGluZyBvbmUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICogXG4gKiBJZiBcbiAqL1xuZXhwb3J0IGNvbnN0IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0OiB0eXBlb2YgZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbiA9IG1lbW9pemUoZ2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHRQcmVtZW1vaXphdGlvbik7XG5cbmludGVyZmFjZSBDc3NDbGFzc2VzUHJvdmlkZXJQcm9wcyB7XG4gICAgYmFzZTogc3RyaW5nO1xuICAgIGVudGVyOiBzdHJpbmc7XG4gICAgZXhpdDogc3RyaW5nO1xuICAgIG1lYXN1cmU6IHN0cmluZztcbiAgICBpbml0OiBzdHJpbmc7XG4gICAgdHJhbnNpdGlvbjogc3RyaW5nO1xuICAgIGZpbmFsaXplOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDc3NDbGFzc0NvbnRleHRUeXBlIHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IHN0cmluZztcbiAgICBHZXRFbnRlckNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0TWVhc3VyZUNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0SW5pdENsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBzdHJpbmc7XG4gICAgR2V0RmluYWxpemVDbGFzczogKCkgPT4gc3RyaW5nO1xufVxuXG5jb25zdCBDc3NDbGFzc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PENzc0NsYXNzQ29udGV4dFR5cGU+KHtcbiAgICBHZXRCYXNlQ2xhc3M6ICgpID0+IFwicHRsXCIsXG4gICAgR2V0RW50ZXJDbGFzczogKCkgPT4gXCJuXCIsXG4gICAgR2V0RXhpdENsYXNzOiAoKSA9PiBcInhcIixcbiAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IFwibVwiLFxuICAgIEdldEluaXRDbGFzczogKCkgPT4gXCJpXCIsXG4gICAgR2V0VHJhbnNpdGlvbkNsYXNzOiAoKSA9PiBcInRcIixcbiAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBcImZcIixcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBDc3NDbGFzc2VzUHJvdmlkZXIoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUsIGNoaWxkcmVuLCAuLi5yZXN0IH06IFJlbmRlcmFibGVQcm9wczxQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPj4pIHtcbiAgICBjb25zdCBjb250ZXh0T2JqZWN0ID0gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUoeyBiYXNlLCBlbnRlciwgZXhpdCwgbWVhc3VyZSwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemUgfSk7XG4gICAgcmV0dXJuICg8Q3NzQ2xhc3NDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0T2JqZWN0fSAgey4uLnJlc3R9IGNoaWxkcmVuPXtjaGlsZHJlbn0gLz4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDc3NDbGFzc2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgR2V0QmFzZUNsYXNzLFxuICAgICAgICBHZXRFbnRlckNsYXNzLFxuICAgICAgICBHZXRFeGl0Q2xhc3MsXG4gICAgICAgIEdldE1lYXN1cmVDbGFzcyxcbiAgICAgICAgR2V0SW5pdENsYXNzLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3MsXG4gICAgICAgIEdldEZpbmFsaXplQ2xhc3NcbiAgICB9ID0gdXNlQ29udGV4dChDc3NDbGFzc0NvbnRleHQpO1xuICAgIGNvbnN0IEdldERpcmVjdGlvbkNsYXNzID0gdXNlQ2FsbGJhY2soKGRpcmVjdGlvbjogVHJhbnNpdGlvbkRpcmVjdGlvbik6IHN0cmluZyA9PiB7IHN3aXRjaCAoZGlyZWN0aW9uKSB7IGNhc2UgXCJlbnRlclwiOiByZXR1cm4gR2V0RW50ZXJDbGFzcygpOyBjYXNlIFwiZXhpdFwiOiByZXR1cm4gR2V0RXhpdENsYXNzKCk7IH0gfSwgW10pO1xuICAgIGNvbnN0IEdldFBoYXNlQ2xhc3MgPSB1c2VDYWxsYmFjaygocGhhc2U6IFRyYW5zaXRpb25QaGFzZSk6IHN0cmluZyA9PiB7IHN3aXRjaCAocGhhc2UpIHsgY2FzZSBcIm1lYXN1cmVcIjogcmV0dXJuIEdldE1lYXN1cmVDbGFzcygpOyBjYXNlIFwiaW5pdFwiOiByZXR1cm4gR2V0SW5pdENsYXNzKCk7IGNhc2UgXCJ0cmFuc2l0aW9uXCI6IHJldHVybiBHZXRUcmFuc2l0aW9uQ2xhc3MoKTsgY2FzZSBcImZpbmFsaXplXCI6IHJldHVybiBHZXRGaW5hbGl6ZUNsYXNzKCk7IH0gfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIEdldEJhc2VDbGFzcyxcbiAgICAgICAgR2V0RW50ZXJDbGFzcyxcbiAgICAgICAgR2V0RXhpdENsYXNzLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3MsXG4gICAgICAgIEdldEluaXRDbGFzcyxcbiAgICAgICAgR2V0VHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzLFxuICAgICAgICBHZXREaXJlY3Rpb25DbGFzcyxcbiAgICAgICAgR2V0UGhhc2VDbGFzc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzQ2xhc3NDb250ZXh0VmFsdWUobmV3VmFsdWVzOiBQYXJ0aWFsPENzc0NsYXNzZXNQcm92aWRlclByb3BzPik6IENzc0NsYXNzQ29udGV4dFR5cGUge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHVzZUNvbnRleHQoQ3NzQ2xhc3NDb250ZXh0KTtcbiAgICBjb25zdCBiYXNlID0gKG5ld1ZhbHVlcz8uYmFzZSA/PyBvbGRWYWx1ZXMuR2V0QmFzZUNsYXNzKCkpO1xuICAgIGNvbnN0IGVudGVyID0gKG5ld1ZhbHVlcz8uZW50ZXIgPz8gb2xkVmFsdWVzLkdldEVudGVyQ2xhc3MoKSk7XG4gICAgY29uc3QgZXhpdCA9IChuZXdWYWx1ZXM/LmV4aXQgPz8gb2xkVmFsdWVzLkdldEV4aXRDbGFzcygpKTtcbiAgICBjb25zdCBtZWFzdXJlID0gKG5ld1ZhbHVlcz8ubWVhc3VyZSA/PyBvbGRWYWx1ZXMuR2V0TWVhc3VyZUNsYXNzKCkpO1xuICAgIGNvbnN0IGluaXQgPSAobmV3VmFsdWVzPy5pbml0ID8/IG9sZFZhbHVlcy5HZXRJbml0Q2xhc3MoKSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IChuZXdWYWx1ZXM/LnRyYW5zaXRpb24gPz8gb2xkVmFsdWVzLkdldFRyYW5zaXRpb25DbGFzcygpKTtcbiAgICBjb25zdCBmaW5hbGl6ZSA9IChuZXdWYWx1ZXM/LmZpbmFsaXplID8/IG9sZFZhbHVlcy5HZXRGaW5hbGl6ZUNsYXNzKCkpO1xuXG4gICAgcmV0dXJuIHVzZU1lbW88Q3NzQ2xhc3NDb250ZXh0VHlwZT4oKCkgPT4gKHtcbiAgICAgICAgR2V0QmFzZUNsYXNzOiAoKSA9PiBiYXNlISxcbiAgICAgICAgR2V0RW50ZXJDbGFzczogKCkgPT4gZW50ZXIhLFxuICAgICAgICBHZXRFeGl0Q2xhc3M6ICgpID0+IGV4aXQhLFxuICAgICAgICBHZXRNZWFzdXJlQ2xhc3M6ICgpID0+IG1lYXN1cmUhLFxuICAgICAgICBHZXRJbml0Q2xhc3M6ICgpID0+IGluaXQhLFxuICAgICAgICBHZXRUcmFuc2l0aW9uQ2xhc3M6ICgpID0+IHRyYW5zaXRpb24hLFxuICAgICAgICBHZXRGaW5hbGl6ZUNsYXNzOiAoKSA9PiBmaW5hbGl6ZSEsXG4gICAgfSksIFtiYXNlLCBlbnRlciwgZXhpdCwgaW5pdCwgdHJhbnNpdGlvbiwgZmluYWxpemVdKVxufVxuXG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgaCwgUmVuZGVyYWJsZVByb3BzLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuRmxhZywgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVPYmplY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgRXhjbHVzaXZlQ29udGV4dFR5cGUsIEV4Y2x1c2l2ZUluZm8sIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcblxuXG5cbmxldCBnbG9iYWxDb3VudCA9IC0xO1xuXG5leHBvcnQgZnVuY3Rpb24gRXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyKHsgZXhjbHVzaXZpdHlLZXksIGNoaWxkcmVuIH06IFJlbmRlcmFibGVQcm9wczx7IGV4Y2x1c2l2aXR5S2V5Pzogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB9Pikge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcIkV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlclwiLCBleGNsdXNpdml0eUtleSk7XG5cbiAgICBjb25zdCBbZ2V0TmV4dEluZGV4SW5MaW5lLCBzZXROZXh0SW5kZXhJbkxpbmVdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZyB8IG51bGwsIG5ldmVyPihudWxsKTtcblxuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuLCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPEV4Y2x1c2l2ZUluZm8+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgZ2V0Q3VycmVudEluZGV4IH0gPSB1c2VDaGlsZHJlbkZsYWc8RXhjbHVzaXZlSW5mbywgbmV2ZXI+KHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4sXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlLFxuICAgICAgICBpbml0aWFsSW5kZXg6IG51bGwsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIHNldEF0OiB1c2VDYWxsYmFjaygobSwgdikgPT4geyBtLnNldEV4Y2x1c2l2ZWx5T3Blbih2KTsgfSwgW10pLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKG0pID0+IG0uZ2V0RXhjbHVzaXZlbHlPcGVuKCksIFtdKSxcbiAgICAgICAgaXNWYWxpZDogdXNlQ2FsbGJhY2soKG0pID0+IHsgcmV0dXJuIHRydWUgfSwgW10pLFxuICAgIH0pXG5cbiAgICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjaygoaW5kZXg6IHN0cmluZywgdmlzaWJsZTogXCJzaG93XCIgfCBcImhpZGRlblwiKSA9PiB7XG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zdCBuZXh0SW5MaW5lID0gZ2V0TmV4dEluZGV4SW5MaW5lKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbkxpbmUgPSBnZXRDdXJyZW50SW5kZXgoKTtcblxuICAgICAgICBpZiAodmlzaWJsZSA9PSBcInNob3dcIiAmJiBpbmRleCAhPSBjdXJyZW50SW5MaW5lKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBjaGlsZCB0cmFuc2l0aW9uIHNob3dzIGl0c2VsZiBpbml0aWFsbHlcbiAgICAgICAgICAgICAqIChpLmUuIHJlcXVlc3RzIGl0c2VsZiB0byBiZSB0aGUgZXhjbHVzaXZlIHRyYW5zaXRpb24pXG4gICAgICAgICAgICAgKiB3ZSBlaXRoZXIgbGV0IGl0IG9wZW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUncyBubyBvbmUgZmluaXNoaW5nIHRoZWlyIGV4aXQsXG4gICAgICAgICAgICAgKiBvciB3YWl0IHVudGlsIHRoYXQgYWZvcmVtZW50aW9uZWQgZXhpdCBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5MaW5lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VJbmRleChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlbigpLmdldEF0KGN1cnJlbnRJbkxpbmUpPy5mb3JjZUNsb3NlPy4oKTtcbiAgICAgICAgICAgICAgICBzZXROZXh0SW5kZXhJbkxpbmUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpc2libGUgPT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIGEgY2hpbGQgdHJhbnNpdGlvbiBoYXMgZmluaXNoZWQgaXRzIGV4aXQgdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAqIG1ha2Ugc3VyZSB0aGF0IGlmIHNvbWVvbmUgcmVxdWVzdGVkIHRvIGJlIHNob3duIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICogdGhhdCB3ZSBkbyBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG5leHRJbkxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUluZGV4KG5leHRJbkxpbmUpO1xuICAgICAgICAgICAgICAgIHNldE5leHRJbmRleEluTGluZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udGV4dDI6IEV4Y2x1c2l2ZUNvbnRleHRUeXBlID0gdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICBleGNsdXNpdml0eUtleSxcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIGNvbnN0IEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0ID0gR2V0RXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQoZXhjbHVzaXZpdHlLZXkpO1xuXG4gICAgcmV0dXJuIChFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCA9PSBudWxsKSA/ICgoY2hpbGRyZW4gYXMgVk5vZGUpID8/IG51bGwpIDogPEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0Mn0+e2NoaWxkcmVufTwvRXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXI+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VFeGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxFeGNsdXNpdmVJbmZvPiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCIgfCBcImNvbnRleHRcIj4ge1xuICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiBQaWNrPFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxhbnk+LCBcInNob3dcIj47XG4gICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZm9yY2VDbG9zZTogKCkgPT4gdm9pZDsgZXhjbHVzaXZpdHlLZXk/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFeGNsdXNpdmVUcmFuc2l0aW9uKHsgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgc2hvdyB9LCBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBmb3JjZUNsb3NlLCBleGNsdXNpdml0eUtleSB9IH06IFVzZUV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYyA9IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0KGV4Y2x1c2l2aXR5S2V5KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VFeGNsdXNpdmVUcmFuc2l0aW9uXCIsIGMgPT0gbnVsbCk7XG4gICAgY29uc3QgY29udGV4dCA9IGM/IHVzZUNvbnRleHQoYykgOiBudWxsO1xuXG4gICAgLy9jb25zdCBpbmRleCA9IHVzZU1lbW8oKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpLCBbXSk7XG4gICAgY29uc3QgaW5kZXggPSB1c2VNZW1vKCgpID0+IHsgZ2xvYmFsQ291bnQgKz0gMTsgcmV0dXJuIChnbG9iYWxDb3VudCkudG9TdHJpbmcoKSB9LCBbXSk7XG4gICAgY29uc3QgW2V4Y2x1c2l2ZWx5T3Blbiwgc2V0RXhjbHVzaXZlbHlPcGVuLCBnZXRFeGNsdXNpdmVseU9wZW5dID0gdXNlU3RhdGU8Ym9vbGVhbj4oISFzaG93KTtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfSA9IHVzZU1hbmFnZWRDaGlsZDxFeGNsdXNpdmVJbmZvPih7IGNvbnRleHQsIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSB9LCB7IGluZGV4LCBnZXRFeGNsdXNpdmVseU9wZW4sIHNldEV4Y2x1c2l2ZWx5T3BlbiwgZm9yY2VDbG9zZSB9KTtcblxuICAgIGNvbnN0IHBhcmVudE9uVmlzQ2hhbmdlID0gY29udGV4dD8uZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQub25WaXNpYmlsaXR5Q2hhbmdlO1xuXG4gICAgY29uc3Qgb25WaXNpYmlsaXR5Q2hhbmdlID0gdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPGFueT5bXCJvblZpc2liaWxpdHlDaGFuZ2VcIl0+PigodmlzaWJsZSkgPT4ge1xuICAgICAgICBwYXJlbnRPblZpc0NoYW5nZT8uKGluZGV4LCB2aXNpYmxlID09IGZhbHNlID8gXCJoaWRkZW5cIiA6IFwic2hvd1wiKTtcbiAgICB9LCBbcGFyZW50T25WaXNDaGFuZ2UsIGluZGV4XSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdylcbiAgICAgICAgICAgIHBhcmVudE9uVmlzQ2hhbmdlPy4oaW5kZXgsIFwic2hvd1wiKTtcbiAgICB9LCBbc2hvdywgcGFyZW50T25WaXNDaGFuZ2UsIGluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBpc0V4Y2x1c2l2ZTogKGNvbnRleHQgIT0gbnVsbCksXG4gICAgICAgICAgICBleGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBzZXRFeGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBnZXRFeGNsdXNpdmVseU9wZW4sXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuIiwiXHJcbmltcG9ydCB7IEZ1bmN0aW9uYWxDb21wb25lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbnR5cGUgRm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+ID0gT21pdDxQLCBcInJlZlwiPiAmIHsgcmVmPzogUmVmPEU+IH1cclxudHlwZSBGb3J3YXJkZWRGdW5jdGlvbmFsQ29tcG9uZW50PFAsIEU+ID0gKHA6IEZvcndhcmRlZEZ1bmN0aW9uYWxDb21wb25lbnRQcm9wczxQLCBFPikgPT4gVk5vZGU8Rm9yd2FyZGVkRnVuY3Rpb25hbENvbXBvbmVudFByb3BzPFAsIEU+PlxyXG5cclxudHlwZSBFbGVtZW50RnJvbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxpbmZlciBFPiA/IEUgOiBFdmVudFRhcmdldDtcclxudHlwZSBQcm9wc0Zyb21Db21wb25lbnQ8QyBleHRlbmRzIEZ1bmN0aW9uYWxDb21wb25lbnQ8YW55Pj4gPSBDIGV4dGVuZHMgRnVuY3Rpb25hbENvbXBvbmVudDxpbmZlciBQPiA/IFAgOiB1bmtub3duO1xyXG5cclxuLyoqXHJcbiAqIFNob3J0Y3V0IGZvciBwcmVhY3QvY29tcGF0J3MgYGZvcndhcmRSZWZgIHRoYXQgYXV0by1hc3N1bWVzIHNvbWUgdGhpbmdzIHRoYXQgYXJlIHVzZWZ1bCBmb3IgZm9yd2FyZGluZyByZWZzIHRvIGBIVE1MRWxlbWVudHNgIHNwZWNpZmljYWxseS5cclxuICogTmFtZWx5IGl0IGludm9sdmVzIGRlLWd1bmtpbmcgdGhlIHR5cGUgc3lzdGVtIGJ5IGxldHRpbmcgdXMgcmV0dXJuICpnZW5lcmljKiBmdW5jdGlvbiBhbmQgcGxheWluZyBuaWNlIHdpdGggUmVhY3QuIEluIGFsbCBvdGhlciByZXNwZWN0cywgaXQgYWN0cyBsaWtlIGBmb3J3YXJkUmVmYC5cclxuICogXHJcbiAqIFRPRE86IFN0aWxsIG5lZWRlZD9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkRWxlbWVudFJlZjxDIGV4dGVuZHMgPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4ocDogYW55LCByZWY6IFJlZjxFPikgPT4gKFZOb2RlPGFueT4gfCBudWxsKT4oQ29tcG9uZW50OiBDKSB7XHJcbiAgICB0eXBlIFAgPSBQcm9wc0Zyb21Db21wb25lbnQ8Qz47XHJcblxyXG5cclxuICAgIGNvbnN0IEZvcndhcmRlZENvbXBvbmVudCA9IGZvcndhcmRSZWYoQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBGb3J3YXJkZWRDb21wb25lbnQgYXMgQztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWZ1bCBpbiBwYXJ0aWN1bGFyIGZvciBTbGlkZXMgd2l0aCBhIFRhYiBQYW5lbCAtLVxyXG4gKiBpZiB3ZSBkbyBNYXRoLnNpZ24oY3VycmVudEluZGV4IC0gc2xpZGVJbmRleCksIGl0XHJcbiAqIHRyYW5zaXRpb25zIG5pY2VseSBpbiB0aGUgZXhwZWN0ZWQgZGlyZWN0aW9uLFxyXG4gKiBidXQgd2UgbmVlZCB0byBcInJlbWVtYmVyXCIgd2hpY2ggZGlyZWN0aW9uIHRvIHVzZVxyXG4gKiB3aGVuIGl0J3MgdGhlIGN1cnJlbnQgcGFuZWwgKGFuZCB0aGUgZGlmZmVyZW5jZSBpcyAwKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhc3ROb25OdWxsVmFsdWU8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogVCB8IG51bGwge1xyXG4gICAgY29uc3QgbGFzdE5vbk51bGxWYWx1ZSA9IHVzZVJlZjxUIHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICBsYXN0Tm9uTnVsbFZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcclxuICAgIH0sIFt2YWx1ZV0pO1xyXG5cclxuICAgIHJldHVybiB2YWx1ZSA/PyBsYXN0Tm9uTnVsbFZhbHVlLmN1cnJlbnQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGNsb25lRWxlbWVudCwgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIgfSBmcm9tIFwiLi9leGNsdXNpdmUuanNcIjtcclxuaW1wb3J0IHsgU3dhcHBhYmxlQ29udGV4dCwgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBOb25JbnRydXNpdmVFbGVtZW50QXR0cmlidXRlcyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3dhcFByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsPENyZWF0ZVN3YXBwYWJsZVByb3BzPiwgTm9uSW50cnVzaXZlRWxlbWVudEF0dHJpYnV0ZXM8RT4ge1xyXG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgZWFjaCBjaGlsZCB0cmFuc2l0aW9ucyBpbi9vdXQgYXQgdGhlIHNhbWUgdGltZSwgaW4gc3luYyB3aXRoIGVhY2ggb3RoZXIuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHlvdSB3YW50IHRvIGd1YXJhbnRlZSB0aGF0LCBubyBtYXR0ZXIgd2hhdCwgb25seSBvbmUgaXMgZXZlciB2aXNpYmxlIGF0IGFsbCxcclxuICAgICAqIHBhc3MgYSBzdHJpbmcgdG8gYGV4Y2x1c2l2aXR5S2V5YCwgYW5kIGFsbCB0cmFuc2l0aW9ucyB0aGF0IHVzZSB0aGF0IHNhbWVcclxuICAgICAqIGBleGNsdXNpdml0eUtleWAgd2lsbCBjb29yZGluYXRlIHRoaXMgYmVoYXZpb3IgYW1vbmcgdGhlbXNlbHZlcy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHNvIGF2YWlsYWJsZSBhcyBhIHNlcGFyYXRlIGNvbXBvbmVudCAoYEV4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcmApXHJcbiAgICAgKiBpZiB5b3UgbmVlZCB0aGlzIGJlaGF2aW9yIGluIHVucmVsYXRlZCBjaXJjdW1zdGFuY2VzLlxyXG4gICAgICovXHJcbiAgICBleGNsdXNpdml0eUtleT86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU3dhcHBhYmxlUHJvcHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgY29tcG9uZW50IGlzIGlubGluZS1ncmlkIG9yIGdyaWQuIFxyXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgY2hpbGQgZWxlbWVudCBpcyBsb29rZWQgYXQuIElmIGl0J3MgYSBzcGFuIG9yIG90aGVyIGlubGluZSBlbGVtZW50LCBpbmxpbmUgaXMgYXNzdW1lZC4gXHJcbiAgICAgKiAoQSBzaW1wbHktZm9vbGVkIGhldXJpc3RpYy0tcHJvdmlkZSB0aGlzIHByb3AgaWYgbmVjZXNzYXJ5KVxyXG4gICAgICovXHJcbiAgICBpbmxpbmU6IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgZGVmYXVsdCB2YWx1ZXMgdG8gYHVzZVRyYW5zaXRpb25gJ3MgYGFuaW1hdGVPbk1vdW50YC4gSWYgbnVsbCwgdGhlIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSwgdGhlbiBgdHJ1ZWAgYWZ0ZXIgdGhlIGBTd2FwcGFibGVgIGl0c2VsZiBoYXMgbW91bnRlZC5cclxuICAgICAqL1xyXG4gICAgY2hpbGRyZW5BbmltYXRlT25Nb3VudD86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIHN3YXAgY29udGFpbmVyLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZVN3YXBwYWJsZVByb3BzPFAgZXh0ZW5kcyB7fT4oeyBpbmxpbmUgfTogQ3JlYXRlU3dhcHBhYmxlUHJvcHMsIG90aGVyUHJvcHM6IFApIHtcclxuICAgIHR5cGUgRSA9IFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxpbmZlciBFPiA/IEUgOiBIVE1MRWxlbWVudDtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChgJHtHZXRCYXNlQ2xhc3MoKX0tc3dhcC1jb250YWluZXJgLCBpbmxpbmUgJiYgYCR7R2V0QmFzZUNsYXNzKCl9LXN3YXAtY29udGFpbmVyLWlubGluZWApXHJcbiAgICB9LCBvdGhlclByb3BzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhIHNldCBvZiBjaGlsZCA8VHJhbnNpdGlvbmFibGU+IGNvbXBvbmVudHMgdG8gYW5pbWF0ZSBpbiAmIG91dCBpbi1wbGFjZS4gVmVyeSB1c2VmdWwgZm9yLCBlLmcuLCB0YWIgcGFuZWxzLlxyXG4gKiBcclxuICogWW91IG11c3QgbWFuYWdlIGVhY2ggY2hpbGQgYDxUcmFuc2l0aW9uYWJsZT5gIGNvbXBvbmVudCdzIGBzaG93YCBwcm9wIC0tIHRoaXMgY29tcG9uZW50ICpkb2VzIG5vdCogbWFuYWdlIGFueSBzb3J0IG9mIHN0YXRlIGluIHRoYXQgcmVnYXJkLlxyXG4gKiBcclxuICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGVsZW1lbnQgKGxpa2UgYSBkaXYpIG9yIG90aGVyIHNpbmdsZSBjb21wb25lbnQsIHRoZW4gdGhlZSBwcm9wcyBhbmQgcmVmIHdpbGwgYmUgZm9yd2FyZGVkIG9udG8gdGhhdCBlbGVtZW50LiBPdGhlcndpc2UsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBiZSB3cmFwcGVkIGluIGEgZGl2IG9yIHNwYW4gZGVwZW5kaW5nIG9uIHRoZSBgaW5saW5lYCBwcm9wLlxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBjb25zdCBTd2FwcGFibGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFN3YXBwYWJsZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hpbGRyZW46IGMsIGlubGluZSwgY2hpbGRyZW5BbmltYXRlT25Nb3VudCwgZXhjbHVzaXZpdHlLZXksIC4uLnAgfTogU3dhcFByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgbGV0IGNoaWxkcmVuID0gYyBhcyBWTm9kZTtcclxuICAgIGlmICghKGNoaWxkcmVuIGFzIFZOb2RlKS50eXBlKVxyXG4gICAgICAgIGNoaWxkcmVuID0gKCFpbmxpbmUgPyA8ZGl2PntjaGlsZHJlbn08L2Rpdj4gOiA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPilcclxuICAgIGlubGluZSA/Pz0gdHlwZW9mIGNoaWxkcmVuLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgaW5saW5lRWxlbWVudHMuaGFzKGNoaWxkcmVuLnR5cGUpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHVzZUNyZWF0ZVN3YXBwYWJsZVByb3BzKHsgaW5saW5lIH0sIHsgLi4ucCwgcmVmIH0pO1xyXG4gICAgY29uc3QgbWVyZ2VkV2l0aENoaWxkcmVuID0gdXNlTWVyZ2VkUHJvcHM8RT4odHJhbnNpdGlvblByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XHJcblxyXG4gICAgY29uc3QgYW5pbWF0ZU9uTW91bnQgPSB1c2VSZWYoY2hpbGRyZW5BbmltYXRlT25Nb3VudCA/PyBmYWxzZSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGFuaW1hdGVPbk1vdW50LmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgfSwgW10pXHJcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VSZWYoeyBnZXRBbmltYXRlT25Nb3VudDogKCkgPT4geyByZXR1cm4gYW5pbWF0ZU9uTW91bnQuY3VycmVudDsgfSB9KTtcclxuICAgIGxldCByZXQgPSBjbG9uZUVsZW1lbnQoY2hpbGRyZW4sIG1lcmdlZFdpdGhDaGlsZHJlbiBhcyB0eXBlb2YgdHJhbnNpdGlvblByb3BzKTtcclxuICAgIHJldCA9ICg8U3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlLmN1cnJlbnR9PntyZXR9PC9Td2FwcGFibGVDb250ZXh0LlByb3ZpZGVyPilcclxuICAgIGlmIChleGNsdXNpdml0eUtleSkge1xyXG4gICAgICAgIHJldCA9ICg8RXhjbHVzaXZlVHJhbnNpdGlvblByb3ZpZGVyIGtleT17ZXhjbHVzaXZpdHlLZXl9IGV4Y2x1c2l2aXR5S2V5PXtleGNsdXNpdml0eUtleX0+e3JldH08L0V4Y2x1c2l2ZVRyYW5zaXRpb25Qcm92aWRlcj4pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59KSlcclxuXHJcbi8vIElmIFwiaW5saW5lXCIgaXNuJ3QgZXhwbGljaXRseSBwcm92aWRlZCwgd2UgdHJ5IHRvIGltcGxpY2l0bHkgZG8gaXQgYmFzZWQgb24gdGhlIGNoaWxkJ3MgdGFnLlxyXG4vLyBOb3QgcGVyZmVjdCwgYnV0IGl0J3Mgbm90IHN1cHBvc2VkIHRvIGJlLiBgaW5saW5lYCBpcyBmb3IgcGVyZmVjdC5cclxuY29uc3QgaW5saW5lRWxlbWVudHMgPSBuZXcgU2V0KFtcclxuICAgIFwiYVwiLFxyXG4gICAgXCJhYmJyXCIsXHJcbiAgICBcImFjcm9ueW1cIixcclxuICAgIFwiYXVkaW9cIixcclxuICAgIFwiYlwiLFxyXG4gICAgXCJiZGlcIixcclxuICAgIFwiYmRvXCIsXHJcbiAgICBcImJpZ1wiLFxyXG4gICAgXCJiclwiLFxyXG4gICAgXCJidXR0b25cIixcclxuICAgIFwiY2FudmFzXCIsXHJcbiAgICBcImNpdGVcIixcclxuICAgIFwiY29kZVwiLFxyXG4gICAgXCJkYXRhXCIsXHJcbiAgICBcImRhdGFsaXN0XCIsXHJcbiAgICBcImRlbFwiLFxyXG4gICAgXCJkZm5cIixcclxuICAgIFwiZW1cIixcclxuICAgIFwiZW1iZWRcIixcclxuICAgIFwiaVwiLFxyXG4gICAgXCJpZnJhbWVcIixcclxuICAgIFwiaW1nXCIsXHJcbiAgICBcImlucHV0XCIsXHJcbiAgICBcImluc1wiLFxyXG4gICAgXCJrYmRcIixcclxuICAgIFwibGFiZWxcIixcclxuICAgIFwibWFwXCIsXHJcbiAgICBcIm1hcmtcIixcclxuICAgIFwibWV0ZXJcIixcclxuICAgIFwibm9zY3JpcHRcIixcclxuICAgIFwib2JqZWN0XCIsXHJcbiAgICBcIm91dHB1dFwiLFxyXG4gICAgXCJwaWN0dXJlXCIsXHJcbiAgICBcInByb2dyZXNzXCIsXHJcbiAgICBcInFcIixcclxuICAgIFwicnVieVwiLFxyXG4gICAgXCJzXCIsXHJcbiAgICBcInNhbXBcIixcclxuICAgIFwic2NyaXB0XCIsXHJcbiAgICBcInNlbGVjdFwiLFxyXG4gICAgXCJzbG90XCIsXHJcbiAgICBcInNtYWxsXCIsXHJcbiAgICBcInNwYW5cIixcclxuICAgIFwic3Ryb25nXCIsXHJcbiAgICBcInN1YlwiLFxyXG4gICAgXCJzdXBcIixcclxuICAgIFwic3ZnXCIsXHJcbiAgICBcInRlbXBsYXRlXCIsXHJcbiAgICBcInRleHRhcmVhXCIsXHJcbiAgICBcInRpbWVcIixcclxuICAgIFwidVwiLFxyXG4gICAgXCJ0dFwiLFxyXG4gICAgXCJ2YXJcIixcclxuICAgIFwidmlkZW9cIixcclxuICAgIFwid2JyXCJcclxuXSk7XHJcbiIsImltcG9ydCB7IGNsb25lRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHJldHVybkZhbHNlLCBydW5JbW1lZGlhdGVseSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUV4Y2x1c2l2ZVRyYW5zaXRpb24gfSBmcm9tIFwiLi9leGNsdXNpdmUuanNcIjtcbmltcG9ydCB7IEdldEV4Y2x1c2l2ZVRyYW5zaXRpb25Db250ZXh0LCB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBTd2FwcGFibGVDb250ZXh0VHlwZSwgVHJhbnNpdGlvbkRpcmVjdGlvbiwgVHJhbnNpdGlvblBoYXNlLCBUcmFuc2l0aW9uU3RhdGUsIFVzZVRyYW5zaXRpb25QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xuaW1wb3J0IHsgU3dhcHBhYmxlQ29udGV4dCB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xuXG5cbmZ1bmN0aW9uIGdldFRpbWVvdXREdXJhdGlvbjxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KGVsZW1lbnQ6IEUgfCBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoYHRyYW5zaXRpb24tZHVyYXRpb25gKSkuc3BsaXQoXCIsXCIpLm1hcChzdHIgPT4ge1xuICAgICAgICBpZiAoc3RyLmVuZHNXaXRoKFwibXNcIikpXG4gICAgICAgICAgICByZXR1cm4gK3N0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICBpZiAoc3RyLmVuZHNXaXRoKFwic1wiKSlcbiAgICAgICAgICAgIHJldHVybiAoK3N0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiAxMDAwO1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGF0ZShuZXh0U3RhdGU6IFRyYW5zaXRpb25TdGF0ZSkge1xuICAgIHJldHVybiBuZXh0U3RhdGUuc3BsaXQoXCItXCIpIGFzIFtUcmFuc2l0aW9uRGlyZWN0aW9uLCBUcmFuc2l0aW9uUGhhc2VdO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgcHJvcHMgdGhhdCBjYW4gYmUgdXNlZCB0byBhbmltYXRlIGEgdHJhbnNpdGlvbi5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhbnNpdGlvbjxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgcHJvcHNJbmNvbWluZzogeyBjaGlsZHJlbiwgLi4ucCB9LCBzaG93LCBhbmltYXRlT25Nb3VudCwgbWVhc3VyZSwgZXhpdFZpc2liaWxpdHksIGR1cmF0aW9uLCBkZWxheU1vdW50VW50aWxTaG93biwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBvblZpc2liaWxpdHlDaGFuZ2UgfSwgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfSB9OiBVc2VUcmFuc2l0aW9uUGFyYW1ldGVyczxFPik6IFZOb2RlPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+PiB8IG51bGwge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVRyYW5zaXRpb25cIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcblxuICAgIGNvbnN0IHsgZ2V0QW5pbWF0ZU9uTW91bnQgfSA9IHVzZUNvbnRleHQoU3dhcHBhYmxlQ29udGV4dCk7XG4gICAgZXhpdFZpc2liaWxpdHkgfHw9IFwiaGlkZGVuXCJcbiAgICBhbmltYXRlT25Nb3VudCA/Pz0gZ2V0QW5pbWF0ZU9uTW91bnQoKTtcbiAgICBtZWFzdXJlID8/PSBmYWxzZTtcblxuICAgIGNvbnN0IGdldEV4aXRWaXNpYmlsaXR5ID0gdXNlU3RhYmxlR2V0dGVyKGV4aXRWaXNpYmlsaXR5KTtcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcywgR2V0RW50ZXJDbGFzcywgR2V0RXhpdENsYXNzLCBHZXRNZWFzdXJlQ2xhc3MsIEdldEluaXRDbGFzcywgR2V0VHJhbnNpdGlvbkNsYXNzLCBHZXRGaW5hbGl6ZUNsYXNzLCBHZXREaXJlY3Rpb25DbGFzcywgR2V0UGhhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xuICAgIGNvbnN0IGdldE1lYXN1cmUgPSB1c2VTdGFibGVHZXR0ZXIobWVhc3VyZSk7XG4gICAgY29uc3QgeyBleGNsdXNpdmVUcmFuc2l0aW9uUmV0dXJuOiB7IGV4Y2x1c2l2ZWx5T3BlbiwgaXNFeGNsdXNpdmUsIG9uVmlzaWJpbGl0eUNoYW5nZTogZXhjbHVzaXZlVHJhbnNpdGlvblZpc2liaWxpdHlDaGFuZ2UgfSB9ID0gdXNlRXhjbHVzaXZlVHJhbnNpdGlvbih7XG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IHNob3cgfSxcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXksIGZvcmNlQ2xvc2U6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgaW50ZXJuYWxPblNob3dDaGFuZ2VkKGZhbHNlLCBnZXRNZWFzdXJlKCkpOyB9KSB9XG4gICAgfSk7XG5cbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcbiAgICAgICAgc2hvdyA9IChzaG93ICYmIGV4Y2x1c2l2ZWx5T3Blbik7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQsIHByb3BzU3RhYmxlIH0gfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pXG4gICAgY29uc3QgY3NzUHJvcGVydGllcyA9IHVzZVJlZjxoLkpTWC5DU1NQcm9wZXJ0aWVzPih7fSk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oW1xuICAgICAgICAvLyBUaGlzIGlzIHJlbW92ZWQgZHVyaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgZmlyc3QgcmVuZGVyXG4gICAgICAgIC8vIChhdCBsZWFzdCBvbmNlIGBzaG93YCBpcyBub24tbnVsbClcbiAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LXBlbmRpbmdgLFxuICAgIF0pKTtcbiAgICBjb25zdCBoYW5kbGVUcmFuc2l0aW9uRmluaXNoZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoISFzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgW2RpcmVjdGlvbiwgcGhhc2VdID0gcGFyc2VTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICBpZiAocGhhc2UgPT0gXCJ0cmFuc2l0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShgJHtkaXJlY3Rpb259LWZpbmFsaXplYCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRIYW5kbGUuY3VycmVudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudD8uKHRpbWVvdXRIYW5kbGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUuY3VycmVudCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuICAgIGNvbnN0IG90aGVyUHJvcHMgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHtcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kOiAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IGdldEVsZW1lbnQoKSAmJiBlLmVsYXBzZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgaGFzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50J3MgQ1NTIGNsYXNzIHRvIG1hdGNoIHRoZSBnaXZlbiBkaXJlY3Rpb24gYW5kIHBoYXNlLlxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZUNsYXNzZXMgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIGRpcmVjdGlvbjogVHJhbnNpdGlvbkRpcmVjdGlvbiwgcGhhc2U/OiBUcmFuc2l0aW9uUGhhc2UpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuXG4gICAgICAgIGNvbnN0IGV4aXRWaXNpYmlsaXR5ID0gZ2V0RXhpdFZpc2liaWxpdHkoKTtcblxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzVG9SZW1vdmUgPSBbXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRNZWFzdXJlQ2xhc3MoKX1gLCBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFbnRlckNsYXNzKCl9LSR7R2V0SW5pdENsYXNzKCl9YCwgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS0ke0dldFRyYW5zaXRpb25DbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tJHtHZXRGaW5hbGl6ZUNsYXNzKCl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldE1lYXN1cmVDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldEluaXRDbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldFRyYW5zaXRpb25DbGFzcygpfWAsIGAke0dldEJhc2VDbGFzcygpfS0ke0dldEV4aXRDbGFzcygpfS0ke0dldEZpbmFsaXplQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJpbmVydFwifWAsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX0tZXYtJHtcInJlbW92ZWRcIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJoaWRkZW5cIn1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7XCJ2aXNpYmxlXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1wZW5kaW5nYCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzVG9BZGQgPSBbXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RGlyZWN0aW9uQ2xhc3MoZGlyZWN0aW9uKX1gLFxuICAgICAgICAgICAgcGhhc2UgPyBgJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXREaXJlY3Rpb25DbGFzcyhkaXJlY3Rpb24pfS0ke0dldFBoYXNlQ2xhc3MocGhhc2UpfWAgOiBcIlwiLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7ZXhpdFZpc2liaWxpdHl9YFxuICAgICAgICBdO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5hbGxDbGFzc2VzVG9SZW1vdmUpO1xuICAgICAgICBhbGxDbGFzc2VzVG9SZW1vdmUubWFwKHYgPT4gY2xhc3NOYW1lcy5jdXJyZW50LmRlbGV0ZSh2KSk7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmFsbENsYXNzZXNUb0FkZCk7XG4gICAgICAgIGFsbENsYXNzZXNUb0FkZC5tYXAodiA9PiBjbGFzc05hbWVzLmN1cnJlbnQuYWRkKHYpKTtcblxuICAgIH0sIFtdKTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBzaW5nbGUgXCJtZWFzdXJlXCIgdmFyaWFibGUgKG9yIHJlbW92ZXMgaXQpXG4gICAgICovXG4gICAgY29uc3QgdXBkYXRlU2l6ZVByb3BlcnR5ID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUsIHZhck5hbWU6IChrZXlvZiBoLkpTWC5DU1NQcm9wZXJ0aWVzKSAmIHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9cHhgO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkodmFyTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W3Zhck5hbWVdO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgXCJtZWFzdXJlXCIgdmFyaXVwZGF0ZUNsYXNzZXNhYmxlcyB0byB0aGUgZWxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gICAgICovXG4gICAgY29uc3QgbWVhc3VyZUVsZW1lbnRBbmRVcGRhdGVQcm9wZXJ0aWVzID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsLCBtZWFzdXJlOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgc2l6ZTogRE9NUmVjdFJlYWRPbmx5IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobWVhc3VyZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS10b3BgLCBzaXplPy50b3ApO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtbGVmdGAsIHNpemU/LmxlZnQpO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZVByb3BlcnR5KGVsZW1lbnQsIGAtLSR7R2V0QmFzZUNsYXNzKCl9LW1lYXN1cmUtd2lkdGhgLCBzaXplPy53aWR0aCk7XG4gICAgICAgICAgICB1cGRhdGVTaXplUHJvcGVydHkoZWxlbWVudCwgYC0tJHtHZXRCYXNlQ2xhc3MoKX0tbWVhc3VyZS1oZWlnaHRgLCBzaXplPy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gV2UgdXNlIGJvdGggdXNlVGltZW91dCBhbmQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciB0aW1pbmcgY2VydGFpbiB0aGluZ3MgLS1cbiAgICAvLyByYWYgaXMgdXNlZCBmb3IgY2hhbmdpbmcgZnJvbSBpbml0IHRvIHRyYW5zaXRpb24gKHdvdWxkIHVzZSBxdWV1ZU1pY3JvdGFzayBidXQgaXQgY2FuJ3QgYmUgY2FuY2VsbGVkKVxuICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCBmb3IgY2hhbmdpbmcgZnJvbSB0cmFuc2l0aW9uIHRvIGZpbmFsaXplIChhcyBhIGJhY2t1cCBpbiBjYXNlIHRyYW5zaXRpb25lbmQgZG9lc24ndCBmaXJlKVxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgc3RhbGUgY2FsbGJhY2tzIHJ1bm5pbmcgKGkuZS4gd2hlbiB3ZSByYXBpZGx5IHN3aXRjaCBiZXR3ZWVuIHZpc2libGUgYW5kIG5vdClcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBhY2N1cmF0ZWx5IGNhbmNlbCBhbnl0aGluZyB0aGF0IGNhbiBjaGFuZ2Ugb3VyIHN0YXRlIG9uIGEgZGVsYXkuXG4gICAgLy9cbiAgICAvLyBBbHNvIG9mIG5vdGUsIHdlIHN0b3JlIFwiKGYpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQoZilcIiBpbnN0ZWFkIG9mIGp1c3QgXCJ3aW5kb3cuY2xlYXJUaW1lb3V0XCIgYmVjYXVzZVxuICAgIC8vIG9mIHRoZSBpbXBsaWNpdCB3aW5kb3cgb2JqZWN0IC0tIHByb2JsZW1zIHdpdGggYSBtaXNzaW5nIGB0aGlzYCBvYmplY3QgYW5kIGFsbCB0aGF0IG5vbnNlbnNlLlxuICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSB1c2VSZWY8bnVtYmVyPigtMSk7XG4gICAgY29uc3QgdGltZW91dENsZWFyRnVuY3Rpb24gPSB1c2VSZWY8KHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSkgfCAodHlwZW9mIGNsZWFyVGltZW91dCkgfCBudWxsPihudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEFueSB0aW1lIHRoZSBzdGF0ZSBjaGFuZ2VzLCB0aGVyZSdzIHNvbWUgbG9naWMgd2UgbmVlZCB0byBydW46XG4gICAgICogXG4gICAgICogKiBJZiB3ZSdyZSBjaGFuZ2luZyB0byBhbiBgaW5pdGAgcGhhc2UsIHVwZGF0ZSB0aGUgY2xhc3NlcywgdGhlbiB3YWl0IGEgbW9tZW50IGFuZCB0aGVuIGNoYW5nZSB0byB0aGUgYHRyYW5zaXRpb25gIHBoYXNlLlxuICAgICAqICogSWYgd2UncmUgY2hhbmdpbmcgdG8gYSBgdHJhbnNpdGlvbmAgcGhhc2UsIHVwZGF0ZSB0aGUgY2xhc3NlcywgdGhlbiB3YWl0IHVudGlsIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcywgdGhlbiBjaGFuZ2UgdG8gdGhlIGBmaW5hbGl6ZWAgcGhhc2UuXG4gICAgICogXG4gICAgICogQW55IGNoYW5nZSBpbiBzdGF0ZSBvciBjbGFzc2VzL3N0eWxlcyBkb2VzIG5vdCBpbXBsaWNpdGx5IGNhdXNlIGEgcmUtcmVuZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IG9uU3RhdGVDaGFuZ2UgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUcmFuc2l0aW9uU3RhdGUgfCBudWxsLCB1bmRlZmluZWQ+PigobmV4dFN0YXRlLCBwcmV2U3RhdGUsIHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY29uc3QgW25leHREaXJlY3Rpb24sIG5leHRQaGFzZV0gPSBwYXJzZVN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIG5vIHN0YWxlIGNoYW5nZSBjb2RlIGV2ZXIgcnVuc1xuICAgICAgICBpZiAodGltZW91dEhhbmRsZS5jdXJyZW50ID49IDAgJiYgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudClcbiAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQodGltZW91dEhhbmRsZS5jdXJyZW50KTtcblxuICAgICAgICAvLyBIYW5kbGUgaW5lcnQgcHJvcHMvcHJvcGVydHlcbiAgICAgICAgY29uc3QgZXhpdFZpc2liaWxpdHkgPSBnZXRFeGl0VmlzaWJpbGl0eSgpO1xuICAgICAgICBpZiAoZXhpdFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZXJ0ID0gKGV4aXRWaXNpYmlsaXR5ID09IFwiaW5lcnRcIiAmJiAobmV4dERpcmVjdGlvbiA9PSBcImV4aXRcIiAmJiBuZXh0UGhhc2UgPT0gXCJmaW5hbGl6ZVwiKSA/IHRydWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKGluZXJ0KVxuICAgICAgICAgICAgICAgIChvdGhlclByb3BzLmN1cnJlbnQgYXMgYW55KS5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG90aGVyUHJvcHMuY3VycmVudFtcImluZXJ0XCIgYXMgbmV2ZXJdO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZXJ0ID0gKGluZXJ0IHx8IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQmVpbmdQYWludGVkID0gKG5leHREaXJlY3Rpb24gPT0gXCJlbnRlclwiIHx8IChuZXh0RGlyZWN0aW9uID09IFwiZXhpdFwiICYmIG5leHRQaGFzZSAhPSBcImZpbmFsaXplXCIpKTtcbiAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlPy4oaXNCZWluZ1BhaW50ZWQpO1xuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZT8uKGlzQmVpbmdQYWludGVkKTtcblxuICAgICAgICB1cGRhdGVDbGFzc2VzKGVsZW1lbnQsIG5leHREaXJlY3Rpb24sIG5leHRQaGFzZSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIChuZXh0UGhhc2UgPT0gXCJpbml0XCIgfHwgbmV4dFBoYXNlID09IFwidHJhbnNpdGlvblwiKSlcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xuXG5cblxuICAgICAgICBzd2l0Y2ggKG5leHRQaGFzZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1lYXN1cmVcIjoge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudEFuZFVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy9zZXRTdGF0ZShgJHtuZXh0RGlyZWN0aW9ufS1pbml0YCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2xhc3NlcyhlbGVtZW50LCBuZXh0RGlyZWN0aW9uLCBcImluaXRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVmbG93KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gISFJbnRlbnRpb25hbCBmYWxsLXRocm91Z2ghIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImluaXRcIjoge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHNldFN0YXRlKGAke25leHREaXJlY3Rpb259LXRyYW5zaXRpb25gKTsgfSk7XG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IChmOiBudW1iZXIpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGYpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVRyYW5zaXRpb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGdldFRpbWVvdXREdXJhdGlvbihlbGVtZW50KSAqIDEuNSk7XG4gICAgICAgICAgICAgICAgdGltZW91dENsZWFyRnVuY3Rpb24uY3VycmVudCA9IChmOiBudW1iZXIpID0+IGNsZWFyVGltZW91dChmKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplXCI6IHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIG9yIHNjaGVkdWxlIG9yIGFueXRoaW5nIC0tIHdlIGp1c3QgdXBkYXRlIG91ciBjbGFzc2VzIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgICAgIHRpbWVvdXRDbGVhckZ1bmN0aW9uLmN1cnJlbnQgPSBudWxsOyAgICAvLyBEb2VzIHRoaXMgbWFrZSBpdCBtb3JlIG9yIGxlc3MgY2xlYXI/XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gSW50ZW50aW9uYWxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZCBzdGF0ZSB1c2VkIGluIHRyYW5zaXRpb246ICR7bmV4dFN0YXRlfS4gUHJldmlvdXMgc3RhdGUgd2FzICR7cHJldlN0YXRlID8/IFwibnVsbFwifWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG5cbiAgICBjb25zdCBbZ2V0U3RhdGUsIHNldFN0YXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxUcmFuc2l0aW9uU3RhdGUgfCBudWxsLCB1bmRlZmluZWQ+KG9uU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcblxuICAgIC8vIFdoZW4gd2UgbW91bnQsIGFuZCBldmVyeSB0aW1lIHRoZXJlYWZ0ZXIgdGhhdCBgc2hvd2AgY2hhbmdlcyxcbiAgICAvLyBjaGFuZ2Ugb3VyIGN1cnJlbnQgc3RhdGUgYWNjb3JkaW5nIHRvIHRoYXQgYHNob3dgIHZhbHVlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiBpbnRlcm5hbE9uU2hvd0NoYW5nZWQoc2hvdywgbWVhc3VyZSksIFttZWFzdXJlLCBzaG93XSk7XG5cblxuICAgIC8vIFRoaXMgaGFzIG5vIGRlcGVuZGVuY2VzIGFuZCBpcyByZWxpZWQgb24gaW4gdHdvIGRpZmZlcmVudCBhcmVhc1xuICAgIGZ1bmN0aW9uIGludGVybmFsT25TaG93Q2hhbmdlZChzaG93OiBib29sZWFuIHwgbnVsbCwgbWVhc3VyZTogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIElmIGBzaG93YCBpcyBudWxsLCB0aGVuIHdlIGRvbid0IGNoYW5nZSBhbnl0aGluZy5cbiAgICAgICAgaWYgKHNob3cgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyAoSWYgYHNob3dgIGlzIHRydWUvZmFsc2UsIHdlJ2xsIHJlbW92ZSB0aGUgQ1NTIGNsYXNzZXMgZHVyaW5nIGBvbkNoYW5nZWApXG5cbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHRQaGFzZTogVHJhbnNpdGlvblBoYXNlID0gbWVhc3VyZSA/IFwibWVhc3VyZVwiIDogXCJpbml0XCI7XG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50RGlyZWN0aW9uLCBjdXJyZW50UGhhc2VdID0gcGFyc2VTdGF0ZShjdXJyZW50U3RhdGUpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQaGFzZSAhPSBcImZpbmFsaXplXCIpXG4gICAgICAgICAgICAgICAgbmV4dFBoYXNlID0gXCJ0cmFuc2l0aW9uXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiB0aGUgc2V0U3RhdGUgY2hhbmdlIGhhbmRsZXIgcnVucyBpbW1lZGlhdGVseSB3aXRoIG5vIGRlYm91bmNlLlxuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgaWYgKGhhc01vdW50ZWQuY3VycmVudCB8fCBhbmltYXRlT25Nb3VudClcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShgZW50ZXItJHtuZXh0UGhhc2V9YCk7XG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShcImVudGVyLWZpbmFsaXplXCIpO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzTW91bnRlZC5jdXJyZW50IHx8IGFuaW1hdGVPbk1vdW50KVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKGBleGl0LSR7bmV4dFBoYXNlfWApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldFN0YXRlKFwiZXhpdC1maW5hbGl6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGR1cmF0aW9uICE9IG51bGwpXG4gICAgICAgIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS1kdXJhdGlvbmBdID0gZHVyYXRpb24gKyBcIm1zXCI7XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LWR1cmF0aW9uYF07XG5cbiAgICBlYXNpbmdJbiA/Pz0gZWFzaW5nO1xuICAgIGVhc2luZ091dCA/Pz0gZWFzaW5nO1xuXG4gICAgaWYgKGVhc2luZ091dCAhPSBudWxsKVxuICAgICAgICBjc3NQcm9wZXJ0aWVzLmN1cnJlbnRbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tJHtHZXRFeGl0Q2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF0gPSBlYXNpbmdPdXQ7XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RXhpdENsYXNzKCl9LXRpbWluZy1mdW5jdGlvbmBdO1xuXG5cbiAgICBpZiAoZWFzaW5nSW4gIT0gbnVsbClcbiAgICAgICAgY3NzUHJvcGVydGllcy5jdXJyZW50W2AtLSR7R2V0QmFzZUNsYXNzKCl9LSR7R2V0RW50ZXJDbGFzcygpfS10aW1pbmctZnVuY3Rpb25gXSA9IGVhc2luZ0luO1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIGNzc1Byb3BlcnRpZXMuY3VycmVudFtgLS0ke0dldEJhc2VDbGFzcygpfS0ke0dldEVudGVyQ2xhc3MoKX0tdGltaW5nLWZ1bmN0aW9uYF07XG5cblxuXG4gICAgLy8gVE9ET1xuICAgIGNvbnN0IGlubGluZURpcmVjdGlvbiA9IG51bGw7XG4gICAgY29uc3QgYmxvY2tEaXJlY3Rpb24gPSBudWxsO1xuXG5cblxuICAgIC8vIE5vIG1hdHRlciB3aGF0IGRlbGF5TW91bnRVbnRpbFNob3duIGlzLFxuICAgIC8vIG9uY2Ugd2UndmUgcmVuZGVyZWQgb3VyIGNoaWxkcmVuIG9uY2UsIFxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRvbid0IHVubW91bnQgdGhlbSBhZ2FpbiBhbmQgd2FzdGUgYWxsIHRoYXQgd29yay5cbiAgICAvLyAoSWYgeW91IHJlYWxseSBuZWVkIHRoaXMgeW91IGNhbiBqdXN0IHVubW91bnQgdGhlIGVudGlyZSB0cmFuc2l0aW9uIGl0c2VsZilcbiAgICBjb25zdCBkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiA9IChzaG93IHx8ICFkZWxheU1vdW50VW50aWxTaG93bik7XG4gICAgY29uc3QgaGFzUmVuZGVyZWRDaGlsZHJlbiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgcmVuZGVyQ2hpbGRyZW4gPSBkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiB8fCBoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQ7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuKVxuICAgICAgICAgICAgaGFzUmVuZGVyZWRDaGlsZHJlbi5jdXJyZW50IHx8PSB0cnVlO1xuICAgIH0sIFtoYXNSZW5kZXJlZENoaWxkcmVuLmN1cnJlbnQgPyBmYWxzZSA6IGRlZmluaXRlbHlTaG91bGRNb3VudENoaWxkcmVuXSk7XG5cblxuICAgIGNvbnN0IGNoaWxkcmVuSXNWbm9kZSA9IChjaGlsZHJlbiAmJiAoY2hpbGRyZW4gYXMgVk5vZGUpLnR5cGUgJiYgKGNoaWxkcmVuIGFzIFZOb2RlKS5wcm9wcyk7XG4gICAgY29uc3QgZmluYWxQcm9wcyA9IHVzZU1lcmdlZFByb3BzPEU+KHAsIHByb3BzU3RhYmxlLCBvdGhlclByb3BzLmN1cnJlbnQsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAuLi5jbGFzc05hbWVzLmN1cnJlbnQsXG4gICAgICAgICAgICBgJHtHZXRCYXNlQ2xhc3MoKX1gLFxuICAgICAgICAgICAgYCR7R2V0QmFzZUNsYXNzKCl9LWV2LSR7ZXhpdFZpc2liaWxpdHl9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1pbmxpbmUtZGlyZWN0aW9uLSR7aW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCJ9YCxcbiAgICAgICAgICAgIGAke0dldEJhc2VDbGFzcygpfS1ibG9jay1kaXJlY3Rpb24tJHtibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwifWBcbiAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgc3R5bGU6IGNzc1Byb3BlcnRpZXMuY3VycmVudFxuICAgIH0sIGNoaWxkcmVuSXNWbm9kZSA/IHsgcmVmOiAoY2hpbGRyZW4gYXMgVk5vZGUpLnJlZiwgLi4uKGNoaWxkcmVuIGFzIFZOb2RlKS5wcm9wcyB9IDoge30pO1xuXG5cblxuICAgIGNvbnN0IHJlc2V0Q29udGV4dCA9IHVzZVJlZjxTd2FwcGFibGVDb250ZXh0VHlwZT4oeyBnZXRBbmltYXRlT25Nb3VudDogcmV0dXJuRmFsc2UgfSkuY3VycmVudDtcblxuICAgIGxldCBtb2RpZmllZENoaWxkcmVuOiBWTm9kZTtcblxuICAgIGlmIChjaGlsZHJlbklzVm5vZGUpIHtcbiAgICAgICAgbW9kaWZpZWRDaGlsZHJlbiA9IDxTd2FwcGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyZXNldENvbnRleHR9PntjbG9uZUVsZW1lbnQoY2hpbGRyZW4gYXMgVk5vZGUsIGZpbmFsUHJvcHMpfTwvU3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlcj5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vZGlmaWVkQ2hpbGRyZW4gPSA8U3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cmVzZXRDb250ZXh0fT48c3BhbiB7Li4uZmluYWxQcm9wcyBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+fT57Y2hpbGRyZW59PC9zcGFuPjwvU3dhcHBhYmxlQ29udGV4dC5Qcm92aWRlcj5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyQ2hpbGRyZW4gPyBtb2RpZmllZENoaWxkcmVuIDogbnVsbDtcbn1cblxuXG5cbmZ1bmN0aW9uIGZvcmNlUmVmbG93PEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oZTogRSkge1xuXG4gICAgLy8gVHJ5IHJlYWxseSBoYXJkIHRvIG1ha2Ugc3VyZSB0aGlzIGlzbid0IG9wdGltaXplZCBvdXQgYnkgYW55dGhpbmcuXG4gICAgLy8gV2UgbmVlZCBpdCBmb3IgaXRzIGRvY3VtZW50IHJlZmxvdyBzaWRlIGVmZmVjdC5cbiAgICBjb25zdCBwID0gKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXk7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gZS5zdHlsZS5vcGFjaXR5O1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX2R1bW15ID0gZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fZHVtbXkgPSBwO1xuICAgIHJldHVybiBlO1xufVxuIiwiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQ3NzQ2xhc3NlcyB9IGZyb20gXCIuL3V0aWwvY29udGV4dC5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyB0aGF0IGFsbG93IGFkanVzdGluZyB0aGUgbWluaW11bSBvciBtYXhpbXVtIG9wYWNpdHkgdmFsdWVzIHRvIHVzZSBmb3IgdGhlIGZhZGUgZWZmZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVyczxFPiB7XHJcbiAgICBmYWRlUGFyYW1ldGVyczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIGZhZGVkIG91dC5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmFkZU1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wYWNpdHkgdG8gdXNlIHdoZW4gZmFkZWQgaW4uXHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZhZGVNYXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgRmFkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqIEJlIHN1cmUgdG8gbWVyZ2UgdGhlc2UgcmV0dXJuZWQgcHJvcHMgd2l0aCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgaW4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzRmFkZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWluLCBmYWRlTWF4IH0gfTogVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWZhZGVgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mYWRlLW1pbmBdOiAoZmFkZU1pbiA/PyAwKSxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWZhZGUtbWF4YF06IChmYWRlTWF4ID8/IDEpLFxyXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGYWRlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmFkZSBlZmZlY3QuXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgd2hpbGUgaXQgaXMgYWJzb2x1dGVseSBwb3NzaWJsZSB0byB3cmFwIGFub3RoZXIgdHJhbnNpdGlvbiB3aXRoIGA8RmFkZT5gLFxyXG4gKiB0aGVyZSB3aWxsIGJlIHNvbWUgZHVwbGljYXRlIGNvZGUgcnVuIGFzIHR3byBgPFRyYW5zaXRpb25hYmxlPmAgY29tcG9uZW50cyBlbmQgdXAgb3BlcmF0aW5nIG9uIHRoZSBzYW1lIGVsZW1lbnQuXHJcbiAqIEl0J3MgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIGVpdGhlciB1c2UgdGhlIGNvbXBvbmVudHMgdGhhdCBpbmNsdWRlIGEgY29tYmluZWQgZmFkZSBlZmZlY3QsXHJcbiAqIG9yIGp1c3QgZGlyZWN0bHkgYSBgPFRyYW5zaXRpb25hYmxlPmAgb24geW91ciBvd24uXHJcbiAqIFxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcclxuICovXHJcbmV4cG9ydCBjb25zdCBGYWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZGVsYXlNb3VudFVudGlsU2hvd24sIGZhZGVNaW4sIGZhZGVNYXgsIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IEZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oeyByZWYsIC4uLnJlc3QgfSwgdXNlQmFzZVByb3BzRmFkZSh7IGZhZGVQYXJhbWV0ZXJzOiB7IGZhZGVNYXgsIGZhZGVNaW4gfSB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgY2xpcFBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIGNsaXAgYXJvdW5kICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gY2xpcCBhcm91bmQgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcylcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwT3JpZ2luSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIGNsaXAgYXJvdW5kIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBPcmlnaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBjbGlwIHRvL2Zyb20sIGZyb20gMCB0byAxICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpcE1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBjbGlwIHRvL2Zyb20sIGZyb20gMCB0byAxIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGlwTWluSW5saW5lOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSBzaXplIHRvIGNsaXAgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsaXBNaW5CbG9jazogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0NsaXA8RSBleHRlbmRzIEVsZW1lbnQ+KHsgY2xpcFBhcmFtZXRlcnM6IHsgY2xpcE1pbiwgY2xpcE1pbkJsb2NrLCBjbGlwTWluSW5saW5lLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBPcmlnaW5JbmxpbmUgfSB9OiBVc2VCYXNlUHJvcHNDbGlwUGFyYW1ldGVyczxFPikge1xyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc3goYCR7R2V0QmFzZUNsYXNzKCl9LWNsaXBgKSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW9yaWdpbi1pbmxpbmVgXTogKGNsaXBPcmlnaW5JbmxpbmUgPz8gY2xpcE9yaWdpbiA/PyAwLjUpLFxyXG4gICAgICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LWNsaXAtb3JpZ2luLWJsb2NrYF06IChjbGlwT3JpZ2luQmxvY2sgPz8gY2xpcE9yaWdpbiA/PyAwKSxcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW1pbi1pbmxpbmVgXTogKGNsaXBNaW5JbmxpbmUgPz8gY2xpcE1pbiA/PyAxKSxcclxuICAgICAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1jbGlwLW1pbi1ibG9ja2BdOiAoY2xpcE1pbkJsb2NrID8/IGNsaXBNaW4gPz8gMCksXHJcbiAgICAgICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICB9XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcFByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+LCBcImNsaXBQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgQ2xpcCA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2ssIGNsaXBNaW4sIGNsaXBNaW5JbmxpbmUsIGNsaXBNaW5CbG9jaywgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ2xpcFByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG5cclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NsaXAoeyBjbGlwUGFyYW1ldGVyczogeyBjbGlwTWluLCBjbGlwTWluSW5saW5lLCBjbGlwTWluQmxvY2ssIGNsaXBPcmlnaW4sIGNsaXBPcmlnaW5JbmxpbmUsIGNsaXBPcmlnaW5CbG9jayB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpXHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzQ2xpcCwgVXNlQmFzZVByb3BzQ2xpcFBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jbGlwLmpzXCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VUcmFuc2l0aW9uIH0gZnJvbSBcIi4vdHJhbnNpdGlvbmFibGUuanNcIjtcclxuaW1wb3J0IHsgR2V0LCBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2UgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRFbGVtZW50UmVmIH0gZnJvbSBcIi4vdXRpbC91dGlsLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbGlwRmFkZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NsaXBQYXJhbWV0ZXJzPEU+LCBcImNsaXBQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnM8RT4sIFwiZmFkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDbGlwRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gQ2xpcEZhZGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGRlbGF5TW91bnRVbnRpbFNob3duLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGNsaXBNaW4sIGNsaXBNaW5CbG9jaywgY2xpcE1pbklubGluZSwgY2xpcE9yaWdpbiwgY2xpcE9yaWdpbkJsb2NrLCBjbGlwT3JpZ2luSW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENsaXBGYWRlUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNDbGlwKHsgY2xpcFBhcmFtZXRlcnM6IHsgY2xpcE1pbiwgY2xpcE1pbklubGluZSwgY2xpcE1pbkJsb2NrLCBjbGlwT3JpZ2luLCBjbGlwT3JpZ2luSW5saW5lLCBjbGlwT3JpZ2luQmxvY2sgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcblxyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNvbGxhcHNlIGVmZmVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuXHJcbiAgICBjb2xsYXBzZVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBzbWFsbGVzdCBzaXplIHRoZSBjb21wb25lbnQgY29sbGFwc2VzIHRvLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgbWluQmxvY2tTaXplOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNldCBvZiBwcm9wcyB0aGF0IGltcGxlbWVudCBhIFpvb20gdHJhbnNpdGlvbi4gTGlrZSBhbGwgYHVzZUNyZWF0ZSpQcm9wc2AgaG9va3MsIG11c3QgYmUgdXNlZCBpbiB0YW1kZW0gd2l0aCBhIGBUcmFuc2l0aW9uYWJsZWAgY29tcG9uZW50IChvciBgdXNlQ3JlYXRlVHJhbnNpdGlvbmFibGVQcm9wc2ApLlxyXG4gKiBCZSBzdXJlIHRvIG1lcmdlIHRoZXNlIHJldHVybmVkIHByb3BzIHdpdGggd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGluLlxyXG4gKiBcclxuICogSU1QT1JUQU5UOiBJZiB1c2VkIG91dHNpZGUgb2YgYSBgPENvbGxhcHNlIC8+YCwgeW91IG11c3QgaW5jbHVkZSB0aGUgYG1lYXN1cmVgIHByb3Agb24gdGhlIGA8VHJhbnNpdGlvbmFibGU+YCB0aGF0IHlvdSB1c2UuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZSA8VHJhbnNpdGlvbmFibGUgbWVhc3VyZSB7Li4udXNlQ3JlYXRlQ29sbGFwc2VQcm9wcyguLi4pfSAvPlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VQcm9wc0NvbGxhcHNlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGNvbGxhcHNlUGFyYW1ldGVyczogeyBtaW5CbG9ja1NpemUgfSB9OiBVc2VCYXNlUHJvcHNDb2xsYXBzZVBhcmFtZXRlcnM8RT4pIHtcclxuICAgIGNvbnN0IHsgR2V0QmFzZUNsYXNzIH0gPSB1c2VDc3NDbGFzc2VzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzTmFtZTogYCR7R2V0QmFzZUNsYXNzKCl9LWNvbGxhcHNlYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tY29sbGFwc2UtbWluLWJsb2NrYF06IG1pbkJsb2NrU2l6ZSA/PyAwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2xsYXBzZVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPiwgXCJjb2xsYXBzZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgQ29sbGFwc2UgZWZmZWN0LlxyXG4gKiBcclxuICogKkltcG9ydGFudCo6IFRoaXMgY29tcG9uZW50IGlzICpub3QqIGVmZmljaWVudCBmb3IgdGhlIGJyb3dzZXIgdG8gYW5pbWF0ZSEgXHJcbiAqIE1ha2Ugc3VyZSB5b3UgZG8gdGVzdGluZyBvbiBsb3dlciBwb3dlciBkZXZpY2VzLCBvciBwcmVmZXIgYSBsaWdodGVyXHJcbiAqIGFsdGVybmF0aXZlLCBsaWtlIGA8Q2xpcD5gLlxyXG4gKiBcclxuICogQHNlZSBgVHJhbnNpdGlvbmFibGVgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ29sbGFwc2UgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzaG93LCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkdXJhdGlvbiwgZGVsYXlNb3VudFVudGlsU2hvd24sIG1pbkJsb2NrU2l6ZSwgYW5pbWF0ZU9uTW91bnQsIGV4aXRWaXNpYmlsaXR5LCBvblZpc2liaWxpdHlDaGFuZ2UsIC4uLnJlc3QgfTogQ29sbGFwc2VQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuXHJcbiAgICByZXR1cm4gdXNlVHJhbnNpdGlvbih7XHJcbiAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgbWVhc3VyZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0NvbGxhcHNlKHsgY29sbGFwc2VQYXJhbWV0ZXJzOiB7IG1pbkJsb2NrU2l6ZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNDb2xsYXBzZSwgVXNlQmFzZVByb3BzQ29sbGFwc2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY29sbGFwc2UuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGFwc2VGYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0NvbGxhcHNlUGFyYW1ldGVyczxFPiwgXCJjb2xsYXBzZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBDb2xsYXBzZUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIENvbGxhcHNlRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgc2hvdywgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZHVyYXRpb24sIGFuaW1hdGVPbk1vdW50LCBkZWxheU1vdW50VW50aWxTaG93biwgZmFkZU1pbiwgZmFkZU1heCwgZXhpdFZpc2liaWxpdHksIG1pbkJsb2NrU2l6ZSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IENvbGxhcHNlRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3csXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgZXhpdFZpc2liaWxpdHksXHJcbiAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgcHJvcHNJbmNvbWluZzogdXNlTWVyZ2VkUHJvcHM8RT4oXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzQ29sbGFwc2UoeyBjb2xsYXBzZVBhcmFtZXRlcnM6IHsgbWluQmxvY2tTaXplIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSwgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91dGlsL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiwgdXNlTGFzdE5vbk51bGxWYWx1ZSB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgdGhhdCBhbGxvdyBhZGp1c3RpbmcgdGhlIGRpcmVjdGlvbiBhbmQgZXh0ZW50IG9mIHRoZSBmbGlwIGVmZmVjdC4gXG4gKiBWYWx1ZXMgYXJlIHJlbGF0aXZlLCB3aXRoIDEgb3IgLTEgYmVpbmcgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGF0IGRpcmVjdGlvbi5cbiAqIGAwLjVgLCBmb3IgZXhhbXBsZSwgd291bGQgZmxpcCB0byB0aGUgcmlnaHQgYnkgNTAlIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xuICAgIGZsaXBQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFyZ2V0IGFuZ2xlIChpbiBkZWdyZWVzKSB0byByb3RhdGUgdG93YXJkcyBvbiB0aGUgaW5saW5lIGF4aXMgKFggYXhpcyBmb3IgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cbiAgICAgICAgICovXG4gICAgICAgIGZsaXBBbmdsZUlubGluZTogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhcmdldCBhbmdsZSAoaW4gZGVncmVlcykgdG8gcm90YXRlIHRvd2FyZHMgb24gdGhlIGJsb2NrIGF4aXMgKFggYXhpcyBmb3IgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGVzKVxuICAgICAgICAgKiBXaGVuIDAsIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlIHdpbGwgYmUgdXNlZC4gUGFzcyBudWxsL3VuZGVmaW5lZCB0byBhY3R1YWxseSB1c2UgMC5cbiAgICAgICAgICovXG4gICAgICAgIGZsaXBBbmdsZUJsb2NrOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaW5jZSB0aGlzIGlzIGEgM0QgZWZmZWN0LCBhIHBlcnNwZWN0aXZlIHZhbHVlIGlzIG5lZWRlZC5cbiAgICAgICAgICogQGRlZmF1bHQgODAwcHhcbiAgICAgICAgICovXG4gICAgICAgIGZsaXBQZXJzcGVjdGl2ZTogc3RyaW5nIHwgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgRmxpcCB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCYXNlUHJvcHNGbGlwPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZsaXBQYXJhbWV0ZXJzOiB7IGZsaXBBbmdsZUJsb2NrLCBmbGlwQW5nbGVJbmxpbmUsIGZsaXBQZXJzcGVjdGl2ZSB9IH06IFVzZUJhc2VQcm9wc0ZsaXBQYXJhbWV0ZXJzPEU+KSB7XG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc05hbWU6IGAke0dldEJhc2VDbGFzcygpfS1mbGlwYCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1mbGlwLWFuZ2xlLWlubGluZWBdOiBgJHsodXNlTGFzdE5vbk51bGxWYWx1ZShmbGlwQW5nbGVJbmxpbmUpID8/IDApfWRlZ2AsXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tZmxpcC1hbmdsZS1ibG9ja2BdOiBgJHsodXNlTGFzdE5vbk51bGxWYWx1ZShmbGlwQW5nbGVCbG9jaykgPz8gMCl9ZGVnYCxcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1wZXJzcGVjdGl2ZWBdOiBgJHsoZmxpcFBlcnNwZWN0aXZlID8/IDgwMCl9cHhgXG4gICAgICAgIH0gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGbGlwUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZTxFPiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzRmxpcFBhcmFtZXRlcnM8RT4sIFwiZmxpcFBhcmFtZXRlcnNcIj4+IHsgfTtcblxuLyoqXG4gKiBXcmFwcyBhIGRpdiAoZXRjLikgYW5kIGFsbG93cyBpdCB0byB0cmFuc2l0aW9uIGluL291dCBzbW9vdGhseSB3aXRoIGEgRmxpcCBlZmZlY3QuXG4gKiBcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBmbGlwSW5saW5lYCBhbmQgYGZsaXBCbG9ja2AsXG4gKiB3aXRoIGAxYCBiZWluZyBgMTAwJWAgb2YgdGhlIGVsZW1lbnQncyB3aWR0aCBvciBoZWlnaHQuXG4gKiBcbiAqIEEgdmFsdWUgb2YgYDBgIGlzIGhhbmRsZWQgc3BlY2lhbGx5LCBlZmZlY3RpdmVseSBtZWFuaW5nIFwidXNlIHRoZSBsYXN0IG5vbi16ZXJvIHZhbHVlXCIsXG4gKiBleGNsdXNpdml0eUtleSBhbGxvd3MgZm9yIGNvbnZlbmllbnQgc2V0dXBzIGluc2lkZSBvZiBhIGBTd2FwQ29udGFpbmVyYCBcbiAqIChgZmxpcElubGluZT17aW5kZXggLSBzZWxlY3RlZEluZGV4fWAgb3Igc2ltaWxhci4pIFxuICogXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWBcbiAqL1xuZXhwb3J0IGNvbnN0IEZsaXAgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIEZsaXA8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgZmxpcEFuZ2xlSW5saW5lLCBmbGlwQW5nbGVCbG9jaywgZmxpcFBlcnNwZWN0aXZlLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBGbGlwUHJvcHM8RT4sIHJlZjogUmVmPEU+KSB7XG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93LFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXG4gICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBlYXNpbmdJbixcbiAgICAgICAgICAgIGVhc2luZ091dCxcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZsaXAoeyBmbGlwUGFyYW1ldGVyczogeyBmbGlwQW5nbGVCbG9jaywgZmxpcEFuZ2xlSW5saW5lLCBmbGlwUGVyc3BlY3RpdmUgfSB9KSxcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxuICAgICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XG4gICAgfSk7XG59KSk7XG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYsIHVzZUxhc3ROb25OdWxsVmFsdWUgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBkaXJlY3Rpb24gYW5kIGV4dGVudCBvZiB0aGUgc2xpZGUgZWZmZWN0LiBcclxuICogVmFsdWVzIGFyZSByZWxhdGl2ZSwgd2l0aCAxIG9yIC0xIGJlaW5nIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQgaW4gdGhhdCBkaXJlY3Rpb24uXHJcbiAqIGAwLjVgLCBmb3IgZXhhbXBsZSwgd291bGQgc2xpZGUgdG8gdGhlIHJpZ2h0IGJ5IDUwJSBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQmFzZVByb3BzQmFzZVBhcmFtZXRlcnM8RT4ge1xyXG4gICAgc2xpZGVQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byBzbGlkZSB0by9mcm9tIChYIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIFdoZW4gMCwgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWUgd2lsbCBiZSB1c2VkLiBQYXNzIG51bGwvdW5kZWZpbmVkIHRvIGFjdHVhbGx5IHVzZSAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNsaWRlVGFyZ2V0SW5saW5lOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGFyZ2V0IHBvaW50IHRvIHNsaWRlIHRvL2Zyb20gKFkgY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogV2hlbiAwLCB0aGUgbGFzdCBub24temVybyB2YWx1ZSB3aWxsIGJlIHVzZWQuIFBhc3MgbnVsbC91bmRlZmluZWQgdG8gYWN0dWFsbHkgdXNlIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2xpZGVUYXJnZXRCbG9jazogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZXQgb2YgcHJvcHMgdGhhdCBpbXBsZW1lbnQgYSBTbGlkZSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzU2xpZGU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0SW5saW5lLCBzbGlkZVRhcmdldEJsb2NrIH0gfTogVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBzbGlkZVRhcmdldElubGluZSA9IHVzZUxhc3ROb25OdWxsVmFsdWUoc2xpZGVUYXJnZXRJbmxpbmUpO1xyXG4gICAgc2xpZGVUYXJnZXRCbG9jayA9IHVzZUxhc3ROb25OdWxsVmFsdWUoc2xpZGVUYXJnZXRCbG9jayk7XHJcblxyXG4gICAgY29uc3QgeyBHZXRCYXNlQ2xhc3MgfSA9IHVzZUNzc0NsYXNzZXMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tc2xpZGVgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS1zbGlkZS10YXJnZXQtaW5saW5lYF06IGAkeyhzbGlkZVRhcmdldElubGluZSA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tc2xpZGUtdGFyZ2V0LWJsb2NrYF06IGAkeyhzbGlkZVRhcmdldEJsb2NrID8/IDApfWBcclxuICAgICAgICB9IGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVQcm9wczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNTbGlkZVBhcmFtZXRlcnM8RT4sIFwic2xpZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFNsaWRlIGVmZmVjdC5cclxuICogXHJcbiAqIFByb3ZpZGUgdGhlIGRpcmVjdGlvbiB0aGUgZWxlbWVudCB3aWxsIHRyYXZlbCBpbiB3aXRoIGBzbGlkZUlubGluZWAgYW5kIGBzbGlkZUJsb2NrYCxcclxuICogd2l0aCBgMWAgYmVpbmcgYDEwMCVgIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGggb3IgaGVpZ2h0LlxyXG4gKiBcclxuICogQSB2YWx1ZSBvZiBgMGAgaXMgaGFuZGxlZCBzcGVjaWFsbHksIGVmZmVjdGl2ZWx5IG1lYW5pbmcgXCJ1c2UgdGhlIGxhc3Qgbm9uLXplcm8gdmFsdWVcIixcclxuICogd2hpY2ggYWxsb3dzIGZvciBjb252ZW5pZW50IHNldHVwcyBpbnNpZGUgb2YgYSBgU3dhcENvbnRhaW5lcmAgXHJcbiAqIChgc2xpZGVJbmxpbmU9e2luZGV4IC0gc2VsZWN0ZWRJbmRleH1gIG9yIHNpbWlsYXIuKSBcclxuICogXHJcbiAqIEBzZWUgYFRyYW5zaXRpb25hYmxlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNsaWRlID0gbWVtbyhmb3J3YXJkRWxlbWVudFJlZihmdW5jdGlvbiBTbGlkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIG9uVmlzaWJpbGl0eUNoYW5nZSwgc2xpZGVUYXJnZXRJbmxpbmUsIHNsaWRlVGFyZ2V0QmxvY2ssIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgZGVsYXlNb3VudFVudGlsU2hvd24sIC4uLnJlc3QgfTogU2xpZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIGVhc2luZyxcclxuICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1NsaWRlKHsgc2xpZGVQYXJhbWV0ZXJzOiB7IHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9LFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUJhc2VQcm9wc0ZhZGUsIFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vZmFkZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4geyB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNsaWRlRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVGYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBTbGlkZUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNTbGlkZSh7IHNsaWRlUGFyYW1ldGVyczogeyBzbGlkZVRhcmdldEJsb2NrLCBzbGlkZVRhcmdldElubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleGNsdXNpdmVUcmFuc2l0aW9uUGFyYW1ldGVyczogeyBleGNsdXNpdml0eUtleSB9XHJcbiAgICB9KTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyB1c2VDc3NDbGFzc2VzIH0gZnJvbSBcIi4vdXRpbC9jb250ZXh0LmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlLCBVc2VCYXNlUHJvcHNCYXNlUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYWxsb3cgYWRqdXN0aW5nIHRoZSBvcmlnaW4sIG1pbmltdW0gc2l6ZSwgYW5kIGRpcmVjdGlvbiBvZiB0aGUgem9vbSBlZmZlY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUJhc2VQcm9wc0Jhc2VQYXJhbWV0ZXJzPEU+IHtcclxuICAgIHpvb21QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21PcmlnaW46IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgcG9pbnQgdG8gem9vbSBvdXQgb2YvaW50byAoWCBjb21wb25lbnQpXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU9yaWdpbklubGluZTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCBwb2ludCB0byB6b29tIG91dCBvZi9pbnRvIChZIGNvbXBvbmVudClcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tT3JpZ2luQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gc2hyaW5rIHRvL2Zyb20sIGZyb20gMCB0byAxICh3aXRoIFggJiBZIGNvbXBvbmVudHMgaWRlbnRpY2FsKS5cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgem9vbU1pbjogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSB0byBzaHJpbmsgdG8vZnJvbSwgZnJvbSAwIHRvIDEgKFggY29tcG9uZW50IGluIGhvcml6b250YWwgd3JpdGluZyBtb2RlcykuXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21NaW5JbmxpbmU6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHNpemUgdG8gc2hyaW5rIHRvL2Zyb20sIGZyb20gMCB0byAxIChZIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIHdyaXRpbmcgbW9kZXMpLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB6b29tTWluQmxvY2s6IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHByb3BzIHRoYXQgaW1wbGVtZW50IGEgWm9vbSB0cmFuc2l0aW9uLiBMaWtlIGFsbCBgdXNlQ3JlYXRlKlByb3BzYCBob29rcywgbXVzdCBiZSB1c2VkIGluIHRhbWRlbSB3aXRoIGEgYFRyYW5zaXRpb25hYmxlYCBjb21wb25lbnQgKG9yIGB1c2VDcmVhdGVUcmFuc2l0aW9uYWJsZVByb3BzYCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVByb3BzWm9vbTxFIGV4dGVuZHMgRWxlbWVudD4oeyB6b29tUGFyYW1ldGVyczogeyB6b29tT3JpZ2luLCB6b29tT3JpZ2luSW5saW5lLCB6b29tT3JpZ2luQmxvY2ssIHpvb21NaW4sIHpvb21NaW5JbmxpbmUsIHpvb21NaW5CbG9jayB9IH06IFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+KSB7XHJcbiAgICBjb25zdCB7IEdldEJhc2VDbGFzcyB9ID0gdXNlQ3NzQ2xhc3NlcygpO1xyXG4gICAgcmV0dXJuICh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBgJHtHZXRCYXNlQ2xhc3MoKX0tem9vbWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tb3JpZ2luLWlubGluZWBdOiBgJHsoem9vbU9yaWdpbklubGluZSA/PyB6b29tT3JpZ2luID8/IDAuNSl9YCxcclxuICAgICAgICAgICAgW2AtLSR7R2V0QmFzZUNsYXNzKCl9LXpvb20tb3JpZ2luLWJsb2NrYF06IGAkeyh6b29tT3JpZ2luQmxvY2sgPz8gem9vbU9yaWdpbiA/PyAwLjUpfWAsXHJcbiAgICAgICAgICAgIFtgLS0ke0dldEJhc2VDbGFzcygpfS16b29tLW1pbi1pbmxpbmVgXTogYCR7KHpvb21NaW5JbmxpbmUgPz8gem9vbU1pbiA/PyAwKX1gLFxyXG4gICAgICAgICAgICBbYC0tJHtHZXRCYXNlQ2xhc3MoKX0tem9vbS1taW4tYmxvY2tgXTogYCR7KHpvb21NaW5CbG9jayA/PyB6b29tTWluID8/IDApfWAsXHJcbiAgICAgICAgfSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9vbVByb3BzPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBkaXYgKGV0Yy4pIGFuZCBhbGxvd3MgaXQgdG8gdHJhbnNpdGlvbiBpbi9vdXQgc21vb3RobHkgd2l0aCBhIFpvb20gZWZmZWN0LlxyXG4gKiBAc2VlIGBUcmFuc2l0aW9uYWJsZWAgYFpvb21GYWRlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFpvb20gPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb208RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGR1cmF0aW9uLCBleGNsdXNpdml0eUtleSwgZWFzaW5nLCBlYXNpbmdJbiwgZWFzaW5nT3V0LCBkZWxheU1vdW50VW50aWxTaG93biwgem9vbU9yaWdpbiwgem9vbU9yaWdpbklubGluZSwgem9vbU9yaWdpbkJsb2NrLCB6b29tTWluLCB6b29tTWluSW5saW5lLCB6b29tTWluQmxvY2ssIHNob3csIGFuaW1hdGVPbk1vdW50LCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFpvb21Qcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAgICAgbWVhc3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgICAgIGVhc2luZ091dCxcclxuICAgICAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxufSkpO1xyXG5cclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNTbGlkZSwgVXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vc2xpZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlVHJhbnNpdGlvbiB9IGZyb20gXCIuL3RyYW5zaXRpb25hYmxlLmpzXCI7XHJcbmltcG9ydCB7IEdldCwgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlIH0gZnJvbSBcIi4vdXRpbC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBmb3J3YXJkRWxlbWVudFJlZiB9IGZyb20gXCIuL3V0aWwvdXRpbC5qc1wiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNab29tLCBVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVycyB9IGZyb20gXCIuL3pvb20uanNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVab29tUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNab29tUGFyYW1ldGVyczxFPiwgXCJ6b29tUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVyczxFPiwgXCJzbGlkZVBhcmFtZXRlcnNcIj4+IHsgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZVpvb20gPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFNsaWRlWm9vbTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlWm9vbVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIHVzZVRyYW5zaXRpb24oe1xyXG4gICAgICAgIHRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93LFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgIGV4aXRWaXNpYmlsaXR5LFxyXG4gICAgICAgICAgICBkZWxheU1vdW50VW50aWxTaG93bixcclxuICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgICAgIGVhc2luZ0luLFxyXG4gICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgIHByb3BzSW5jb21pbmc6IHVzZU1lcmdlZFByb3BzPEU+KFxyXG4gICAgICAgICAgICAgICAgeyByZWYsIC4uLnJlc3QgfSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnM6IHsgZXhjbHVzaXZpdHlLZXkgfVxyXG4gICAgfSk7XHJcbn0pKTtcclxuIiwiaW1wb3J0IHsgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VCYXNlUHJvcHNGYWRlLCBVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL2ZhZGUuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzU2xpZGUsIFVzZUJhc2VQcm9wc1NsaWRlUGFyYW1ldGVycyB9IGZyb20gXCIuL3NsaWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzWm9vbSwgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnMgfSBmcm9tIFwiLi96b29tLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlWm9vbUZhZGVQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBUcmFuc2l0aW9uUGFyYW1ldGVyc0Jhc2U8RT4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiwgUGFydGlhbDxHZXQ8VXNlQmFzZVByb3BzU2xpZGVQYXJhbWV0ZXJzPEU+LCBcInNsaWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc0ZhZGVQYXJhbWV0ZXJzPEU+LCBcImZhZGVQYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVab29tRmFkZSA9IG1lbW8oZm9yd2FyZEVsZW1lbnRSZWYoZnVuY3Rpb24gU2xpZGVab29tRmFkZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZHVyYXRpb24sIGV4Y2x1c2l2aXR5S2V5LCBlYXNpbmcsIGVhc2luZ0luLCBlYXNpbmdPdXQsIHpvb21NaW4sIHpvb21NaW5CbG9jaywgem9vbU1pbklubGluZSwgem9vbU9yaWdpbiwgem9vbU9yaWdpbkJsb2NrLCB6b29tT3JpZ2luSW5saW5lLCBzaG93LCBhbmltYXRlT25Nb3VudCwgZGVsYXlNb3VudFVudGlsU2hvd24sIHNsaWRlVGFyZ2V0QmxvY2ssIHNsaWRlVGFyZ2V0SW5saW5lLCBmYWRlTWF4LCBmYWRlTWluLCBleGl0VmlzaWJpbGl0eSwgb25WaXNpYmlsaXR5Q2hhbmdlLCAuLi5yZXN0IH06IFNsaWRlWm9vbUZhZGVQcm9wczxFPiwgcmVmOiBSZWY8RT4pIHtcclxuICAgIHJldHVybiB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICB0cmFuc2l0aW9uUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBtZWFzdXJlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50LFxyXG4gICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgZGVsYXlNb3VudFVudGlsU2hvd24sXHJcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZSxcclxuICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICBlYXNpbmdJbixcclxuICAgICAgICAgICAgZWFzaW5nT3V0LFxyXG4gICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgdXNlQmFzZVByb3BzU2xpZGUoeyBzbGlkZVBhcmFtZXRlcnM6IHsgc2xpZGVUYXJnZXRCbG9jaywgc2xpZGVUYXJnZXRJbmxpbmUgfSB9KSxcclxuICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc0ZhZGUoeyBmYWRlUGFyYW1ldGVyczogeyBmYWRlTWF4LCBmYWRlTWluIH0gfSksXHJcbiAgICAgICAgICAgICAgICB7IHJlZiwgLi4ucmVzdCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgIH0pO1xyXG59KSk7XHJcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzRmFkZSwgVXNlQmFzZVByb3BzRmFkZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9mYWRlLmpzXCI7XHJcbmltcG9ydCB7IHVzZVRyYW5zaXRpb24gfSBmcm9tIFwiLi90cmFuc2l0aW9uYWJsZS5qc1wiO1xyXG5pbXBvcnQgeyBHZXQsIFRyYW5zaXRpb25QYXJhbWV0ZXJzQmFzZSB9IGZyb20gXCIuL3V0aWwvdHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZEVsZW1lbnRSZWYgfSBmcm9tIFwiLi91dGlsL3V0aWwuanNcIjtcclxuaW1wb3J0IHsgdXNlQmFzZVByb3BzWm9vbSwgVXNlQmFzZVByb3BzWm9vbVBhcmFtZXRlcnMgfSBmcm9tIFwiLi96b29tLmpzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFpvb21GYWRlUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVHJhbnNpdGlvblBhcmFtZXRlcnNCYXNlPEU+LCBQYXJ0aWFsPEdldDxVc2VCYXNlUHJvcHNGYWRlUGFyYW1ldGVyczxFPiwgXCJmYWRlUGFyYW1ldGVyc1wiPj4sIFBhcnRpYWw8R2V0PFVzZUJhc2VQcm9wc1pvb21QYXJhbWV0ZXJzPEU+LCBcInpvb21QYXJhbWV0ZXJzXCI+PiB7IH07XHJcblxyXG5leHBvcnQgY29uc3QgWm9vbUZhZGUgPSBtZW1vKGZvcndhcmRFbGVtZW50UmVmKGZ1bmN0aW9uIFpvb21GYWRlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBkdXJhdGlvbiwgZXhjbHVzaXZpdHlLZXksIGVhc2luZywgZWFzaW5nSW4sIGVhc2luZ091dCwgZmFkZU1pbiwgZmFkZU1heCwgc2hvdywgYW5pbWF0ZU9uTW91bnQsIGRlbGF5TW91bnRVbnRpbFNob3duLCB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSwgZXhpdFZpc2liaWxpdHksIG9uVmlzaWJpbGl0eUNoYW5nZSwgLi4ucmVzdCB9OiBab29tRmFkZVByb3BzPEU+LCByZWY6IFJlZjxFPikge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB1c2VUcmFuc2l0aW9uKHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgICAgIG1lYXN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2hvdyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZU9uTW91bnQsXHJcbiAgICAgICAgICAgICAgICBleGl0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgICAgIGRlbGF5TW91bnRVbnRpbFNob3duLFxyXG4gICAgICAgICAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nSW4sXHJcbiAgICAgICAgICAgICAgICBlYXNpbmdPdXQsXHJcbiAgICAgICAgICAgICAgICBwcm9wc0luY29taW5nOiB1c2VNZXJnZWRQcm9wczxFPihcclxuICAgICAgICAgICAgICAgICAgICB1c2VCYXNlUHJvcHNGYWRlKHsgZmFkZVBhcmFtZXRlcnM6IHsgZmFkZU1heCwgZmFkZU1pbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2VQcm9wc1pvb20oeyB6b29tUGFyYW1ldGVyczogeyB6b29tTWluLCB6b29tTWluQmxvY2ssIHpvb21NaW5JbmxpbmUsIHpvb21PcmlnaW4sIHpvb21PcmlnaW5CbG9jaywgem9vbU9yaWdpbklubGluZSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcmVmLCAuLi5yZXN0IH0sXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4Y2x1c2l2ZVRyYW5zaXRpb25QYXJhbWV0ZXJzOiB7IGV4Y2x1c2l2aXR5S2V5IH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxufSkpO1xyXG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXREZXZUb29scygpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fUFJFQUNUX0RFVlRPT0xTX18pIHtcblx0XHR3aW5kb3cuX19QUkVBQ1RfREVWVE9PTFNfXy5hdHRhY2hQcmVhY3QoJzEwLjEyLjEnLCBvcHRpb25zLCB7XG5cdFx0XHRGcmFnbWVudCxcblx0XHRcdENvbXBvbmVudFxuXHRcdH0pO1xuXHR9XG59XG4iLCJjb25zdCBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbmxldCBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBSZXNldCB0aGUgaGlzdG9yeSBvZiB3aGljaCBwcm9wIHR5cGUgd2FybmluZ3MgaGF2ZSBiZWVuIGxvZ2dlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UHJvcFdhcm5pbmdzKCkge1xuXHRsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3Byb3AtdHlwZXMvYmxvYi9tYXN0ZXIvY2hlY2tQcm9wVHlwZXMuanNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKFxuXHR0eXBlU3BlY3MsXG5cdHZhbHVlcyxcblx0bG9jYXRpb24sXG5cdGNvbXBvbmVudE5hbWUsXG5cdGdldFN0YWNrXG4pIHtcblx0T2JqZWN0LmtleXModHlwZVNwZWNzKS5mb3JFYWNoKHR5cGVTcGVjTmFtZSA9PiB7XG5cdFx0bGV0IGVycm9yO1xuXHRcdHRyeSB7XG5cdFx0XHRlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKFxuXHRcdFx0XHR2YWx1ZXMsXG5cdFx0XHRcdHR5cGVTcGVjTmFtZSxcblx0XHRcdFx0Y29tcG9uZW50TmFtZSxcblx0XHRcdFx0bG9jYXRpb24sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdFJlYWN0UHJvcFR5cGVzU2VjcmV0XG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGVycm9yID0gZTtcblx0XHR9XG5cdFx0aWYgKGVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG5cdFx0XHRsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0YEZhaWxlZCAke2xvY2F0aW9ufSB0eXBlOiAke2Vycm9yLm1lc3NhZ2V9JHsoZ2V0U3RhY2sgJiZcblx0XHRcdFx0XHRgXFxuJHtnZXRTdGFjaygpfWApIHx8XG5cdFx0XHRcdFx0Jyd9YFxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEdldCBodW1hbiByZWFkYWJsZSBuYW1lIG9mIHRoZSBjb21wb25lbnQvZG9tIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuXHRcdHJldHVybiAnRnJhZ21lbnQnO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gdm5vZGUudHlwZS5kaXNwbGF5TmFtZSB8fCB2bm9kZS50eXBlLm5hbWU7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUudHlwZTtcblx0fVxuXG5cdHJldHVybiAnI3RleHQnO1xufVxuXG4vKipcbiAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGB2bm9kZWAgYW5kIHByaW50IGl0XG4gKiBpbiBkZWJ1ZyBtZXNzYWdlcy5cbiAqL1xubGV0IHJlbmRlclN0YWNrID0gW107XG5cbi8qKlxuICogS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lcnMuIEFuIG93bmVyIGRlc2NyaWJlcyBhIGNvbXBvbmVudFxuICogd2hpY2ggd2FzIHJlc3BvbnNpYmxlIHRvIHJlbmRlciBhIHNwZWNpZmljIGB2bm9kZWAuIFRoaXMgZXhjbHVkZVxuICogY2hpbGRyZW4gdGhhdCBhcmUgcGFzc2VkIHZpYSBgcHJvcHMuY2hpbGRyZW5gLCBiZWNhdXNlIHRoZXkgYmVsb25nXG4gKiB0byB0aGUgcGFyZW50IG93bmVyLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgRm9vID0gcHJvcHMgPT4gPGRpdj57cHJvcHMuY2hpbGRyZW59PC9kaXY+IC8vIGRpdidzIG93bmVyIGlzIEZvb1xuICogY29uc3QgQmFyID0gcHJvcHMgPT4ge1xuICogICByZXR1cm4gKFxuICogICAgIDxGb28+PHNwYW4gLz48L0Zvbz4gLy8gRm9vJ3Mgb3duZXIgaXMgQmFyLCBzcGFuJ3Mgb3duZXIgaXMgQmFyXG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGU6IEEgYHZub2RlYCBtYXkgYmUgaG9pc3RlZCB0byB0aGUgcm9vdCBzY29wZSBkdWUgdG8gY29tcGlsZXJcbiAqIG9wdGltaXp0aW9ucy4gSW4gdGhlc2UgY2FzZXMgdGhlIGBfb3duZXJgIHdpbGwgYmUgZGlmZmVyZW50LlxuICovXG5sZXQgb3duZXJTdGFjayA9IFtdO1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGB2bm9kZWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50Vk5vZGUoKSB7XG5cdHJldHVybiByZW5kZXJTdGFjay5sZW5ndGggPiAwID8gcmVuZGVyU3RhY2tbcmVuZGVyU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG4vKipcbiAqIElmIHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSBgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcmVhY3QtanN4LXNvdXJjZWBcbiAqIHNvbWV3aGVyZSBpbiBoaXMgdG9vbCBjaGFpbiB3ZSBjYW4ndCBwcmludCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZVxuICogbG9jYXRpb24gb2YgYSBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBqdXN0IG9taXQgdGhhdCwgYnV0IHdlJ2xsXG4gKiBwcmludCBhIGhlbHBmdWwgbWVzc2FnZSB0byB0aGUgY29uc29sZSwgbm90aWZ5aW5nIHRoZSB1c2VyIG9mIGl0LlxuICovXG5sZXQgaGFzQmFiZWxQbHVnaW4gPSBmYWxzZTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGB2bm9kZWAgaXMgYSBwb3NzaWJsZSBvd25lci5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGlzUG9zc2libGVPd25lcih2bm9kZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB2bm9kZS50eXBlICE9IEZyYWdtZW50O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY29tcG9uZW50IHN0YWNrIHRoYXQgd2FzIGNhcHR1cmVkIHVwIHRvIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE93bmVyU3RhY2sodm5vZGUpIHtcblx0Y29uc3Qgc3RhY2sgPSBbdm5vZGVdO1xuXHRsZXQgbmV4dCA9IHZub2RlO1xuXHR3aGlsZSAobmV4dC5fb3duZXIgIT0gbnVsbCkge1xuXHRcdHN0YWNrLnB1c2gobmV4dC5fb3duZXIpO1xuXHRcdG5leHQgPSBuZXh0Ll9vd25lcjtcblx0fVxuXG5cdHJldHVybiBzdGFjay5yZWR1Y2UoKGFjYywgb3duZXIpID0+IHtcblx0XHRhY2MgKz0gYCAgaW4gJHtnZXREaXNwbGF5TmFtZShvd25lcil9YDtcblxuXHRcdGNvbnN0IHNvdXJjZSA9IG93bmVyLl9fc291cmNlO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdGFjYyArPSBgIChhdCAke3NvdXJjZS5maWxlTmFtZX06JHtzb3VyY2UubGluZU51bWJlcn0pYDtcblx0XHR9IGVsc2UgaWYgKCFoYXNCYWJlbFBsdWdpbikge1xuXHRcdFx0aGFzQmFiZWxQbHVnaW4gPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHQnQWRkIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXJlYWN0LWpzeC1zb3VyY2UgdG8gZ2V0IGEgbW9yZSBkZXRhaWxlZCBjb21wb25lbnQgc3RhY2suIE5vdGUgdGhhdCB5b3Ugc2hvdWxkIG5vdCBhZGQgaXQgdG8gcHJvZHVjdGlvbiBidWlsZHMgb2YgeW91ciBBcHAgZm9yIGJ1bmRsZSBzaXplIHJlYXNvbnMuJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGFjYyArPSAnXFxuJyk7XG5cdH0sICcnKTtcbn1cblxuLyoqXG4gKiBTZXR1cCBjb2RlIHRvIGNhcHR1cmUgdGhlIGNvbXBvbmVudCB0cmFjZSB3aGlsZSByZW5kZXJpbmcuIE5vdGUgdGhhdFxuICogd2UgY2Fubm90IHNpbXBseSB0cmF2ZXJzZSBgdm5vZGUuX3BhcmVudGAgdXB3YXJkcywgYmVjYXVzZSB3ZSBoYXZlIHNvbWVcbiAqIGRlYnVnIG1lc3NhZ2VzIGZvciBgdGhpcy5zZXRTdGF0ZWAgd2hlcmUgdGhlIGB2bm9kZWAgaXMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENvbXBvbmVudFN0YWNrKCkge1xuXHRsZXQgb2xkRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5cdGxldCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcblx0bGV0IG9sZFJvb3QgPSBvcHRpb25zLl9yb290O1xuXHRsZXQgb2xkVk5vZGUgPSBvcHRpb25zLnZub2RlO1xuXHRsZXQgb2xkUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xuXG5cdG9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRcdGlmIChpc1Bvc3NpYmxlT3duZXIodm5vZGUpKSB7XG5cdFx0XHRvd25lclN0YWNrLnBvcCgpO1xuXHRcdH1cblx0XHRyZW5kZXJTdGFjay5wb3AoKTtcblx0XHRpZiAob2xkRGlmZmVkKSBvbGREaWZmZWQodm5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdFx0aWYgKGlzUG9zc2libGVPd25lcih2bm9kZSkpIHtcblx0XHRcdHJlbmRlclN0YWNrLnB1c2godm5vZGUpO1xuXHRcdH1cblx0XHRpZiAob2xkRGlmZikgb2xkRGlmZih2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fcm9vdCA9ICh2bm9kZSwgcGFyZW50KSA9PiB7XG5cdFx0b3duZXJTdGFjayA9IFtdO1xuXHRcdGlmIChvbGRSb290KSBvbGRSb290KHZub2RlLCBwYXJlbnQpO1xuXHR9O1xuXG5cdG9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdFx0dm5vZGUuX293bmVyID1cblx0XHRcdG93bmVyU3RhY2subGVuZ3RoID4gMCA/IG93bmVyU3RhY2tbb3duZXJTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG5cdFx0aWYgKG9sZFZOb2RlKSBvbGRWTm9kZSh2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5fcmVuZGVyID0gdm5vZGUgPT4ge1xuXHRcdGlmIChpc1Bvc3NpYmxlT3duZXIodm5vZGUpKSB7XG5cdFx0XHRvd25lclN0YWNrLnB1c2godm5vZGUpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRSZW5kZXIpIG9sZFJlbmRlcih2bm9kZSk7XG5cdH07XG59XG4iLCJpbXBvcnQgeyBjaGVja1Byb3BUeXBlcyB9IGZyb20gJy4vY2hlY2stcHJvcHMnO1xuaW1wb3J0IHsgb3B0aW9ucywgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7XG5cdEVMRU1FTlRfTk9ERSxcblx0RE9DVU1FTlRfTk9ERSxcblx0RE9DVU1FTlRfRlJBR01FTlRfTk9ERVxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuXHRnZXRPd25lclN0YWNrLFxuXHRzZXR1cENvbXBvbmVudFN0YWNrLFxuXHRnZXRDdXJyZW50Vk5vZGUsXG5cdGdldERpc3BsYXlOYW1lXG59IGZyb20gJy4vY29tcG9uZW50LXN0YWNrJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGlzV2Vha01hcFN1cHBvcnRlZCA9IHR5cGVvZiBXZWFrTWFwID09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3REb21Ob2RlUGFyZW50KHBhcmVudCkge1xuXHRpZiAoIXBhcmVudCkgcmV0dXJuIHt9O1xuXHRpZiAodHlwZW9mIHBhcmVudC50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZ2V0Q2xvc2VzdERvbU5vZGVQYXJlbnQocGFyZW50Ll9wYXJlbnQpO1xuXHR9XG5cdHJldHVybiBwYXJlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGVidWcoKSB7XG5cdHNldHVwQ29tcG9uZW50U3RhY2soKTtcblxuXHRsZXQgaG9va3NBbGxvd2VkID0gZmFsc2U7XG5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXHRsZXQgb2xkQmVmb3JlRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5cdGxldCBvbGREaWZmZWQgPSBvcHRpb25zLmRpZmZlZDtcblx0bGV0IG9sZFZub2RlID0gb3B0aW9ucy52bm9kZTtcblx0bGV0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xuXHRsZXQgb2xkUm9vdCA9IG9wdGlvbnMuX3Jvb3Q7XG5cdGxldCBvbGRIb29rID0gb3B0aW9ucy5faG9vaztcblx0Y29uc3Qgd2FybmVkQ29tcG9uZW50cyA9ICFpc1dlYWtNYXBTdXBwb3J0ZWRcblx0XHQ/IG51bGxcblx0XHQ6IHtcblx0XHRcdFx0dXNlRWZmZWN0OiBuZXcgV2Vha01hcCgpLFxuXHRcdFx0XHR1c2VMYXlvdXRFZmZlY3Q6IG5ldyBXZWFrTWFwKCksXG5cdFx0XHRcdGxhenlQcm9wVHlwZXM6IG5ldyBXZWFrTWFwKClcblx0XHQgIH07XG5cdGNvbnN0IGRlcHJlY2F0aW9ucyA9IFtdO1xuXG5cdG9wdGlvbnMuX2NhdGNoRXJyb3IgPSAoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSA9PiB7XG5cdFx0bGV0IGNvbXBvbmVudCA9IHZub2RlICYmIHZub2RlLl9jb21wb25lbnQ7XG5cdFx0aWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgZXJyb3IudGhlbiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjb25zdCBwcm9taXNlID0gZXJyb3I7XG5cdFx0XHRlcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0YE1pc3NpbmcgU3VzcGVuc2UuIFRoZSB0aHJvd2luZyBjb21wb25lbnQgd2FzOiAke2dldERpc3BsYXlOYW1lKHZub2RlKX1gXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgcGFyZW50ID0gdm5vZGU7XG5cdFx0XHRmb3IgKDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0XHRpZiAocGFyZW50Ll9jb21wb25lbnQgJiYgcGFyZW50Ll9jb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZCkge1xuXHRcdFx0XHRcdGVycm9yID0gcHJvbWlzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSBoYXZlbid0IHJlY292ZXJlZCBhbmQgd2Uga25vdyBhdCB0aGlzIHBvaW50IHRoYXQgdGhlcmUgaXMgbm9cblx0XHRcdC8vIFN1c3BlbnNlIGNvbXBvbmVudCBoaWdoZXIgdXAgaW4gdGhlIHRyZWVcblx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRlcnJvckluZm8gPSBlcnJvckluZm8gfHwge307XG5cdFx0XHRlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPSBnZXRPd25lclN0YWNrKHZub2RlKTtcblx0XHRcdG9sZENhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcblxuXHRcdFx0Ly8gd2hlbiBhbiBlcnJvciB3YXMgaGFuZGxlZCBieSBhbiBFcnJvckJvdW5kYXJ5IHdlIHdpbGwgbm9uZXRoZWxlc3MgZW1pdCBhbiBlcnJvclxuXHRcdFx0Ly8gZXZlbnQgb24gdGhlIHdpbmRvdyBvYmplY3QuIFRoaXMgaXMgdG8gbWFrZSB1cCBmb3IgcmVhY3QgY29tcGF0aWJpbGl0eSBpbiBkZXYgbW9kZVxuXHRcdFx0Ly8gYW5kIHRodXMgbWFrZSB0aGUgTmV4dC5qcyBkZXYgb3ZlcmxheSB3b3JrLlxuXHRcdFx0aWYgKHR5cGVvZiBlcnJvci50aGVuICE9ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9O1xuXG5cdG9wdGlvbnMuX3Jvb3QgPSAodm5vZGUsIHBhcmVudE5vZGUpID0+IHtcblx0XHRpZiAoIXBhcmVudE5vZGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J1VuZGVmaW5lZCBwYXJlbnQgcGFzc2VkIHRvIHJlbmRlcigpLCB0aGlzIGlzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuJyArXG5cdFx0XHRcdFx0J0NoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGF2YWlsYWJsZSBpbiB0aGUgRE9NL2hhcyB0aGUgY29ycmVjdCBpZC4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBpc1ZhbGlkO1xuXHRcdHN3aXRjaCAocGFyZW50Tm9kZS5ub2RlVHlwZSkge1xuXHRcdFx0Y2FzZSBFTEVNRU5UX05PREU6XG5cdFx0XHRjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG5cdFx0XHRjYXNlIERPQ1VNRU5UX05PREU6XG5cdFx0XHRcdGlzVmFsaWQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzVmFsaWQpIHtcblx0XHRcdGxldCBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWUodm5vZGUpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgRXhwZWN0ZWQgYSB2YWxpZCBIVE1MIG5vZGUgYXMgYSBzZWNvbmQgYXJndW1lbnQgdG8gcmVuZGVyLlx0UmVjZWl2ZWQgJHtwYXJlbnROb2RlfSBpbnN0ZWFkOiByZW5kZXIoPCR7Y29tcG9uZW50TmFtZX0gLz4sICR7cGFyZW50Tm9kZX0pO2Bcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFJvb3QpIG9sZFJvb3Qodm5vZGUsIHBhcmVudE5vZGUpO1xuXHR9O1xuXG5cdG9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdFx0bGV0IHsgdHlwZSwgX3BhcmVudDogcGFyZW50IH0gPSB2bm9kZTtcblx0XHRsZXQgcGFyZW50Vk5vZGUgPSBnZXRDbG9zZXN0RG9tTm9kZVBhcmVudChwYXJlbnQpO1xuXG5cdFx0aG9va3NBbGxvd2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J1VuZGVmaW5lZCBjb21wb25lbnQgcGFzc2VkIHRvIGNyZWF0ZUVsZW1lbnQoKVxcblxcbicgK1xuXHRcdFx0XHRcdCdZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgb3IgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzJyArXG5cdFx0XHRcdFx0c2VyaWFsaXplVk5vZGUodm5vZGUpICtcblx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSAhPSBudWxsICYmIHR5cGVvZiB0eXBlID09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAodHlwZS5fY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlLl9kb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0YEludmFsaWQgdHlwZSBwYXNzZWQgdG8gY3JlYXRlRWxlbWVudCgpOiAke3R5cGV9XFxuXFxuYCArXG5cdFx0XHRcdFx0XHQnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIEpTWCBsaXRlcmFsIGFzIEpTWCB0d2ljZT9cXG5cXG4nICtcblx0XHRcdFx0XHRcdGAgIGxldCBNeSR7Z2V0RGlzcGxheU5hbWUodm5vZGUpfSA9ICR7c2VyaWFsaXplVk5vZGUodHlwZSl9O1xcbmAgK1xuXHRcdFx0XHRcdFx0YCAgbGV0IHZub2RlID0gPE15JHtnZXREaXNwbGF5TmFtZSh2bm9kZSl9IC8+O1xcblxcbmAgK1xuXHRcdFx0XHRcdFx0J1RoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4geW91IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGFuZCBub3QgdGhlIGNvbXBvbmVudC4nICtcblx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnSW52YWxpZCB0eXBlIHBhc3NlZCB0byBjcmVhdGVFbGVtZW50KCk6ICcgK1xuXHRcdFx0XHRcdChBcnJheS5pc0FycmF5KHR5cGUpID8gJ2FycmF5JyA6IHR5cGUpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCh0eXBlID09PSAndGhlYWQnIHx8IHR5cGUgPT09ICd0Zm9vdCcgfHwgdHlwZSA9PT0gJ3Rib2R5JykgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0YWJsZSdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0aGVhZC90Ym9keS90Zm9vdD4gc2hvdWxkIGhhdmUgYSA8dGFibGU+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHR5cGUgPT09ICd0cicgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0aGVhZCcgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0Zm9vdCcgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0Ym9keScgJiZcblx0XHRcdHBhcmVudFZOb2RlLnR5cGUgIT09ICd0YWJsZSdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0cj4gc2hvdWxkIGhhdmUgYSA8dGhlYWQvdGJvZHkvdGZvb3QvdGFibGU+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndGQnICYmIHBhcmVudFZOb2RlLnR5cGUgIT09ICd0cicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0ZD4gc2hvdWxkIGhhdmUgYSA8dHI+IHBhcmVudC4nICtcblx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndGgnICYmIHBhcmVudFZOb2RlLnR5cGUgIT09ICd0cicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdJbXByb3BlciBuZXN0aW5nIG9mIHRhYmxlLiBZb3VyIDx0aD4gc2hvdWxkIGhhdmUgYSA8dHI+LicgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHR2bm9kZS5yZWYgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0dHlwZW9mIHZub2RlLnJlZiAhPSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2Ygdm5vZGUucmVmICE9ICdvYmplY3QnICYmXG5cdFx0XHQhKCckJHR5cGVvZicgaW4gdm5vZGUpIC8vIGFsbG93IHN0cmluZyByZWZzIHdoZW4gcHJlYWN0LWNvbXBhdCBpcyBpbnN0YWxsZWRcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENvbXBvbmVudCdzIFwicmVmXCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgZnVuY3Rpb24sIG9yIGFuIG9iamVjdCBjcmVhdGVkIGAgK1xuXHRcdFx0XHRcdGBieSBjcmVhdGVSZWYoKSwgYnV0IGdvdCBbJHt0eXBlb2Ygdm5vZGUucmVmfV0gaW5zdGVhZFxcbmAgK1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0YFxcblxcbiR7Z2V0T3duZXJTdGFjayh2bm9kZSl9YFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ3N0cmluZycpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHZub2RlLnByb3BzKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRrZXlbMF0gPT09ICdvJyAmJlxuXHRcdFx0XHRcdGtleVsxXSA9PT0gJ24nICYmXG5cdFx0XHRcdFx0dHlwZW9mIHZub2RlLnByb3BzW2tleV0gIT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRcdHZub2RlLnByb3BzW2tleV0gIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRgQ29tcG9uZW50J3MgXCIke2tleX1cIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgYCArXG5cdFx0XHRcdFx0XHRcdGBidXQgZ290IFske3R5cGVvZiB2bm9kZS5wcm9wc1trZXldfV0gaW5zdGVhZFxcbmAgK1xuXHRcdFx0XHRcdFx0XHRzZXJpYWxpemVWTm9kZSh2bm9kZSkgK1xuXHRcdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIHByb3AtdHlwZXMgaWYgYXZhaWxhYmxlXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgJiYgdm5vZGUudHlwZS5wcm9wVHlwZXMpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dm5vZGUudHlwZS5kaXNwbGF5TmFtZSA9PT0gJ0xhenknICYmXG5cdFx0XHRcdHdhcm5lZENvbXBvbmVudHMgJiZcblx0XHRcdFx0IXdhcm5lZENvbXBvbmVudHMubGF6eVByb3BUeXBlcy5oYXModm5vZGUudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBtID1cblx0XHRcdFx0XHQnUHJvcFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGxhenkoKS4gVXNlIHByb3BUeXBlcyBvbiB0aGUgd3JhcHBlZCBjb21wb25lbnQgaXRzZWxmLiAnO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGxhenlWTm9kZSA9IHZub2RlLnR5cGUoKTtcblx0XHRcdFx0XHR3YXJuZWRDb21wb25lbnRzLmxhenlQcm9wVHlwZXMuc2V0KHZub2RlLnR5cGUsIHRydWUpO1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdG0gKyBgQ29tcG9uZW50IHdyYXBwZWQgaW4gbGF6eSgpIGlzICR7Z2V0RGlzcGxheU5hbWUobGF6eVZOb2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBjYXRjaCAocHJvbWlzZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdG0gKyBcIldlIHdpbGwgbG9nIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIG5hbWUgb25jZSBpdCBpcyBsb2FkZWQuXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCB2YWx1ZXMgPSB2bm9kZS5wcm9wcztcblx0XHRcdGlmICh2bm9kZS50eXBlLl9mb3J3YXJkZWQpIHtcblx0XHRcdFx0dmFsdWVzID0gYXNzaWduKHt9LCB2YWx1ZXMpO1xuXHRcdFx0XHRkZWxldGUgdmFsdWVzLnJlZjtcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tQcm9wVHlwZXMoXG5cdFx0XHRcdHZub2RlLnR5cGUucHJvcFR5cGVzLFxuXHRcdFx0XHR2YWx1ZXMsXG5cdFx0XHRcdCdwcm9wJyxcblx0XHRcdFx0Z2V0RGlzcGxheU5hbWUodm5vZGUpLFxuXHRcdFx0XHQoKSA9PiBnZXRPd25lclN0YWNrKHZub2RlKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG5cdH07XG5cblx0b3B0aW9ucy5faG9vayA9IChjb21wLCBpbmRleCwgdHlwZSkgPT4ge1xuXHRcdGlmICghY29tcCB8fCAhaG9va3NBbGxvd2VkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hvb2sgY2FuIG9ubHkgYmUgaW52b2tlZCBmcm9tIHJlbmRlciBtZXRob2RzLicpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRIb29rKSBvbGRIb29rKGNvbXAsIGluZGV4LCB0eXBlKTtcblx0fTtcblxuXHQvLyBJZGVhbGx5IHdlJ2Qgd2FudCB0byBwcmludCBhIHdhcm5pbmcgb25jZSBwZXIgY29tcG9uZW50LCBidXQgd2Vcblx0Ly8gZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIHZub2RlIHRoYXQgdHJpZ2dlcmVkIGl0IGhlcmUuIEFzIGFcblx0Ly8gY29tcHJvbWlzZSBhbmQgdG8gYXZvaWQgZmxvb2RpbmcgdGhlIGNvbnNvbGUgd2l0aCB3YXJuaW5ncyB3ZVxuXHQvLyBwcmludCBlYWNoIGRlcHJlY2F0aW9uIHdhcm5pbmcgb25seSBvbmNlLlxuXHRjb25zdCB3YXJuID0gKHByb3BlcnR5LCBtZXNzYWdlKSA9PiAoe1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGtleSA9ICdnZXQnICsgcHJvcGVydHkgKyBtZXNzYWdlO1xuXHRcdFx0aWYgKGRlcHJlY2F0aW9ucyAmJiBkZXByZWNhdGlvbnMuaW5kZXhPZihrZXkpIDwgMCkge1xuXHRcdFx0XHRkZXByZWNhdGlvbnMucHVzaChrZXkpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYGdldHRpbmcgdm5vZGUuJHtwcm9wZXJ0eX0gaXMgZGVwcmVjYXRlZCwgJHttZXNzYWdlfWApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2V0KCkge1xuXHRcdFx0Y29uc3Qga2V5ID0gJ3NldCcgKyBwcm9wZXJ0eSArIG1lc3NhZ2U7XG5cdFx0XHRpZiAoZGVwcmVjYXRpb25zICYmIGRlcHJlY2F0aW9ucy5pbmRleE9mKGtleSkgPCAwKSB7XG5cdFx0XHRcdGRlcHJlY2F0aW9ucy5wdXNoKGtleSk7XG5cdFx0XHRcdGNvbnNvbGUud2Fybihgc2V0dGluZyB2bm9kZS4ke3Byb3BlcnR5fSBpcyBub3QgYWxsb3dlZCwgJHttZXNzYWdlfWApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Y29uc3QgZGVwcmVjYXRlZEF0dHJpYnV0ZXMgPSB7XG5cdFx0bm9kZU5hbWU6IHdhcm4oJ25vZGVOYW1lJywgJ3VzZSB2bm9kZS50eXBlJyksXG5cdFx0YXR0cmlidXRlczogd2FybignYXR0cmlidXRlcycsICd1c2Ugdm5vZGUucHJvcHMnKSxcblx0XHRjaGlsZHJlbjogd2FybignY2hpbGRyZW4nLCAndXNlIHZub2RlLnByb3BzLmNoaWxkcmVuJylcblx0fTtcblxuXHRjb25zdCBkZXByZWNhdGVkUHJvdG8gPSBPYmplY3QuY3JlYXRlKHt9LCBkZXByZWNhdGVkQXR0cmlidXRlcyk7XG5cblx0b3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0XHRjb25zdCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRcdGlmIChcblx0XHRcdHZub2RlLnR5cGUgIT09IG51bGwgJiZcblx0XHRcdHByb3BzICE9IG51bGwgJiZcblx0XHRcdCgnX19zb3VyY2UnIGluIHByb3BzIHx8ICdfX3NlbGYnIGluIHByb3BzKVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgbmV3UHJvcHMgPSAodm5vZGUucHJvcHMgPSB7fSk7XG5cdFx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRcdGNvbnN0IHYgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKGkgPT09ICdfX3NvdXJjZScpIHZub2RlLl9fc291cmNlID0gdjtcblx0XHRcdFx0ZWxzZSBpZiAoaSA9PT0gJ19fc2VsZicpIHZub2RlLl9fc2VsZiA9IHY7XG5cdFx0XHRcdGVsc2UgbmV3UHJvcHNbaV0gPSB2O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXHRcdHZub2RlLl9fcHJvdG9fXyA9IGRlcHJlY2F0ZWRQcm90bztcblx0XHRpZiAob2xkVm5vZGUpIG9sZFZub2RlKHZub2RlKTtcblx0fTtcblxuXHRvcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdXNlciBwYXNzZWQgcGxhaW4gb2JqZWN0cyBhcyBjaGlsZHJlbi4gTm90ZSB0aGF0IHdlIGNhbm5vdFxuXHRcdC8vIG1vdmUgdGhpcyBjaGVjayBpbnRvIGBvcHRpb25zLnZub2RlYCBiZWNhdXNlIGNvbXBvbmVudHMgY2FuIHJlY2VpdmVcblx0XHQvLyBjaGlsZHJlbiBpbiBhbnkgc2hhcGUgdGhleSB3YW50IChlLmcuXG5cdFx0Ly8gYDxNeUpTT05Gb3JtYXR0ZXI+e3sgZm9vOiAxMjMsIGJhcjogXCJhYmNcIiB9fTwvTXlKU09ORm9ybWF0dGVyPmApLlxuXHRcdC8vIFB1dHRpbmcgdGhpcyBjaGVjayBpbiBgb3B0aW9ucy5kaWZmZWRgIGVuc3VyZXMgdGhhdFxuXHRcdC8vIGB2bm9kZS5fY2hpbGRyZW5gIGlzIHNldCBhbmQgdGhhdCB3ZSBvbmx5IHZhbGlkYXRlIHRoZSBjaGlsZHJlblxuXHRcdC8vIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZC5cblx0XHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkICYmIGNoaWxkLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGlsZCkuam9pbignLCcpO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdGBPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBjaGlsZC4gRW5jb3VudGVyZWQgYW4gb2JqZWN0IHdpdGggdGhlIGtleXMgeyR7a2V5c319LmAgK1xuXHRcdFx0XHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHZub2RlKX1gXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aG9va3NBbGxvd2VkID0gZmFsc2U7XG5cblx0XHRpZiAob2xkRGlmZmVkKSBvbGREaWZmZWQodm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRjb25zdCBrZXlzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgPT0gbnVsbCkgY29udGludWU7XG5cblx0XHRcdFx0Y29uc3Qga2V5ID0gY2hpbGQua2V5O1xuXHRcdFx0XHRpZiAoa2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XHRcdCdGb2xsb3dpbmcgY29tcG9uZW50IGhhcyB0d28gb3IgbW9yZSBjaGlsZHJlbiB3aXRoIHRoZSAnICtcblx0XHRcdFx0XHRcdFx0YHNhbWUga2V5IGF0dHJpYnV0ZTogXCIke2tleX1cIi4gVGhpcyBtYXkgY2F1c2UgZ2xpdGNoZXMgYW5kIG1pc2JlaGF2aW9yIGAgK1xuXHRcdFx0XHRcdFx0XHQnaW4gcmVuZGVyaW5nIHByb2Nlc3MuIENvbXBvbmVudDogXFxuXFxuJyArXG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZVZOb2RlKHZub2RlKSArXG5cdFx0XHRcdFx0XHRcdGBcXG5cXG4ke2dldE93bmVyU3RhY2sodm5vZGUpfWBcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gQnJlYWsgZWFybHkgdG8gbm90IHNwYW0gdGhlIGNvbnNvbGVcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuY29uc3Qgc2V0U3RhdGUgPSBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlO1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlID09IG51bGwpIHtcblx0XHQvLyBgdGhpcy5fdm5vZGVgIHdpbGwgYmUgYG51bGxgIGR1cmluZyBjb21wb25lbnRXaWxsTW91bnQuIEJ1dCBpdFxuXHRcdC8vIGlzIHBlcmZlY3RseSB2YWxpZCB0byBjYWxsIGBzZXRTdGF0ZWAgZHVyaW5nIGNXTS4gU28gd2Vcblx0XHQvLyBuZWVkIGFuIGFkZGl0aW9uYWwgY2hlY2sgdG8gdmVyaWZ5IHRoYXQgd2UgYXJlIGRlYWxpbmcgd2l0aCBhXG5cdFx0Ly8gY2FsbCBpbnNpZGUgY29uc3RydWN0b3IuXG5cdFx0aWYgKHRoaXMuc3RhdGUgPT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRgQ2FsbGluZyBcInRoaXMuc2V0U3RhdGVcIiBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGEgY29tcG9uZW50IGlzIGEgYCArXG5cdFx0XHRcdFx0YG5vLW9wIGFuZCBtaWdodCBiZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiBJbnN0ZWFkLCBzZXQgYCArXG5cdFx0XHRcdFx0YFwidGhpcy5zdGF0ZSA9IHt9XCIgZGlyZWN0bHkuXFxuXFxuJHtnZXRPd25lclN0YWNrKGdldEN1cnJlbnRWTm9kZSgpKX1gXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzZXRTdGF0ZS5jYWxsKHRoaXMsIHVwZGF0ZSwgY2FsbGJhY2spO1xufTtcblxuY29uc3QgZm9yY2VVcGRhdGUgPSBDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlO1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSA9PSBudWxsKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YENhbGxpbmcgXCJ0aGlzLmZvcmNlVXBkYXRlXCIgaW5zaWRlIHRoZSBjb25zdHJ1Y3RvciBvZiBhIGNvbXBvbmVudCBpcyBhIGAgK1xuXHRcdFx0XHRgbm8tb3AgYW5kIG1pZ2h0IGJlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uXFxuXFxuJHtnZXRPd25lclN0YWNrKFxuXHRcdFx0XHRcdGdldEN1cnJlbnRWTm9kZSgpXG5cdFx0XHRcdCl9YFxuXHRcdCk7XG5cdH0gZWxzZSBpZiAodGhpcy5fcGFyZW50RG9tID09IG51bGwpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgQ2FuJ3QgY2FsbCBcInRoaXMuZm9yY2VVcGRhdGVcIiBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIGlzIGEgbm8tb3AsIGAgK1xuXHRcdFx0XHRgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvIGZpeCwgY2FuY2VsIGFsbCBgICtcblx0XHRcdFx0YHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiB0aGUgY29tcG9uZW50V2lsbFVubW91bnQgbWV0aG9kLmAgK1xuXHRcdFx0XHRgXFxuXFxuJHtnZXRPd25lclN0YWNrKHRoaXMuX3Zub2RlKX1gXG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gZm9yY2VVcGRhdGUuY2FsbCh0aGlzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIHZub2RlIHRyZWUgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplVk5vZGUodm5vZGUpIHtcblx0bGV0IHsgcHJvcHMgfSA9IHZub2RlO1xuXHRsZXQgbmFtZSA9IGdldERpc3BsYXlOYW1lKHZub2RlKTtcblxuXHRsZXQgYXR0cnMgPSAnJztcblx0Zm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuXHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm9wICE9PSAnY2hpbGRyZW4nKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wc1twcm9wXTtcblxuXHRcdFx0Ly8gSWYgaXQgaXMgYW4gb2JqZWN0IGJ1dCBkb2Vzbid0IGhhdmUgdG9TdHJpbmcoKSwgdXNlIE9iamVjdC50b1N0cmluZ1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHZhbHVlID0gYGZ1bmN0aW9uICR7dmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZX0oKSB7fWA7XG5cdFx0XHR9XG5cblx0XHRcdHZhbHVlID1cblx0XHRcdFx0T2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUgJiYgIXZhbHVlLnRvU3RyaW5nXG5cdFx0XHRcdFx0PyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG5cdFx0XHRcdFx0OiB2YWx1ZSArICcnO1xuXG5cdFx0XHRhdHRycyArPSBgICR7cHJvcH09JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcblx0XHR9XG5cdH1cblxuXHRsZXQgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblx0cmV0dXJuIGA8JHtuYW1lfSR7YXR0cnN9JHtcblx0XHRjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPyAnPi4uPC8nICsgbmFtZSArICc+JyA6ICcgLz4nXG5cdH1gO1xufVxuIiwiZXhwb3J0IGNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XG5leHBvcnQgY29uc3QgRE9DVU1FTlRfTk9ERSA9IDk7XG5leHBvcnQgY29uc3QgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuIiwiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuIiwiaW1wb3J0IHsgaW5pdERlYnVnIH0gZnJvbSAnLi9kZWJ1Zyc7XG5pbXBvcnQgJ3ByZWFjdC9kZXZ0b29scyc7XG5cbmluaXREZWJ1ZygpO1xuXG5leHBvcnQgeyByZXNldFByb3BXYXJuaW5ncyB9IGZyb20gJy4vY2hlY2stcHJvcHMnO1xuIiwiaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZWxhdGl2ZWx5IGxvdy1sZXZlbCBob29rIHRoYXQgYWxsb3dzIHlvdSB0byBpbnNwZWN0XG4gKiB3aGVuIHRoZSBlbnRpcmUgVVJMIGNoYW5nZXMsIGVpdGhlciBiZWNhdXNlIHRoZSBoYXNoIGNoYW5nZWQsXG4gKiBvciBiZWNhdXNlIHRoZSBCYWNrL0ZvcndhcmQgYnJvd3NlciBidXR0b25zIHdlcmUgcHJlc3NlZC5cbiAqIFxuICogKENoYW5naW5nIHF1ZXJ5IHBhcmFtZXRlcnMgcmVsb2FkcyB0aGUgcGFnZSBhbmQgc28gaXNuJ3RcbiAqIHRyYWNrZWQsIHVubGVzcyBvZiBjb3Vyc2UgaXQncyBiZWNhdXNlIG9mIHRoZSBicm93c2VyXG4gKiBuYXZpZ2F0aW5nIGJhY2svZm9yd2FyZHMpLlxuICogXG4gKiBJbiBnZW5lcmFsLCB5b3UnbGwgd2FudCB0byBpbnNwZWN0IGEgc3BlY2lmaWMgZGlyZWN0b3J5IG9mXG4gKiBhIHBhdGgsIG9yIGEgc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyIHZhbHVlLCBub3QgdGhlXG4gKiBlbnRpcmUgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVXJsKG9uVXJsQ2hhbmdlOiAodXJsOiBzdHJpbmcpID0+IHZvaWQpIHtcblxuICAgIGNvbnN0IFtnZXRVcmwsIHNldFVybF0gPSB1c2VQYXNzaXZlU3RhdGU8c3RyaW5nLCBuZXZlcj4odXNlU3RhYmxlQ2FsbGJhY2sob25VcmxDaGFuZ2UpLCB1c2VDYWxsYmFjaygoKSA9PiB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSwgW10pKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcImhhc2hjaGFuZ2VcIiwgZSA9PiB7XG4gICAgICAgIHNldFVybCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgfSk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKHdpbmRvdywgXCJwb3BzdGF0ZVwiLCAoZTogUG9wU3RhdGVFdmVudCkgPT4ge1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3BvcHN0YXRlX2V2ZW50I3RoZV9oaXN0b3J5X3N0YWNrXG4gICAgICAgIC8vIFRPRE86IElmIHRoaXMgYXNzZXJ0IG5ldmVyIGZpcmVzLCBpdCdzICpwcm9iYWJseSogZmluZT8/XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpID09PSBkb2N1bWVudC5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICAgICAgc2V0VXJsKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBbZ2V0VXJsLCBzZXRVcmxdIGFzIGNvbnN0O1xufVxuXG5cbiIsImltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuXG5cbi8vZXhwb3J0IGNvbnN0IFJvdXRlckxldmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIHRvIHRyaW0gdGhlIGNydXN0cyBvZmYgb2YgYSBoYXNoIHBhdGguXG4gKiBAcGFyYW0gaGFzaCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUhhc2goaGFzaDogc3RyaW5nKSB7XG4gICAgaWYgKGhhc2guc3RhcnRzV2l0aChcIiNcIikpXG4gICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cigxKTtcbiAgICBpZiAoaGFzaC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDEpO1xuICAgIGlmIChoYXNoLmVuZHNXaXRoKFwiL1wiKSlcbiAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDAsIGhhc2gubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIYXNoVG9QYXRoKGhhc2g6IHN0cmluZykge1xuICAgIGhhc2ggPSB0cmltSGFzaChoYXNoKTtcbiAgICByZXR1cm4gaGFzaC5zcGxpdChcIi9cIik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZU1hcCB7XG4gICAgXCJiaWdpbnRcIjogYmlnaW50O1xuICAgIFwibnVtYmVyXCI6IG51bWJlcjtcbiAgICBcInN0cmluZ1wiOiBzdHJpbmc7XG4gICAgXCJib29sZWFuXCI6IGJvb2xlYW47XG4gICAgXCJ1bmtub3duXCI6IHVua25vd247XG59XG5cbi8vIE5vdCBwdWJsaWMgLS0ganVzdCBjb250YWlucyBzaGFyZWQgY29kZSBmb3IgaGlzdG9yeSBtb2RpZmljYXRpb24uXG4vLyBUaGlzIGlzIHdoYXQgYWN0dWFsbHkgY2hhbmdlcyBIaXN0b3J5IGFuZCB1cGRhdGVzIHRoZSB3aW5kb3cncyBVUkwuXG5leHBvcnQgZnVuY3Rpb24gc2V0RW50aXJlSGFzaChoYXNoOiBzdHJpbmcsIGFjdGlvbjogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikge1xuICAgIGFjdGlvbiA/Pz0gXCJwdXNoXCI7XG4gICAgaGFzaCA9IHRyaW1IYXNoKGhhc2gpO1xuICAgIGxldCBvbGRVUkwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtcbiAgICBsZXQgbmV4dFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgIG5leHRVcmwuaGFzaCA9IGAjJHtoYXNofWA7XG5cbiAgICBoaXN0b3J5W2Ake2FjdGlvbn1TdGF0ZWBdKHt9LCBkb2N1bWVudC50aXRsZSwgbmV4dFVybCk7XG5cbiAgICAvLyBNb2RpZnlpbmcgaGlzdG9yeSBkb2Vzbid0IGFjdHVhbGx5IGNhdXNlIGEgaGFzaGNoYW5nZSBldmVudC5cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgSGFzaENoYW5nZUV2ZW50KCdoYXNoY2hhbmdlJywgeyBvbGRVUkwsIG5ld1VSTDogbmV4dFVybC50b1N0cmluZygpIH0pKTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgZ2l2ZW4gU2VhcmNoIFBhcmFtcyBvYmplY3QgdG8gaGF2ZSBpdHMga2V5IGJlIHNldCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKiBcbiAqIFNwZWNpZmljYWxseSBmb3IgYm9vbGVhbiB0eXBlcyB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgcGFyYW0gaXMgc2ltcGx5IGV4aXN0YW50L25vbi1leGlzdGFudCxcbiAqIGJ1dCBmb3Igb3RoZXIgdHlwZXMgdGhpcyBpcyBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLlxuICogQHBhcmFtIHBhcmFtcyBcbiAqIEBwYXJhbSBrZXkgXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcGFyYW0gdHlwZSBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFyc2VQYXJhbTxUIGV4dGVuZHMgXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCI+KHBhcmFtczogVVJMU2VhcmNoUGFyYW1zLCBrZXk6IHN0cmluZywgdmFsdWU6IFR5cGVNYXBbVF0sIHR5cGU6IFQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCBgJHt2YWx1ZX1gKTtcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSByZXF1ZXN0ZWQgU2VhcmNoIFBhcmFtIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAqIFxuICogVGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHBhcnNlZCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGJvb2xlYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhcmFtPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4odXJsOiBVUkwsIGtleTogc3RyaW5nLCB0eXBlOiBUKTogVHlwZU1hcFtUXSB8IG51bGwge1xuICAgIGxldCB2YWx1ZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBhcyBUeXBlTWFwW1RdKSA/PyBudWxsO1xuXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpIGFzIFR5cGVNYXBbVF07XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUocGFyc2VkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkIGFzIFR5cGVNYXBbVF07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgYXMgVHlwZU1hcFtUXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSBhcyBUeXBlTWFwW1RdID8/IG51bGw7XG59XG5cblxuZXhwb3J0IHR5cGUgUm91dGVyUGF0aFR5cGUgPSBudWxsIHwgc3RyaW5nIHwgUmVnRXhwIHwgKChsb2NhbFBhdGg6IHN0cmluZykgPT4gYm9vbGVhbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyQ29udHJvbHMge1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBkaXJlY3RvcnkgYXQgdGhlIGN1cnJlbnQgbGV2ZWwgdG8gYGRpcmAuXG4gICAgICogXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBjbG9zZXIgdG8gdGhlIHJvb3QgYXJlIG5vdCBhZmZlY3RlZC4gIFxuICAgICAqICogRGlyZWN0b3JpZXMgb24gdGhlIHNpZGUgZmFydGhlciBmcm9tIHRoZSByb290IGFyZSBkZWxldGVkIHVubGVzcyByZXF1ZXN0ZWQgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNldExvY2FsUGF0aChkaXI6IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBHbyBvbmUgbGV2ZWwgZGVlcGVyIGludG8gdGhpcyBkaXJlY3RvcnkgYnkgYXBwZW5kaW5nIGAvZGlyYCB0byBpdC5cbiAgICAgKiBcbiAgICAgKiAqIFRoZSBjdXJyZW50IGRpcmVjdG9yeSBpcyBub3QgYWZmZWN0ZWRcbiAgICAgKiAqIERpcmVjdG9yaWVzIG9uIHRoZSBzaWRlIGNsb3NlciB0byB0aGUgcm9vdCBhcmUgbm90IGFmZmVjdGVkLiAgXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBmYXJ0aGVyIGZyb20gdGhlIHJvb3QgYXJlIGRlbGV0ZWQgdW5sZXNzIHJlcXVlc3RlZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVzaExvY2FsUGF0aChkaXI6IHN0cmluZywgYWN0aW9uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiwga2VlcFRyYWlsaW5nPzogYm9vbGVhbik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBHbyBiYWNrIG9uZSBsZXZlbCBieSBzZXR0aW5nIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB0byBlbXB0eSBhbmQsIG9wdGlvbmFsbHksIGNoYW5naW5nIHRoZSBwYXJlbnQgZGlyZWN0b3J5IHRvIGBkaXJgIGFzIHdlbGwuXG4gICAgICogXG4gICAgICogKiBUaGUgY3VycmVudCBkaXJlY3RvcnkgaXMgc2V0IHRvIGVtcHR5XG4gICAgICogKiBBbGwgZGlyZWN0b3JpZXMgYWZ0ZXIgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LCBpZiBhbnksIGFyZSBlbXB0aWVkLlxuICAgICAqICogSWYgcHJvdmlkZWQsIHRoZSBwYXJlbnQgZGlyZWN0b3J5IHRvIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBpcyBzZXQgdG8gYGRpcmAuXG4gICAgICogKiBEaXJlY3RvcmllcyBvbiB0aGUgc2lkZSBjbG9zZXIgdG8gdGhlIHJvb3QgYXJlIG5vdCBhZmZlY3RlZFxuICAgICAqL1xuICAgIHBvcExvY2FsUGF0aChkaXI/OiBzdHJpbmcsIGFjdGlvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpOiB2b2lkO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyQ2hpbGRJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxzdHJpbmc+IHtcbiAgICBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoYW55TWF0Y2hlczogYm9vbGVhbik6IHZvaWQ7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250ZXh0VHlwZSBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgcm91dGVyQ29udGV4dDoge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBsZXZlbCB0aGUgY2hpbGQgc2hvdWxkIGNvbnNpZGVyIGl0c2VsZiBhcy0tXG4gICAgICAgIC8vIGNoaWxkcmVuIG5lZWQgdGhpcyB0byBrbm93IHdoYXQgcGFydCBvZiB0aGUgVVJMIHRvIHBhcnNlXG4gICAgICAgIC8vIGFuZCBhbHNvIHRvIGluZm9ybSAqdGhlaXIqIGNoaWxkcmVuIHdoYXQgbGV2ZWwgdGhleSBhcmVcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBpbiBvcmRlciB0byBmYWNpbGl0YXRlIHNob3dpbmcgdGhlIGRlZmF1bHQgY2hpbGQgd2hlbiBubyBub24tZGVmYXVsdCBjaGlsZHJlbiBhcmUgYmVpbmcgc2hvd24uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggXG4gICAgICAgICAqIEBwYXJhbSBtYXRjaGVzIFxuICAgICAgICAgKi9cbiAgICAgICAgbm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQoaW5kZXg6IHN0cmluZywgbWF0Y2hlczogYm9vbGVhbiB8IG51bGwpOiB2b2lkO1xuICAgIH07XG59XG5cbi8vZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZz4ge1xuLy8gICAgbm90aWZ5T2ZTaWJsaW5nc0hhdmVOb01hdGNoZXMobm9NYXRjaGVzOiBib29sZWFuKTogdm9pZDtcbiAgICAvL3BhdGg6IFJvdXRlclBhdGhUeXBlIHwgbnVsbDtcbi8vICAgIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsO1xuLy99XG4iLCJpbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VVcmwgfSBmcm9tIFwiLi91c2UtdXJsLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBSb3V0ZXJDaGlsZEluZm8sIFJvdXRlclBhdGhUeXBlLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvY2FsUGF0aFBhcmFtZXRlcnMge1xuICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IFBpY2s8VXNlQ29uc3VtZVJvdXRlclJldHVybltcImNvbnN1bWVSb3V0ZXJSZXR1cm5cIl0sIFwibGV2ZWxcIj47XG4gICAgbG9jYWxSb3V0ZVBhcmFtZXRlcnM6IHtcbiAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2U6IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZywgbmV2ZXI+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb250ZXh0VHlwZSBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgcm91dGVyQ29udGV4dDoge1xuICAgICAgICBsZXZlbDogbnVtYmVyO1xuICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleDogc3RyaW5nLCBtYXRjaGVzOiBib29sZWFuIHwgbnVsbCk6IHZvaWQ7XG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3V0ZXJDb25zdW1lckFyZ3VtZW50cyB7XG4gICAgcm91dGVyQ29uc3VtZXJQYXJhbWV0ZXJzOiB7IGxvY2FsUGF0aDogUm91dGVyUGF0aFR5cGUgfCBudWxsOyB9XG59XG5cbi8qKlxuICogVGhlIFwiY2hpbGRcIiBwYXJ0IG9mIGEgcm91dGVyLlxuICogXG4gKiBUaGlzIGlzIHJlc3BvbnNpYmxlIGZvciBvYnNlcnZpbmcgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGluIHRoZSBoYXNoLFxuICogYW5kIG5vdGlmeWluZyB0aGUgcGFyZW50IGFueSB0aW1lIGl0IGJlY29tZXMgdmFsaWQvaW52YWxpZCwgYmVjYXVzZVxuICogaWYgdGhpcyBwYXRoIGFuZCBhbGwgaXRzIHNpYmxpbmdzIGFyZSBpbnZhbGlkIGF0IHRoZSBzYW1lIHRpbWUsXG4gKiB0aGUgZGVmYXVsdCBwYXRoIGlzIGFsbG93ZWQgdG8gYmUgc2hvd24uXG4gKi9cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDb25zdW1lUm91dGVyUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgY29udGV4dDogUm91dGVyQ29udGV4dFR5cGU7XG4gICAgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHtcbiAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nLCBuZXZlcj47XG4gICAgICAgIGxvY2FsUGF0aDogUm91dGVyUGF0aFR5cGU7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbnN1bWVSb3V0ZXJSZXR1cm4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPFJvdXRlckNoaWxkSW5mbz4ge1xuICAgIGNvbnN1bWVSb3V0ZXJSZXR1cm46IHtcbiAgICAgICAgbGV2ZWw6IG51bWJlcjtcbiAgICAgICAgbWF0Y2hlczogYm9vbGVhbiB8IG51bGw7XG4gICAgICAgIGdldExvY2FsUGF0aDogKCkgPT4gc3RyaW5nO1xuICAgICAgICBzZXRMb2NhbFBhdGg6IChwYXRoOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgICAgIHBhdGhXaGVuTWF0Y2hpbmc6IHN0cmluZyB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29uc3VtZVJvdXRlcih7IGNvbnRleHQsIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSwgY29uc3VtZVJvdXRlclBhcmFtZXRlcnM6IHsgb25Mb2NhbFBhdGhDaGFuZ2UsIGxvY2FsUGF0aDogd2FudGVkTG9jYWxQYXRoIH0gfTogVXNlQ29uc3VtZVJvdXRlclBhcmFtZXRlcnMpOiBVc2VDb25zdW1lUm91dGVyUmV0dXJuIHtcbiAgICBjb25zdCB7IHJvdXRlckNvbnRleHQ6IHsgbGV2ZWwsIG5vdGlmeVBhcmVudFRoYXROb25EZWZhdWx0TWF0Y2hIYXNDaGFuZ2VkIH0gfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgW2FueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncywgc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzXSA9IHVzZVN0YXRlKG51bGwgYXMgbnVsbCB8IGJvb2xlYW4pO1xuXG4gICAgY29uc3QgW3BhdGhXaGVuTWF0Y2hpbmcsIHNldFBhdGhXaGVuTWF0Y2hpbmddID0gdXNlU3RhdGUobnVsbCBhcyBudWxsIHwgc3RyaW5nKTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGQ8Um91dGVyQ2hpbGRJbmZvPih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcbiAgICB9LCB7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3M6IHVzZVN0YWJsZUNhbGxiYWNrKChhbnlNYXRjaGVzKSA9PiB7XG4gICAgICAgICAgICBzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MoYW55TWF0Y2hlcyk7XG4gICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTIod2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzLCBnZXRMb2NhbFBhdGgoKSk7XG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTIod2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MsIGdldExvY2FsUGF0aCgpKTtcbiAgICB9LCBbd2FudGVkTG9jYWxQYXRoLCBhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3NdKVxuXG5cbiAgICBjb25zdCBvbkxvY2FsUGF0aENoYW5nZTIgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiAod2FudGVkTG9jYWxQYXRoOiBSb3V0ZXJQYXRoVHlwZSwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzOiBib29sZWFuIHwgbnVsbCwgcGF0aDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBwYXRoQ29tcGFyZSh3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncywgcGF0aCk7XG4gICAgICAgIHNldE1hdGNoZXMobWF0Y2hlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke2luZGV4fTogb25Mb2NhbFBhdGhDaGFuZ2UyKHdscDogJHsod2FudGVkTG9jYWxQYXRoID8/IFwibnVsbFwiKS50b1N0cmluZygpfSwgYW1hbmRzOiAkeyhhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MgPz8gXCJudWxsXCIpLnRvU3RyaW5nKCl9LCBwOiAke3BhdGh9KTogJHsobWF0Y2hlcyA/PyBcIm51bGxcIikudG9TdHJpbmcoKX1gKVxuICAgICAgICBpZiAobWF0Y2hlcylcbiAgICAgICAgICAgIHNldFBhdGhXaGVuTWF0Y2hpbmcocGF0aCk7XG5cbiAgICAgICAgaWYgKHdhbnRlZExvY2FsUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleCwgbWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZChpbmRleCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IFttYXRjaGVzLCBzZXRNYXRjaGVzXSA9IHVzZVN0YXRlKG51bGwgYXMgbnVsbCB8IGJvb2xlYW4pO1xuICAgIGNvbnN0IFtnZXRMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0gPSB1c2VMb2NhbFBhdGgoe1xuICAgICAgICBjb25zdW1lUm91dGVyUmV0dXJuOiB7IGxldmVsIH0sXG4gICAgICAgIGxvY2FsUm91dGVQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkxvY2FsUGF0aENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKHBhdGgsIHByZXYsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIG9uTG9jYWxQYXRoQ2hhbmdlMih3YW50ZWRMb2NhbFBhdGgsIGFueU1hdGNoZXNBbW9uZ05vbkRlZmF1bHRTaWJsaW5ncywgcGF0aCk7XG4gICAgICAgICAgICAgICAgb25Mb2NhbFBhdGhDaGFuZ2U/LihwYXRoLCBwcmV2LCByZWFzb24pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBjb25zdW1lUm91dGVyUmV0dXJuOiB7XG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBnZXRMb2NhbFBhdGgsXG4gICAgICAgICAgICBzZXRMb2NhbFBhdGgsXG4gICAgICAgICAgICBwYXRoV2hlbk1hdGNoaW5nXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gdXNlTG9jYWxQYXRoKHsgY29uc3VtZVJvdXRlclJldHVybjogeyBsZXZlbCB9LCBsb2NhbFJvdXRlUGFyYW1ldGVyczogeyBvbkxvY2FsUGF0aENoYW5nZSB9IH06IFVzZUxvY2FsUGF0aFBhcmFtZXRlcnMpIHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxvY2FsUGF0aFwiLCBsZXZlbCk7XG5cbiAgICBjb25zdCB1cmxUb1BhdGggPSB1c2VDYWxsYmFjaygodXJsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwodXJsKS5oYXNoKSk7XG4gICAgICAgIHJldHVybiBvbGRIYXNoUGF0aFtsZXZlbF07XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBbZ2V0TG9jYWxQYXRoLCBzZXRMb2NhbFBhdGhdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZywgbmV2ZXI+KHVzZVN0YWJsZUNhbGxiYWNrKG9uTG9jYWxQYXRoQ2hhbmdlKSwgdXNlQ2FsbGJhY2soKCkgPT4geyBcbiAgICAgICAgcmV0dXJuIHVybFRvUGF0aCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfSwgW3VybFRvUGF0aF0pKTtcblxuXG4gICAgLy8gQW55IHRpbWUgdGhlIFVSTCBjaGFuZ2VzLCBpbnNwZWN0IHRoZSBoYXNoXG4gICAgLy8gYXQgb3VyIGN1cnJlbnQgbGV2ZWwsIGFuZCBjaGFuZ2Ugb3VyIGxvY2FsIGNvcHkgb2Ygb3VyIHBhdGhcbiAgICAvLyBpbiBvdXIgcGFzc2l2ZSBzdGF0ZS4gVGhpcyB3aWxsIHRyaWdnZXIgb3VyIGNhbGxiYWNrIGlmIHRoZXkncmUgZGlmZmVyZW50LlxuICAgIHVzZVVybCh1cmwgPT4geyBzZXRMb2NhbFBhdGgodXJsVG9QYXRoKHVybCkpOyB9KTtcblxuICAgIHJldHVybiBbZ2V0TG9jYWxQYXRoLCBzZXRMb2NhbFBhdGhdIGFzIGNvbnN0O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoQ29tcGFyZShyZXF1ZXN0ZWRMb2NhbEhhc2g6IG51bGwgfCBzdHJpbmcgfCBSZWdFeHAgfCAoKGxvY2FsSGFzaDogc3RyaW5nKSA9PiBib29sZWFuKSwgYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzOiBib29sZWFuIHwgbnVsbCwgbG9jYWxQYXRoOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgbGV0IG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsO1xuICAgIGxvY2FsUGF0aCA/Pz0gXCJcIjtcblxuICAgIGlmIChyZXF1ZXN0ZWRMb2NhbEhhc2ggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIG1hdGNoZXMgPSAocmVxdWVzdGVkTG9jYWxIYXNoLnRlc3QobG9jYWxQYXRoKSk7XG4gICAgZWxzZSBpZiAocmVxdWVzdGVkTG9jYWxIYXNoIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgIG1hdGNoZXMgPSAocmVxdWVzdGVkTG9jYWxIYXNoKGxvY2FsUGF0aCkpO1xuXG4gICAgZWxzZSBpZiAocmVxdWVzdGVkTG9jYWxIYXNoID09IG51bGwpXG4gICAgICAgIG1hdGNoZXMgPSAoYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzID09IG51bGw/IG51bGwgOiAhYW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzKTtcbiAgICBlbHNlXG4gICAgICAgIG1hdGNoZXMgPSAocmVxdWVzdGVkTG9jYWxIYXNoID09PSBsb2NhbFBhdGgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG4iLCJcbi8qKlxuICogRXJyb3IgY2xhc3MgdXNlZCB3aGVuIGF0dGVtcHMgdG8gbW9kaWZ5IHRoZSByb290IGRpcmVjdG9yeSBvY2N1ci5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvb3RSb3V0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYFRoZSByb290IFJvdXRlcidzIHBhdGggY2FuIG9ubHkgYmUgcHVzaGVkIHRvIGFuZCBjYW5ub3QgYmUgc2V0IG9yIHBvcHBlZCBmcm9tLmApO1xuICAgIH1cbn0gIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBSb290Um91dGVyRXJyb3IgfSBmcm9tIFwiLi9yb290LXJvdXRlci1lcnJvci5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGlyZWN0b3J5IGF0IHRoZSBjdXJyZW50IGxldmVsLCBlZmZlY3RpdmVseSByZXR1cm5pbmdcbiAqIHRvIHRoZSBwcmV2aW91cyBsZXZlbC4gIFlvdSBjYW4gYWxzbyBzd2l0Y2ggdG8gYSBkaWZmZXJlbnRcbiAqIHByZXZpb3VzIGxldmVsIGlmIHlvdSB3b3VsZCBsaWtlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUG9wTG9jYWxQYXRoKGxldmVsOiBudW1iZXIpIHtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbihkaXI/OiBzdHJpbmcsIGFjdGlvbjogXCJwdXNoXCIgfCBcInJlcGxhY2VcIiA9IFwicHVzaFwiKSB7XG4gICAgICAgIHNldEVudGlyZUhhc2gocG9wTG9jYWxQYXRoKGxldmVsLCBkaXIpLCBhY3Rpb24pO1xuICAgIH0sIFtsZXZlbF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wTG9jYWxQYXRoKGxldmVsOiBudW1iZXIsIGRpcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGxldmVsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJvb3RSb3V0ZXJFcnJvcigpO1xuICAgIGNvbnN0IG9sZEhhc2hQYXRoID0gbm9ybWFsaXplSGFzaFRvUGF0aCh0cmltSGFzaChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKS5oYXNoKSk7XG4gICAgbGV0IG5ld0hhc2hQYXRoID0gb2xkSGFzaFBhdGguc2xpY2UoMCwgbGV2ZWwpLm1hcChzID0+IChzID8/IFwiXCIpKTtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIGRpciA9IHRyaW1IYXNoKGRpcik7XG4gICAgICAgIG5ld0hhc2hQYXRoW25ld0hhc2hQYXRoLmxlbmd0aCAtIDFdID0gZGlyO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdIYXNoUGF0aC5qb2luKFwiL1wiKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFzaFRvUGF0aCwgc2V0RW50aXJlSGFzaCwgdHJpbUhhc2ggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbi8qKlxuICogQWRkcyBhIGRpcmVjdG9yeSBhdCBvbmUgbGV2ZWwgZGVlcGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHVzaExvY2FsUGF0aChsZXZlbDogbnVtYmVyKSB7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gcHVzaExvY2FsSGFzaChkaXI6IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiID0gXCJwdXNoXCIsIGtlZXBUcmFpbGluZz86IGJvb2xlYW4pIHtcbiAgICAgICAgZGlyID0gdHJpbUhhc2goZGlyKTtcbiAgICAgICAgY29uc3Qgb2xkSGFzaFBhdGggPSBub3JtYWxpemVIYXNoVG9QYXRoKHRyaW1IYXNoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpLmhhc2gpKTtcbiAgICAgICAgbGV0IG5ld0hhc2hQYXRoID0gb2xkSGFzaFBhdGguc2xpY2UoMCwga2VlcFRyYWlsaW5nID8gdW5kZWZpbmVkIDogbGV2ZWwgKyAxKS5tYXAocyA9PiAocyA/PyBcIlwiKSk7XG4gICAgICAgIG5ld0hhc2hQYXRoLnNwbGljZShsZXZlbCArIDEsIDEsIGRpcik7XG4gICAgICAgIHNldEVudGlyZUhhc2gobmV3SGFzaFBhdGguam9pbihcIi9cIiksIGFjdGlvbik7XG4gICAgfSwgW2xldmVsXSk7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFJvb3RSb3V0ZXJFcnJvciB9IGZyb20gXCIuL3Jvb3Qtcm91dGVyLWVycm9yLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVIYXNoVG9QYXRoLCBzZXRFbnRpcmVIYXNoLCB0cmltSGFzaCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgZGlyZWN0b3J5IGF0IHRoZSBjdXJyZW50IGxldmVsIHdpdGggYSBuZXcgb25lLiBZb3UgY2FuXG4gKiBjaG9vc2Ugd2hldGhlciBvciBub3QgYW55IHRyYWlsaW5nIHBhdGhzIGFyZSBrZXB0IC0tIGJ5IGRlZmF1bHQgdGhpcyBpcyBmYWxzZS5cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXRMb2NhbFBhdGgobGV2ZWw6IG51bWJlcikge1xuICAgIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbihkaXI6IHN0cmluZywgYWN0aW9uOiBcInB1c2hcIiB8IFwicmVwbGFjZVwiID0gXCJwdXNoXCIsIGtlZXBUcmFpbGluZz86IGJvb2xlYW4pIHtcbiAgICAgICAgc2V0RW50aXJlSGFzaChzZXRMb2NhbFBhdGgobGV2ZWwsIGRpciwga2VlcFRyYWlsaW5nIHx8IGZhbHNlKSwgYWN0aW9uKTtcbiAgICB9LCBbbGV2ZWxdKTtcbn1cblxuZnVuY3Rpb24gc2V0TG9jYWxQYXRoKGxldmVsOiBudW1iZXIsIGRpcjogc3RyaW5nLCBrZWVwVHJhaWxpbmc6IGJvb2xlYW4pIHtcbiAgICBpZiAobGV2ZWwgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUm9vdFJvdXRlckVycm9yKCk7XG5cbiAgICBkaXIgPSB0cmltSGFzaChkaXIpO1xuICAgIGNvbnN0IG9sZEhhc2hQYXRoID0gbm9ybWFsaXplSGFzaFRvUGF0aCh0cmltSGFzaChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKS5oYXNoKSk7XG4gICAgbGV0IG5ld0hhc2hQYXRoID0gb2xkSGFzaFBhdGguc2xpY2UoMCwga2VlcFRyYWlsaW5nID8gdW5kZWZpbmVkIDogbGV2ZWwgKyAxKS5tYXAocyA9PiAocyA/PyBcIlwiKSk7XG4gICAgbmV3SGFzaFBhdGguc3BsaWNlKGxldmVsLCAxLCBkaXIpO1xuICAgIHJldHVybiBuZXdIYXNoUGF0aC5qb2luKFwiL1wiKTtcbn1cbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VQb3BMb2NhbFBhdGggfSBmcm9tIFwiLi91c2UtcG9wLWxvY2FsLXBhdGguanNcIjtcbmltcG9ydCB7IHVzZVB1c2hMb2NhbFBhdGggfSBmcm9tIFwiLi91c2UtcHVzaC1sb2NhbC1wYXRoLmpzXCI7XG5pbXBvcnQgeyB1c2VTZXRMb2NhbFBhdGggfSBmcm9tIFwiLi91c2Utc2V0LWxvY2FsLXBhdGguanNcIjtcbmltcG9ydCB7IFJvdXRlckNvbnRyb2xzIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5cbi8qKlxuICogQWxsb3dzIGVhc3kgYWNjZXNzIHRvIHRoZSBjb250cm9scyBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAqIFxuICogWW91IGNhbiBhbHNvIGdldCB0aGlzIGluZm9ybWF0aW9uIGZyb20gYSBjaGlsZCA8Um91dGVyIC8+XG4gKiBieSBwYXNzaW5nIGluIGEgcmVmIChlLmcuIDxSb3V0ZXIgcmVmPXtzZXRDb250cm9sc30gLz4pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyQ29udHJvbHMobGV2ZWw6IG51bWJlcik6IFJvdXRlckNvbnRyb2xzIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoYXNoIGF0IHRoaXMgbGV2ZWwgc3BlY2lmaWNhbGx5LCBcbiAgICAvLyBzbyBpdCBjb250YWlucyBubyBkaXJlY3Rvcnkgc2VwYXJhdG9ycy5cbiAgICBjb25zdCBwb3BMb2NhbFBhdGggPSB1c2VQb3BMb2NhbFBhdGgobGV2ZWwpO1xuICAgIGNvbnN0IHB1c2hMb2NhbFBhdGggPSB1c2VQdXNoTG9jYWxQYXRoKGxldmVsKTtcbiAgICBjb25zdCBzZXRMb2NhbFBhdGggPSB1c2VTZXRMb2NhbFBhdGgobGV2ZWwpO1xuXG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgcG9wTG9jYWxQYXRoLFxuICAgICAgICBwdXNoTG9jYWxQYXRoLFxuICAgICAgICBzZXRMb2NhbFBhdGgsXG4gICAgfSksIFtwb3BMb2NhbFBhdGgsIHB1c2hMb2NhbFBhdGgsIHNldExvY2FsUGF0aF0pO1xufVxuXG5cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBSb3V0ZXJDaGlsZEluZm8sIFJvdXRlckNvbnRleHRUeXBlIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxSb3V0ZXJDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcm92aWRlUm91dGVyUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8Um91dGVyQ2hpbGRJbmZvPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcm92aWRlUm91dGVyUmV0dXJuVHlwZSBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8Um91dGVyQ2hpbGRJbmZvPiB7XG4gICAgY29udGV4dDogUm91dGVyQ29udGV4dFR5cGU7XG59XG5cbi8vY29uc3QgUm91dGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Um91dGVyQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuLyoqXG4gKiBUaGUgXCJwYXJlbnRcIiBwYXJ0IG9mIGEgcm91dGVyLlxuICogXG4gKiBUaGlzIGlzIHJlc3BvbnNpYmxlIGZvciBjb29yZGluYXRpbmcsIGFtb25nIGFsbCBjaGlsZHJlbiwgd2hpY2ggcm91dGUgdG8gc2hvdy5cbiAqIFRoaXMgY29vcmRpbmF0aW9uIGlzIHJlYWxseSBvbmx5IG5lZWRlZCBmb3IgdGhlIFwiZGVmYXVsdFwiIHBhdGh3YXksIHdoaWNoXG4gKiBuZWVkcyB0byBrbm93IGFzIHBhaW5sZXNzbHkgYXMgcG9zc2libGUgd2hldGhlciBhbnkgb2YgaXRzIHNpYmxpbmdzIGFyZSBjdXJyZW50bHkgdmFsaWQuXG4gKiBcbiAqIEl0IGFsc28gaW5jcmVhc2VzIHRoZSBkZXB0aCBieSBvbmUsIHN0YXJ0aW5nIGF0IGRlcHRoPS0xIGZvciB0aGUgcm9vdCByb3V0ZXIgaXMgKmp1c3QqIGEgcGFyZW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm92aWRlUm91dGVyKHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9OiBVc2VQcm92aWRlUm91dGVyUGFyYW1ldGVycyk6IFVzZVByb3ZpZGVSb3V0ZXJSZXR1cm5UeXBlIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIG1hbmFnZWRDaGlsZHJlblJldHVybiB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPFJvdXRlckNoaWxkSW5mbz4oeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHsgcm91dGVyQ29udGV4dDogeyBsZXZlbCB9IH0gPSB1c2VDb250ZXh0KFJvdXRlckNvbnRleHQpID8/IHsgcm91dGVyQ29udGV4dDogeyBsZXZlbDogLTEgfSB9XG5cbiAgICBjb25zdCBtYXRjaGluZ0luZGljZXMgPSB1c2VSZWY8U2V0PHN0cmluZz4+KG5ldyBTZXQoKSk7XG4gICAgY29uc3QgW2dldFNob3dpbmdEZWZhdWx0LCBzZXRTaG93aW5nRGVmYXVsdF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiB8IG51bGwsIG5ldmVyPih1c2VTdGFibGVDYWxsYmFjayhzaG93aW5nRGVmYXVsdCA9PiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuc2V0QW55TWF0Y2hlc0Ftb25nTm9uRGVmYXVsdFNpYmxpbmdzKCFzaG93aW5nRGVmYXVsdCk7XG4gICAgICAgIH0pXG4gICAgfSksIHJldHVybk51bGwpO1xuICAgIGNvbnN0IG9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGluZGV4OiBzdHJpbmcsIG1hdGNoZXM6IGJvb2xlYW4gfCBudWxsKSA9PiB7XG4gICAgICAgIG1hdGNoaW5nSW5kaWNlcy5jdXJyZW50W21hdGNoZXMgPyBcImFkZFwiIDogXCJkZWxldGVcIl0oaW5kZXgpO1xuICAgICAgICBzZXRTaG93aW5nRGVmYXVsdChtYXRjaGluZ0luZGljZXMuY3VycmVudC5zaXplID09IDApO1xuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHJvdXRlckNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsICsgMSxcbiAgICAgICAgICAgICAgICBub3RpZnlQYXJlbnRUaGF0Tm9uRGVmYXVsdE1hdGNoSGFzQ2hhbmdlZDogb25Ob25EZWZhdWx0Q2hpbGRNYXRjaENoYW5nZWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VDb25zdW1lUm91dGVyLCBVc2VDb25zdW1lUm91dGVyUmV0dXJuIH0gZnJvbSBcIi4vdXNlLXJvdXRlci1jb25zdW1lci5qc1wiO1xuaW1wb3J0IHsgdXNlUm91dGVyQ29udHJvbHMgfSBmcm9tIFwiLi91c2Utcm91dGVyLWNvbnRyb2xzLmpzXCI7XG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0LCB1c2VQcm92aWRlUm91dGVyIH0gZnJvbSBcIi4vdXNlLXJvdXRlci1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUm91dGVyQ29udHJvbHMsIFJvdXRlclBhdGhUeXBlIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclByb3BzIHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY2hpbGRyZW4gdG8gZGlzcGxheSwgZ2l2ZW4gdGhlIGN1cnJlbnQgbG9jYWwgcGF0aCwgaWYgb25lIG1hdGNoZXMuXG4gICAgICogXG4gICAgICogYG51bGxgIHdpbGwgYmUgcGFzc2VkIHdoZW4geW91IHNob3VsZCBoaWRlIHRoZSBjb250ZW50cywgYW5kIHRoZSBzdHJpbmcgdGhhdCBtYXRjaGVkIHdpbGwgYmUgcGFzc2VkIG90aGVyd2lzZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gcGF0aFdoZW5NYXRjaGluZyBXaGVuIGBudWxsYCwgZG9uJ3Qgc2hvdywgYmVjYXVzZSB0aGUgVVJMIGlzbid0IG9uIHRoaXMgcGF0aC4gQW55IG90aGVyIHN0cmluZyB2YWx1ZSBpcyB0aGUgY3VycmVudCBwYXRoIHRoYXQgdGhpcyBgUm91dGVyYCBtYXRjaGVzLlxuICAgICAqIEByZXR1cm5zIFdoYXQgeW91IHdhbnQgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiAocGF0aFdoZW5NYXRjaGluZzogc3RyaW5nIHwgbnVsbCwgY29udHJvbHM6IFJvdXRlckNvbnRyb2xzKSA9PiBDb21wb25lbnRDaGlsZHJlbjtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgcGF0aCBvciBwYXRocyB0aGlzIGBSb3V0ZXJgIHNob3VsZCBzaG93IGl0c2VsZiBvbi5cbiAgICAgKiBcbiAgICAgKiBDYW4gYmUgYSBzdHJpbmcsIFJlZ0V4cCwgb3IgYChwOiBzdHJpbmcpID0+IGJvb2xlYW5gLiBPciBgbnVsbGAgdG8gYmUgYSBcImRlZmF1bHRcIiBgUm91dGVyYC5cbiAgICAgKiBcbiAgICAgKiBcIkRlZmF1bHRcIiBgUm91dGVyYHMgKGBsb2NhcFBhdGg9e251bGx9YCkgYXJlIHNob3duIHdoZW4gbm8gb3RoZXIgYFJvdXRlcmAgYXQgdGhlIHNhbWUgbGV2ZWwgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBsb2NhbFBhdGg6IFJvdXRlclBhdGhUeXBlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGtub3cgd2hhdCB0aGUgY3VycmVudCBwYXRoIGlzIGV2ZW4gd2hlbiBub3QgY3VycmVudGx5IGJlaW5nIHNob3duLCB5b3UgY2FuIGdldCB0aGF0IGluZm9ybWF0aW9uIGhlcmUuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gcGFzcyBhIG5vcm1hbCBgc2V0U3RhdGVgIGZ1bmN0aW9uIGhlcmUuXG4gICAgICovXG4gICAgb25Mb2NhbFBhdGhDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxzdHJpbmcsIG5ldmVyPjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGNvbmRpdGlvbmFsbHkgaGlkZS9zaG93IGNvbnRlbnQgYmFzZWQgb24gYSBwYXRoIGluIHRoZSBoYXNoIGNvbXBvbmVudCBvZiB0aGUgVVJMLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHBhcmFtIHJlZiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHsgbG9jYWxQYXRoLCBvbkxvY2FsUGF0aENoYW5nZSwgY2hpbGRyZW4gfTogUm91dGVyUHJvcHMsIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dCk7XG5cbiAgICBjb25zdCB7IGNvbnRleHQ6IGNvbnRleHRGcm9tUGFyZW50LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZVByb3ZpZGVSb3V0ZXIoeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCBpbmRleCA9IHVzZU1lbW8oKCkgPT4gKChsb2NhbFBhdGggPz8gXCI8ZGVmYXVsdD5cIikgKyBgLSR7TWF0aC5yYW5kb20oKX1gKSwgW2xvY2FsUGF0aF0pO1xuICAgIGxldCBjb25zdW1lUm91dGVyUmV0dXJuOiBVc2VDb25zdW1lUm91dGVyUmV0dXJuIHwgbnVsbCA9IG51bGw7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwiUm91dGVyXCIsICEhY29udGV4dCk7XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBjb25zdW1lUm91dGVyUmV0dXJuID0gdXNlQ29uc3VtZVJvdXRlcih7IGNvbnN1bWVSb3V0ZXJQYXJhbWV0ZXJzOiB7IGxvY2FsUGF0aCwgb25Mb2NhbFBhdGhDaGFuZ2UgfSwgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9IH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHsgY29uc3VtZVJvdXRlclJldHVybjogeyBsZXZlbCwgbWF0Y2hlcywgcGF0aFdoZW5NYXRjaGluZyB9IH0gPSBjb25zdW1lUm91dGVyUmV0dXJuID8/IHsgY29uc3VtZVJvdXRlclJldHVybjogeyBsZXZlbDogLTEsIG1hdGNoZXM6IG51bGwsIHBhdGhXaGVuTWF0Y2hpbmc6IG51bGwgfSB9XG5cbiAgICBjb25zdCBjb250cm9scyA9IHVzZVJvdXRlckNvbnRyb2xzKGxldmVsKTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gKHtcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHBhdGhXaGVuTWF0Y2hpbmcsXG4gICAgICAgIC4uLmNvbnRyb2xzXG4gICAgfSkpXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Um91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEZyb21QYXJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVuKGxldmVsID09IC0xID8gXCIvXCIgOiBtYXRjaGVzID8gcGF0aFdoZW5NYXRjaGluZyA6IG51bGwsIHVzZVJvdXRlckNvbnRyb2xzKGxldmVsKSl9XG4gICAgICAgIDwvUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbiIsIlxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VVcmwgfSBmcm9tIFwiLi91c2UtdXJsLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVBhcmFtLCBUeXBlTWFwLCB1bnBhcnNlUGFyYW0gfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmV4cG9ydCB0eXBlIE9uUGFyYW1WYWx1ZUNoYW5nZWQ8VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPiA9IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFR5cGVNYXBbVF0gfCBudWxsLCBuZXZlcj47IC8vKHZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCwgcmVhc29uPzogXCJwdXNoXCIgfCBcInJlcGxhY2VcIikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFNldFBhcmFtV2l0aEhpc3Rvcnk8VCBleHRlbmRzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiPiA9ICh2YWx1ZTogVHlwZU1hcFtUXSB8IG51bGwgfCAoKHByZXZWYWx1ZTogVHlwZU1hcFtUXSB8IG51bGwpID0+IChUeXBlTWFwW1RdIHwgbnVsbCkpLCByZWFzb24/OiBcInB1c2hcIiB8IFwicmVwbGFjZVwiKSA9PiB2b2lkO1xuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcmVxdWVzdGVkIFNlYXJjaCBQYXJhbSdzIHZhbHVlXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSB0aGlzIGZ1bmN0aW9uIGlzIGxpa2UgdXNlUGFzc2l2ZVN0YXRlIChpdHNlbGYgbGlrZSB1c2VTdGF0ZSBhbmQgdXNlRWZmZWN0IGNvbWJpbmVkKSxcbiAqIHRoZSBgc2V0U3RhdGVgIHJldHVybiBmdW5jdGlvbiBpcywgZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvbnMsIG5vdCBzeW5jcm9ub3VzLCBidXQgdGhhdCdzXG4gKiBsaWtlIG1vc3QgY2FsbHMgdG8gYHNldFN0YXRlYCBhbnl3YXkgSSBndWVzcz9cbiAqIFxuICogQHBhcmFtIHBhcmFtS2V5IFRoZSBuYW1lIG9mIHRoZSBVUkwgc2VhcmNoIHBhcmFtZXRlciB0byByZWZlcmVuY2UgXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBkYXRhIGVuY29kZS9kZWNvZGUgKGBcInN0cmluZ1wiYCB8IGBcImJvb2xlYW5cImAgfCBgXCJudW1iZXJcImAgfCBgXCJiaWdpbnRcImApXG4gKiBAcGFyYW0gb25QYXJhbVZhbHVlQ2hhbmdlZCBXaWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGUgcmVxdWVzdGVkIFNlYXJjaCBQYXJhbWV0ZXIncyB2YWx1ZSBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zPFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJib29sZWFuXCIgfCBcIm51bWJlclwiIHwgXCJiaWdpbnRcIj4ocGFyYW1LZXk6IHN0cmluZywgdHlwZTogVCwgb25QYXJhbVZhbHVlQ2hhbmdlZD86IE9uUGFyYW1WYWx1ZUNoYW5nZWQ8VD4pIHtcblxuICAgIC8vIFdlIGtlZXAgYSBsb2NhbCBjb3B5IG9mIG91ciBjdXJyZW50IFNlYXJjaCBQYXJhbSB2YWx1ZVxuICAgIC8vIGJlY2F1c2UgY2hhbmdpbmcgaXQgaXMgYWN0dWFsbHkgYW4gYXN5bmNyb25vdXMgb3BlcmF0aW9uXG4gICAgLy8gYW5kIHdlIGNhbid0IGtub3cgd2hlbiBpdCBlbmRzIGFzaWRlIGZyb20ganVzdCBcImRpZCB0aGUgVVJMIGNoYW5nZSBvciBub3RcIlxuICAgIC8vIHNvIHdlIG1pZ2h0IGFzIHdlbGwga2VlcCB0aGlzIHN0YXRlIGFyb3VuZCBsb2NhbGx5IHRvIGNvbXBlbnNhdGUuXG4gICAgY29uc3QgW2dldFNhdmVkUGFyYW1WYWx1ZSwgc2V0U2F2ZWRQYXJhbVZhbHVlXSA9IHVzZVBhc3NpdmVTdGF0ZTxUeXBlTWFwW1RdIHwgbnVsbCwgbmV2ZXI+KG9uUGFyYW1WYWx1ZUNoYW5nZWQsIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0obmV3IFVSTCh3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSksIHBhcmFtS2V5LCB0eXBlKTtcbiAgICB9LCBbXSkpO1xuICAgIGNvbnN0IHNldFBhcmFtV2l0aEhpc3RvcnkgPSB1c2VTdGFibGVDYWxsYmFjazxTZXRQYXJhbVdpdGhIaXN0b3J5PFQ+PigobmV3VmFsdWVPclVwZGF0ZXIsIHJlYXNvbj86IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIpID0+IHtcblxuICAgICAgICBsZXQgcHJldlZhbHVlID0gcGFyc2VQYXJhbShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKSwgcGFyYW1LZXksIHR5cGUpO1xuICAgICAgICBsZXQgbmV4dFZhbHVlOiBUeXBlTWFwW1RdIHwgbnVsbCA9ICh0eXBlb2YgbmV3VmFsdWVPclVwZGF0ZXIgPT0gXCJmdW5jdGlvblwiPyBuZXdWYWx1ZU9yVXBkYXRlcihwcmV2VmFsdWUpIDogbmV3VmFsdWVPclVwZGF0ZXIpO1xuXG4gICAgICAgIGxldCBuZXdQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKS5zZWFyY2hQYXJhbXMpKTtcbiAgICAgICAgdW5wYXJzZVBhcmFtKG5ld1BhcmFtcywgcGFyYW1LZXksIG5leHRWYWx1ZSBhcyBUeXBlTWFwW1RdLCB0eXBlKTtcbiAgICAgICAgbGV0IG5leHRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICAgICAgbmV4dFVybC5zZWFyY2ggPSBwcmV0dHlQcmludFBhcmFtcyhuZXdQYXJhbXMpO1xuICAgICAgICBoaXN0b3J5W2Ake3JlYXNvbiA/PyBcInJlcGxhY2VcIn1TdGF0ZWBdKHt9LCBkb2N1bWVudC50aXRsZSwgbmV4dFVybCk7XG4gICAgICAgIHNldFNhdmVkUGFyYW1WYWx1ZShuZXh0VmFsdWUpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBbnkgdGltZSB0aGUgVVJMIGNoYW5nZXMsIGl0IG1lYW5zIHRoZSBTZWFyY2ggUGFyYW0gd2UgY2FyZSBhYm91dCBtaWdodCBoYXZlIGNoYW5nZWQuXG4gICAgLy8gUGFyc2UgaXQgb3V0IGFuZCBzYXZlIGl0LlxuICAgIHVzZVVybCh1c2VTdGFibGVDYWxsYmFjayh1cmwgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXJhbSA9IHBhcnNlUGFyYW0obmV3IFVSTCh1cmwpLCBwYXJhbUtleSwgdHlwZSk7XG4gICAgICAgIHNldFNhdmVkUGFyYW1WYWx1ZShuZXdQYXJhbSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIFtnZXRTYXZlZFBhcmFtVmFsdWUsIHNldFBhcmFtV2l0aEhpc3RvcnldIGFzIGNvbnN0O1xufVxuXG5mdW5jdGlvbiBwcmV0dHlQcmludFBhcmFtcyhwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtQXJyYXkgPSBbLi4ucGFyYW1zLmVudHJpZXMoKV0uZmlsdGVyKChrZXksIHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsKTtcbiAgICBpZiAocGFyYW1BcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG5cblxuICAgIGxldCBxdWVyeVN0cmluZyA9IHBhcmFtQXJyYXkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiIHx8ICh2YWx1ZSBhcyBhbnkpID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG4gICAgfSkuam9pbihcIiZcIik7XG5cbiAgICByZXR1cm4gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cbn1cbiIsbnVsbF0sIm5hbWVzIjpbInNsaWNlIiwib3B0aW9ucyIsInZub2RlSWQiLCJyZXJlbmRlclF1ZXVlIiwicHJldkRlYm91bmNlIiwiZGVmZXIiLCJpIiwiRU1QVFlfT0JKIiwiRU1QVFlfQVJSIiwiSVNfTk9OX0RJTUVOU0lPTkFMIiwiYXNzaWduIiwib2JqIiwicHJvcHMiLCJyZW1vdmVOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJrZXkiLCJyZWYiLCJub3JtYWxpemVkUHJvcHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwiY3JlYXRlVk5vZGUiLCJvcmlnaW5hbCIsInZub2RlIiwiX19rIiwiX18iLCJfX2IiLCJfX2UiLCJfX2QiLCJfX2MiLCJfX2giLCJjb25zdHJ1Y3RvciIsIl9fdiIsIkZyYWdtZW50IiwiQ29tcG9uZW50IiwiY29udGV4dCIsInRoaXMiLCJnZXREb21TaWJsaW5nIiwiY2hpbGRJbmRleCIsImluZGV4T2YiLCJzaWJsaW5nIiwidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCJjaGlsZCIsImJhc2UiLCJlbnF1ZXVlUmVuZGVyIiwiYyIsInB1c2giLCJwcm9jZXNzIiwiX19yIiwiZGVib3VuY2VSZW5kZXJpbmciLCJyZW5kZXJRdWV1ZUxlbmd0aCIsImNvbXBvbmVudCIsImNvbW1pdFF1ZXVlIiwib2xkVk5vZGUiLCJvbGREb20iLCJwYXJlbnREb20iLCJzb3J0IiwiYSIsImIiLCJzaGlmdCIsImRpZmYiLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJnZXRMYXN0RG9tIiwibmV4dFNpYmxpbmciLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJzb21lIiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJsYXN0RG9tIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfX24iLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl9fUCIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIlByb21pc2UiLCJ0aGVuIiwiYmluZCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaXNTdGF0aWNDaGlsZHJlbiIsIl9fc291cmNlIiwiX19zZWxmIiwiY3VycmVudEluZGV4IiwiY3VycmVudENvbXBvbmVudCIsInByZXZpb3VzQ29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJFTVBUWSIsIm9sZEJlZm9yZURpZmYiLCJvbGRCZWZvcmVSZW5kZXIiLCJvbGRBZnRlckRpZmYiLCJvbGRDb21taXQiLCJvbGRCZWZvcmVVbm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJob29rcyIsIl9fSCIsIl9fViIsInVzZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlciIsImludm9rZU9yUmV0dXJuIiwicmVkdWNlciIsImluaXQiLCJob29rU3RhdGUiLCJfcmVkdWNlciIsImFjdGlvbiIsImN1cnJlbnRWYWx1ZSIsIl9fTiIsIm5leHRWYWx1ZSIsIl9oYXNTY3VGcm9tSG9va3MiLCJwcmV2U2N1IiwicCIsInN0YXRlSG9va3MiLCJmaWx0ZXIiLCJ4IiwiZXZlcnkiLCJzaG91bGRVcGRhdGUiLCJob29rSXRlbSIsInVzZUVmZmVjdCIsImFyZ3MiLCJhcmdzQ2hhbmdlZCIsIl9wZW5kaW5nQXJncyIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZU1lbW8iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3JlYXRlSGFuZGxlIiwiY29uY2F0IiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJpbnZva2VDbGVhbnVwIiwiaW52b2tlRWZmZWN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWZ0ZXJOZXh0RnJhbWUiLCJoYXNFcnJvcmVkIiwiSEFTX1JBRiIsInJhZiIsImRvbmUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJob29rIiwiY29tcCIsImNsZWFudXAiLCJvbGRBcmdzIiwibmV3QXJncyIsImFyZyIsImYiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiT2JqZWN0IiwiZnJlZUdsb2JhbCQzIiwiZnJlZVNlbGYiLCJzZWxmIiwiRnVuY3Rpb24iLCJyb290JDMiLCJTeW1ib2wiLCJTeW1ib2wkNCIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJjb3JlSnNEYXRhIiwiY29yZUpzRGF0YSQzIiwibWFza1NyY0tleSIsInVpZCIsImV4ZWMiLCJrZXlzIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwiZ2V0VmFsdWUiLCJvYmplY3QiLCJnZXROYXRpdmUiLCJlcSIsIm90aGVyIiwibmF0aXZlQ3JlYXRlIiwibmF0aXZlQ3JlYXRlJDMiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsInNpemUiLCJoYXNoRGVsZXRlIiwiaGFzIiwiSEFTSF9VTkRFRklORUQiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJzZXQiLCJnZXQiLCJsaXN0Q2FjaGVDbGVhciIsImFzc29jSW5kZXhPZiIsImFycmF5IiwiYXJyYXlQcm90byIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIk1hcCIsIk1hcCQ0IiwibWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJtYXAiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwibWVtb2l6ZWQiLCJhcHBseSIsImNhY2hlIiwiQ2FjaGUiLCJtZW1vaXplJDEiLCJnZXRCdWlsZE1vZGVVbm1lbW9pemVkIiwiZW52IiwiTk9ERV9FTlYiLCJfZSIsImdldEJ1aWxkTW9kZSIsInVzZUVuc3VyZVN0YWJpbGl0eSIsInBhcmVudEhvb2tOYW1lIiwidmFsdWVzIiwiaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkiLCJzaG93bkVycm9yIiwidXNlSGVscGVyIiwiY29uc29sZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiZXgiLCJ3YXJuIiwic2V0VmFsdWUiLCJyZWFzb24iLCJuZXh0UmVhc29uIiwibmV4dERlcCIsInByZXZEZXAiLCJyZXR1cm5OdWxsIiwiVGFibGUiLCJiYXNlNjQiLCJyYW5kb202Qml0cyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJhbmRvbTY0Qml0cyIsImdlbmVyYXRlUmFuZG9tSWQiLCJwcmVmaXgiLCJuIiwiam9pbiIsInByZXZpb3VzSW5wdXRzIiwidG9SdW4iLCJjb21taXROYW1lIiwib3JpZ2luYWxDb21taXQiLCJuZXdDb21taXQiLCJpZCIsImVmZmVjdEluZm8iLCJvbGRJbnB1dHMiLCJpbnB1dHMiLCJlZmZlY3QiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJkZWxldGUiLCJ1c2VTdGFibGVHZXR0ZXIiLCJFcnJvciIsInVzZVN0YWJsZU9iamVjdCIsInQiLCJfayIsInYiLCJXZWFrTWFwIiwiaXNTdGFibGVHZXR0ZXIiLCJzZXRJc1N0YWJsZUdldHRlciIsInVzZVN0YWJsZUNhbGxiYWNrIiwiZm4iLCJub0RlcHMiLCJjdXJyZW50Q2FsbGJhY2tHZXR0ZXIiLCJ1c2VDYWxsYmFja05hdGl2ZSIsImFzc2VydCIsInVzZUdsb2JhbEhhbmRsZXIiLCJ0YXJnZXQiLCJoYW5kbGVyIiwibW9kZSIsInVzZUdsb2JhbEhhbmRsZXJHcm91cGVkIiwidXNlR2xvYmFsSGFuZGxlclNpbmdsZSIsIm1hcFRoaW5nIiwiZG9NYXBUaGluZyIsIm9wIiwib3B0aW9uc0tleSIsImJ5VHlwZSIsImJ5T3B0aW9ucyIsImluZm8iLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsIlNldCIsImFkZFRvTWFwVGhpbmciLCJoIiwiYWRkIiwicmVtb3ZlRnJvbU1hcFRoaW5nIiwic3RhYmxlSGFuZGxlciIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsIl90b3BDaGFuZ2VkIiwiX3N3YXBJbmVydGVkU2libGluZyIsIl9pbmVydFNpYmxpbmdzIiwiX3Jlc3RvcmVJbmVydGVkU2libGluZ3MiLCJfZ2V0UGFyZW50cyIsIl9nZXREaXN0cmlidXRlZENoaWxkcmVuIiwiX2lzSW5lcnRhYmxlIiwiX2hhbmRsZU11dGF0aW9ucyIsIkJsb2NraW5nRWxlbWVudHNJbXBsIiwiX2EiLCJfYiIsIl9jIiwiZGVzdHJ1Y3RvciIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJlbGVtZW50IiwicmVtb3ZlIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsImJvZHkiLCJ0b1NraXAiLCJvbGRJbmVydCIsIm5ld0luZXJ0Iiwic2libGluZ3NUb1Jlc3RvcmUiLCJpbmVydCIsImVsZW1lbnRzIiwibW8iLCJkaXNjb25uZWN0Iiwic2libGluZ3MiLCJwYXJlbnQiLCJpbmVydGVkU2libGluZ3MiLCJNdXRhdGlvbk9ic2VydmVyIiwicGFyZW50VG9PYnNlcnZlIiwibWF5YmVTaGFkeVJvb3QiLCJfX3NoYWR5IiwiaG9zdCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJyZW1vdmVkTm9kZXMiLCJhZGRlZE5vZGVzIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImFzc2lnbmVkU2xvdCIsInNoYWRvd1Jvb3QiLCJub2RlcyIsInNsb3RzIiwicXVlcnlTZWxlY3RvckFsbCIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiJGJsb2NraW5nRWxlbWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIndpbmRvdyIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiX29uTXV0YXRpb24iLCJzdWJ0cmVlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwicmVjb3JkIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsInRhYkluZGV4IiwiaGFzU2F2ZWRUYWJJbmRleCIsImFkZEluZXJ0Um9vdCIsInJlbW92ZUluZXJ0Um9vdCIsIkluZXJ0TWFuYWdlciIsIl9kb2N1bWVudCIsIl93YXRjaEZvckluZXJ0IiwiYWRkSW5lcnRTdHlsZSIsImhlYWQiLCJkb2N1bWVudEVsZW1lbnQiLCJyZWFkeVN0YXRlIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJfaW5lcnRSb290IiwiaW5lcnRFbGVtZW50cyIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsImNvbnRlbnQiLCJkaXN0cmlidXRlZE5vZGVzIiwiZ2V0RGlzdHJpYnV0ZWROb2RlcyIsInNsb3QiLCJfZGlzdHJpYnV0ZWROb2RlcyIsIl9pIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiSFRNTEVsZW1lbnQiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsIm9uQ2hpbGRDb3VudENoYW5nZSIsInJlc3QiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZmllbGQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsImdldENoaWxkcmVuIiwibWF4Iiwic2hhdmUiLCJtYW5hZ2VkQ2hpbGRyZW4iLCJfIiwiZ2V0QXQiLCJhcnJheVNsaWNlIiwibWFuYWdlZENoaWxkQ29udGV4dCIsIm1hbmFnZWRDaGlsZHJlblJldHVybiIsInVzZU1hbmFnZWRDaGlsZCIsIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMiLCJmbGF0IiwibWFuYWdlZENoaWxkUmV0dXJuIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwicHJldlZhbHVlIiwiZ2V0U3RhdGUiLCJpc05hTiIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsIm1lbW8iLCJjb21wYXJlciIsIm5leHRQcm9wcyIsInVwZGF0ZVJlZiIsIk1lbW9lZCIsImRpc3BsYXlOYW1lIiwiaXNSZWFjdENvbXBvbmVudCIsIl9fZiIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwib2xkRGlmZkhvb2siLCJSRUFDVF9GT1JXQVJEX1NZTUJPTCIsImZvciIsImZvcndhcmRSZWYiLCJGb3J3YXJkZWQiLCJjbG9uZSIsIiQkdHlwZW9mIiwibWFwRm4iLCJvbGRDYXRjaEVycm9yIiwib2xkVW5tb3VudCIsImRldGFjaGVkQ2xvbmUiLCJkZXRhY2hlZFBhcmVudCIsInJlbW92ZU9yaWdpbmFsIiwib3JpZ2luYWxQYXJlbnQiLCJTdXNwZW5zZSIsIl9fdSIsIl9zdXNwZW5kZXJzIiwic3VzcGVuZGVkIiwiX19hIiwiU3VzcGVuc2VMaXN0IiwiX25leHQiLCJfbWFwIiwiX19SIiwicHJvbWlzZSIsInN1c3BlbmRpbmdWTm9kZSIsInN1c3BlbmRpbmdDb21wb25lbnQiLCJyZXNvbHZlZCIsIm9uUmVzb2x2ZWQiLCJvblN1c3BlbnNpb25Db21wbGV0ZSIsInN1c3BlbmRlZFZOb2RlIiwiX19PIiwid2FzSHlkcmF0aW5nIiwiZGV0YWNoZWRDb21wb25lbnQiLCJmYWxsYmFjayIsImxpc3QiLCJyZXZlYWxPcmRlciIsImRlbGVnYXRlZCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJyZXZlcnNlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiQ0FNRUxfUFJPUFMiLCJJU19ET00iLCJvbkNoYW5nZUlucHV0VHlwZSIsIm9sZEV2ZW50SG9vayIsImVtcHR5IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicGVyc2lzdCIsIm5hdGl2ZUV2ZW50IiwiY2xhc3NOYW1lRGVzY3JpcHRvciIsImNsYXNzIiwib2xkVk5vZGVIb29rIiwibm9uQ3VzdG9tRWxlbWVudCIsIm11bHRpcGxlIiwic2VsZWN0ZWQiLCJjbGFzc05hbWUiLCJvbGREaWZmZWQiLCJjbHN4IiwiZnJlZUdsb2JhbCQxIiwicm9vdCQxIiwiU3ltYm9sJDIiLCJjb3JlSnNEYXRhJDEiLCJuYXRpdmVDcmVhdGUkMSIsIk1hcCQyIiwicmV0dXJuRmFsc2UiLCJydW5JbW1lZGlhdGVseSIsInVzZU1lcmdlZENoaWxkcmVuIiwibGhzIiwicmhzIiwidXNlTWVyZ2VkQ2xhc3NlcyIsImxoc0NsYXNzIiwibGhzQ2xhc3NOYW1lIiwicmhzQ2xhc3MiLCJyaHNDbGFzc05hbWUiLCJsaHNDbGFzc2VzIiwic3BsaXQiLCJyaHNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsImZyb20iLCJwcm9jZXNzUmVmIiwidXNlTWVyZ2VkUmVmcyIsImNvbWJpbmVkIiwic3R5bGVTdHJpbmdUb09iamVjdCIsImZyb21FbnRyaWVzIiwic3RhdGVtZW50IiwidXNlTWVyZ2VkU3R5bGVzIiwibG9nIiwidXNlTWVyZ2VkUHJvcHMiLCJhbGxQcm9wcyIsInJldCIsInVzZU1lcmdlZFByb3BzMiIsImtub3ducyIsIm1lcmdlVW5rbm93biIsImxoc1ZhbHVlIiwicmhzVmFsdWUiLCJtZXJnZWQiLCJtZXJnZUZ1bmN0aW9ucyIsImxoc0FsbCIsInJoc0FsbCIsImxoc0tleVUiLCJsaHNLZXkiLCJyaHNLZXlVIiwicmhzS2V5IiwibHYiLCJydiIsImFsbCIsInVzZVJlZkVsZW1lbnQiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwicmVmRWxlbWVudFBhcmFtZXRlcnMiLCJnZXRFbGVtZW50Iiwic2V0RWxlbWVudCIsInByb3BzU3RhYmxlIiwicmVmRWxlbWVudFJldHVybiIsInVzZUNoaWxkcmVuRmxhZyIsImluaXRpYWxJbmRleCIsImNsb3Nlc3RGaXQiLCJvbkluZGV4Q2hhbmdlIiwic2V0QXQiLCJpc1ZhbGlkIiwiZ2V0Q3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiZ2V0UmVxdWVzdGVkSW5kZXgiLCJzZXRSZXF1ZXN0ZWRJbmRleCIsImdldENsb3Nlc3RGaXQiLCJyZXF1ZXN0ZWRJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY2xvc2VzdEluZGV4IiwibmV3RGlzdGFuY2UiLCJhYnMiLCJyZWV2YWx1YXRlQ2xvc2VzdEZpdCIsImN1cnJlbnRDaGlsZCIsImNsb3Nlc3RGaXRJbmRleCIsImNsb3Nlc3RGaXRDaGlsZCIsImNoYW5nZUluZGV4IiwibmV3TWF0Y2hpbmdDaGlsZCIsIm9sZE1hdGNoaW5nQ2hpbGQiLCJjaGlsZElzVmFsaWQiLCJnZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dFByZW1lbW9pemF0aW9uIiwiZXhjbHVzaXZpdHlLZXkiLCJTd2FwcGFibGVDb250ZXh0IiwiZ2V0QW5pbWF0ZU9uTW91bnQiLCJHZXRFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIkNzc0NsYXNzQ29udGV4dCIsIkdldEJhc2VDbGFzcyIsIkdldEVudGVyQ2xhc3MiLCJHZXRFeGl0Q2xhc3MiLCJHZXRNZWFzdXJlQ2xhc3MiLCJHZXRJbml0Q2xhc3MiLCJHZXRUcmFuc2l0aW9uQ2xhc3MiLCJHZXRGaW5hbGl6ZUNsYXNzIiwidXNlQ3NzQ2xhc3NlcyIsIkdldERpcmVjdGlvbkNsYXNzIiwiZGlyZWN0aW9uIiwiR2V0UGhhc2VDbGFzcyIsInBoYXNlIiwiZ2xvYmFsQ291bnQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uUHJvdmlkZXIiLCJnZXROZXh0SW5kZXhJbkxpbmUiLCJzZXROZXh0SW5kZXhJbkxpbmUiLCJtIiwic2V0RXhjbHVzaXZlbHlPcGVuIiwiZ2V0RXhjbHVzaXZlbHlPcGVuIiwib25WaXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJsZSIsIm5leHRJbkxpbmUiLCJjdXJyZW50SW5MaW5lIiwiZm9yY2VDbG9zZSIsImNvbnRleHQyIiwiZXhjbHVzaXZlVHJhbnNpdGlvbkNvbnRleHQiLCJFeGNsdXNpdmVUcmFuc2l0aW9uQ29udGV4dCIsIl9qc3giLCJ1c2VFeGNsdXNpdmVUcmFuc2l0aW9uIiwidHJhbnNpdGlvblBhcmFtZXRlcnMiLCJzaG93IiwiZXhjbHVzaXZlVHJhbnNpdGlvblBhcmFtZXRlcnMiLCJleGNsdXNpdmVseU9wZW4iLCJwYXJlbnRPblZpc0NoYW5nZSIsImV4Y2x1c2l2ZVRyYW5zaXRpb25SZXR1cm4iLCJpc0V4Y2x1c2l2ZSIsImZvcndhcmRFbGVtZW50UmVmIiwiRm9yd2FyZGVkQ29tcG9uZW50IiwidXNlTGFzdE5vbk51bGxWYWx1ZSIsImxhc3ROb25OdWxsVmFsdWUiLCJ1c2VDcmVhdGVTd2FwcGFibGVQcm9wcyIsIm90aGVyUHJvcHMiLCJpbmxpbmUiLCJTd2FwcGFibGUiLCJjaGlsZHJlbkFuaW1hdGVPbk1vdW50IiwiaW5saW5lRWxlbWVudHMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtZXJnZWRXaXRoQ2hpbGRyZW4iLCJhbmltYXRlT25Nb3VudCIsImdldFRpbWVvdXREdXJhdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic3RyIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJwYXJzZVN0YXRlIiwibmV4dFN0YXRlIiwidXNlVHJhbnNpdGlvbiIsInByb3BzSW5jb21pbmciLCJtZWFzdXJlIiwiZXhpdFZpc2liaWxpdHkiLCJkdXJhdGlvbiIsImRlbGF5TW91bnRVbnRpbFNob3duIiwiZWFzaW5nIiwiZWFzaW5nSW4iLCJlYXNpbmdPdXQiLCJnZXRFeGl0VmlzaWJpbGl0eSIsImdldE1lYXN1cmUiLCJleGNsdXNpdmVUcmFuc2l0aW9uVmlzaWJpbGl0eUNoYW5nZSIsImludGVybmFsT25TaG93Q2hhbmdlZCIsImNzc1Byb3BlcnRpZXMiLCJjbGFzc05hbWVzIiwiaGFuZGxlVHJhbnNpdGlvbkZpbmlzaGVkIiwidGltZW91dEhhbmRsZSIsInRpbWVvdXRDbGVhckZ1bmN0aW9uIiwib25UcmFuc2l0aW9uRW5kIiwiZWxhcHNlZFRpbWUiLCJoYXNNb3VudGVkIiwidXBkYXRlQ2xhc3NlcyIsImFsbENsYXNzZXNUb1JlbW92ZSIsImFsbENsYXNzZXNUb0FkZCIsImNsYXNzTGlzdCIsInVwZGF0ZVNpemVQcm9wZXJ0eSIsInZhck5hbWUiLCJyZW1vdmVQcm9wZXJ0eSIsIm1lYXN1cmVFbGVtZW50QW5kVXBkYXRlUHJvcGVydGllcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsIm9uU3RhdGVDaGFuZ2UiLCJwcmV2U3RhdGUiLCJuZXh0RGlyZWN0aW9uIiwibmV4dFBoYXNlIiwiaXNCZWluZ1BhaW50ZWQiLCJmb3JjZVJlZmxvdyIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50UGhhc2UiLCJkZWZpbml0ZWx5U2hvdWxkTW91bnRDaGlsZHJlbiIsImhhc1JlbmRlcmVkQ2hpbGRyZW4iLCJyZW5kZXJDaGlsZHJlbiIsImNoaWxkcmVuSXNWbm9kZSIsImZpbmFsUHJvcHMiLCJyZXNldENvbnRleHQiLCJtb2RpZmllZENoaWxkcmVuIiwiZ2xvYmFsVGhpcyIsIl9kdW1teSIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJ1c2VCYXNlUHJvcHNGYWRlIiwiZmFkZVBhcmFtZXRlcnMiLCJmYWRlTWluIiwiZmFkZU1heCIsIkZhZGUiLCJ1c2VCYXNlUHJvcHNDbGlwIiwiY2xpcFBhcmFtZXRlcnMiLCJjbGlwTWluIiwiY2xpcE1pbkJsb2NrIiwiY2xpcE1pbklubGluZSIsImNsaXBPcmlnaW4iLCJjbGlwT3JpZ2luQmxvY2siLCJjbGlwT3JpZ2luSW5saW5lIiwiQ2xpcCIsIkNsaXBGYWRlIiwidXNlQmFzZVByb3BzQ29sbGFwc2UiLCJjb2xsYXBzZVBhcmFtZXRlcnMiLCJtaW5CbG9ja1NpemUiLCJDb2xsYXBzZSIsIkNvbGxhcHNlRmFkZSIsInVzZUJhc2VQcm9wc0ZsaXAiLCJmbGlwUGFyYW1ldGVycyIsImZsaXBBbmdsZUJsb2NrIiwiZmxpcEFuZ2xlSW5saW5lIiwiZmxpcFBlcnNwZWN0aXZlIiwiRmxpcCIsInVzZUJhc2VQcm9wc1NsaWRlIiwic2xpZGVQYXJhbWV0ZXJzIiwic2xpZGVUYXJnZXRJbmxpbmUiLCJzbGlkZVRhcmdldEJsb2NrIiwiU2xpZGUiLCJTbGlkZUZhZGUiLCJ1c2VCYXNlUHJvcHNab29tIiwiem9vbVBhcmFtZXRlcnMiLCJ6b29tT3JpZ2luIiwiem9vbU9yaWdpbklubGluZSIsInpvb21PcmlnaW5CbG9jayIsInpvb21NaW4iLCJ6b29tTWluSW5saW5lIiwiem9vbU1pbkJsb2NrIiwiWm9vbSIsIlNsaWRlWm9vbSIsIlNsaWRlWm9vbUZhZGUiLCJab29tRmFkZSIsIl9fUFJFQUNUX0RFVlRPT0xTX18iLCJhdHRhY2hQcmVhY3QiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJyZXNldFByb3BXYXJuaW5ncyIsImdldERpc3BsYXlOYW1lIiwicmVuZGVyU3RhY2siLCJvd25lclN0YWNrIiwiZ2V0Q3VycmVudFZOb2RlIiwiaGFzQmFiZWxQbHVnaW4iLCJpc1Bvc3NpYmxlT3duZXIiLCJnZXRPd25lclN0YWNrIiwic3RhY2siLCJuZXh0IiwiX19vIiwicmVkdWNlIiwiYWNjIiwib3duZXIiLCJzb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJpc1dlYWtNYXBTdXBwb3J0ZWQiLCJnZXRDbG9zZXN0RG9tTm9kZVBhcmVudCIsInNlcmlhbGl6ZVZOb2RlIiwiYXR0cnMiLCJwcm9wIiwib2xkRGlmZiIsIm9sZFJvb3QiLCJvbGRSZW5kZXIiLCJzZXR1cENvbXBvbmVudFN0YWNrIiwiaG9va3NBbGxvd2VkIiwib2xkVm5vZGUiLCJvbGRIb29rIiwid2FybmVkQ29tcG9uZW50cyIsImxhenlQcm9wVHlwZXMiLCJkZXByZWNhdGlvbnMiLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudE5hbWUiLCJwcm9wVHlwZXMiLCJsYXp5Vk5vZGUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJtZXNzYWdlIiwicHJvcGVydHkiLCJkZXByZWNhdGVkQXR0cmlidXRlcyIsIm5vZGVOYW1lIiwiZGVwcmVjYXRlZFByb3RvIiwiY3JlYXRlIiwiX19wcm90b19fIiwiaW5pdERlYnVnIiwidXNlVXJsIiwib25VcmxDaGFuZ2UiLCJnZXRVcmwiLCJzZXRVcmwiLCJ0cmltSGFzaCIsImhhc2giLCJzdGFydHNXaXRoIiwic3Vic3RyIiwibm9ybWFsaXplSGFzaFRvUGF0aCIsInNldEVudGlyZUhhc2giLCJvbGRVUkwiLCJuZXh0VXJsIiwiVVJMIiwiaGlzdG9yeSIsInRpdGxlIiwiZGlzcGF0Y2hFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsIm5ld1VSTCIsInVucGFyc2VQYXJhbSIsInBhcmFtcyIsInBhcnNlUGFyYW0iLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJwYXJzZWQiLCJpc0Zpbml0ZSIsIkJpZ0ludCIsInVzZUNvbnN1bWVSb3V0ZXIiLCJjb25zdW1lUm91dGVyUGFyYW1ldGVycyIsIm9uTG9jYWxQYXRoQ2hhbmdlIiwibG9jYWxQYXRoIiwid2FudGVkTG9jYWxQYXRoIiwicm91dGVyQ29udGV4dCIsImxldmVsIiwibm90aWZ5UGFyZW50VGhhdE5vbkRlZmF1bHRNYXRjaEhhc0NoYW5nZWQiLCJhbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MiLCJzZXRBbnlNYXRjaGVzQW1vbmdOb25EZWZhdWx0U2libGluZ3MiLCJwYXRoV2hlbk1hdGNoaW5nIiwic2V0UGF0aFdoZW5NYXRjaGluZyIsImFueU1hdGNoZXMiLCJvbkxvY2FsUGF0aENoYW5nZTIiLCJnZXRMb2NhbFBhdGgiLCJwYXRoIiwicGF0aENvbXBhcmUiLCJzZXRNYXRjaGVzIiwic2V0TG9jYWxQYXRoIiwidXNlTG9jYWxQYXRoIiwiY29uc3VtZVJvdXRlclJldHVybiIsImxvY2FsUm91dGVQYXJhbWV0ZXJzIiwicHJldiIsInVybFRvUGF0aCIsIm9sZEhhc2hQYXRoIiwiaHJlZiIsInJlcXVlc3RlZExvY2FsSGFzaCIsIlJvb3RSb3V0ZXJFcnJvciIsInVzZVBvcExvY2FsUGF0aCIsImRpciIsInBvcExvY2FsUGF0aCIsIm5ld0hhc2hQYXRoIiwidXNlUHVzaExvY2FsUGF0aCIsInB1c2hMb2NhbEhhc2giLCJrZWVwVHJhaWxpbmciLCJ1c2VTZXRMb2NhbFBhdGgiLCJ1c2VSb3V0ZXJDb250cm9scyIsInB1c2hMb2NhbFBhdGgiLCJSb3V0ZXJDb250ZXh0IiwidXNlUHJvdmlkZVJvdXRlciIsIm1hdGNoaW5nSW5kaWNlcyIsImdldFNob3dpbmdEZWZhdWx0Iiwic2V0U2hvd2luZ0RlZmF1bHQiLCJzaG93aW5nRGVmYXVsdCIsIm9uTm9uRGVmYXVsdENoaWxkTWF0Y2hDaGFuZ2VkIiwiUm91dGVyIiwiY29udGV4dEZyb21QYXJlbnQiLCJjb250cm9scyIsInVzZVNlYXJjaFBhcmFtcyIsInBhcmFtS2V5Iiwib25QYXJhbVZhbHVlQ2hhbmdlZCIsImdldFNhdmVkUGFyYW1WYWx1ZSIsInNldFNhdmVkUGFyYW1WYWx1ZSIsInNldFBhcmFtV2l0aEhpc3RvcnkiLCJuZXdWYWx1ZU9yVXBkYXRlciIsIm5ld1BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsInByZXR0eVByaW50UGFyYW1zIiwibmV3UGFyYW0iLCJwYXJhbUFycmF5IiwicXVlcnlTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJleGFtcGxlIiwic2V0RXhhbXBsZUxvY2FsIiwiZ2V0RXhhbXBsZSIsInNldEV4YW1wbGUiLCJfanN4cyIsIm9uQ2xpY2siLCJvbklucHV0IiwiY3VycmVudFRhcmdldCIsInZhbHVlQXNOdW1iZXIiLCJMZXZlbDEiLCJfRnJhZ21lbnQiLCJnZXRFbGVtZW50QnlJZCJdLCJtYXBwaW5ncyI6Ijs7O0VBMEJhQSxJQUFBQSxDQUFBQTtJQ2ZQQyxHQ1JGQztJQUFBQSxHQUFBQTtJQ3lLQUMsR0FBQUE7SUFXQUM7SUFFRUMsR0N2TEtDO0lBQUFBLEdBQUFBO0lDRkVDLEdBQVksR0FBQTtJQUNaQyxHQUFZLEdBQUEsRUFBQTtJQUNaQyxHQUFxQixHQUFBLG1FQUFBO0VMT2xCQyxTQUFBQSxHQUFPQyxDQUFBQSxDQUFBQSxFQUFLQyxDQUUzQixFQUFBO0lBQUEsS0FBSyxJQUFJTixDQUFLTSxJQUFBQSxDQUFBQSxFQUFPRCxDQUFJTCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFLTSxFQUFNTixDQUNwQyxDQUFBO0lBQUEsT0FBNkJLLENBQzdCO0VBQUE7RUFRTSxTQUFTRSxHQUFXQyxDQUFBQSxDQUFBQSxFQUFBQTtJQUMxQixJQUFJQyxDQUFBQSxHQUFhRCxFQUFLQyxVQUNsQkE7SUFBQUEsQ0FBQUEsSUFBWUEsQ0FBV0MsQ0FBQUEsV0FBQUEsQ0FBWUYsQ0FDdkMsQ0FBQTtFQUFBO0VFWE0sU0FBU0csR0FBQUEsQ0FBY0MsR0FBTU4sQ0FBT08sRUFBQUEsQ0FBQUEsRUFBQUE7SUFDMUMsSUFDQ0MsQ0FBQUE7TUFDQUM7TUFDQWYsQ0FIR2dCO01BQUFBLENBQUFBLEdBQWtCLENBQUEsQ0FBQTtJQUl0QixLQUFLaEIsQ0FBS00sSUFBQUEsQ0FBQUEsRUFDQSxLQUFMTixJQUFBQSxDQUFBQSxHQUFZYyxJQUFNUixDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxHQUNkLEtBQUxBLElBQUFBLENBQUFBLEdBQVllLElB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
